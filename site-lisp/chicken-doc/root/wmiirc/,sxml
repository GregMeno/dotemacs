((tags "egg") (section 2 "wmiirc" (toc) (section 3 "Description" (p "A library for writing configuration scripts for " (link "http://wmii.suckless.org" "wmii, window manager improved 2") ".") (p "See also the " (int-link "/wmiirc snippets" "wmiirc snippets") " page for useful code snippets you can use in your own wmiirc scripts.")) (section 3 "Author" (p (int-link "/users/peter-bex" "Peter Bex"))) (section 3 "Requirements" (p "Requires the " (link "http://www.call-with-current-continuation.org/eggs/9p" "9p") " egg.") (p "Works with wmii 3.6 (and possibly 3.5) only.")) (section 3 "Documentation" (p (link "http://wmii.suckless.org" "wmii") " is a minimalist windowmanager for the X window system that, instead of implementing a lot of policy in the WM, allows you to control it completely through a virtual filesystem it exports over the " (int-link "9p") " protocol. Because of this, you can script it using any language or tool that can speak this protocol and define (almost) any behaviour you want.") (p "This egg is an attempt to make an abstraction that lets you write scripts that can control wmii without having to study the structure of the 9p filesystem that wmii exports.  Instead, you can do everything by calling procedures from this egg.  Of course, if you know the filesystem structure you can still choose to access the filesystem directly if you need to do something extreme.") (section 4 "Concepts" (p "Because wmii works slightly different than most other window managers, it is useful to start by exploring its fundamental concepts.  There's an official guide that explains these concepts at " (link "http://www.suckless.org/wmii/guide.html") " but it is not very complete at the time of this writing.") (p "First off, wmii is a so-called " (i "dynamic") " window manager.  This means it manages the windows for you, so you don't have to bother about placing them on your screen.  In default mode, it will divide the screen up in equal parts and tile the windows so they are not obscured.  However, it also has a " (i "floated") " mode, which is the only mode classic window managers support.  This will simply place the windows somewhere on the screen such that they can overlap.  You will have to drag them around and/or resize them manually (or write a smart script that can position them sanely).") (section 5 "Tags and views" (p "wmii manages windows (or " (i "clients") " in X speak) by " (i "tagging") " them. Any window can have several tags, but it always displays the contents of only one tag on the screen.  This is called a " (i "view") " on that tag. This feature provides a superset of the functionality that other window managers offer with " (i "virtual desktops") ".  Because windows can have multiple tags, it is possible for one window to show up in multiple views, effectively causing it to be \"sticky\" for only a selected number of views.")) (section 5 "Modes" (p "As explained above, wmii supports dynamic management as well as floated window management.  Floating windows all live in a special tag sometimes identified by the name '~' (tilde).  In dynamic mode there are three \"submodes\".  In 'default' mode the windows are tiled, or divided equally across the screen.  When a new window is created, the other windows are made smaller to accommodate for the new one, which is given an equal amount of space as all the other windows, and the window is placed such that it does not obscure any of the other windows.  In 'stacked' mode, all windows are placed behind eachother in a staircased fashion so " (b "only") " their titlebars show.  The window that has focus is placed in front of all the others, so it takes up almost all of your screen.  Clicking on any titlebar sends that window to the front, and restacks such that all other windows' titlebars are still visible.  In 'maximized' mode you only see one window with its titlebar.")) (section 5 "States" (p "Individual windows can also have different states.  When a window is in the 'fullscreen' state, " (b "all") " window decoration and other stuff is hidden so your entire screen is used by one window of one application. When a window has the 'urgent' state, it has its \"urgent hint\" set, which is a hint to the window manager that this window's state demands immediate attention from the user (for example, in an IM client a private message may have arrived).  Wmii can take action when this state is set and it can distinguish between client-requested urgency and manager-requested urgency.")) (section 5 "Columns" (p "The screen is further divided up into columns.  When you first start wmii, the screen has only one column so you don't see it.  However, when you send a window to the right or the left, it will create a new column it will live in from then on.  The first column will be resized so the columns can fit next to eachother.  Wmii allows you to define rules what the sizes of these columns will be.  Each column has its own mode, so you can have one column maximized or stacked while the column next to it is in tiled mode.")) (section 5 "Bars and tabs" (p "The bottom of the screen contains a bar, which is actually " (i "two") " bars: one on the left and one on the right (" (i "lbar") " and " (i "rbar") ").  These bars consist of " (i "tabs") ".  Tabs can contain text in a given color and are clickable. Their name does not have to match their text contents, but it is advisable to keep these matched for your own sanity.  In the default config, the left tab shows a list of available tags/views, with the current one highlighted. When you click a tab, a view on the corresponding tag is shown.  By default the right bar shows a status that is continuously updated with the current time and system load.")) (section 5 "Events" (p "Whenever anything happens in wmii, an event is fired which your wmiirc can catch and act upon.  Events are fired when a key is pressed (but only when it is grabbed by the WM, otherwise it goes to applications), when a window is (de)selected, when a tag is (de)selected, when a tag is created/destroyed etc.  The exact events are listed with the " (tt "event-handlers") " procedure.")) (section 5 "Special names and limitations" (p "wmii reserves a couple of names and syntaxes, which means you can't use arbitrary names for tags, tabs and some other things.  It uses the plus symbol (+) as a separator for tag names.  This cannot be escaped in any way, which means the + can simply not be used inside names. The special name " (i "sel") " is reserved for the currently selected tag/view/client etc. This has an alias as the exclamation mark, but its use is deprecated.  Contents of tabs can be prefixed with three 6-digit hexadecimal numbers which are prefixed with a pound sign (#). If they are, this indicates the colors of that tab.  This egg tries to take care of doing the formatting of this so you can simply pass integer values as colorcodes instead.  Spaces are not allowed in several names either.  It's probably safest to avoid all these special characters and names altogether."))) (section 4 "Initialization" (p "To get a connection to the server, call the following:") (pre " procedure: (connect [inport outport])") (p "If you provide an inport and outport, it will connect to a 9p server on those input/output ports.  If you do not provide them, it will try to connect to the wmii 9p server on the default location, namely a unix domain socket named " (tt "/tmp/ns.USERNAME.DISPLAY/wmii") ", where USERNAME is your Unix username and DISPLAY is the current X display string.") (p "After initializing, you can set up column rules, tag rules and event handlers.  After having done this, you can enter the event loop using") (pre " procedure: (event-loop [kill-others])") (p "This procedure will only return when another wmiirc wants to take over from the current one.  The " (tt "kill-others") " parameter tells wmiirc to tell other wmiirc scripts (whether written using this egg or not) to quit.  It defaults to " (tt "#t") ".")) (section 4 "wmii operations" (pre " procedure: (quit)") (p "Tells wmii to quit.") (pre " procedure: (exec cmdline)") (p "Tells wmii to execute the given commandline, replacing the wmii process.  This can be used to change to a different window manager.") (pre " procedure: (global-settings)") (p "Returns an alist of the current global settings.") (pre " procedure: (global-settings-set! alist)") (p "Change the global settings.  Example:") (highlight scheme "(global-settings-set!\n `((font . \"-*-fixed-medium-r-*-*-13-*-*-*-*-*-*-*\")\n   (focuscolors . (#xffffff #x285577 #x4c7899))\n   (normcolors . (#x888888 #x222222 #x333333))\n   (grabmod . \"Mod1\")\n   (border . \"1\")))") (p "This sets the default font (used in titlebars, for example) to the one in the string, sets the colors of a window that is focused to the given colorcodes in " (tt "focuscolors") ", the default colors to the one in " (tt "normcolors") " and grabs Mod1 for dragging windows around.  The border thickness is set to one pixel.")) (section 4 "Column rules" (p "You can define the percentage of the screen each column should take up by setting up column rules.  This can be done per view, using a simple alist and the following procedure:") (pre " procedure: (colrules-set! alist)") (p "The keys of the alist are strings that are interpreted by wmii as a regular expression of view names on which the column rules should apply.  The values of the alist are integers or lists of integers which represent percentages of the screen width the columns can take. The percentages apply to the columns in the same order, from left to right.") (p "Example:") (highlight scheme "  (colrules-set! '((\"www\" . (20 80))\n                        (\"email\" . (10 20 70))\n                        (\"graphics\" . 100) ;; can also be (100)\n                        (\".*\" . (30 50 20))))") (p "You can request the current column rules with the following procedure:") (pre " procedure: (colrules)") (p "This returns an alist of the same type as accepted by colrules-set!.")) (section 4 "Tag rules" (p "Tag rules work much like column rules, except they specify which tags a client should get when it's first created.") (pre " procedure: (tagrules-set! alist)") (p "The alist here takes again strings as keys which are interpreted as regexes by wmii.  The values are either strings or lists of strings which are taken to be tagnames. Example:") (highlight scheme "  (tagrules-set! `((\"XMMS.*\" . (\"music\" \"~\"))\n                        (\"display.*\" . (\"graphics\" \"~\"))\n                        (\"Gimp.*\" . (\"graphics\" \"~\"))\n                        (\"xjump.*\" . (\"games\" \"~\"))\n                        (\"MPlayer.*\" . \"~\")\n                        (\"VICE.*\" . (\"games\" \"~\"))\n                        (\".*\" . \"sel\") ;; Default to current tag\n                        (\".*\" . \"1\"))) ;; If no tag exists yet, start with '1'") (p "Just like colrules, tagrules can be listed:") (pre " procedure: (tagrules)") (p "Returns an alist that looks just like the one from " (tt "tagrules-set!") ".")) (section 4 "Event handlers" (p "The core of wmiirc script writing is in the event handlers.  You can register those with this procedure:") (pre " procedure: (event-handlers-set! alist [grab-keys])") (p "The alist has keys that are either simply symbols that name the event or lists that provide a full match for the incoming event.  The first rule that matches an incoming event is used, the others are ignored. The values of the alist are lambdas which handle the event.  The " (tt "grab-keys") " parameter defaults to " (tt "#t") " and indicates if key handlers should be filtered from the event handlers and the keys used by them should be grabbed.  If a key is not grabbed, it will never be visible by the wmiirc script; it will be passed to the client directly without being passed to the script by wmii.") (p "The events that you can expect are as follows:") (dl (dt (tt "(create-tag TAGNAME)")) (dd "The tag with the name " (tt "TAGNAME") " has just been created.") (dt (tt "(destroy-tag TAGNAME)")) (dd "The tag with name " (tt "TAGNAME") " has just been destroyed.") (dt (tt "(focus-tag TAGNAME)")) (dd "The focus was changed to the tag with name " (tt "TAGNAME")) (dt (tt "(unfocus-tag TAGNAME)")) (dd "The tag with name " (tt "TAGNAME") " which had focus is now not in focus anymore.") (dt (tt "urgent CLIENT CLIENT-REQUEST?")) (dd "The client with identifier " (tt "CLIENT") " just got the " (i "urgency hint") " set. " (tt "CLIENT-REQUEST?") " is #" (tt "t") " if the client requested it, " (tt "#f") " if the window manager did.") (dt (tt "not-urgent CLIENT CLIENT-REQUEST?")) (dd "The client with identifier " (tt "CLIENT") " just got the " (i "urgency hint") " removed. " (tt "CLIENT-REQUEST?") " is #" (tt "t") " if the client removed it, " (tt "#f") " if the window manager did.") (dt (tt "urgent-tag TAGNAME CLIENT-REQUEST?")) (dd "The tag with name " (tt "TAGNAME") " has a client which just got the " (i "urgency hint") " set.  " (tt "CLIENT-REQUEST") " is " (tt "#t") " if the client requested it, " (tt "#f") " if the urgency hint was set by the window manager itself.") (dt (tt "not-urgent-tag TAGNAME CLIENT-REQUEST?")) (dd "The tag with name " (tt "TAGNAME") " has a client which just lost the " (i "urgency hint") ".  " (tt "CLIENT") " is " (tt "#t") " if the client removed it, " (tt "#f") " if the urgency hint was removed by the window manager itself.") (dt (tt "left-bar-click BUTTON TAB")) (dd "The user clicked on the left bar. " (tt "BUTTON") " is an integer which indicates the mouse button the user pressed (1 = left, 2 = middle, 3 = right).  " (tt "TAB") " is the name of the tab on which was clicked.") (dt (tt "right-bar-click BUTTON TAB")) (dd "The user clicked on the right bar. " (tt "BUTTON") " is an integer which indicates the mouse button the user pressed (1 = left, 2 = middle, 3 = right).  " (tt "TAB") " is the name of the tab on which was clicked.") (dt (tt "client-mouse-down CLIENT BUTTON")) (dd "The user pressed a mouse button while his mouse cursor was on the titlebar of a window. " (tt "CLIENT") " indicates the client on which was clicked, " (tt "BUTTON") " is an integer which indicates the mouse button the user pressed (1 = left, 2 = middle, 3 = right).") (dt (tt "client-mouse-click CLIENT BUTTON")) (dd "The user completed a mouse click on the titlebar of a window (he did not leave the titlebar before releasing the button).  " (tt "CLIENT") " indicates the client on which was clicked, " (tt "BUTTON") " is an integer which indicates the mouse button the user pressed (1 = left, 2 = middle, 3 = right).") (dt (tt "(key keys ...)")) (dd "A key was pressed.  The exact key pressed is encoded as several strings with key names.  Usually it is easiest to handle the keys with rest arg notation to capture them in a list.")) (p "See the " (int-link "#Example" "example section") " for a good example of how to use these events.") (p "You can also use the following procedure to get the current event handlers:") (pre " procedure: (event-handlers)") (p "Note that this procedure can not return event handlers in other processes. It's simply a getter for the current wmiirc instance's list of event handlers."))) (section 3 "Keys" (pre " procedure: (grabbed-keys)") (p "Get a list of currently grabbed keys.") (pre " procedure: (grabbed-keys-set! keys)") (p "Sets the keys grabbed by wmii.  " (tt "keys") " is a list of key descriptions. Keys must be grabbed or they won't be passed to the wmiirc event loop. Example:") (highlight scheme "  (grabbed-keys-set! '((\"Mod1\" \"x\")\n                            (\"Mod2\" \"Space\")\n\t\t\t    (\"Mod1\" \"Shift\" \"Space\")))") (p "This grabs the key combinations Mod1-x, Mod2-space and Mod1-shift-space. Key names of \"special\" keys are always capitalized in wmii.  Normal literal keys like the x in the example are always lower case.  If you would like to hook shift-x, that would not be (\"X\"), but (\"Shift\" \"x\").") (pre " procedure: (key-code->string)\n procedure: (string->key-code)") (p "Translate a chicken-wmiirc keycode to a string that can be written to wmii's " (tt "/keys") " file.  Example:") (pre " (key-code->string '(\"Mod1\" \"Shift\" \"x\")) => \"Mod1-Shift-x\"\n (string->keycode \"Mod1-Shift-x\") => (\"Mod1\" \"Shift\" \"x\")")) (section 3 "Navigating" (pre " procedure: (goto-tag tag)") (p "Switch the view to the named " (tt "tag") ".") (pre " procedure: (navigate-to direction [tag])") (p "Navigate to the given " (tt "direction") " in the given " (tt "tag") ".  Tag defaults to \"sel\", the current tag.  " (tt "where") " can be \"up\", \"down\", \"left\", \"right\" or \"toggle\".  If one of the directions, the client above, below, to the left or to the right of the current client is selected.  If the direction is toggle, clients in float mode are selected if currently a client in normal mode is selected, or the other way around.  If tag is not the current tag, the currently selected client on that tag is changed, but nothing happens in the current view, unless the current view just happens to be a view on that tag.") (pre " procedure: (send-to direction [client] [tag])") (p "Send the given " (tt "client") " (defaults to \"sel\", the currently selected client) into the given " (tt "direction") ", as described above.  If " (tt "tag") " is given, the client is sent to the given direction on that tag.  It is " (i "not") " sent to that tag.")) (section 3 "Tags" (pre " procedure: (tags)\n ") (p "This procedure returns a list of all the tags known to wmii, as strings.") (pre " procedure: (tag-settings-set! alist [tag])") (p "Change the settings for the named " (tt "tag") ", which defaults to \"sel\", the current tag.  " (tt "alist") " is an alist with setting names (strings) as keys, and setting lists as values. Example:") (pre " (tag-settings-set! '((\"colmode\" . (\"sel\" \"stack\"))))") (p "This sets the current tag's column mode to stacked.") (pre " \n procedure: (tag-settings [tag])") (p "Returns an alist of the settings for the named " (tt "tag") ".  " (tt "tag") " defaults to " (tt "\"sel\"") ", that is the current tag.")) (section 3 "Bars" (pre " procedure: (tabs bar)") (p "Return a list of all tabs on the " (tt "bar") ".  " (tt "bar") " can be " (tt "\"lbar\"") " (the left bar) or " (tt "\"rbar\"") " (the right bar).") (pre " procedure: (write-tab bar tab contents [colors])") (p "Change the string " (tt "contents") " of a " (tt "tab") " on the indicated " (tt "bar") ". Creates the tab if it doesn't exist yet.  If " (tt "colors") " is given and not " (tt "#f") " it should be a list of three numbers which represent in hexadecimal the color values of the foreground, background and border, respectively.") (p "Example:") (pre " (write-tab \"lbar\" \"hello\" \"hello there\")") (p "Creates a tab called \"hello\" on the left bar, which displays the string \"hello there\".") (pre " procedure: (destroy-tab bar tab)") (p "Destroy " (tt "tab") " on " (tt "bar") ".")) (section 3 "Clients" (pre " procedure: (client=? client1 client2)") (p "Are two clients one and the same?  Currently clients are represented as simple strings, the way wmii returns them, but in the future clients may have more information-rich representations, so always use this to compare them to be forwards-compatible.  These \"opaque\" client objects can be obtained by event handlers from the various events that operate on a client, or by " (tt "clients") ", for example.") (pre " procedure: (clients [tag ...])") (p "Returns a list of all the clients that have any of the named tags. If no tags are given, returns all clients.") (pre " procedure: (client-tags [client])") (p "Return a list of all tags on " (tt "client") ".  Defaults to the currently selected client (\"sel\").") (pre " procedure: (client-tags-set! tags [client])") (p "Set the " (tt "tags") " (a list of strings) on the " (tt "client") ".")) (section 3 "Low-level procedures" (p "If you would like access to the 9p filesystem exported by wmii, you can use the following procedures:") (pre " procedure: (write file data)") (p "Write the string contents of " (tt "data") " to the named " (tt "file") ".  If the file does not exist, it is created.") (pre " procedure: (read file)") (p "Read the given " (tt "file") " into a string.") (pre " procedure: (read-lines file)") (p "Read the given " (tt "file") " line by line and create a list with an entry per line.") (pre " procedure: (directory path)") (p "Show the directory contents of the named " (tt "path") ".") (pre " ")) (section 3 "Example" (p "This example simply translates the default wmiirc script that's shipped with wmii from shell to Chicken:") (highlight scheme "#!/usr/pkg/bin/csi -s\n\n(require-library wmiirc srfi-18)\n(import scheme chicken (prefix wmiirc wmii:) srfi-18)\n\n(wmii:connect)\n\n(define modkey \"Mod2\")\n\n(define directions\n  `((up . \"k\")\n    (down . \"j\")\n    (left . \"h\")\n    (right . \"l\")))\n\n(define wmii-normcolors  '(#x888888 #x222222 #x333333))\n(define wmii-focuscolors '(#xffffff #x285577 #x4c7899))\n\n(define wmii-background #x333333)\n(define wmii-font \"-*-fixed-medium-r-*-*-13-*-*-*-*-*-*-*\")\n\n(define (wmii9menu options . rest)\n  (let-optionals rest ((default #f))\n    (receive (in out pid)\n             (process\n              \"wmii9menu\"\n              `(,@(if default (list \"-initial\" default) '())\n                \"-sf\" ,(wmii:color->string (first wmii-focuscolors))\n                \"-sb\" ,(wmii:color->string (second wmii-focuscolors))\n                \"-nf\" ,(wmii:color->string (first wmii-normcolors))\n                \"-nb\" ,(wmii:color->string (second wmii-normcolors))\n                \"-font\" ,wmii-font\n                ,@options))\n             (close-output-port out)\n             (let ((chosen (read-line in)))\n               (close-input-port in)\n               (and (string? chosen) chosen)))))\n\n(define (dmenu options . rest)\n  (receive (in out pid)\n           (process\n            \"dmenu\"\n            `(\"-b\"\n              \"-sf\" ,(wmii:color->string (first wmii-focuscolors))\n              \"-sb\" ,(wmii:color->string (second wmii-focuscolors))\n              \"-nf\" ,(wmii:color->string (first wmii-normcolors))\n              \"-nb\" ,(wmii:color->string (second wmii-normcolors))\n              \"-fn\" ,wmii-font))\n           (display (string-join options \"\\n\") out)\n           (close-output-port out)\n           (let ((chosen (read-line in)))\n             (close-input-port in)\n             (and (string? chosen) chosen))))\n\n(define client-menu\n (let ((last-option \"nonexistingoption\"))\n   (lambda (client)\n     (and-let* ((option (wmii9menu '(\"Nop\" \"Delete\" \"Fullscreen\") last-option)))\n       (cond\n        ((string=? option \"Delete\") (wmii:kill client))\n        ((string=? option \"Fullscreen\") (wmii:change-state \"Fullscreen\" #t client)))\n       (set! last-option option)))))\n\n(define wmii-term \"xterm\")\n\n(wmii:colrules-set! `((\".*\" . (58 42))))\n\n(wmii:tagrules-set! `((\"XMMS.*\" . \"~\")\n                      (\"MPlayer.*\" . \"~\")\n                      (\".*\" . \"sel\")\n                      (\".*\" . \"1\")))\n\n;; We need to do this in order to avoid getting lots of zombie processes\n(define (run . args) (process-wait (process-fork (lambda () (apply process-run args)))))\n\n(define status\n  (let ((status-thread #f))\n    (lambda ()\n      (and status-thread (thread-terminate! status-thread))\n      (set! status-thread\n\t    (thread-start!\n\t     (make-thread\n\t      (lambda ()\n\t\t(let loop ()\n\t\t  (wmii:write-tab \"rbar\" \"status\"\n                                  (with-input-from-pipe \"echo -n $(uptime | sed 's/.*://; s/,//g') '|' $(date)\" read-string))\n\t\t  (thread-sleep! 1)\n\t\t  (loop)))))))))\n\n(wmii:event-handlers-set!\n `((create-tag\n    . ,(lambda (event tag) (wmii:write-tab \"lbar\" tag tag wmii-normcolors)))\n   (destroy-tag\n    . ,(lambda (event tag) (wmii:destroy-tab \"lbar\" tag)))\n   (focus-tag\n    . ,(lambda (event tag)\n         (if (member tag (wmii:tabs \"lbar\"))\n             (wmii:write-tab \"lbar\" tag tag wmii-focuscolors))))\n   (unfocus-tag\n    . ,(lambda (event tag)\n         (if (member tag (wmii:tabs \"lbar\"))\n             (wmii:write-tab \"lbar\" tag tag wmii-normcolors))))\n   (urgent-tag\n    . ,(lambda (event tag client?) (wmii:write-tab \"lbar\" tag (string-append \"*\" tag))))\n   (not-urgent-tag\n    . ,(lambda (event tag client?) (wmii:write-tab \"lbar\" tag tag)))\n   (left-bar-click\n    . ,(lambda (event button tab) (wmii:goto-tag tab)))\n   (client-mouse-down\n    . ,(lambda (event client button)\n         (case button\n           ((3) (client-menu client)))))\n   ((key ,modkey \"Control\" \"t\")\n    . ,(let ((prev #f))\n         (lambda _\n           (let ((keys (wmii:grabbed-keys)))\n             (if prev\n                 (begin (wmii:grabbed-keys-set! prev)\n                        (set! prev #f))\n                 (begin (set! prev keys)\n                        (wmii:grabbed-keys-set! `((,modkey \"Control\" \"t\")))))))))\n   ((key ,modkey \"space\")\n    . ,(lambda _ (wmii:navigate-to \"toggle\")))\n   ((key ,modkey \"d\")\n    . ,(lambda _ (wmii:tag-settings-set! '((\"colmode\" . (\"sel\" \"default\"))))))\n   ((key ,modkey \"s\")\n    . ,(lambda _ (wmii:tag-settings-set! '((\"colmode\" . (\"sel\" \"stack\"))))))\n   ((key ,modkey \"m\")\n    . ,(lambda _ (wmii:tag-settings-set! '((\"colmode\" . (\"sel\" \"max\"))))))\n   ((key ,modkey \"a\")\n    . ,(lambda _\n         (and-let* ((action (dmenu (append\n                                 `(\"rehash\" \"exec\" \"status\" \"quit\")\n                                 (proglist (string-split (getenv \"WMII_CONFPATH\") \":\"))))))\n           (cond\n            ((string=? action \"rehash\") (update-programs))\n            ((string-prefix? \"exec \" action)\n             (wmii:exec (string-drop action 5)))\n            ((string=? action \"status\") (status))\n            ((string=? action \"quit\")\n             (wmii:quit)\n             (exit))\n            (else (run (sprintf \"env PATH=${WMII_CONFPATH}:${PATH} ~A\" action)))))))\n   ((key ,modkey \"p\")\n    . ,(lambda _\n         (and-let* ((program (dmenu programs))) (run program))))\n   ((key ,modkey \"t\")\n    . ,(lambda _\n         (and-let* ((tag (dmenu (wmii:tags)))) (wmii:goto-tag tag))))\n   ((key ,modkey \"Return\")\n    . ,(lambda _ (run wmii-term)))\n   ((key ,modkey \"Shift\" \"space\")\n    . ,(lambda _ (wmii:send-to \"toggle\")))\n   ((key ,modkey \"f\")\n    . ,(lambda _ (wmii:change-state \"Fullscreen\" 'toggle)))\n   ((key ,modkey \"Shift\" \"c\")\n    . ,(lambda _ (wmii:kill)))\n   ((key ,modkey \"Shift\" \"t\")\n    . ,(lambda _\n         (and-let* ((tag (dmenu (wmii:tags)))) (wmii:client-tags-set! (list tag)))))\n   ,@(map (lambda (x)\n            `((key ,modkey ,(cdr x))\n              . ,(lambda _ (wmii:navigate-to (->string (car x))))))\n          directions)\n   ,@(map (lambda (x)\n            `((key ,modkey \"Shift\" ,(cdr x))\n              . ,(lambda _ (wmii:send-to (->string (car x))))))\n          directions)   \n   ,@(map (lambda (x)\n            `((key ,modkey ,(->string x))\n              . ,(lambda _ (wmii:goto-tag x))))\n          (iota 10))\n   ,@(map (lambda (x)\n            `((key ,modkey \"Shift\" ,(->string x))\n              . ,(lambda _ (wmii:client-tags-set! (list (->string x)))))) (iota 10))))\n\n(wmii:global-settings-set!\n `((font . ,wmii-font)\n   (focuscolors . ,wmii-focuscolors)\n   (normcolors . ,wmii-normcolors)\n   (grabmod . ,modkey)\n   (border . \"1\")))\n\n(define (proglist path)\n  (sort!\n   (delete-duplicates!\n    (flatten\n     (map (lambda (dir)\n            (if ((conjoin directory? file-execute-access? file-read-access?) dir)\n                (map pathname-strip-directory\n                     (find-files dir (conjoin (complement directory?) file-execute-access?) cons '() 0))\n                '()))\n          path))\n    string=?)\n   string<?))\n\n(define programs '())\n(define (update-programs)\n  (thread-start!\n   (make-thread\n    (lambda () (set! programs (proglist (string-split (getenv \"PATH\") \":\")))))))\n(update-programs)\n\n(let ((curtag (wmii:tag))) \n  (for-each (cut wmii:destroy-tab \"lbar\" <>) (wmii:tabs \"lbar\"))\n  (for-each (lambda (t)\n              (if (string=? curtag t)\n                  (wmii:write-tab \"lbar\" t t wmii-focuscolors)\n                  (wmii:write-tab \"lbar\" t t wmii-normcolors)))\n            (wmii:tags)))\n\n(run (sprintf \"xsetroot -solid '~A'\" (wmii:color->string wmii-background)))\n\n(status)\n(wmii:event-loop)") (p "For some other cool snippets, have a look at the " (int-link "/wmiirc snippets" "wmiirc snippets") " page.")) (section 3 "Changelog" (ul (li "0.4 Fix crash in " (tt "colrules") " procedure, remove dependency on matchable egg") (li "0.3 Improvement in " (tt "clients") " procedure") (li "0.2 Port to hygienic Chicken") (li "0.1 Initial release"))) (section 3 "License" (pre " Copyright (c) 2008, Peter Bex\n All rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n \n Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n \n Redistributions in binary form must reproduce the above copyright\n notice, this list of conditions and the following disclaimer in the\n documentation and/or other materials provided with the distribution.\n \n Neither the name of the author nor the names of its contributors may\n be used to endorse or promote products derived from this software\n without specific prior written permission.\n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n OF THE POSSIBILITY OF SUCH DAMAGE."))))