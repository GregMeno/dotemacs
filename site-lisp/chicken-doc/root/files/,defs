(index ("absolute-pathname?" 0) ("decompose-pathname" 207) ("make-pathname" 510) ("make-absolute-pathname" 510) ("pathname-directory" 1279) ("pathname-file" 1279) ("pathname-extension" 1279) ("pathname-replace-directory" 1633) ("pathname-replace-file" 1633) ("pathname-replace-extension" 1633) ("pathname-strip-directory" 2021) ("pathname-strip-extension" 2021) ("normalize-pathname" 2283) ("directory-null?" 2984) ("decompose-directory" 3205) ("create-temporary-file" 3959) ("create-temporary-directory" 4455) ("delete-file*" 4747) ("file-copy" 4982) ("file-move" 5682))
(def (sig (procedure "(absolute-pathname? PATHNAME)" (id absolute-pathname?))) (p "Returns " (tt "#t") " if the string " (tt "PATHNAME") " names an absolute pathname, and returns " (tt "#f") " otherwise."))
(def (sig (procedure "(decompose-pathname PATHNAME)" (id decompose-pathname))) (p "Returns three values: the directory-, filename- and extension-components of the file named by the string " (tt "PATHNAME") ". For any component that is not contained in " (tt "PATHNAME") ", " (tt "#f") " is returned."))
(def (sig (procedure "(make-pathname DIRECTORY FILENAME [EXTENSION])" (id make-pathname)) (procedure "(make-absolute-pathname DIRECTORY FILENAME [EXTENSION])" (id make-absolute-pathname))) (p "Returns a string that names the file with the components " (tt "DIRECTORY, FILENAME") " and (optionally) " (tt "EXTENSION") " with " (tt "SEPARATOR") " being the directory separation indicator (usually " (tt "/") " on UNIX systems and " (tt "\\") " on Windows, defaulting to whatever platform this is running on). " (tt "DIRECTORY") " can be " (tt "#f") " (meaning no directory component), a string or a list of strings. " (tt "FILENAME") " and " (tt "EXTENSION") " should be strings or " (tt "#f") ". " (tt "make-absolute-pathname") " returns always an absolute pathname."))
(def (sig (procedure "(pathname-directory PATHNAME)" (id pathname-directory)) (procedure "(pathname-file PATHNAME)" (id pathname-file)) (procedure "(pathname-extension PATHNAME)" (id pathname-extension))) (p "Accessors for the components of " (tt "PATHNAME") ". If the pathname does not contain the accessed component, then " (tt "#f") " is returned."))
(def (sig (procedure "(pathname-replace-directory PATHNAME DIRECTORY)" (id pathname-replace-directory)) (procedure "(pathname-replace-file PATHNAME FILENAME)" (id pathname-replace-file)) (procedure "(pathname-replace-extension PATHNAME EXTENSION)" (id pathname-replace-extension))) (p "Return a new pathname with the specified component of " (tt "PATHNAME") " replaced by a new value."))
(def (sig (procedure "(pathname-strip-directory PATHNAME)" (id pathname-strip-directory)) (procedure "(pathname-strip-extension PATHNAME)" (id pathname-strip-extension))) (p "Return a new pathname with the specified component of " (tt "PATHNAME") " stripped."))
(def (sig (procedure "(normalize-pathname PATHNAME [PLATFORM])" (id normalize-pathname))) (p "Performs a simple \"normalization\" on the " (tt "PATHNAME") ", suitably for " (tt "PLATFORM") ", which should be one of the symbols " (tt "windows") " or " (tt "unix") " and defaults to on whatever platform is currently in use. All relative path elements and duplicate separators are processed and removed.  If " (tt "NAME") " ends with a " (tt "/") " or is empty, the appropriate slash is appended to the tail. Tilde " (tt "~") " and variable " (tt "$<name>/...") " expansion is also done.") (p "No directories or files are actually tested for existence; this procedure only canonicalises path syntax."))
(def (sig (procedure "(directory-null? DIRECTORY)" (id directory-null?))) (p "Does the " (tt "DIRECTORY") " consist only of path separators and the period?") (p (tt "DIRECTORY") " may be a string or a list of strings."))
(def (sig (procedure "(decompose-directory DIRECTORY)" (id decompose-directory))) (p "Returns 3 values: the " (tt "base-origin") ", " (tt "base-directory") ", and the " (tt "directory-elements") " for the " (tt "DIRECTORY") ".") (dl (dt (tt "base-origin")) (dd "a " (tt "string") " or " (tt "#f") ". The drive, if any.") (dt (tt "base-directory")) (dd "a " (tt "string") " or " (tt "#f") ". A directory-separator when " (tt "DIRECTORY") " is an " (tt "absolute-pathname") ".") (dt (tt "directory-elements")) (dd "a " (tt "list-of string") " or " (tt "#f") ". The non-directory-separator bits.")) (p (tt "DIRECTORY") " is a " (tt "string") ".") (ul (li "On Windows " (tt "(decompose-directory \"c:foo/bar\")") " => " (tt "\"c:\" #f (\"foo\" \"bar\")"))))
(def (sig (procedure "(create-temporary-file [EXTENSION])" (id create-temporary-file))) (p "Creates an empty temporary file and returns its pathname. If " (tt "EXTENSION") " is not given, then " (tt ".tmp") " is used. If the environment variable " (tt "TMPDIR, TEMP") " or " (tt "TMP") " is set, then the pathname names a file in that directory. If none of the environment variables is given the location of the temporary file defaults to " (tt "/tmp") " if it exists or the current-directory"))
(def (sig (procedure "(create-temporary-directory)" (id create-temporary-directory))) (p "Creates an empty temporary directory and returns its pathname. If the environment variable " (tt "TMPDIR, TEMP") " or " (tt "TMP") " is set, then the temporary directory is created at that location."))
(def (sig (procedure "(delete-file* FILENAME)" (id delete-file*))) (p "If the file " (tt "FILENAME") " exists, it is deleted and " (tt "#t") " is returned.  If the file does not exist, nothing happens and " (tt "#f") " is returned."))
(def (sig (procedure "(file-copy ORIGFILE NEWFILE #!optional CLOBBER BLOCKSIZE)" (id file-copy))) (p "Copies " (tt "ORIGFILE") " (a string denoting some filename) to " (tt "NEWFILE") ", " (tt "BLOCKSIZE") " bytes at a time.  " (tt "BLOCKSIZE") " defaults to 1024, and must be a positive integer.  Returns the number of bytes copied on success, or errors on failure.  " (tt "CLOBBER") " determines the behaviour of " (tt "file-copy") " when " (tt "NEWFILE") " is already extant.  When set to " (tt "#f") " (default), an error is signalled.  When set to any other value, " (tt "NEWFILE") " is overwritten. " (tt "file-copy") " will work across filesystems and devices and is not platform-dependent."))
(def (sig (procedure "(file-move ORIGFILE NEWFILE #!optional CLOBBER BLOCKSIZE)" (id file-move))) (p "Moves " (tt "ORIGFILE") " (a string denoting some filename) to " (tt "NEWFILE") ", with the same semantics as " (tt "file-copy") ", above.  " (tt "file-move") " is safe across filesystems and devices (unlike " (tt "rename-file") ").  It is possible for an error to be signalled despite partial success if " (tt "NEWFILE") " could be created and fully written but removing " (tt "ORIGFILE") " fails."))
