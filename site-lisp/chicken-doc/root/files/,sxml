((tags "manual") (toc) (section 2 "Unit files" (p "This unit contains file- and pathname-oriented procedures. It uses the " (tt "regex") " unit.") (section 3 "Pathname operations" (section 4 "absolute-pathname?" (def (sig (procedure "(absolute-pathname? PATHNAME)" (id absolute-pathname?))) (p "Returns " (tt "#t") " if the string " (tt "PATHNAME") " names an absolute pathname, and returns " (tt "#f") " otherwise."))) (section 4 "decompose-pathname" (def (sig (procedure "(decompose-pathname PATHNAME)" (id decompose-pathname))) (p "Returns three values: the directory-, filename- and extension-components of the file named by the string " (tt "PATHNAME") ". For any component that is not contained in " (tt "PATHNAME") ", " (tt "#f") " is returned."))) (section 4 "make-pathname") (section 4 "make-absolute-pathname" (def (sig (procedure "(make-pathname DIRECTORY FILENAME [EXTENSION])" (id make-pathname)) (procedure "(make-absolute-pathname DIRECTORY FILENAME [EXTENSION])" (id make-absolute-pathname))) (p "Returns a string that names the file with the components " (tt "DIRECTORY, FILENAME") " and (optionally) " (tt "EXTENSION") " with " (tt "SEPARATOR") " being the directory separation indicator (usually " (tt "/") " on UNIX systems and " (tt "\\") " on Windows, defaulting to whatever platform this is running on). " (tt "DIRECTORY") " can be " (tt "#f") " (meaning no directory component), a string or a list of strings. " (tt "FILENAME") " and " (tt "EXTENSION") " should be strings or " (tt "#f") ". " (tt "make-absolute-pathname") " returns always an absolute pathname."))) (section 4 "pathname-directory") (section 4 "pathname-file") (section 4 "pathname-extension" (def (sig (procedure "(pathname-directory PATHNAME)" (id pathname-directory)) (procedure "(pathname-file PATHNAME)" (id pathname-file)) (procedure "(pathname-extension PATHNAME)" (id pathname-extension))) (p "Accessors for the components of " (tt "PATHNAME") ". If the pathname does not contain the accessed component, then " (tt "#f") " is returned."))) (section 4 "pathname-replace-directory") (section 4 "pathname-replace-file") (section 4 "pathname-replace-extension" (def (sig (procedure "(pathname-replace-directory PATHNAME DIRECTORY)" (id pathname-replace-directory)) (procedure "(pathname-replace-file PATHNAME FILENAME)" (id pathname-replace-file)) (procedure "(pathname-replace-extension PATHNAME EXTENSION)" (id pathname-replace-extension))) (p "Return a new pathname with the specified component of " (tt "PATHNAME") " replaced by a new value."))) (section 4 "pathname-strip-directory") (section 4 "pathname-strip-extension" (def (sig (procedure "(pathname-strip-directory PATHNAME)" (id pathname-strip-directory)) (procedure "(pathname-strip-extension PATHNAME)" (id pathname-strip-extension))) (p "Return a new pathname with the specified component of " (tt "PATHNAME") " stripped."))) (section 4 "normalize-pathname" (def (sig (procedure "(normalize-pathname PATHNAME [PLATFORM])" (id normalize-pathname))) (p "Performs a simple \"normalization\" on the " (tt "PATHNAME") ", suitably for " (tt "PLATFORM") ", which should be one of the symbols " (tt "windows") " or " (tt "unix") " and defaults to on whatever platform is currently in use. All relative path elements and duplicate separators are processed and removed.  If " (tt "NAME") " ends with a " (tt "/") " or is empty, the appropriate slash is appended to the tail. Tilde " (tt "~") " and variable " (tt "$<name>/...") " expansion is also done.") (p "No directories or files are actually tested for existence; this procedure only canonicalises path syntax."))) (section 4 "directory-null?" (def (sig (procedure "(directory-null? DIRECTORY)" (id directory-null?))) (p "Does the " (tt "DIRECTORY") " consist only of path separators and the period?") (p (tt "DIRECTORY") " may be a string or a list of strings."))) (section 4 "decompose-directory" (def (sig (procedure "(decompose-directory DIRECTORY)" (id decompose-directory))) (p "Returns 3 values: the " (tt "base-origin") ", " (tt "base-directory") ", and the " (tt "directory-elements") " for the " (tt "DIRECTORY") ".") (dl (dt (tt "base-origin")) (dd "a " (tt "string") " or " (tt "#f") ". The drive, if any.") (dt (tt "base-directory")) (dd "a " (tt "string") " or " (tt "#f") ". A directory-separator when " (tt "DIRECTORY") " is an " (tt "absolute-pathname") ".") (dt (tt "directory-elements")) (dd "a " (tt "list-of string") " or " (tt "#f") ". The non-directory-separator bits.")) (p (tt "DIRECTORY") " is a " (tt "string") ".") (ul (li "On Windows " (tt "(decompose-directory \"c:foo/bar\")") " => " (tt "\"c:\" #f (\"foo\" \"bar\")")))))) (section 3 "Temporary files and directories" (section 4 "create-temporary-file" (def (sig (procedure "(create-temporary-file [EXTENSION])" (id create-temporary-file))) (p "Creates an empty temporary file and returns its pathname. If " (tt "EXTENSION") " is not given, then " (tt ".tmp") " is used. If the environment variable " (tt "TMPDIR, TEMP") " or " (tt "TMP") " is set, then the pathname names a file in that directory. If none of the environment variables is given the location of the temporary file defaults to " (tt "/tmp") " if it exists or the current-directory"))) (section 4 "create-temporary-directory" (def (sig (procedure "(create-temporary-directory)" (id create-temporary-directory))) (p "Creates an empty temporary directory and returns its pathname. If the environment variable " (tt "TMPDIR, TEMP") " or " (tt "TMP") " is set, then the temporary directory is created at that location.")))) (section 3 "Deleting a file without signalling an error" (section 4 "delete-file*" (def (sig (procedure "(delete-file* FILENAME)" (id delete-file*))) (p "If the file " (tt "FILENAME") " exists, it is deleted and " (tt "#t") " is returned.  If the file does not exist, nothing happens and " (tt "#f") " is returned.")))) (section 3 "File move/copy" (section 4 "file-copy" (def (sig (procedure "(file-copy ORIGFILE NEWFILE #!optional CLOBBER BLOCKSIZE)" (id file-copy))) (p "Copies " (tt "ORIGFILE") " (a string denoting some filename) to " (tt "NEWFILE") ", " (tt "BLOCKSIZE") " bytes at a time.  " (tt "BLOCKSIZE") " defaults to 1024, and must be a positive integer.  Returns the number of bytes copied on success, or errors on failure.  " (tt "CLOBBER") " determines the behaviour of " (tt "file-copy") " when " (tt "NEWFILE") " is already extant.  When set to " (tt "#f") " (default), an error is signalled.  When set to any other value, " (tt "NEWFILE") " is overwritten. " (tt "file-copy") " will work across filesystems and devices and is not platform-dependent."))) (section 4 "file-move" (def (sig (procedure "(file-move ORIGFILE NEWFILE #!optional CLOBBER BLOCKSIZE)" (id file-move))) (p "Moves " (tt "ORIGFILE") " (a string denoting some filename) to " (tt "NEWFILE") ", with the same semantics as " (tt "file-copy") ", above.  " (tt "file-move") " is safe across filesystems and devices (unlike " (tt "rename-file") ").  It is possible for an error to be signalled despite partial success if " (tt "NEWFILE") " could be created and fully written but removing " (tt "ORIGFILE") " fails.")) (hr) (p "Previous: " (int-link "Unit ports")) (p "Next: " (int-link "Unit extras"))))))