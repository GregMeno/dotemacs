(index ("#~STRING" 0) ("#~SYMBOL" 373) ("#~(ITEM ...)" 806))
(def (sig (read "#~STRING" (id "#~STRING"))) (p "Registers the shared library named STRING. Subsequent access to foreign symbols will try to find the required symbol in all libraries registered so far. The library name may also be " (tt "#f") ", which allows looking up symbols in the current executable (this may require special linker options, depending on platform)."))
(def (sig (read "#~SYMBOL" (id "#~SYMBOL"))) (p "Identifies a foreign symbol, which will be looked up in the currently registered shared libraries.  Returns a procedure that can be called like a normal Scheme procedure.") (p "A special case is the syntax " (tt "#~~") ". When used, an expression is expected preceding any further arguments that should evaluate to a foreign pointer object identifying the address of a C function."))
(def (sig (read "#~(ITEM ...)" (id "#~(ITEM ...)"))) (p "Equivalent to " (tt "(list #~ITEM ...)") ". This can be used to register several shared libraries at once or pre-resolve foreign symbols.") (p "A foreign procedure is called like a normal procedure, with argument values automatically converted to the appropriate foreign representation, using the following mapping of Scheme types to C types:") (table (tr (th "Scheme type") (th "C type")) "\n" (tr (td "boolean") (td (tt "int") " (1 or 0)")) "\n" (tr (td "exact") (td (tt "int"))) "\n" (tr (td "inexact") (td (tt "double"))) "\n" (tr (td "char") (td (tt "char"))) "\n" (tr (td "pointer or locative") (td (tt "void *"))) "\n" (tr (td "string") (td (tt "char *"))) "\n" (tr (td "symbol") (td (tt "char *")))) (p "Arguments of any other type will signal an error (see below for specifying argument conversions).") (p "Additionally the procedure can be called with a number of special keyword arguments:") (dl (dt (tt "return:")) (dd (tt "TYPE"))) (p "Specifies the result type. If not given, the result will be ignored. TYPE should be one of the following:") (table (tr (td (tt "int:"))) "\n" (tr (td (tt "char:"))) "\n" (tr (td (tt "float:"))) "\n" (tr (td (tt "double:"))) "\n" (tr (td (tt "pointer:"))) "\n" (tr (td (tt "string:"))) "\n" (tr (td (tt "symbol:"))) "\n" (tr (td (tt "bool:"))) "\n" (tr (td (tt "void:"))) "\n" (tr (td (tt "scheme-object:")))) (dl (dt (tt "safe:")) (dd (tt "BOOLEAN"))) (p "If given, then the call may call back into Scheme (for example by passing a pointer to a callback function).  If not given, then call may " (b "not") " invoke any Scheme callbacks, or bad things will happen.") (p (tt "TYPE VALUE")) (p "To force a specific argument type conversion (and to allow slightly better argument type checking), a type specifier may also be provided as a keyword, followed by the actual argument. Valid type specifiers are:") (table (tr (td (tt "int:")) (td "exact number")) "\n" (tr (td (tt "float: double:")) (td "inexact number")) "\n" (tr (td (tt "pointer:")) (td "pointer object")) "\n" (tr (td (tt "bool:")) (td "boolean (actually any Scheme object), will be passed as 1 or 0")) "\n" (tr (td (tt "char:")) (td "char")) "\n" (tr (td (tt "string:")) (td "string")) "\n" (tr (td (tt "symbol:")) (td "string (the name of the symbol)")) "\n" (tr (td (tt "scheme-object:")) (td "any Scheme value")) "\n" (tr (td (tt "scheme-pointer:")) (td "any non-immediate Scheme value (a pointer to the data-section will be passed)"))) (p "(The type specifiers " (tt "scheme-pointer:") " and " (tt "scheme-object:") " are mainly intended for advanced uses of this extension)"))
