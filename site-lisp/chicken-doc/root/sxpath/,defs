(index ("sxpath" 0) ("if-sxpath" 2242) ("car-sxpath" 2454) ("if-car-sxpath" 2658) ("sxml:id-alist" 2831) ("sxml:xpath" 4337) ("txpath" 4337) ("sxml:xpath+root" 4337) ("sxml:xpath+root+vars" 4337) ("sxml:xpath+index" 6738) ("sxml:xpointer" 7068) ("sxml:xpointer+root+vars" 7068) ("sxml:xpointer+index" 8424) ("sxml:xpath-expr" 8766) ("sxml:core-last" 9833) ("sxml:core-position" 9833) ("sxml:core-count" 9833) ("sxml:core-id" 9833) ("sxml:core-local-name" 9833) ("sxml:core-namespace-uri" 9833) ("sxml:core-name" 9833) ("sxml:core-string" 10287) ("sxml:core-concat" 10287) ("sxml:core-starts-with" 10287) ("sxml:core-contains" 10287) ("sxml:core-substring-before" 10287) ("sxml:core-substring-after" 10287) ("sxml:core-substring" 10287) ("sxml:core-string-length" 10287) ("sxml:core-normalize-space" 10287) ("sxml:core-translate" 10287) ("sxml:core-boolean" 11096) ("sxml:core-not" 11096) ("sxml:core-true" 11096) ("sxml:core-false" 11096) ("sxml:core-lang" 11096) ("sxml:core-number" 11394) ("sxml:core-sum" 11394) ("sxml:core-floor" 11394) ("sxml:core-ceiling" 11394) ("sxml:core-round" 11394) ("sxml:classic-params" 11712) ("sxml:empty-element?" 12139) ("sxml:shallow-normalized?" 12483) ("sxml:normalized?" 12745) ("sxml:shallow-minimized?" 12973) ("sxml:minimized?" 13231) ("sxml:name" 13455) ("sxml:element-name" 13604) ("sxml:node-name" 13822) ("sxml:ncname" 14315) ("sxml:name->ns-id" 14865) ("sxml:content" 15245) ("sxml:text" 16015) ("sxml:content-raw" 16534) ("sxml:attr-list-u" 17039) ("sxml:aux-list" 17281) ("sxml:aux-list-u" 17281) ("sxml:aux-node" 17584) ("sxml:aux-nodes" 17996) ("sxml:attr" 18222) ("sxml:attr-from-list" 18449) ("sxml:num-attr" 18812) ("sxml:attr-u" 19109) ("sxml:ns-list" 19358) ("sxml:ns-id->nodes" 19592) ("sxml:ns-id->uri" 20121) ("sxml:ns-uri->nodes" 20554) ("sxml:ns-uri->id" 21032) ("sxml:ns-id" 21476) ("sxml:ns-uri" 21626) ("sxml:ns-prefix" 21779) ("sxml:change-content!" 22018) ("sxml:change-content" 22018) ("sxml:change-attrlist" 22421) ("sxml:change-attrlist!" 22421) ("sxml:change-name" 22696) ("sxml:change-name!" 22696) ("sxml:add-attr" 22933) ("sxml:add-attr!" 22933) ("sxml:change-attr" 23229) ("sxml:change-attr!" 23229) ("sxml:set-attr" 23649) ("sxml:set-attr!" 23649) ("sxml:add-aux" 24040) ("sxml:add-aux!" 24040) ("sxml:squeeze" 24266) ("sxml:squeeze!" 24266) ("sxml:clean" 24562) ("select-first-kid" 24804) ("sxml:node-parent" 25129) ("sxml:add-parents" 25465) ("sxml:lookup" 25914) ("sxml:attr->xml" 26085) ("sxml:string->xml" 26553) ("sxml:sxml->xml" 26837) ("sxml:attr->html" 27082) ("sxml:string->html" 27621) ("sxml:non-terminated-html-tag?" 27893) ("sxml:sxml->html" 28103) ("nodeset?" 28351) ("as-nodeset" 28467) ("sxml:element?" 28613) ("ntype-names??" 28782) ("ntype??" 29121) ("ntype-namespace-id??" 30289) ("sxml:complement" 30651) ("node-eq?" 30917) ("node-equal?" 31103) ("node-pos" 31299) ("sxml:filter" 31997) ("take-until" 32440) ("take-after" 32440) ("map-union" 33394) ("node-reverse" 33676) ("select-kids" 33945) ("node-self" 34207) ("node-join" 34488) ("node-reduce" 35066) ("node-or" 35428) ("node-closure" 35686) ("node-trace" 35933) ("sxml:node?" 36296) ("sxml:attr-list" 36519) ("sxml:attribute" 37039) ("sxml:child" 37533) ("sxml:parent" 37727) ("node-parent" 38226) ("sxml:child-nodes" 38554) ("sxml:child-elements" 38761) ("sxml:string" 39021) ("sxml:boolean" 39402) ("sxml:number" 39580) ("sxml:string-value" 39912) ("sxml:id" 40070) ("sxml:list-head" 40474) ("sxml:merge-sort" 40791) ("sxml:equality-cmp" 41088) ("sxml:equal?" 41657) ("sxml:not-equal?" 41657) ("sxml:relational-cmp" 41937) ("sxml:ancestor" 42402) ("sxml:ancestor-or-self" 42610) ("sxml:descendant" 42794) ("sxml:descendant-or-self" 42985) ("sxml:following" 43175) ("sxml:following-sibling" 43437) ("sxml:preceding" 43648) ("sxml:preceding-sibling" 43910) ("sxml:namespace" 44121))
(def (sig (procedure "(sxpath path [ns-binding])" (id sxpath))) (p "Returns a procedure that accepts an SXML document tree and an optional association list of variables and returns a nodeset (list of nodes) that match the " (tt "path") " expression.") (p "The optional " (tt "ns-binding") " argument is an alist of namespace bindings.  It is used to map abbreviated namespace prefixes to full URI strings but " (i "only for textual XPath strings") " embedded in the " (tt "path") " expression.") (p "The optional association list of variables must include all the variables defined by the " (tt "sxpath") " expression.") (p "It can be useful to compare the following examples to those for " (int-link "#txpath" "txpath") ".") (highlight scheme "(use sxpath)\n\n;; selects all the 'item' elements that have an 'olist' parent\n;; (which is not root) and that are in the same document as the context node\n((sxpath `(// olist item))\n '(doc (olist (item \"1\")) (item \"2\") (nested (olist (item \"3\")))))\n => ((item \"1\") (item \"3\"))\n\n\n(use sxpath-lolevel data-structures)\n\n;; selects only the nth 'item' element under each 'olist' parent\n;; (which is not root) and that is in the same document as the context node\n;; The n is parameterized to be the first item\n;; The node-pos function comes from sxpath-lolevel and implements txpath position selector [$n]\n((sxpath `(// olist ((item ,(lambda (nodeset var-binding) ((node-pos (alist-ref 'n var-binding)) nodeset))))))\n '(doc (olist (item \"1\") (item \"2\")) (nested (olist (item \"3\")))) '((n . 1)))\n => ((item \"1\") (item \"3\"))\n\n;; selects the 'chapter' children of the context node that have one or\n;; more 'title' children with string-value equal to 'Introduction'\n((sxpath '((chapter ((equal? (title \"Introduction\"))))))\n '(text  (chapter (title \"Introduction\"))  (chapter \"No title for this chapter\")  (chapter (title \"Conclusion\"))))\n => ((chapter (title \"Introduction\")))\n\n;; (sxpath string-expr) is equivalent to (txpath string-expr)\n((sxpath \"chapter[title='Introduction']\")\n '(text  (chapter (title \"Introduction\"))  (chapter \"No title for this chapter\")  (chapter (title \"Conclusion\"))))\n => ((chapter (title \"Introduction\")))"))
(def (sig (procedure "(if-sxpath path)" (id if-sxpath))) (p "Like " (tt "sxpath") ", only returns " (tt "#f") " instead of the empty list if nothing matches (so it does " (i "not") " always return a nodeset)."))
(def (sig (procedure "(car-sxpath path)" (id car-sxpath))) (p "Like " (tt "sxpath") ", only instead of a nodeset it returns the first node found.  If no node was found, return " (b "an empty list") "."))
(def (sig (procedure "(if-car-sxpath path)" (id if-car-sxpath))) (p "Like " (tt "car-sxpath") ", only returns " (tt "#f") " instead of the empty list if nothing matches."))
(def (sig (procedure "(sxml:id-alist node . lpaths)" (id sxml:id-alist))) (p "Builds an index as a list of " (tt "(ID_value . element)") " pairs for given " (tt "node") ". " (tt "lpaths") " are location paths for attributes of type ID (ie, sxpath expressions that tell it how to find the ID attribute).") (p "Note: location paths " (i "must") " be of the form " (tt "(expr '@ attrib-name)") ".") (p "See also " (tt "sxml:lookup") " below, in " (tt "sxpath-lolevel") ", which can use this index.") (highlight scheme "\n;; Obtain ID values for a regular XHTML DOM\n(sxml:id-alist\n '(div (h1 (@ (id \"info\"))\n           \"A story\")\n       (p (@ (id \"story-body\"))\n\t  \"Once upon a time\")\n       (a (@ (id \"back\") (href \"../index.xml\"))\n\t  \"click here to go back\"))\n '(* @ id))\n => ((\"info\" h1 (@ (id \"info\")) \"A story\")\n     (\"story-body\" p (@ (id \"story-body\")) \"Once upon a time\")\n     (\"back\" a (@ (id \"back\") (href \"../index.xml\")) \"click here to go back\"))\n\n;; In an alternate reality, where links are uniquely identified\n;; by their href, we would use this\n(sxml:id-alist\n '(div (h1 (@ (id \"info\"))\n\t   \"A story\")\n       (p (@ (id \"story-body\"))\n\t  \"Once upon a time\")\n       (a (@ (id \"back\") (href \"../index.xml\"))\n\t  \"click here to go back\"))\n '(h1 @ foo) '(a @ href))\n => ((\"../index.xml\" . (a (@ (id \"back\")\n                             (href \"../index.xml\"))\n                          \"click here to go back\")))"))
(def (sig (procedure "(sxml:xpath string . ns-binding)" (id sxml:xpath)) (procedure "(txpath string . ns-binding)" (id txpath)) (procedure "(sxml:xpath+root string . ns-binding)" (id sxml:xpath+root)) (procedure "(sxml:xpath+root+vars string . ns-binding)" (id sxml:xpath+root+vars))) (p "Returns a procedure that accepts an SXML document tree and an optional association list of variable bindings and returns a nodeset (list of nodes) that match the XPath expression " (tt "string") ".") (p "The optional " (tt "ns-binding") " argument is an alist of namespace bindings.  It is used to map abbreviated namespace prefixes to full URI strings.") (p (tt "(txpath x)") " is equivalent to " (tt "(sxpath x)") " whenever " (tt "x") " is a string.  The " (tt "txpath") ", " (tt "sxml:xpath+root") " and " (tt "sxml:xpath+root+vars") " procedures are currently all aliases for " (tt "sxml:xpath") ", which exist for backwards compatibility reasons.") (p "It's useful to compare the following examples to the above examples for " (int-link "#sxpath" "sxpath") ".") (highlight scheme "(use txpath)\n\n;; selects all the 'item' elements that have an 'olist' parent\n;; (which is not root) and that are in the same document as the context node\n((txpath \"//olist/item\")\n '(doc (olist (item \"1\")) (item \"2\") (nested (olist (item \"3\")))))\n => ((item \"1\") (item \"3\"))\n\n;; Same example as above, but now with a namespace prefix of 'x',\n;; which is bound to the namespace \"bar\" in the ns-binding parameter.\n((txpath \"//x:olist/item\" '((x . \"bar\")))\n '(doc (bar:olist (item \"1\")) (item \"2\") (nested (olist (item \"3\")))))\n => ((item \"1\"))\n\n\n(use sxpath sxpath-lolevel data-structures)\n\n;; selects only the nth 'item' element under each 'olist' parent\n;; (which is not root) and that is in the same document as the context node\n;; The n is parameterized to be the first item\n((txpath \"//olist/item[$n]\")\n '(doc (olist (item \"1\") (item \"2\")) (nested (olist (item \"3\")))) '((n . 1)))\n => ((item \"1\") (item \"3\"))\n\n;; selects the 'chapter' children of the context node that have one or\n;; more 'title' children with string-value equal to 'Introduction'\n((txpath \"chapter[title='Introduction']\")\n '(text  (chapter (title \"Introduction\"))  (chapter \"No title for this chapter\")  (chapter (title \"Conclusion\"))))\n => ((chapter (title \"Introduction\")))"))
(def (sig (procedure "(sxml:xpath+index string . ns-binding)" (id sxml:xpath+index))) (p "This procedure returns the result of " (tt "sxml:xpath") " consed onto " (tt "#t") ".  If the " (tt "sxml:xpath") " would return " (tt "#f") ", this returns " (tt "#f") " instead.") (p "It is provided solely for backwards compatibility."))
(def (sig (procedure "(sxml:xpointer string . ns-binding)" (id sxml:xpointer)) (procedure "(sxml:xpointer+root+vars string . ns-binding)" (id sxml:xpointer+root+vars))) (p "Returns a procedure that accepts an SXML document tree and returns a nodeset (list of nodes) that match the XPointer expression " (tt "string") ".") (p "The optional " (tt "ns-binding") " argument is an alist of namespace bindings.  It is used to map abbreviated namespace prefixes to full URI strings.") (p "Currently, only the XPointer " (tt "xmlns()") " and " (tt "xpointer()") " schemes are implemented, the " (tt "element()") " scheme is not.") (highlight scheme ";; selects all the 'item' elements that have an 'olist' parent\n;; (which is not root) and that are in the same document as the context node.\n;; Equivalent to (txpath \"//olist/item\").\n((sxml:xpointer \"xpointer(//olist/item)\")\n '(doc (olist (item \"1\")) (item \"2\") (nested (olist (item \"3\")))))\n => ((item \"1\") (item \"3\"))\n\n;; An example with a namespace prefix, now using the XPointer xmlns()\n;; function instead of the ns-binding parameter. xmlns always have full\n;; namespace names on their right-hand side, never bound shortcuts.\n((sxml:xpointer \"xmlns(x=bar)xpointer(//x:olist/item)\")\n '(doc (bar:olist (item \"1\")) (item \"2\") (nested (olist (item \"3\")))))\n => ((item \"1\"))"))
(def (sig (procedure "(sxml:xpointer+index string . ns-binding)" (id sxml:xpointer+index))) (p "This procedure returns the result of " (tt "sxml:xpointer") " consed onto " (tt "#t") ".  If the " (tt "sxml:xpointer") " would return " (tt "#f") ", this returns " (tt "#f") " instead.") (p "It is provided solely for backwards compatibility."))
(def (sig (procedure "(sxml:xpath-expr string . ns-binding)" (id sxml:xpath-expr))) (p "Returns a procedure that accepts an SXML node and returns " (tt "#t") " if the node matches the " (tt "string") " expression.  This is an expression of type " (tt "Expr") ", which is whatever you can put in a predicate (between square brackets after a node name).") (p "The optional " (tt "ns-binding") " argument is an alist of namespace bindings.  It is used to map abbreviated namespace prefixes to full URI strings.") (highlight scheme ";; Does the node have a class attribute with \"content\" as value?\n((sxml:xpath-expr \"@class=\\\"content\\\"\")\n '(div (@ (class \"content\")) (p \"Lorem ipsum\")))\n => #t\n\n;; Does the node have a paragraph with string value of \"Lorem ipsum\"?\n((sxml:xpath-expr \"p=\\\"Lorem ipsum\\\"\")\n '(div (@ (class \"content\")) (p \"Lorem ipsum\")))\n => #t\n\n;; Does the node have a \"p\" child node with string value of \"Blah\"?\n((sxml:xpath-expr \"p=\\\"Blah\\\"\")\n '(div (@ (class \"content\")) (p \"Lorem ipsum\")))\n => #f"))
(def (sig (procedure "(sxml:core-last)" (id sxml:core-last)) (procedure "(sxml:core-position)" (id sxml:core-position)) (procedure "(sxml:core-count node-set)" (id sxml:core-count)) (procedure "(sxml:core-id object)" (id sxml:core-id)) (procedure "(sxml:core-local-name [node-set])" (id sxml:core-local-name)) (procedure "(sxml:core-namespace-uri [node-set])" (id sxml:core-namespace-uri)) (procedure "(sxml:core-name [node-set])" (id sxml:core-name))))
(def (sig (procedure "(sxml:core-string [object])" (id sxml:core-string)) (procedure "(sxml:core-concat [string ...])" (id sxml:core-concat)) (procedure "(sxml:core-starts-with string prefix)" (id sxml:core-starts-with)) (procedure "(sxml:core-contains string substring)" (id sxml:core-contains)) (procedure "(sxml:core-substring-before string separator)" (id sxml:core-substring-before)) (procedure "(sxml:core-substring-after string separator)" (id sxml:core-substring-after)) (procedure "(sxml:core-substring string numeric-offset [length])" (id sxml:core-substring)) (procedure "(sxml:core-string-length [string])" (id sxml:core-string-length)) (procedure "(sxml:core-normalize-space [string])" (id sxml:core-normalize-space)) (procedure "(sxml:core-translate string from to)" (id sxml:core-translate))))
(def (sig (procedure "(sxml:core-boolean object)" (id sxml:core-boolean)) (procedure "(sxml:core-not boolean)" (id sxml:core-not)) (procedure "(sxml:core-true)" (id sxml:core-true)) (procedure "(sxml:core-false)" (id sxml:core-false)) (procedure "(sxml:core-lang lang-code)" (id sxml:core-lang))))
(def (sig (procedure "(sxml:core-number [object])" (id sxml:core-number)) (procedure "(sxml:core-sum node-set)" (id sxml:core-sum)) (procedure "(sxml:core-floor number)" (id sxml:core-floor)) (procedure "(sxml:core-ceiling number)" (id sxml:core-ceiling)) (procedure "(sxml:core-round number)" (id sxml:core-round))))
(def (sig (constant "sxml:classic-params" (id sxml:classic-params))) (p "This is a very long list of parameters containing parser and traversal information for the textual xpath parser engine.  This corresponds to the \"function library\" mentioned in the " (link "http://www.w3.org/TR/xpath#section-Introduction" "introduction of the XPath spec") ". You will have read the source code for details on how exactly to use it."))
(def (sig (procedure "(sxml:empty-element? obj)" (id sxml:empty-element?))) (p "Predicate which returns " (tt "#t") " if given element " (tt "obj") " is empty. Empty elements have no nested elements, text nodes, PIs, Comments or entities but may contain attributes or namespace-id.  It is a SXML counterpart of XML " (tt "empty-element") "."))
(def (sig (procedure "(sxml:shallow-normalized? obj)" (id sxml:shallow-normalized?))) (p "Returns " (tt "#t") " if the given " (tt "obj") " is a shallow-normalized SXML element.  The element itself has to be normalised but its nested elements are not tested."))
(def (sig (procedure "(sxml:normalized? obj)" (id sxml:normalized?))) (p "Returns " (tt "#t") " if the given " (tt "obj") " is a normalized SXML element.  The element itself and all its nested elements have to be normalised."))
(def (sig (procedure "(sxml:shallow-minimized? obj)" (id sxml:shallow-minimized?))) (p "Returns " (tt "#t") " if the given " (tt "obj") " is a shallow-minimized SXML element.  The element itself has to be minimised but its nested elements are not tested."))
(def (sig (procedure "(sxml:minimized? obj)" (id sxml:minimized?))) (p "Returns " (tt "#t") " if the given " (tt "obj") " is a minimized SXML element.  The element itself and all its nested elements have to be minimised."))
(def (sig (procedure "(sxml:name node)" (id sxml:name))) (p "Returns a name of a given SXML node. It is introduced for the sake of encapsulation."))
(def (sig (procedure "(sxml:element-name obj)" (id sxml:element-name))) (p "A checked version of sxml:name, which returns " (tt "#f") " if the given " (tt "obj") " is not a SXML element. Otherwise returns its name."))
(def (sig (procedure "(sxml:node-name obj)" (id sxml:node-name))) (p "Safe version of sxml:name, which returns " (tt "#f") " if the given " (tt "obj") " is not a SXML node.  Otherwise returns its name.") (p "The difference between this and " (tt "sxml::element-name") " is that a node can be one of " (tt "@") ", " (tt "@@") ", " (tt "*PI*") ", " (tt "*COMMENT*") " or " (tt "*ENTITY*") " while an element must be a real element (any symbol not in that set is considered to be an element)."))
(def (sig (procedure "(sxml:ncname node)" (id sxml:ncname))) (p "Like " (tt "sxml:name") ", except returns only the local part of the name (called an \"NCName\" in the " (link "http://www.w3.org/TR/xml-names/" "XML namespaces spec") ").") (p "The node's name is interpreted as a \"Qualified Name\", a colon-separated name of which the last one is considered to be the local part.  If the name contains no colons, the name itself is returned.") (p (b "Important:") " Please note that while an SXML name is a symbol, this function returns a string."))
(def (sig (procedure "(sxml:name->ns-id sxml-name)" (id sxml:name->ns-id))) (p "Given a node name, return the namespace part of the name (called a " (tt "namespace-id") ").  If the name contains no colons, returns " (tt "#f") ".  See " (tt "sxml:ncname") " for more info.") (p (b "Important:") " Please note that while an SXML name is a symbol, this function returns a string."))
(def (sig (procedure "(sxml:content obj)" (id sxml:content))) (p "Retrieve the contents of an SXML element or nodeset.  Any non-element nodes (attributes, processing instructions, etc) are discarded, while the elements and text nodes are returned as a list of strings and nested elements in document order.  This list is empty if " (tt "obj") " is an empty element or empty list.") (p "The inner elements are unmodified so they still contain attributes, but also comments or other non-element nodes.") (highlight scheme "(sxml:content\n  '(div (@ (class \"content\"))\n        (*COMMENT* \"main contents start here\")\n         \"The document moved \"\n\t (a (@ (href \"/other.xml\")) \"here\")))\n => (\"The document moved \" (a (@ (href \"/other.xml\")) \"here\"))"))
(def (sig (procedure "(sxml:text node)" (id sxml:text))) (p "Returns a string which combines all the character data from text node children of the given SXML element or \"\" if there are no text node children.  Note that it does not include text from descendant nodes, only direct children.") (highlight scheme "(sxml:text\n  '(div (@ (class \"content\"))\n        (*COMMENT* \"main contents start here\")\n         \"The document moved \"\n\t (a (@ (href \"/other.xml\")) \"here\")))\n => (\"The document moved \")"))
(def (sig (procedure "(sxml:content-raw obj)" (id sxml:content-raw))) (p "Returns all the content of normalized SXML element except attr-list and aux-list.  Thus it includes " (tt "PI") ", " (tt "COMMENT") " and " (tt "ENTITY") " nodes as well as " (tt "TEXT") " and " (tt "ELEMENT") " nodes returned by " (tt "sxml:content") ".  Returns a list of nodes in document order or empty list if " (tt "obj") " is an empty element or an empty list.") (p "This function is faster than " (tt "sxml:content") "."))
(def (sig (procedure "(sxml:attr-list-u obj)" (id sxml:attr-list-u))) (p "Returns the list of attributes for given element or nodeset.  Analog of " (tt "((sxpath '(@ *)) obj)") ".  Empty list is returned if there is no list of attributes."))
(def (sig (procedure "(sxml:aux-list obj)" (id sxml:aux-list)) (procedure "(sxml:aux-list-u obj)" (id sxml:aux-list-u))) (p "Returns the list of auxiliary nodes for given element or nodeset. Analog of " (tt "((sxpath '(@@ *)) obj)") ".  Empty list is returned if a list of auxiliary nodes is absent."))
(def (sig (procedure "(sxml:aux-node obj aux-name)" (id sxml:aux-node))) (p "Return the first aux-node with <aux-name> given in SXML element " (tt "obj") " or " (tt "#f") " is such a node is absent.") (p (b "NOTE:") " it returns just the " (i "first") " node found even if multiple nodes are present, so it's mostly intended for nodes with unique names. Use " (tt "sxml:aux-nodes") " if you want all of them."))
(def (sig (procedure "(sxml:aux-nodes obj aux-name)" (id sxml:aux-nodes))) (pre "  ") (p "Return a list of aux-nodes with " (tt "aux-name") " given in SXML element " (tt "obj") " or " (tt "'()") " if such a node is absent."))
(def (sig (procedure "(sxml:attr obj attr-name)" (id sxml:attr))) (p "Returns the value of the attribute with name " (tt "attr-name") " in the given SXML element " (tt "obj") ", or " (tt "#f") " if no such attribute exists."))
(def (sig (procedure "(sxml:attr-from-list attr-list name)" (id sxml:attr-from-list))) (p "Returns the value of the attribute with name " (tt "attr-name") " in the given list of attributes " (tt "attr-list") ", or " (tt "#f") " if no such attribute exists.  The list of attributes can be obtained from an element using the " (tt "sxml:attr-list") " procedure."))
(def (sig (procedure "(sxml:num-attr obj attr-name)" (id sxml:num-attr))) (p "Returns the value of the numerical attribute with name " (tt "attr-name") " in the given SXML element " (tt "obj") ", or " (tt "#f") " if no such attribute exists.  This value is converted from a string to a number."))
(def (sig (procedure "(sxml:attr-u obj attr-name)" (id sxml:attr-u))) (p "Accessor for an attribute " (tt "attr-name") " of given SXML element " (tt "obj") ", which may also be an attributes-list or a nodeset (usually content of an SXML element)"))
(def (sig (procedure "(sxml:ns-list obj)" (id sxml:ns-list))) (p "Returns the list of namespaces for given element.  Analog of " (tt "((sxpath '(@@ *NAMESPACES* *)) obj)") ".  The empty list is returned if there are no namespaces."))
(def (sig (procedure "(sxml:ns-id->nodes obj namespace-id)" (id sxml:ns-id->nodes))) (p "Returns a list of namespace information lists that match the given " (tt "namespace-id") " in SXML element " (tt "obj") ".  Analog of " (tt "((sxpath '(@@ *NAMESPACES* namespace-id)) obj)") ". The empty list is returned if there is no namespace with the given " (tt "namespace-id") ".") (highlight scheme "(sxml:ns-id->nodes\n  '(c:part (@) (@@ (*NAMESPACES* (c \"http://www.cars.com/xml\")))) 'c)\n => ((c \"http://www.cars.com/xml\"))"))
(def (sig (procedure "(sxml:ns-id->uri obj namespace-id)" (id sxml:ns-id->uri))) (p "Returns the URI for the (first) namespace matching the given " (tt "namespace-id") ", or " (tt "#f") " if no namespace matches the given " (tt "namespace-id") ".") (p "<enscript highlight=\"scheme\" (sxml:ns-id->uri") (pre " '(c:part (@) (@@ (*NAMESPACES* (c \"http://www.cars.com/xml\")))) 'c)\n=> \"http://www.cars.com/xml\"") (p "</enscript>"))
(def (sig (procedure "(sxml:ns-uri->nodes obj uri)" (id sxml:ns-uri->nodes))) (p "Returns a list of namespace information lists that match the given " (tt "uri") " in SXML element " (tt "obj") ".") (highlight scheme "(sxml:ns-uri->nodes\n  '(c:part (@) (@@ (*NAMESPACES* (c \"http://www.cars.com/xml\")\n                                 (d \"http://www.cars.com/xml\"))))\n  \"http://www.cars.com/xml\")\n => ((c \"http://www.cars.com/xml\") (d \"http://www.cars.com/xml\"))"))
(def (sig (procedure "(sxml:ns-uri->id obj uri)" (id sxml:ns-uri->id))) (p "Returns the namespace id for the (first) namespace matching the given " (tt "uri") ", or " (tt "#f") " if no namespace matches the given " (tt "uri") ".") (highlight scheme "(sxml:ns-uri->id\n  '(c:part (@) (@@ (*NAMESPACES* (c \"http://www.cars.com/xml\")\n                                 (d \"http://www.cars.com/xml\"))))\n  \"http://www.cars.com/xml\")\n => c"))
(def (sig (procedure "(sxml:ns-id ns-list)" (id sxml:ns-id))) (p "Given a namespace information list " (tt "ns-list") ", returns the namespace ID."))
(def (sig (procedure "(sxml:ns-uri ns-list)" (id sxml:ns-uri))) (p "Given a namespace information list " (tt "ns-list") ", returns the namespace URI."))
(def (sig (procedure "(sxml:ns-prefix ns-list)" (id sxml:ns-prefix))) (p "Given a namespace information list " (tt "ns-list") ", returns the namespace prefix if it is present in the list.  If it's not present, returns the namespace ID."))
(def (sig (procedure "(sxml:change-content! obj new-content)" (id sxml:change-content!)) (procedure "(sxml:change-content obj new-content)" (id sxml:change-content))) (p "Change the content of given SXML element " (tt "obj") " to " (tt "new-content") ". If " (tt "new-content") " is an empty list then the " (tt "obj") " is transformed to an empty element.  The resulting SXML element is normalized."))
(def (sig (procedure "(sxml:change-attrlist obj new-attrlist)" (id sxml:change-attrlist)) (procedure "(sxml:change-attrlist! obj new-attrlist)" (id sxml:change-attrlist!))) (p "Change the attribute list of the given SXML element " (tt "obj") " to " (tt "new-attrlist") "."))
(def (sig (procedure "(sxml:change-name obj new-name)" (id sxml:change-name)) (procedure "(sxml:change-name! obj new-name)" (id sxml:change-name!))) (p "Change the name of the given SXML element " (tt "obj") " to " (tt "new-name") "."))
(def (sig (procedure "(sxml:add-attr obj attr)" (id sxml:add-attr)) (procedure "(sxml:add-attr! obj attr)" (id sxml:add-attr!))) (p "Returns the given SXML element " (tt "obj") " with the attribute " (tt "attr") " added to the attribute list, or " (tt "#f") " if the attribute already exists."))
(def (sig (procedure "(sxml:change-attr obj attr)" (id sxml:change-attr)) (procedure "(sxml:change-attr! obj attr)" (id sxml:change-attr!))) (p "Returns SXML element " (tt "obj") " with changed value of attribute " (tt "attr") " or " (tt "#f") " if where is no attribute with given name.") (p (tt "attr") " is a list like it would occur as a member of an attribute list: " (tt "(attr-name attr-value)") ".") (pre "  "))
(def (sig (procedure "(sxml:set-attr obj attr)" (id sxml:set-attr)) (procedure "(sxml:set-attr! obj attr)" (id sxml:set-attr!))) (p "Returns SXML element " (tt "obj") " with changed value of attribute " (tt "attr") ". If there is no such attribute the new one is added.") (p (tt "attr") " is a list like it would occur as a member of an attribute list: " (tt "(attr-name attr-value)") "."))
(def (sig (procedure "(sxml:add-aux obj aux-node)" (id sxml:add-aux)) (procedure "(sxml:add-aux! obj aux-node)" (id sxml:add-aux!))) (p "Returns SXML element " (tt "obj") " with an auxiliary node " (tt "aux-node") " added."))
(def (sig (procedure "(sxml:squeeze obj)" (id sxml:squeeze)) (procedure "(sxml:squeeze! obj)" (id sxml:squeeze!))) (p "Returns a minimized and normalized SXML element " (tt "obj") " with empty lists of attributes and aux-lists eliminated, in " (tt "obj") " and all its descendants.") (pre "  "))
(def (sig (procedure "(sxml:clean obj)" (id sxml:clean))) (p "Returns a minimized and normalized SXML element " (tt "obj") " with empty lists of attributes and " (b "all") " aux-lists eliminated, in " (tt "obj") " and all its descendants."))
(def (sig (procedure "(select-first-kid test-pred?)" (id select-first-kid))) (p "Given a node, return the first child that satisfies the " (tt "test-pred?") ".  Given a nodeset, traverse the set until a node is found whose first child matches the predicate.  Returns " (tt "#f") " if there is no such a child to be found."))
(def (sig (procedure "(sxml:node-parent rootnode)" (id sxml:node-parent))) (p "Returns a function of one argument - an SXML element - which returns its parent node using " (tt "*PARENT*") " pointer in the aux-list. " (tt "'*TOP-PTR*") " may be used as a pointer to root node.  It returns an empty list when applied to the root node."))
(def (sig (procedure "(sxml:add-parents obj [top-ptr])" (id sxml:add-parents))) (p "Returns the SXML element " (tt "obj") " annotated with " (tt "*PARENT*") " pointers for " (tt "obj") " and all its descendants.  If " (tt "obj") " is not the root node (a node with a name of " (tt "*TOP*") "), you must pass in the parent pointer for " (tt "obj") " as " (tt "top-ptr") ".") (p (b "Warning:") " This procedure mutates its " (tt "obj") " argument."))
(def (sig (procedure "(sxml:lookup id index)" (id sxml:lookup))) (p "Lookup an element using its ID.  " (tt "index") " should be an alist of " (tt "(id . element)") "."))
(def (sig (procedure "(sxml:attr->xml attr)" (id sxml:attr->xml))) (p "Returns a list containing tokens that when joined together form the attribute's XML output.") (p (b "Warning:") " This procedure assumes that the attribute's values have already been escaped (ie, " (tt "sxml:string->xml has been called on the strings inside it") ").") (highlight scheme "(sxml:attr->xml '(href \"http://example.com\"))\n => (\" \" \"href\" \"='\" \"http://example.com\" \"'\")"))
(def (sig (procedure "(sxml:string->xml string)" (id sxml:string->xml))) (p "Escape the " (tt "string") " so it can be used anywhere in XML output.  This converts the " (tt "<") ", " (tt ">") ", " (tt "'") ", " (tt "\"") " and " (tt "&") " characters to their respective entities."))
(def (sig (procedure "(sxml:sxml->xml tree)" (id sxml:sxml->xml))) (p "Convert the " (tt "tree") " of SXML nodes to a nested list of XML fragments. These fragments can be output by flattening the list and concatenating the strings inside it."))
(def (sig (procedure "(sxml:attr->html attr)" (id sxml:attr->html))) (p "Returns a list containing tokens that when joined together form the attribute's HTML output.  The difference with the XML variant is that this encodes empty attribute values to attributes with no value (think " (tt "selected") " in option elements, or " (tt "checked") " in checkboxes).") (p (b "Warning:") " This procedure assumes that the attribute's values have already been escaped (ie, " (tt "sxml:string->html has been called on the strings inside it") ")."))
(def (sig (procedure "(sxml:string->html string)" (id sxml:string->html))) (p "Escape the " (tt "string") " so it can be used anywhere in XML output.  This converts the " (tt "<") ", " (tt ">") ", " (tt "\"") " and " (tt "&") " characters to their respective entities."))
(def (sig (procedure "(sxml:non-terminated-html-tag? tag)" (id sxml:non-terminated-html-tag?))) (p "Is the named " (tt "tag") " one that is \"self-closing\" (ie, does not need to be terminated) in HTML 4.0?"))
(def (sig (procedure "(sxml:sxml->html tree)" (id sxml:sxml->html))) (p "Convert the " (tt "tree") " of SXML nodes to a nested list of HTML fragments. These fragments can be output by flattening the list and concatenating the strings inside it."))
(def (sig (procedure "(nodeset? obj)" (id nodeset?))) (p "Returns " (tt "#t") " if " (tt "obj") " is a nodelist."))
(def (sig (procedure "(as-nodeset obj)" (id as-nodeset))) (p "If " (tt "obj") " is a nodelist - returns it as is, otherwise wrap it in a list."))
(def (sig (procedure "(sxml:element? obj)" (id sxml:element?))) (p "Predicate which returns " (tt "#t") " if " (tt "obj") " is SXML element, otherwise " (tt "#f") "."))
(def (sig (procedure "(ntype-names?? crit)" (id ntype-names??))) (p "Takes a list of acceptable node names as a criterion and returns a function, which, when applied to a node, will return " (tt "#t") " if the node name is present in criterion list and " (tt "#f") " otherwise.") (pre "  ntype-names?? :: ListOfNames -> Node -> Boolean"))
(def (sig (procedure "(ntype?? crit)" (id ntype??))) (p "Takes a type criterion and returns a function, which, when applied to a node, will tell if the node satisfies the test.") (pre " ntype?? :: Crit -> Node -> Boolean") (p "The criterion " (tt "crit") " is  one of the following symbols:") (dl (dt (tt "@")) (dd "tests if the Node is an " (tt "attributes-list")) (dt (tt "*")) (dd "tests if the Node is an " (tt "Element")) (dt (tt "*text*")) (dd "tests if the Node is a text node") (dt (tt "*data*")) (dd "tests if the Node is a data node  (text, number, boolean, etc., but not pair)") (dt (tt "*PI*")) (dd "tests if the Node is a processing instructions node") (dt (tt "*COMMENT*")) (dd "tests if the Node is a comment node") (dt (tt "*ENTITY*")) (dd "tests if the Node is an entity node") (dt (tt "*any*")) (dd (tt "#t") " for any type of Node") (dt "other symbol") (dd "tests if the Node has the right name given by the symbol")) (highlight scheme "((ntype?? 'div) '(div (@ (class \"greeting\")) \"hi\"))\n => #t\n\n((ntype?? 'div) '(span (@ (class \"greeting\")) \"hi\"))\n => #f\n\n((ntype?? '*) '(span (@ (class \"greeting\")) \"hi\"))\n => #t") (pre "  "))
(def (sig (procedure "(ntype-namespace-id?? ns-id)" (id ntype-namespace-id??))) (p "This function takes a namespace-id, and returns a predicate " (tt "Node -> Boolean") ", which is " (tt "#t") " for nodes with the given namespace id. " (tt "ns-id") " is a string. " (tt "(ntype-namespace-id?? #f)") " will be " (tt "#t") " for nodes with non-qualified names."))
(def (sig (procedure "(sxml:complement pred)" (id sxml:complement))) (p "This function takes a predicate and returns it complemented, that is if the given predicate yields " (tt "#f") " or " (tt "'()") " the complemented one yields the given node and vice versa."))
(def (sig (procedure "(node-eq? other)" (id node-eq?))) (p "Returns a predicate procedure that, given a node, returns " (tt "#t") " if the node is the exact same as " (tt "other") "."))
(def (sig (procedure "(node-equal? other)" (id node-equal?))) (p "Returns a predicate procedure that, given a node, returns " (tt "#t") " if the node has the same contents as " (tt "other") "."))
(def (sig (procedure "(node-pos n)" (id node-pos))) (p "Returns a procedure that, given a nodelist, returns a new nodelist containing only the " (tt "n") "th element, counting from 1.  If " (tt "n") " is negative, it returns a nodelist with the " (tt "n") "th element counting from the right.  If no such node exists, returns the empty list.  " (tt "n") " may not equal zero.") (p "Examples:") (highlight scheme "((node-pos 1) '((div \"hi\") (span \"hello\") (em \"really, hi!\")))\n => ((div \"hi\"))\n\n((node-pos 6) '((div \"hi\") (span \"hello\") (em \"really, hi!\")))\n => ()\n\n((node-pos -1) '((div \"hi\") (span \"hello\") (em \"is this thing on?\")))\n => ((em \"is this thing on?\"))"))
(def (sig (procedure "(sxml:filter pred?)" (id sxml:filter))) (p "Returns a procedure that accepts a nodelist or a node (which will be converted to a one-element nodelist) and returns only those nodes for which the predicate " (tt "pred?") " does not return " (tt "#f") " or " (tt "'()") ".") (highlight scheme "((sxml:filter (ntype?? 'div)) '((div \"hi\") (span \"hello\") (div \"still here?\")))\n => ((div \"hi\") (div \"still here?\"))"))
(def (sig (procedure "(take-until pred?)" (id take-until)) (procedure "(take-after pred?)" (id take-after))) (p "Returns a procedure that accepts a node or a nodelist.") (p "The " (tt "take-until") " variant returns everything " (i "before") " the first node for which the predicate " (tt "pred?") " returns anything but " (tt "#f") " or " (tt "'()") ".  In other words, it returns the longest prefix for which the predicate returns " (tt "#f") " or " (tt "'()") ".") (p "The " (tt "take-after") " variant returns everything " (i "after") " the first node for which the predicate " (tt "pred?") " returns anything besides " (tt "#f") " or " (tt "'()") ".") (highlight scheme "((take-until (ntype?? 'span)) '((div \"hi\") (span \"hello\") (span \"there\") (div \"still here?\")))\n => ((div \"hi\"))\n\n((take-after (ntype?? 'span)) '((div \"hi\") (span \"hello\") (span \"there\") (div \"still here?\")))\n => ((span \"there\") (div \"still here?\"))"))
(def (sig (procedure "(map-union proc list)" (id map-union))) (p "Apply " (tt "proc") " to each element of the nodelist " (tt "lst") " and return the list of results.  If " (tt "proc") " returns a nodelist, splice it into the result (essentially returning a flattened nodelist)."))
(def (sig (procedure "(node-reverse node-or-nodelist)" (id node-reverse))) (p "Accepts a nodelist and reverses the nodes inside.  If a node is passed to this procedure, it returns a nodelist containing just that node. (it does not change the order of the children)."))
(def (sig (procedure "(select-kids pred?)" (id select-kids))) (p "Returns a procedure that accepts a node and returns a nodelist of the node's children that satisfy " (tt "pred?") " (ie, " (tt "pred?") " returns anything but " (tt "#f") " or " (tt "'()") ")."))
(def (sig (procedure "(node-self pred?)" (id node-self))) (p "Similar to " (tt "select-kids") " but applies to the node itself rather than to its children. The resulting Nodelist will contain either one component (the node), or will be empty (if the node failed the predicate)."))
(def (sig (procedure "(node-join . selectors)" (id node-join))) (p "Returns a procedure that accepts a nodelist or a node, and returns a nodelist with all the selectors applied to every node in sequence. The selectors must function as converter combinators, ie they must accept a " (i "node") " and output a " (i "nodelist") ".") (highlight scheme "((node-join\n  (select-kids (ntype?? 'li))\n  sxml:content)\n '((ul (@ (class \"whiskies\"))\n       (li \"Ardbeg\")\n       (li \"Glenfarclas\")\n       (li \"Springbank\"))))\n => (\"Ardbeg\" \"Glenfarclas\" \"Springbank\")"))
(def (sig (procedure "(node-reduce . converters)" (id node-reduce))) (p "A regular functional composition of converters.") (p "From a different point of view,") (pre " ((apply node-reduce converters) nodelist)") (p "is equivalent to") (pre " (fold apply nodelist converters)") (p "i.e., folding, or reducing, a list of converters with the nodelist as a seed."))
(def (sig (procedure "(node-or . converters)" (id node-or))) (p "This combinator applies all converters to a given node and produces the union of their results.  This combinator corresponds to a union, \"" (tt "|") "\" operation for XPath location paths."))
(def (sig (procedure "(node-closure test-pred?)" (id node-closure))) (p "Select all " (i "descendants") " of a node that satisfy a converter-predicate.  This combinator is similar to " (tt "select-kids") " but applies to grandchildren as well."))
(def (sig (procedure "(node-trace title)" (id node-trace))) (p "Returns a procedure that accepts a node or a nodelist, which it pretty-prints to the current output port, preceded by " (tt "title") ".  It returns the node or the nodelist unchanged.  This is a useful debugging aid, since it doesn't really do anything besides print its argument and pass it on."))
(def (sig (procedure "(sxml:node? obj)" (id sxml:node?))) (p "Returns " (tt "#t") " if the given " (tt "obj") " is an SXML node, " (tt "#f") " otherwise. A node is anything except an attribute list or an auxiliary list."))
(def (sig (procedure "(sxml:attr-list node)" (id sxml:attr-list))) (p "Returns the list of attributes for a given SXML node.  The empty list is returned if the given node is not an element, or if it has no list of attributes.") (p "This differs from " (tt "sxml:attr-list-u") " in that this procedure accepts any SXML node while " (tt "sxml:attr-list-u") " only accepts nodelists or elements.  This means that sxml:attr-list-u will throw an error if you pass it a text node (a string), while sxml:attr-list will not."))
(def (sig (procedure "(sxml:attribute test-pred?)" (id sxml:attribute))) (p "Like " (tt "sxml:filter") ", but considers the attributes instead of the nodes.  Returns a nodelist of attribtes that match " (tt "test-pred?") ".") (highlight scheme "((sxml:attribute (ntype?? 'id))\n '((div (@ (id \"navigation\")) \"navigation here\")\n   (div (@ (class \"pullquote\")) \"random stuff\")\n   (div (@ (id \"main-content\")) \"lorem ipsum ...\")))\n => ((id \"navigation\") (id \"main-content\"))"))
(def (sig (procedure "(sxml:child test-pred?)" (id sxml:child))) (p "This procedure is similar to " (tt "select-kids") ", but it returns an empty child-list for PI, Comment and Entity nodes."))
(def (sig (procedure "(sxml:parent test-pred?)" (id sxml:parent))) (p "Returns a procedure that accepts a root-node, and returns another procedure.  This second procedure accepts a nodeset (or a node) and returns the immediate parents of the nodes in the set, but only if for those parents that match the predicate.") (p "The root-node does not have to be the root node of the whole SXML tree -- it may be a root node of a branch of interest.") (p "This procedure can be used with any SXML node."))
(def (sig (procedure "(node-parent node)" (id node-parent))) (p (tt "(node-parent rootnode)") " yields a converter that returns a parent of a node it is applied to. If applied to a nodelist, it returns the list of parents of nodes in the nodelist.") (p "This is equivalent to " (tt "((sxml:parent (ntype? '*any*)) node)") "."))
(def (sig (procedure "(sxml:child-nodes node)" (id sxml:child-nodes))) (p "Returns all the child nodes of the given " (tt "node") ".") (p "This is equivalent to " (tt "((sxml:child sxml:node?) node)") "."))
(def (sig (procedure "(sxml:child-elements node)" (id sxml:child-elements))) (p "Returns all the child " (i "elements") " of the given " (tt "node") ". (ie, excludes any textnodes).") (p "This is equivalent to " (tt "((select-kids sxml:element?) node)") "."))
(def (sig (procedure "(sxml:string object)" (id sxml:string))) (p "The counterpart to XPath 'string' function (section 4.2 XPath 1.0 Rec.). Converts a given object to a string.") (p "Notes:") (ol (li "When converting a nodeset, document order is not preserved") (li (tt "number->string") " returns the result in a form which is slightly different from XPath Rec. specification")))
(def (sig (procedure "(sxml:boolean object)" (id sxml:boolean))) (p "The counterpart to XPath 'boolean' function (section 4.3 XPath Rec.). Converts its argument to a boolean."))
(def (sig (procedure "(sxml:number object)" (id sxml:number))) (p "The counterpart to XPath 'number' function (section 4.4 XPath Rec.). Converts its argument to a number.") (p "Notes:") (ol (li "The argument is not optional (yet?)") (li "string->number conversion is not IEEE 754 round-to-nearest") (li "NaN is represented as 0")))
(def (sig (procedure "(sxml:string-value node)" (id sxml:string-value))) (p "Returns a string value for a given node in accordance to XPath Rec. 5.1 - 5.7"))
(def (sig (procedure "(sxml:id id-index)" (id sxml:id))) (p "Returns a procedure that accepts a nodeset and returns a nodeset containing the elements in the id-index that match the string-values of each entry of the nodeset.  XPath Rec. 4.1") (p "The " (tt "id-index") " is an alist with unique IDs as key, and elements as values:") (pre " id-index = ( (id-value . element) (id-value . element) ... )"))
(def (sig (procedure "(sxml:list-head list n)" (id sxml:list-head))) (p "Returns the " (tt "n") " first members of " (tt "list") ".  Mostly equivalent to SRFI-1's " (tt "take") " procedure, except it returns the " (tt "list") " if " (tt "n") " is larger than the length of said list, instead of throwing an error."))
(def (sig (procedure "(sxml:merge-sort less-than? list)" (id sxml:merge-sort))) (p "Returns the sorted list, the smallest member first.") (pre " less-than? ::= (lambda (obj1 obj2) ...)") (p (tt "less-than?") " returns " (tt "#t") " if " (tt "obj1 < obj2") " with respect to the given ordering."))
(def (sig (procedure "(sxml:equality-cmp bool=? number=? string=?)" (id sxml:equality-cmp))) (p "A helper for XPath equality operations: " (tt "=") " , " (tt "!=") ".  The " (tt "bool=?") ", " (tt "number=?") " and " (tt "string=?") " arguments are comparison operations for booleans, numbers and strings respectively.") (p "Returns a procedure that accepts two objects, looks at the first object's type and applies the correct comparison predicate to it. Type coercion takes place depending on the rules described in the XPath 1.0 spec, section 3.4 (\"Booleans\")."))
(def (sig (procedure "(sxml:equal? obj1 obj2)" (id sxml:equal?)) (procedure "(sxml:not-equal? obj1 obj2)" (id sxml:not-equal?))) (p "Equality procedures with the default comparison operators " (tt "eq?") ", " (tt "=") " and " (tt "string=?") ", or their inverse, respectively."))
(def (sig (procedure "(sxml:relational-cmp op)" (id sxml:relational-cmp))) (p "A helper for XPath relational operations: " (tt "<") ", " (tt ">") ", " (tt "<=") ", " (tt ">=") " for two XPath objects.  " (tt "op") " is one of these operators.") (p "Returns a procedure that accepts two objects and returns the value of the procedure applied to these objects, converted according to the coercion rules described in the XPath 1.0 spec, section 3.4 (\"Booleans\")."))
(def (sig (procedure "(sxml:ancestor test-pred?)" (id sxml:ancestor))) (p "Like " (tt "sxml:parent") ", except it returns all the ancestors that match " (tt "test-pred?") ", not just the immediate parent."))
(def (sig (procedure "(sxml:ancestor-or-self test-pred?)" (id sxml:ancestor-or-self))) (p "Like " (tt "sxml:ancestor") ", except also allows the node itself to match the predicate."))
(def (sig (procedure "(sxml:descendant test-pred?)" (id sxml:descendant))) (p "Like " (tt "node-closure") ", except the resulting nodeset is in depth-first order instead of breadth-first."))
(def (sig (procedure "(sxml:descendant-or-self test-pred?)" (id sxml:descendant-or-self))) (p "Like " (tt "sxml:descendant") ", except also allows the node itself to match the predicate."))
(def (sig (procedure "(sxml:following test-pred?)" (id sxml:following))) (p "Returns a procedure that accepts a root node and returns a new procedure that accepts a node and returns all nodes following this node in the document source matching the predicate."))
(def (sig (procedure "(sxml:following-sibling test-pred?)" (id sxml:following-sibling))) (p "Like " (tt "sxml:following") ", except only siblings (nodes at the same level under the same parent) are returned."))
(def (sig (procedure "(sxml:preceding test-pred?)" (id sxml:preceding))) (p "Returns a procedure that accepts a root node and returns a new procedure that accepts a node and returns all nodes preceding this node in the document source matching the predicate."))
(def (sig (procedure "(sxml:preceding-sibling test-pred?)" (id sxml:preceding-sibling))) (p "Like " (tt "sxml:preceding") ", except only siblings (nodes at the same level under the same parent) are returned."))
(def (sig (procedure "(sxml:namespace test-pred?)" (id sxml:namespace))) (p "Returns a procedure that accepts a nodeset and returns the namespace lists of the nodes matching " (tt "test-pred?") "."))
