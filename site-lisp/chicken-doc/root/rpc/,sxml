((section 2 "RPC" (section 3 "Description" (p "A flexible peer-to-peer RPC system.")) (section 3 "Author" (p (link "http://www.chust.org/" "Thomas Chust"))) (section 3 "Requires" (ul (li (int-link "tcp-server")) (li (int-link "s11n")) (li (int-link "matchable")))) (section 3 "Documentation" (p "This egg is a thin but flexible layer on top of tcp-server and s11n providing remote-procedure-call based communications. Special support for callbacks is provided, which makes the interface more a peer-to-peer than a client-server solution.") (section 4 "Managing published procedures" (def (sig (procedure "(rpc:publish-procedure! name procedure #!optional (callback-outgoing? #t)) => <void>" (id rpc:publish-procedure!))) (p "Registers " (tt "procedure") " to be callable by incoming RPC requests under the name " (tt "name") ".") (p "Names of procedures are matched using " (tt "equal?") ".") (p "If " (tt "callback-outgoing?") " is true, a reverse lookup entry associating the procedure with its name is also created. The table of reverse lookup entries is used by " (tt "rpc:procedure") " to send a callback stub to the remote machine instead of the procedure itself, should the procedure be one of the parameters of a RPC call.")) (def (sig (procedure "(rpc:withdraw-procedure! name-or-procedure) => <void>" (id rpc:withdraw-procedure!))) (p "Unregisters the given " (tt "name-or-procedure") " as an externally callable object.  If a procedure is passed for the " (tt "name-or-procedure") " parameter, it can only successfully be removed if a reverse lookup entry for this procedure exists.") (p "As mutex lock intervals are kept as short as possible, it may happen, that a currently active server thread calls the procedure once more immediately after its removal before it becomes completely unavailable to the outside world."))) (section 4 "Managing connections" (def (sig (parameter "rpc:default-server-port" (id rpc:default-server-port))) (p "The standard port number to establish RPC connections to. The default value is 29296.")) (def (sig (parameter "rpc:connect-procedure" (id rpc:connect-procedure))) (p "The procedure used to establish network connections for RPC. Defaults to " (tt "tcp-connect") " and must be signature-compatible with it.")) (def (sig (procedure "(rpc:is-connected? host #!optional (port (rpc:default-server-port))) => <boolean>" (id rpc:is-connected?))) (p "Determines whether an RPC connection to the given " (tt "host") " and " (tt "port") " is active. The table of active connections is thread-local.")) (def (sig (procedure "(rpc:get-connection host #!optional (port (rpc:default-server-port))) => <input-port>, <output-port>" (id rpc:get-connection))) (p "Retrieves an existing RPC connection to the given " (tt "host") " and " (tt "port") " or creates a new one. The table of active connections is thread-local.")) (def (sig (procedure "(rpc:close-connection! host #!optional (port (rpc:default-server-port))) => <void>" (id rpc:close-connection!))) (p "Closes an existing RPC connection to the given " (tt "host") " and " (tt "port") ". Fails if no such connection exists. The table of active connections is thread-local.")) (def (sig (procedure "(rpc:close-all-connections!) => <void>" (id rpc:close-all-connections!))) (p "Closes all existing RPC connections of the current thread."))) (section 4 "Client and server frontend" (def (sig (parameter "rpc:current-peer" (id rpc:current-peer))) (p "Inside the server threads processing RPC requests, this parameter is set to the address (as a string) of the peer on behalf of which the thread is executing.") (p (i "Consider this parameter read-only unless you really know what you are doing. You may seriously mess up communications otherwise."))) (def (sig (procedure "(rpc:procedure name host #!optional (port (rpc:default-server-port))) => <procedure>" (id rpc:procedure))) (p "Creates a procedure that can be called with any number of parameters to invoke the externally callable procedure published as " (tt "name") " on the server at " (tt "host:port") " with the given arguments.") (p "The arguments are scanned for procedures and if any such are found, those in the reverse lookup table are replaced with callback stubs before all the parameters are serialized over the network connection. Callback stubs are small procedures that use the value of the " (tt "rpc:current-peer") " and " (tt "rpc:default-server-port") " parameters in the remote server thread in order to determine where they came from and to use " (tt "rpc:procedure") " again to connect back to their home and execute their real counterpart.") (p "Some care has been taken to isolate code executing in an RPC server thread properly:") (ul (li "Exceptions caused in the remotely executing code are caught, sent back to the client and rethrown there.") (li "The " (tt "current-input-port") ", " (tt "current-output-port") " and " (tt "current-error-port") " parameters are changed for the remotely executing code. " (tt "current-input-port") " never yields any input and the two output ports accumulate data into strings that are sent back to the client and printed on the " (tt "current-output-port") " and " (tt "current-error-port") " there."))) (def (sig (procedure "(rpc:make-server listener) => <procedure>" (id rpc:make-server))) (p "Uses " (tt "make-tcp-server") " to create a server procedure.  The server threads spawned by this procedure are continuously processing RPC requests from their clients until the connection is closed.")))) (section 3 "Examples" (p "This first example is a very simple server/client example:") (highlight scheme ";;;; server.scm\n(use rpc)\n\n(rpc:publish-procedure!\n 'foo\n (lambda (x)\n   (print \"foo: \" x)\n   #f))\n\n(rpc:publish-procedure!\n 'fini\n (lambda () (print \"fini\") (thread-start! (lambda () (thread-sleep! 3) (print \"terminate\") (exit))) #f))\n\n((rpc:make-server (tcp-listen (rpc:default-server-port))) #t)") (highlight scheme ";;;; client.scm\n(use rpc posix)\n\n(define call (rpc:procedure 'foo \"localhost\"))\n\n(do ((i 10 (sub1 i)))\n    ((zero? i))\n  (print \"-> \" (call (random 100))))") (p "This next example is a simple database server and client using " (int-link "sqlite3") ". As sqlite3 is not perfectly thread-safe and as there are of course better database servers around the example is perhaps a little academic, but it illustrates the use of this extension quite nicely.") (p "Note that in this example the " (tt "rpc:default-server-port") " parameter in the server can be set by the client because the server does not know where the client is listening. In a similar way, " (tt "rpc:current-peer") " may be reset if the client knows its public IP better than the server.") (highlight scheme ";;;; rpc-demo.scm\n;;;; Simple database server / client\n\n(require-extension (srfi 18) extras tcp rpc sqlite3)\n\n;;; Common things\n\n(define operation (string->symbol (car (command-line-arguments))))\n(define param (cadr (command-line-arguments)))\n\n(define rpc:listener\n  (if (eq? operation 'server)\n      (tcp-listen (rpc:default-server-port))\n      (tcp-listen 0)))\n\n;; Start server thread\n(define rpc:server\n  (make-thread\n   (cute (rpc:make-server rpc:listener) \"rpc:server\")\n   'rpc:server))\n\n(thread-start! rpc:server)\n\n;;; Server side\n\n(define (server)\n  (rpc:publish-procedure!\n   'change-response-port\n   (lambda (port)\n     (rpc:default-server-port port))\n   #f)\n  (let ((db (sqlite3:open param)))\n    (set-finalizer! db sqlite3:finalize!)\n    (rpc:publish-procedure!\n     'query\n     (lambda (sql callback)\n       (print \"Executing query '\" sql \"' ...\")\n       (sqlite3:for-each-row\n\tcallback\n\tdb sql))))\n  (thread-join! rpc:server))\n\n;;; Client side\n\n(define (callback1 . columns)\n  (let loop ((c columns) (i 0))\n    (unless (null? c)\n      (printf \"~a=~s \" i (car c))\n      (loop (cdr c) (+ i 1))))\n  (newline))\n\n(define callback2-results '())\n\n(define (callback2 . columns)\n  (set! callback2-results (cons columns callback2-results)))\n\n(define (client)\n  ((rpc:procedure 'change-response-port \"localhost\")\n   (tcp-listener-port rpc:listener))\n  ((rpc:procedure 'query \"localhost\") param callback1)\n  (rpc:publish-procedure! 'callback2 callback2)\n  ((rpc:procedure 'query \"localhost\") param callback2)\n  (pp callback2-results))\n\n;;; Run it\n\n(if (eq? operation 'server)\n    (server)\n    (client))")) (section 3 "Changelog" (ul (li "1.1.1 handles eof from client in persistent connection (felix)") (li "1.1.0 ported to CHICKEN 4 by felix") (li "1.0.0 Initial release"))) (section 3 "License" (pre " Copyright (c) 2005, Thomas Chust <chust@web.de>.  All rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n \n   Redistributions of source code must retain the above copyright notice,\n   this list of conditions and the following disclaimer. Redistributions in\n   binary form must reproduce the above copyright notice, this list of\n   conditions and the following disclaimer in the documentation and/or\n   other materials provided with the distribution. Neither the name of the\n   author nor the names of its contributors may be used to endorse or\n   promote products derived from this software without specific prior\n   written permission.\n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS\n IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\n CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."))))