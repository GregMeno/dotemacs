(index ("lpx:empty-problem" 0) ("lpx:make-problem" 151) ("lpx?" 2043) ("lpx:set-problem-name" 2233) ("lpx:get-problem-name" 2351) ("lpx:set-direction" 2483) ("lpx:get-direction" 2685) ("lpx:set-class" 2829) ("lpx:get-class" 3059) ("lpx:add-rows" 3166) ("lpx:add-columns" 3406) ("lpx:set-row-name" 3578) ("lpx:set-column-name" 3708) ("lpx:get-row-name" 3847) ("lpx:get-column-name" 3974) ("lpx:get-num-rows" 4110) ("lpx:get-num-columns" 4249) ("lpx:set-row-bounds" 4397) ("lpx:set-column-bounds" 5149) ("lpx:set-objective-coefficient" 5913) ("lpx:set-column-kind" 6111) ("lpx:load-constraint-matrix" 6449) ("lpx:get-column-primals" 6910) ("lpx:get-objective-value" 7077) ("lpx:message_level" 7231) ("lpx:scaling" 7406) ("lpx:use_dual_simplex" 7580) ("lpx:pricing" 7711) ("lpx:solution_rounding" 7876) ("lpx:iteration_limit" 8014) ("lpx:iteration_count" 8146) ("lpx:branching_heuristic" 8278) ("lpx:backtracking_heuristic" 8465) ("lpx:use_presolver" 8677) ("lpx:relaxation" 8803) ("lpx:time_limit" 8946) ("lpx:scale-problem" 9078) ("lpx:simplex" 9271) ("lpx:integer" 11356))
(def (sig (procedure "lpx:empty-problem:: () -> LPX" (id lpx:empty-problem))) (p "This procedure creates a new problem that has no rows or columns."))
(def (sig (procedure "lpx:make-problem:: DIR * PBOUNDS * XBOUNDS * OBJCOEFS * CONSTRAINTS * [ORDER] -> LPX" (id lpx:make-problem))) (p "This procedure creates a new problem with the specified parameters.") (ul (li "Argument " (tt "DIR") " specifies the optimization direction flag. It can be one of " (tt "'maximize") " or  " (tt "'minimize") ". ") (li "Argument " (tt "PBOUNDS") " is a list that specifies the type and bounds for each row of the problem object. Each element of this list can take one of the following forms: ")) (table (@ (class "symbol-table")) (tr (td "'(unbounded)") (td "Free (unbounded) variable, " (tt "-Inf <= x <= +Inf"))) "\n" (tr (td "'(lower-bound LB)") (td "Variable with lower bound, " (tt "LB <= x <= +Inf"))) "\n" (tr (td "'(upper-bound UB)") (td "Variable with upper bound, " (tt "-Inf <= x <= UB"))) "\n" (tr (td "'(double-bounded LB UB)") (td "Double-bounded variable, " (tt "LB <= x <= UB"))) "\n" (tr (td "'(fixed LB UB)") (td "Fixed variable, " (tt "LB = x = UB")))) (ul (li "Argument " (tt "XBOUNDS") " is a list that specifies the type and bounds for each column (structural variable) of the problem object. Each element of this list can take one of the forms described for parameter " (tt "PBOUNDS") ". ") (li "Argument " (tt "OBJCOEFS") " is a list that specifies the objective coefficients for each column (structural variable). This list must be of the same length as " (tt "XBOUNDS") ". ") (li "Argument " (tt "OBJCOEFS") " is a list that specifies the objective coefficients for each column (structural variable). ") (li "Argument " (tt "CONSTRAINTS") " is an SRFI-4 " (tt "f64vector") " that represents the problem's constraint matrix (in row-major or column-major order). ") (li "Optional argument " (tt "ORDER") " specifies the element order of the constraints matrix. It can be one of " (tt "'row-major") " or " (tt "'column-major") ". ")))
(def (sig (procedure "lpx?:: OBJECT -> BOOL" (id lpx?))) (p "Returns true if the given object was created by " (tt "lpx:empty-problem") " or " (tt "lpx:make-problem") ", false otherwise."))
(def (sig (procedure "lpx:set-problem-name:: LPX * NAME -> LPX" (id lpx:set-problem-name))) (p "Sets problem name."))
(def (sig (procedure "lpx:get-problem-name:: LPX -> NAME" (id lpx:get-problem-name))) (p "Returns the name of the given problem."))
(def (sig (procedure "lpx:set-direction:: LPX * DIR -> LPX" (id lpx:set-direction))) (p "Specifies the optimization direction flag, which can be one of " (tt "'maximize") " or  " (tt "'minimize") "."))
(def (sig (procedure "lpx:get-direction:: LPX -> DIR" (id lpx:get-direction))) (p "Returns the optimization direction for the given problem."))
(def (sig (procedure "lpx:set-class:: LPX * CLASS -> LPX" (id lpx:set-class))) (p "Sets problem class (linear programming or mixed-integer programming. Argument " (tt "CLASS") " can be one of " (tt "'lp") " or " (tt "'mip") "."))
(def (sig (procedure "lpx:get-class:: LPX -> CLASS" (id lpx:get-class))) (p "Returns the problem class."))
(def (sig (procedure "lpx:add-rows:: LPX * N -> LPX" (id lpx:add-rows))) (p "This procedure adds " (tt "N") " rows (constraints) to the given problem. Each new row is initially unbounded and has an empty list of constraint coefficients."))
(def (sig (procedure "lpx:add-columns:: LPX * N -> LPX" (id lpx:add-columns))) (p "This procedure adds " (tt "N") " columns (structural variables) to the given problem."))
(def (sig (procedure "lpx:set-row-name:: LPX * I * NAME -> LPX" (id lpx:set-row-name))) (p "Sets the name of row " (tt "I") "."))
(def (sig (procedure "lpx:set-column-name:: LPX * J * NAME -> LPX" (id lpx:set-column-name))) (p "Sets the name of column " (tt "J") "."))
(def (sig (procedure "lpx:get-row-name:: LPX * I -> NAME" (id lpx:get-row-name))) (p "Returns the name of row " (tt "I") "."))
(def (sig (procedure "lpx:get-column-name:: LPX * J -> NAME" (id lpx:get-column-name))) (p "Returns the name of column " (tt "J") "."))
(def (sig (procedure "lpx:get-num-rows:: LPX -> N" (id lpx:get-num-rows))) (p "Returns the current number of rows in the given problem."))
(def (sig (procedure "lpx:get-num-columns:: LPX -> N" (id lpx:get-num-columns))) (p "Returns the current number of columns in the given problem."))
(def (sig (procedure "lpx:set-row-bounds:: LPX * I * BOUNDS -> LPX" (id lpx:set-row-bounds))) (p "Sets bounds for row " (tt "I") " in the given problem. Argument " (tt "BOUNDS") " specifies the type and bounds for the specified row. It can take one of the following forms:") (table (@ (class "symbol-table")) (tr (td "'(unbounded)") (td "Free (unbounded) variable, " (tt "-Inf <= x <= +Inf"))) "\n" (tr (td "'(lower-bound LB)") (td "Variable with lower bound, " (tt "LB <= x <= +Inf"))) "\n" (tr (td "'(upper-bound UB)") (td "Variable with upper bound, " (tt "-Inf <= x <= UB"))) "\n" (tr (td "'(double-bounded LB UB)") (td "Double-bounded variable, " (tt "LB <= x <= UB"))) "\n" (tr (td "'(fixed LB UB)") (td "Fixed variable, " (tt "LB = x = UB")))))
(def (sig (procedure "lpx:set-column-bounds:: LPX * J * BOUNDS -> LPX" (id lpx:set-column-bounds))) (p "Sets bounds for column " (tt "J") " in the given problem. Argument " (tt "BOUNDS") " specifies the type and bounds for the specified column. It can take one of the following forms:") (table (@ (class "symbol-table")) (tr (td "'(unbounded)") (td "Free (unbounded) variable, " (tt "-Inf <= x <= +Inf"))) "\n" (tr (td "'(lower-bound LB)") (td "Variable with lower bound, " (tt "LB <= x <= +Inf"))) "\n" (tr (td "'(upper-bound UB)") (td "Variable with upper bound, " (tt "-Inf <= x <= UB"))) "\n" (tr (td "'(double-bounded LB UB)") (td "Double-bounded variable, " (tt "LB <= x <= UB"))) "\n" (tr (td "'(fixed LB UB)") (td "Fixed variable, " (tt "LB = x = UB")))))
(def (sig (procedure "lpx:set-objective-coefficient:: LPX * J * COEF -> LPX" (id lpx:set-objective-coefficient))) (p "Sets the objective coefficient at column " (tt "J") " (structural variable)."))
(def (sig (procedure "lpx:set-column-kind:: LPX * J * KIND -> LPX" (id lpx:set-column-kind))) (p "Sets the kind of column " (tt "J") " (structural variable). Argument " (tt "KIND") " can be one of the following:") (table (@ (class "symbol-table")) (tr (td "'iv") (td "integer variable")) "\n" (tr (td "'cv") (td "continuous variable"))))
(def (sig (procedure "lpx:load-constraint-matrix:: LPX * F64VECTOR * NROWS * NCOLS [* ORDER] -> LPX" (id lpx:load-constraint-matrix))) (p "Loads the constraint matrix for the given problem. The constraints matrix is represented as an SRFI-4 " (tt "f64vector") " (in row-major or column-major order). Optional argument " (tt "ORDER") " specifies the element order of the constraints matrix. It can be one of " (tt "'row-major") " or " (tt "'column-major") "."))
(def (sig (procedure "lpx:get-column-primals:: LPX -> F64VECTOR" (id lpx:get-column-primals))) (p "Returns the primal values of all structural variables (columns)."))
(def (sig (procedure "lpx:get-objective-value:: LPX -> NUMBER" (id lpx:get-objective-value))) (p "Returns the current value of the objective function."))
(def (sig (procedure "lpx:message_level:: LPX [ * (none | error | normal | full)] -> LPX | VALUE" (id lpx:message_level))) (p "Level of messages output by solver routines."))
(def (sig (procedure "lpx:scaling:: LPX [ * (none | equilibration | geometric-mean | geometric-mean+equilibration)] -> LPX | VALUE" (id lpx:scaling))) (p "Scaling option."))
(def (sig (procedure "lpx:use_dual_simplex:: LPX [ * BOOL] -> LPX | VALUE" (id lpx:use_dual_simplex))) (p "Dual simplex option."))
(def (sig (procedure "lpx:pricing:: LPX [ * (textbook | steepest-edge)] -> LPX | VALUE" (id lpx:pricing))) (p "Pricing option (for both primal and dual simplex)."))
(def (sig (procedure "lpx:solution_rounding:: LPX [ * BOOL] -> LPX | VALUE" (id lpx:solution_rounding))) (p "Solution rounding option."))
(def (sig (procedure "lpx:iteration_limit:: LPX [ * INT] -> LPX | VALUE" (id lpx:iteration_limit))) (p "Simplex iteration limit."))
(def (sig (procedure "lpx:iteration_count:: LPX [ * INT] -> LPX | VALUE" (id lpx:iteration_count))) (p "Simplex iteration count."))
(def (sig (procedure "lpx:branching_heuristic:: LPX [ * (first | last | driebeck+tomlin)] -> LPX | VALUE" (id lpx:branching_heuristic))) (p "Branching heuristic option (for MIP only)."))
(def (sig (procedure "lpx:backtracking_heuristic:: LPX [ * (dfs | bfs | best-projection | best-local-bound)] -> LPX | VALUE" (id lpx:backtracking_heuristic))) (p "Backtracking heuristic option (for MIP only)."))
(def (sig (procedure "lpx:use_presolver:: LPX [ * BOOL] -> LPX | VALUE" (id lpx:use_presolver))) (p "Use the LP presolver."))
(def (sig (procedure "lpx:relaxation:: LPX [ * REAL] -> LPX | VALUE" (id lpx:relaxation))) (p "Relaxation parameter used in the ratio test."))
(def (sig (procedure "lpx:time_limit:: LPX [ * REAL] -> LPX | VALUE" (id lpx:time_limit))) (p "Searching time limit, in seconds."))
(def (sig (procedure "lpx:scale-problem:: LPX -> LPX" (id lpx:scale-problem))) (p "This procedure performs scaling of of the constraints matrix in order to improve its numerical properties."))
(def (sig (procedure "lpx:simplex:: LPX -> STATUS" (id lpx:simplex))) (p "This procedure solves the given LP problem using the simplex method.  It can return one of the following status codes:") (table (@ (class "symbol-table")) (tr (td "LPX_E_OK") (td "the LP problem has been successfully solved")) "\n" (tr (td "LPX_E_BADB") (td "Unable to start\nthe search, because the initial basis specified in the problem object\nis invalid--the number of basic (auxiliary and structural) variables\nis not the same as the number of rows in the problem object. ")) "\n" (tr (td "LPX_E_SING") (td "Unable to start\nthe search, because the basis matrix corresponding to the initial\nbasis is singular within the working precision. ")) "\n" (tr (td "LPX_E_COND") (td "Unable to start\nthe search, because the basis matrix corresponding to the initial\nbasis is ill-conditioned, i.e. its condition number is too large. ")) "\n" (tr (td "LPX_E_BOUND") (td "Unable to start\nthe search, because some double-bounded (auxiliary or structural)\nvariables have incorrect bounds. ")) "\n" (tr (td "LPX_E_FAIL") (td "The search was\nprematurely terminated due to the solver failure. ")) "\n" (tr (td "LPX_E_OBJLL") (td "The search was\nprematurely terminated, because the objective function being maximized\nhas reached its lower limit and continues decreasing (the dual simplex\nonly). ")) "\n" (tr (td "LPX_E_OBJUL") (td "The search was\nprematurely terminated, because the objective function being minimized\nhas reached its upper limit and continues increasing (the dual simplex\nonly). ")) "\n" (tr (td "LPX_E_ITLIM") (td "The search was\nprematurely terminated, because the simplex iteration limit has been\nexceeded. ")) "\n" (tr (td "LPX_E_TMLIM") (td "The search was\nprematurely terminated, because the time limit has been exceeded. ")) "\n" (tr (td "LPX_E_NOPFS") (td "The LP problem\ninstance has no primal feasible solution (only if the LP presolver is used). ")) "\n" (tr (td "LPX_E_NODFS") (td "The LP problem\ninstance has no dual feasible solution (only if the LP presolver is used)."))))
(def (sig (procedure "lpx:integer:: LPX -> STATUS" (id lpx:integer))) (p "Solves an MIP problem using the branch-and-bound method."))
