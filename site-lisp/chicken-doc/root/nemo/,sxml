((tags "egg") (section 2 "nemo" (p "An implementation of a description language for computational models of ion channels.") (toc)) (section 2 "Usage" (p "nemo [options...] [input files ...]")) (section 2 "Documentation" (p (tt "NEMO") " is a program that reads an ion channel description and generates corresponding model simulation code in " (link "http://www.gnu.org/software/octave/" "GNU Octave") " or the " (link "http://www.neuron.yale.edu/neuron/docs/help/neuron/nmodl/nmodl.html" "NMODL") " language used by the " (link "http://www.neuron.yale.edu/neuron/" "NEURON simulator") ".") (section 3 "Options" (dl (dt (tt "-i FORMAT")) (dd "specify input format (nemo, xml, sxml, s-exp)") (dt (tt "--xml[=FILE]")) (dd "write XML output to file (default: <model-name>.xml)") (dt (tt "--sxml[=FILE]")) (dd "write SXML output to file (default: <model-name>.sxml)") (dt (tt "--nmodl[=FILE]")) (dd "write NMODL output to file (default: <model-name>.mod)") (dt (tt "--nmodl-method=METHOD")) (dd "specify NMODL integration method (cnexp, derivimplicit, cvode)") (dt (tt "--nmodl-kinetic=[STATES]")) (dd "use NMODL kinetic equations for the given reactions") (dt (tt "--nmodl-depend=VARS")) (dd "specify DEPEND variables for NMODL interpolation tables") (dt (tt "--octave[=FILE]")) (dd "write Octave output to file (default: <model-name>.m)") (dt (tt "--matlab[=FILE]")) (dd "write Matlab output to file (default: <model-name>.m)") (dt (tt "-t")) (dd "use interpolation tables in generated code") (dt (tt "-h, --help")) (dd "print help"))) (section 3 "Model description language" (p "The following constructs comprise the model description language:") (dl (dt (b (tt "MODEL")) (tt " ::= ") " ( " (b (tt "INPUT ")) " {" (i "ID") "}" (tt " | ") "( {" (i "ID") "}  [" (b (tt "AS ")) "{" (i "LOCAL-ID") "}]   [" (b (tt "FROM ")) "{" (i "NAMESPACE") "}]  ) ... )") (dd "Declares one or several imported quantities. If the optional " (b (tt "AS")) " parameter is given, then the quantity is imported as {" (i "LOCAL-ID") "}. If the optional " (b (tt "FROM")) " parameter is given, then the quantity is imported from namespace {" (i "NAMESPACE") "}. ") (dt (tt " | ") "( " (b (tt "OUTPUT")) " {" (i "ID") "} )") (dd "Declares that an existing quantity be exported.") (dt (tt " | ") "( " (b (tt "CONST")) " {" (i "ID") "} = {" (i "EXPR") "} )") (dd "Declares a constant quantity (its value will be computed at declaration time).") (dt (tt " | ") "( " (b (tt "DEFUN")) " {" (i "ID") "} ( {" (i "ARG-ID") "} ... ) {" (i "EXPR") "} )") (dd "Declares a function (a parameterized expression with no free variables).") (dt (tt " | ") "( {" (i "ID") "} = {" (i "EXPR") "} )") (dd "Declares an assigned quantity (an expression that can refer to other quantities in the system).") (dt (tt " | ") "( " (b (tt "REACTION")) " {" (i "ID") "} {" (i "TRANSITIONS") "} {" (i "INITIAL-EXPR") "} {" (i "OPEN-ID") "} )") (dd "Declares a reaction quantity. See below for the syntax of state transition equations. {" (i "INITIAL-EXPR") "} is an expression that computes the initial value. {" (i "OPEN-ID") "} is the name of the open state. It must be one of the states defined by the transition equations. ") (dt (tt " | ") "( " (b (tt "COMPONENT")) " ( " (b (tt "TYPE")) " {" (i "ID") "} ) ( " (b (tt "NAME")) " {" (i "ID") "} ) {" (i "ELEMENTS") "} )") (dd "Declares a system component (a quantity that can contain other quantities).")) (section 4 "Expressions" (p "Expressions in the model description language are defined as:") (dl (dt (b (tt "EXPR")) (tt " ::= ") " {" (i "NUM") "}") (dd "A numeric constant.") (dt (tt " | ") "{" (i "ID") "}") (dd "A variable name.") (dt (tt " | ") "( {" (i "ID") "} ( {" (i "EXPR") "} ... ) )") (dd "A function invocation.") (dt (tt " | ") "( {" (i "EXPR") "} {" (i "OP") "} {" (i "EXPR") "} )") (dd "Arithmetic operator invocation. The following operators are supported: " (tt "+ - / * > < <= >= ^")) (dt (tt " | ") "( " (b (tt "LET")) " ( {" (i "BINDINGS") "} ) {" (i "EXPR") "} )") (dd "Local variables declaration. Each element in {" (i "BINDINGS") "} is of the form: ( {" (i "ID") "} {" (i "EXPR") "} )") (dt (tt " | ") "( " (b (tt "IF")) " {" (i "CONDITION") "} " (b (tt "THEN")) " {" (i "EXPR") "} " (b (tt "ELSE")) " {" (i "EXPR") "} )") (dd "Conditional expression. The expression after " (b (tt "IF")) " must be a comparison expression. "))) (section 4 "State transition equations" (p "State transition equations in the model description language are defined as:") (dl (dt (b (tt "TRANSITION")) (tt " ::= ") " ( " (b (tt "->")) " {" (i "SRC-ID") "} {" (i "DEST-ID") "} {" (i "EXPR") "} )") (dd "Declares that a transition occurs from state {" (i "SRC-ID") "} to state {" (i "DEST-ID") "} at rate computed by {" (i "EXPR") "}. ") (dt (tt " | ") "( " (b (tt "<->")) " {" (i "SRC-ID") "} {" (i "DEST-ID") "} {" (i "EXPR-1") "} {" (i "EXPR-2") "} )") (dd "Declares that a transition occurs from state {" (i "SRC-ID") "} to state {" (i "DEST-ID") "} and vice versa, at rates computed by {" (i "EXPR-1") "} and {" (i "EXPR-2") "}. "))) (section 4 "Ion channel definitions" (p "Currently, the " (tt "NMODL") " code generator recognizes and generates code for ion channel components that are defined as follows:") (dl (dt (b "(" (tt "COMPONENT (TYPE gate-complex) (NAME {NAME})")) " ( " (b (tt "COMPONENT")) " ( " (b (tt "TYPE")) " gate ) ... )") (dd "One or more gate definitions. Each component of type gate must export the reactions that characterize the gate dynamics. ") (dt "( " (b (tt "COMPONENT")) " ( " (b (tt "TYPE")) " pore ) ... )") (dd "Conductance law definition. This component must export a constant maximal conductance, or an assigned quantity whose equation represents the conductance law used. ") (dt "[( " (b (tt "COMPONENT")) " ( " (b (tt "TYPE")) " permeating-ion ) ... )] ") (dt "[( " (b (tt "COMPONENT")) " ( " (b (tt "TYPE")) " accumulating-substance ) ... )] ") (dt (b ")")))) (section 4 "Hodgkin-Huxley ionic conductance extension" (p "The Hodgkin-Huxley ionic conductance extension is a shortcut that declares a reaction corresponding to the Hodgkin-Huxley formulation of ion channel dynamics.") (dl (dt (b "(" (tt "HH-IONIC-GATE"))) (dd "( {" (i "ION-NAME") "} : Ion name: exported variables will be of the form " (tt "{ion}_{id") "}. ") (dt "( " (b (tt "M-POWER")) " {" (i "INTEGER") "} )") (dd "Power of state variable " (tt "M") ". ") (dt "( " (b (tt "H-POWER")) " {" (i "INTEGER") "} )") (dd "Power of state variable " (tt "H") ". If zero, the initial value and equations for this variable can be omitted. ") (dt "( " (b (tt "INITIAL-M")) " {" (i "EXPR") "} )") (dd "Expression that computes initial value for state variable " (tt "M") ". ") (dt "( " (b (tt "INITIAL-H")) " {" (i "EXPR") "} )") (dd "Expression that computes initial value for state variable " (tt "H") ". ") (dt "( " (b (tt "M-ALPHA")) " {" (i "EXPR") "} )") (dd "Closed state to open state rate expression for state variable " (tt "M") ". ") (dt "( " (b (tt "M-BETA")) " {" (i "EXPR") "} )") (dd "Open state to closed state rate expression for state variable " (tt "M") ". ") (dt "( " (b (tt "H-ALPHA")) " {" (i "EXPR") "} )") (dd "Closed state to open state rate expression for state variable " (tt "H") ". ") (dt "( " (b (tt "H-BETA")) " {" (i "EXPR") "} )") (dd "Open state to closed state rate expression for state variable " (tt "H") ". ") (dt "( " (b (tt "M-INF")) " {" (i "EXPR") "} )") (dd "Steady state expression for variable " (tt "M") ". ") (dt "( " (b (tt "M-TAU")) " {" (i "EXPR") "} )") (dd "Time constant expression for variable " (tt "M") ". ") (dt "( " (b (tt "H-INF")) " {" (i "EXPR") "} )") (dd "Steady state expression for variable " (tt "H") ". ") (dt "( " (b (tt "H-TAU")) " {" (i "EXPR") "} )") (dd "Time constant expression for variable " (tt "H") ". ") (dt ")") (dt ")"))))) (section 2 "Examples" (pre "\n;; Cerebellar Purkinje Cell: resurgent Na current and high frequency\n;; firing (Khaliq et al 2003).\n\n(nemo-model Khaliq03\n\n  ((input v \n\t  (cai from ion-pools)\n\t  (ica from ion-currents))\n\n   (const ena = 60)\n   (const ek = -88)\n   (const ca0 = 1e-4)\n\n   (component (type gate-complex) (name CaBK)\n   ;: BK-type Purkinje calcium-activated potassium current\n\n\t      (component (type gate)\n\n\t\t\t ;; constants\n\t\t\t (const CaBK_ztau = 1.0)\n\n\n\t\t\t ;; rate functions\n\n\t\t\t (CaBK_v = (v + 5))\n\n\t\t\t (CaBK_minf = \n  \t\t           (let ((vh -28.9)\n\t\t\t\t (k  6.2))\n\t\t\t     (1.0 / (1.0 + exp (neg ((CaBK_v - vh) / k))))))\n\n\t\t\t (CaBK_mtau =\n\t\t\t   (let\n\t\t\t       ((y0   0.000505)\n\t\t\t\t(vh1  -33.3)\n\t\t\t\t(k1   -10.0)\n\t\t\t\t(vh2  86.4)\n\t\t\t\t(k2   10.1))\n\t\t\t     ((1e3) * (y0 + 1 / (exp ((CaBK_v + vh1) / k1) + \n\t\t\t     \t      \t         exp ((CaBK_v + vh2) / k2))))))\n\n\t\t\t (CaBK_hinf = \n\t\t\t   (let ((y0  0.085)\n\t\t\t\t (vh  -32.0)\n\t\t\t\t (k   5.8))\n\t\t\t     (y0 + (1 - y0) / (1 + exp ((CaBK_v - vh) / k)))))\n\n\n\t\t\t (CaBK_htau = \n\t\t\t    (let ((y0   0.0019)\n\t\t\t\t  (vh1  -54.2)\n\t\t\t\t  (k1   -12.9)\n\t\t\t\t  (vh2   48.5)\n\t\t\t\t  (k2    5.2))\n\t\t\t      ((1e3) * (y0 + 1 / (exp ((CaBK_v + vh1) / k1) + exp ((CaBK_v + vh2) / k2))))))\n\n\n\t\t\t (CaBK_zinf = \n                           (let ((k 0.001))\n\t\t\t     (1 / (1 + (k / cai)))))\n\n\t\t\t (CaBK_z_alpha = (CaBK_zinf / CaBK_ztau))\n\t\t\t (CaBK_z_beta  = ((1 - CaBK_zinf) / CaBK_ztau))\n\n\t\t\t (reaction\n\t\t\t  (CaBK_z\n\t\t\t   (transitions (<-> O C CaBK_z_alpha CaBK_z_beta))\n                           (conserve  (1 = (O + C)))\t\t\t\t\t     \n\t\t\t   (initial   (let ((k 0.001))\n\t\t\t\t\t(1 / (1 + k / ca0))))\n\t\t\t   (open O)   (power 2)))\n\t\t\t \n\t\t\t (output CaBK_z )  \n\n\t\t\t \n\t\t\t (hh-ionic-gate \n\t\t\t  (CaBK  ;; ion name: exported variables will be of the form {ion}_{id}\n\t\t\t   (initial-m  (CaBK_minf))\n\t\t\t   (initial-h  (CaBK_hinf))\n\t\t\t   (m-power    3)\n\t\t\t   (h-power    1)\n\t\t\t   (m-inf      (CaBK_minf))\n\t\t\t   (m-tau      (CaBK_mtau))\n\t\t\t   (h-inf      (CaBK_hinf))\n\t\t\t   (h-tau      (CaBK_htau))))\n\t\t\t \n\t\t\t )\n\t      \n\t      (component (type pore)\n\t\t\t (const  gbar_CaBK  = 0.007)\n\t\t\t (output gbar_CaBK ))\n\t      \n\t      (component (type permeating-ion) (name k)\n\t\t\t (const e_CaBK = ek)\n\t\t\t (output e_CaBK ))\n\t      \n\t      ) ;; end BK current\n\n   \n   (component (type gate-complex) (name CaP)\n\t      ;; HH P-type Calcium current\n\t      \n\t      (component (type gate)\n\n\t\t\t \n\t\t\t ;; rate functions\n\t\t\t (CaP_inf =  \n\t\t\t   (let ((cv  -19)  (ck  5.5))\n\t\t\t     (1.0 / (1.0 + exp (neg ((v - cv) / ck))))))\n\n\t\t\t (CaP_tau =\n\t\t\t  ((1e3) *\n\t\t\t   (if (v > -50) \n\t\t\t       then (0.000191 + (0.00376 * exp (neg (((v + 41.9) / 27.8) ^ 2))))\n\t\t\t       else (0.00026367 + (0.1278 * exp (0.10327 * v))))))\n\n\n\t\t\t (hh-ionic-gate \n\t\t\t  (CaP  ;; ion name: exported variables will be of the form {ion}_{id}\n\t\t\t   (initial-m  (CaP_inf))\n\t\t\t   (m-power    1)\n\t\t\t   (h-power    0)\n\t\t\t   (m-inf      CaP_inf)\n\t\t\t   (m-tau      CaP_tau)))\n\t\t\t \n\t\t\t )\n\n\t      (component (type permeability)") (pre "\t\t\t (defun ghk (v ci co)\n\t\t\t   (let ((F  9.6485e4)\n\t\t\t   \t (R  8.3145)\n   \t\t\t         (T  (22 + 273.19))  \n                                 (Z  2)\n\t\t\t\t (E  ((1e-3) * v)))\n                             (let ((k0 ((Z * F * E) / (R * T))))\n \t\t               (let ((k1 (exp (neg(k0))))\n\t\t\t             (k2 (((Z ^ 2) * (E * (F ^ 2))) / (R * T))))\n                                (1e-6) * (if (abs (1 - k1) < 1e-6) \n                                          then (Z * F * (ci - (co * k1)) * (1 - k0))\n                                          else (k2 * (ci - (co * k1)) / (1 - k1)))))))") (pre "\t\t\t (const pcabar_CaP  = 0.00005)\n\t\t\t (const cao       = 2.4)\n\t\t\t (pca_CaP        = (pcabar_CaP * ghk (v cai cao)))\n\t\t\t (output pca_CaP ))\n\t      \n\t      (component (type permeating-ion) (name ca) )\n\t      \n\t      \n\t      ) ;; end CaP current\n\n   (component (type gate-complex) (name K1)\n   ;; HH TEA-sensitive Purkinje potassium current\n\n\t      (component (type gate)\n\n\t\t\t ;; constants\n\n\t\t\t ;; rate functions\n\n\t\t\t (K1_v = (v + 11)) ;; account for junction potential\n\n\t\t\t (K1_minf = \n  \t\t           (let ((mivh -24)\n\t\t\t\t (mik  15.4))\n\t\t\t     (1 / (1 + exp (neg (K1_v - mivh) / mik)))))\n\n\n\t\t\t (K1_mtau =\n\t\t\t   (let ((mty0   0.00012851)\n\t\t\t\t (mtvh1  100.7)\n\t\t\t\t (mtk1   12.9)\n\t\t\t\t (mtvh2  -56.0)\n\t\t\t\t (mtk2   -23.1))\n\t\t\t     (1e3 * (if (K1_v < -35) \n\t\t\t\t\tthen (3.0 * (3.4225e-5 + 0.00498 * exp (neg (K1_v) / -28.29)))\n\t\t\t\t\telse (mty0 + 1.0 / (exp ((K1_v + mtvh1) / mtk1) + exp ((K1_v + mtvh2) / mtk2)))\n\t\t\t\t\t))))\n\n\t\t\t (K1_hinf = \n\t\t\t   (let ((hiy0  0.31)\n\t\t\t\t (hiA   0.78)\n\t\t\t\t (hivh  -5.802)\n\t\t\t\t (hik   11.2))\n\t\t\t     (hiy0 + hiA / (1 + exp ((K1_v - hivh) / hik)))))\n\n\n\t\t\t (K1_htau = \n\t\t\t      (1e3 * (if ( K1_v > 0 ) \n\t\t\t\t\t   then (0.0012 + 0.0023 * exp (-0.141 * K1_v))\n\t\t\t\t\t   else (1.2202e-05 + 0.012 * exp (neg (((K1_v - (-56.3)) / 49.6) ^ 2))))))\n\n\t\t\t (hh-ionic-gate \n\t\t\t  (K1  ;; ion name: exported variables will be of the form {ion}_{id}\n\t\t\t   (initial-m  (K1_minf))\n\t\t\t   (initial-h  (K1_hinf))\n\t\t\t   (m-power    3)\n\t\t\t   (h-power    1)\n\t\t\t   (m-inf      (K1_minf))\n\t\t\t   (m-tau      (K1_mtau))\n\t\t\t   (h-inf      (K1_hinf))\n\t\t\t   (h-tau      (K1_htau))))\n\t\t\t \n\t\t\t )\n\t      \n\t      (component (type pore)\n\t\t\t (const  gbar_K1  = 0.004)\n\t\t\t (output gbar_K1 ))\n\t      \n\t      (component (type permeating-ion) (name k)\n\t\t\t (const e_K1 = ek)\n\t\t\t (output e_K1 ))\n\t      \n\t      ) ;; end K1 current\n\n   (component (type gate-complex) (name K2)\n   ;; HH Low TEA-sensitive Purkinje potassium current\n\n\t      (component (type gate)\n\n\t\t\t ;; constants\n\n\t\t\t ;; rate functions\n\n\t\t\t (K2_v = (v + 11)) ;; account for junction potential\n\n\t\t\t (K2_minf = \n  \t\t           (let ((mivh -24)\n\t\t\t\t (mik  20.4))\n\t\t\t     (1 / (1 + exp ((neg(K2_v - mivh)) / mik)))))\n\n\n\t\t\t (K2_mtau =\n\t\t\t     ((1e3) * (if (K2_v < -20) \n\t\t\t\t\t  then (0.000688 + 1 / (exp ((K2_v + 64.2) / 6.5) + exp ((K2_v - 141.5) / -34.8)))\n\t\t\t\t\t  else (0.00016 + 0.0008 * exp (-0.0267 * K2_v)))))\n\n\t\t\t \n\t\t\t (hh-ionic-gate \n\t\t\t  (K2  ;; ion name: exported variables will be of the form {ion}_{id}\n\t\t\t   (initial-m  (K2_minf))\n\t\t\t   (m-power    4)\n\t\t\t   (h-power    0)\n\t\t\t   (m-inf      (K2_minf))\n\t\t\t   (m-tau      (K2_mtau))))\n\t\t\t \n\t\t\t )\n\t      \n\t      (component (type pore)\n\t\t\t (const  gbar_K2  = 0.002)\n\t\t\t (output gbar_K2 ))\n\t      \n\t      (component (type permeating-ion) (name k)\n\t\t\t (const e_K2 = ek)\n\t\t\t (output e_K2 ))\n\t      \n\t      ) ;; end K2 current\n\n\n\n\t\n   (component (type gate-complex) (name K3)\n   ;; HH slow TEA-insensitive Purkinje potassium current\n\n\t      (component (type gate)\n\n\t\t\t ;; constants\n\n\t\t\t ;; rate functions\n\n\t\t\t (K3_v = (v + 11)) ;; account for junction potential\n\n\t\t\t (K3_minf = \n  \t\t           (let ((mivh -16.5)\n\t\t\t\t (mik  18.4))\n\t\t\t     (1 / (1 + exp ((neg(K3_v - mivh)) / mik)))))\n\n\n\t\t\t (K3_mtau =\n\t\t\t     ((1e3) * (0.000796 + 1.0 / (exp ((K3_v + 73.2) / 11.7) + exp ((K3_v - 306.7) / -74.2)))))\n\t\t\t \n\t\t\t (hh-ionic-gate \n\t\t\t  (K3  ;; ion name: exported variables will be of the form {ion}_{id}\n\t\t\t   (initial-m  (K3_minf))\n\t\t\t   (m-power    4)\n\t\t\t   (h-power    0)\n\t\t\t   (m-inf      (K3_minf))\n\t\t\t   (m-tau      (K3_mtau))))\n\t\t\t \n\t\t\t )\n\t      \n\t      (component (type pore)\n\t\t\t (const  gbar_K3  =  0.004)\n\t\t\t (output gbar_K3 ))\n\t      \n\t      (component (type permeating-ion) (name k)\n\t\t\t (const e_K3 = ek)\n\t\t\t (output e_K3 ))\n\t      \n\t      ) ;; end K3 current\n\n   (component (type gate-complex) (name Narsg) \n\n\t      ;; constants\n\t\t     \n\t      (component (type gate)\n\t\t\t\t\n\t\t\t (const Na_Con   = 0.005)\n\t\t\t (const Na_Coff  = 0.5)\n\t\t\t (const Na_Oon   = 0.75)\n\t\t\t (const Na_Ooff  = 0.005)\n\n\n\t\t\t (const Na_alfac = (pow ((Na_Oon / Na_Con) (1.0 / 4.0))))\n\t\t\t (const Na_btfac = (pow ((Na_Ooff / Na_Coff) (1.0 / 4.0))))\n\t\t\t \n\t\t\t (const Na_alpha = 150)\n\t\t\t (const Na_beta  = 3)\n\t\t\t (const Na_gamma = 150)\n\t\t\t (const Na_delta = 40)\n\t\t\t (const Na_epsilon = 1.75)\n\t\t\t (const Na_zeta = 0.03)\n\t\t\t (const Na_x1 = 20)\n\t\t\t (const Na_x2 = -20)\n\t\t\t (const Na_x3 = 1e12)\n\t\t\t (const Na_x4 = -1e12)\n\t\t\t (const Na_x5 = 1e12)\n\t\t\t (const Na_x6 = -25)\n   \n\t\t\t ;; rate functions\n\t\t\t \n\t\t\t (f01 = (4.0 * Na_alpha * exp (v / Na_x1)))\n\t\t\t (f02 = (3.0 * Na_alpha * exp (v / Na_x1)))\n\t\t\t (f03 = (2.0 * Na_alpha * exp (v / Na_x1)))\n\t\t\t (f04 = (Na_alpha * exp (v / Na_x1)))\n\t\t\t (f0O = (Na_gamma * exp (v / Na_x3)))\n\t\t\t (fip = (Na_epsilon * exp (v / Na_x5)))\n\t\t\t (f11 = (4.0 * Na_alpha * Na_alfac * exp (v / Na_x1)))\n\t\t\t (f12 = (3.0 * Na_alpha * Na_alfac * exp (v / Na_x1)))\n\t\t\t (f13 = (2.0 * Na_alpha * Na_alfac * exp (v / Na_x1)))\n\t\t\t (f14 = (Na_alpha * Na_alfac * exp (v / Na_x1)))\n\t\t\t (f1n = (Na_gamma * exp (v / Na_x3)))\n\t\t\t \n\t\t\t (fi1 = (Na_Con))\n\t\t\t (fi2 = (Na_Con * Na_alfac))\n\t\t\t (fi3 = (Na_Con * Na_alfac * Na_alfac))\n\t\t\t (fi4 = (Na_Con * Na_alfac * Na_alfac * Na_alfac))\n\t\t\t (fi5 = (Na_Con * Na_alfac * Na_alfac * Na_alfac * Na_alfac))\n\t\t\t (fin = (Na_Oon))\n\t\t\t \n\t\t\t (b01 = (Na_beta * exp (v / Na_x2)))\n\t\t\t (b02 = (2.0 * Na_beta * exp (v / Na_x2)))\n\t\t\t (b03 = (3.0 * Na_beta * exp (v / Na_x2)))\n\t\t\t (b04 = (4.0 * Na_beta * exp (v / Na_x2)))\n\t\t\t (b0O = (Na_delta * exp (v / Na_x4)))\n\t\t\t (bip = (Na_zeta * exp (v / Na_x6)))\n\t\t\t \n\t\t\t (b11 = (Na_beta * Na_btfac * exp (v / Na_x2)))\n\t\t\t (b12 = (2.0 * Na_beta * Na_btfac * exp (v / Na_x2)))\n\t\t\t (b13 = (3.0 * Na_beta * Na_btfac * exp (v / Na_x2)))\n\t\t\t (b14 = (4.0 * Na_beta * Na_btfac * exp (v / Na_x2)))\n\t\t\t (b1n = (Na_delta * exp (v / Na_x4)))\n\t\t\t \n\t\t\t (bi1 = (Na_Coff))\n\t\t\t (bi2 = (Na_Coff * Na_btfac))\n\t\t\t (bi3 = (Na_Coff * Na_btfac * Na_btfac))\n\t\t\t (bi4 = (Na_Coff * Na_btfac * Na_btfac * Na_btfac))\n\t\t\t (bi5 = (Na_Coff * Na_btfac * Na_btfac * Na_btfac * Na_btfac))\n\t\t\t (bin = (Na_Ooff))\n\t\t\t \n\t\t(reaction\n\t\t    (Na_z\n\t\t     (transitions\n\t\t      (<-> C1 C2 f01 b01)\n\t\t      (<-> C2 C3 f02 b02)\n\t\t      (<-> C3 C4 f03 b03)\n\t\t      (<-> C4 C5 f04 b04)\n\t\t      (<-> C5 O  f0O b0O)\n\t\t      (<-> O  B  fip bip)\n\t\t      (<-> O  I6 fin bin)\n\t\t      (<-> C1 I1 fi1 bi1)\n\t\t      (<-> C2 I2 fi2 bi2)\n\t\t      (<-> C3 I3 fi3 bi3)\n\t\t      (<-> C4 I4 fi4 bi4)\n\t\t      (<-> C5 I5 fi5 bi5)\n\t\t      (<-> I1 I2 f11 b11)\n\t\t      (<-> I2 I3 f12 b12)\n\t\t      (<-> I3 I4 f13 b13)\n\t\t      (<-> I4 I5 f14 b14)\n\t\t      (<-> I5 I6 f1n b1n)\n\t\t      )\n\n\t\t      (conserve (1 = (I1 + I2 + I3 + I4 + I5 + I6 + C1 + C2 + C3 + C4 + C5 + O + B)))\n\t\t     \n\t\t     (open O)   (power 1)))\n\t\t   \n\t\t   (output Na_z )  \n\t\t   \n\t\t   )\n\t\t\t\n\t\t(component (type pore)\n\t\t\t   (const  gbar  = 0.015)\n\t\t\t   (output gbar ))\n\t\t\n\t\t(component (type permeating-ion) (name na)\n\t\t\t   (const e = ena)\n\t\t\t   (output e ))\n\t\t\n\t\t) ;; end Narsg component\n\n\n\n\n\n   (component (type gate-complex) (name Ih)\n\t      \n\t      (component (type gate)\n\t\t\t \n\t\t\t ;; rate functions\n\t\t\t \n\t\t\t (Ih_inf = (1.0 /(1.0 + exp ((v + 90.1) / 9.9))))\n\t\t\t \n\t\t\t (Ih_tau = ((1e3) * (0.19 + 0.72 * exp (neg(((v - (-81.5)) / 11.9) ^ 2)))))\n\t\t\t \n\t\t\t (hh-ionic-gate \n\t\t\t  (Ih  ;; ion name: exported variables will be of the form {ion}_{id}\n\t\t\t   (initial-m (Ih_inf))\n\t\t\t   (m-power   1)\n\t\t\t   (h-power   0)\n\t\t\t   (m-inf     (Ih_inf))\n\t\t\t   (m-tau     (Ih_tau))\n\t\t\t   ))\n\t\t\t \n\t\t\t )\n\n\t      (component (type pore)\n\t\t\t (const  gbar_Ih  = 0.0001)\n\t\t\t (output gbar_Ih ))\n\t      \n\t      (component (type permeating-ion) (name non-specific)\n\t\t\t (const e_Ih = -30)\n\t\t\t (output e_Ih ))\n\t      \n\t      ) ;; end Ih current\n\n\t\n   (component (type gate-complex) (name Leak)\n\t      \n\t      (component (type pore)\n\t\t\t (const  gbar_Leak  = 5e-5)\n\t\t\t (output gbar_Leak ))\n\t      \n\t      (component (type permeating-ion) (name non-specific)\n\t\t\t (const e_Leak = -60)\n\t\t\t (output e_Leak ))\n\t      \n\t      ) ;; end leak current\n\n\n   (component (type decaying-pool) (name ca)\n \t      (const  F = 96485.0)\n \t      (const  ca_depth   = 0.1)\n \t      (const  ca_beta    = 1.0)\n\t      \n\t      (d (ca) =  ((neg (ica) / (2 * ca0 * F * ca_depth)) -\n \t\t\t  ((if (ca < ca0) then ca0 else ca) * ca_beta))\n\t      \t      \t (initial ca0))\n\n              (cac = (if (ca < ca0) then ca0 else ca))\n\n  \t      (output cac)\n \t      )\n\n\n   (component (type membrane-capacitance)\n           (const C_m = 1e-3)\n\t   (output C_m))\n\n))\n")) (section 2 "About this egg" (section 3 "Author" (p (int-link "/users/ivan-raikov" "Ivan Raikov"))) (section 3 "Version history" (dl (dt "4.3") (dd "Renamed permeating-substance components to permeating-ion") (dt "4.2") (dd "Using installation-chicken-home to install example files") (dt "4.1") (dd "Documentation converted to wiki format") (dt "4.0") (dd "Introducing the gate-complex element") (dt "3.4") (dd "Documentation update") (dt "3.1-3.3") (dd "Fixes to the examples") (dt "3.0") (dd "Internal restructuring and new examples") (dt "2.5") (dd "Bug fixes in option handling and NMODL backend") (dt "2.4") (dd "Converted to using getopt-long") (dt "2.3") (dd "Added eggdoc as a dependency") (dt "2.2") (dd "Added stx-engine.scm to file manifest") (dt "2.1") (dd "Ported to Chicken 4") (dt "2.0") (dd "Introduced functors") (dt "1.15") (dd "Added nmodl-depend option") (dt "1.14") (dd "Added support for exponential Euler integration") (dt "1.13") (dd "Change in the integration method used for the AKP example") (dt "1.12") (dd "Added support for binary conductances and conservation equations") (dt "1.11") (dd "Bug fixes in the current equations part of NMODL code generator") (dt "1.10") (dd "AKP06 example is now installed in CHICKEN-HOME/nemo/examples") (dt "1.9") (dd "Documentation and example updates") (dt "1.8") (dd "Bug fixes related to kinetic equation processing") (dt "1.6") (dd "Added infix expression parser (nemo format)") (dt "1.0") (dd "Initial release"))) (section 3 "License" (pre "Copyright 2008-2010 Ivan Raikov and the Okinawa Institute of Science and Technology.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or (at\nyour option) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nA full copy of the GPL license can be found at\n<http://www.gnu.org/licenses/>."))))