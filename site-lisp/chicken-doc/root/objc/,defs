(index ("objc:send" 0) ("objc:send/safe" 523) ("objc:send/maybe-safe" 892) ("objc:optimize-callbacks" 892) ("@" 1578) ("@[RECEIVER KEYWORD ARGUMENT ...]" 2151) ("objc:instance" 2576) ("objc:class-of" 2774) ("objc:instance->pointer" 3017) ("objc:pointer->instance" 3164) ("objc:nsstring" 3407) ("@\"...\"" 3554) ("objc:nsstring->string" 3656) ("objc:ivar-ref" 3789) ("objc:ivar-set!" 4229) ("ivar-ref" 4754) ("ivar-set!" 4891) ("@VAR" 5043) ("define-objc-classes" 5457) ("objc:class" 5927) ("objc:class->pointer" 7103) ("objc:pointer->class" 7245) ("objc:string->class" 7390) ("objc:define-method" 7529) ("objc:define-class-method" 7529) ("define-objc-class" 9180) ("objc:allow-class-redefinition" 11605) ("ns:rect" 11883) ("ns:size" 12377) ("ns:point" 12525) ("ns:range" 12679) ("objc:register-class" 12979) ("objc:set-ivars!" 13234) ("objc:add-method" 13848) ("objc:add-class-method" 13848) ("objc:wrap" 15016) ("objc:unwrap" 15016) ("objc:raw-ivar" 15642) ("objc:ivar" 16113) ("with-autorelease-pool" 16443) ("objc:import-classes-at-toplevel!" 16960) ("objc:get-class-list" 17355) ("ns:application-main" 17576) ("ns:beep" 17805) ("ns:log" 17905) ("ns:rect-fill" 18104) ("cocoa:run" 18262))
(def (sig (syntax "(objc:send RECEIVER KEYWORD1 ARGUMENT1 ...)" (id objc:send))) (p "Sends the message KEYWORD1 ARGUMENT1 ... to RECEIVER, which is an " (tt "objc:instance") " or " (tt "objc:class") " object.  This follows the normal Objective C syntax, so the call " (tt "(objc:send myRect setWidth: 15.0 height: 20.0)") " invokes the method " (tt "setWidth:height:") " on myRect, with arguments 15.0 and 20.0.  If the method has no arguments, use a symbol instead of a keyword: " (tt "(objc:send NSScanner alloc)") "."))
(def (sig (syntax "(objc:send/safe RECEIVER KEYWORD1 ARGUMENT1 ...)" (id objc:send/safe))) (p "Identical to " (tt "(objc:send RECEIVER KEYWORD1 ARGUMENT1 ...)") ", but allows callbacks from Objective C into Scheme.  Safe calls are required when invoking any Objective C method that is either implemented in Scheme, or could itself invoke a method defined in Scheme."))
(def (sig (syntax "(objc:send/maybe-safe RECEIVER KEYWORD1 ARGUMENT1 ...)" (id objc:send/maybe-safe)) (parameter "(objc:optimize-callbacks) [default: #t]" (id objc:optimize-callbacks))) (p "Identical to " (tt "objc:send/safe") " when the object or class (or any superclass) is implemented in Scheme, and to " (tt "objc:send") " otherwise.  In general, this greatly improves invocation time for pure Objective C classes and objects, has a negligible impact on Scheme classes, and incurs a 10% penalty for Scheme instances.  This optimization can be disabled by setting the parameter " (tt "objc:optimize-callbacks") " to " (tt "#f") "---in which case a safe call will always be used."))
(def (sig (syntax "(@ RECEIVER KEYWORD ARGUMENT ...)" (id @))) (p "An abbreviation for " (tt "(objc:send/maybe-safe RECEIVER KEYWORD ARGUMENT ...)") ".  The older " (tt "@[...]") " form is deprecated.") (p "For enhanced readability, the bridge accepts hyphenated selector keywords and translates them into their Objective C counterparts by uppercasing any character after a hyphen, then removing the hyphens.  For example, the following are equivalent:") (pre "(@ NSDictionary dictionary-with-contents-of-file: name)\n(@ NSDictionary dictionaryWithContentsOfFile: name)"))
(def (sig (read "@[RECEIVER KEYWORD ARGUMENT ...]" (id "@[RECEIVER KEYWORD ARGUMENT ...]"))) (p "Same as " (tt "objc:send/maybe-safe") ".  If the receiver is prefixed with the " (tt "unsafe:") " keyword, then this form expands into a " (tt "(objc:send ...)") " expression instead.  Prefixing with " (tt "safe:") " guarantees an " (tt "objc:send/safe") " call.") (p "This form is deprecated in favor of " (tt "(@ ...)") "."))
(def (sig (record "objc:instance" (id objc:instance))) (p "A wrapper for an instance of an Objective C class.  The object's " (tt "description") " method determines how this record is displayed."))
(def (sig (procedure "(objc:class-of ID)" (id objc:class-of))) (p "Return the class of objc:instance ID, obtained by sending ID a class message.  This procedure also accepts a class object, but the result will generally be the same object."))
(def (sig (procedure "(objc:instance->pointer OBJ)" (id objc:instance->pointer))) (p "Return the raw pointer associated with objc:instance OBJ."))
(def (sig (procedure "(objc:pointer->instance ptr)" (id objc:pointer->instance))) (p "Create an objc:instance from a raw instance pointer (an " (tt "id") ").  Implicitly retains the object, releasing it when the objc:instance is finalized."))
(def (sig (procedure "(objc:nsstring STRING)" (id objc:nsstring))) (p "Constructs a new NSString from STRING.  Currently assumes UTF8 encoding."))
(def (sig (read "@\"...\"" (id "@\"...\""))) (p "Equivalent to " (tt "(objc:nsstring \"...\")") "."))
(def (sig (procedure "(objc:nsstring->string STRING)" (id objc:nsstring->string))) (p "Converts an NSString into a Scheme string."))
(def (sig (procedure "(objc:ivar-ref OBJECT NAME)" (id objc:ivar-ref))) (p "Returns the value of OBJECT's instance variable NAME (which should be a string).") (p (int-link "#type-conversions" "Type conversion") " is performed on the result, based on the ivar's type.  When the ivar refers to a Scheme object (i.e., is a " (int-link "#type-qualifiers" ((tt "#:slot") " or " (tt "#:wrapper") ")")) ", the object is returned transparently."))
(def (sig (procedure "(objc:ivar-set! OBJECT NAME VALUE)" (id objc:ivar-set!))) (p "Sets the value of OBJECT's instance variable NAME to VALUE.") (p "Type conversion is performed on VALUE, based on the ivar type.  When the ivar is a " (tt "#:slot") " or a " (tt "#:wrapper") ",  VALUE can be any Scheme object.") (p (int-link "#memory-management" "Reference counts are automatically managed") " for " (tt "id") " types.") (p "A SRFI-17 setter is also provided, in the form") (pre "(set! (objc:ivar-ref OBJECT NAME) VALUE)"))
(def (sig (syntax "(ivar-ref OBJECT NAME)" (id ivar-ref))) (p "Shorthand for " (tt "(objc:ivar-ref OBJECT (symbol->string NAME))") "."))
(def (sig (syntax "(ivar-set! OBJECT NAME VALUE)" (id ivar-set!))) (p "Shorthand for " (tt "(objc:ivar-set! OBJECT (symbol->string NAME) VALUE)") "."))
(def (sig (read "@VAR" (id "@VAR"))) (p "Intended for use within methods, this expands to " (tt "(objc:ivar-ref self \"VAR\")") ".") (p "Use " (tt "(set! @var value)") " to set an instance variable.") (pre "Examples: \n(objc:ivar-set! p \"x\" 3) \n(objc:ivar-ref p \"x\")     ; => 3 \n(ivar-ref p x)            ; => 3   \n(set! @x (vector 1 2 3))  ; when @x is a slot: \n@x                        ; => #(1 2 3)"))
(def (sig (syntax "(define-objc-classes NAME ...)" (id define-objc-classes))) (p "Locates the Objective C classes NAME ... and defines variables holding pointers to the class objects. NAME may be a symbol or a list of the form " (tt "(VARIABLE CLASSNAME)") ". For example, " (tt "(define-objc-classes NSTextView NSTask)") " is equivalent to") (pre "(begin\n  (define NSTextView (objc:string->class \"NSTextView\"))\n  (define NSTask (objc:string->class \"NSTask\")))"))
(def (sig (record "objc:class" (id objc:class))) (p "A record representing an Objective C class.") (table (@ (class "symbol-table")) (tr (td "name") (td "Class name as a string.")) "\n" (tr (td "method-list") (td "List of instance methods.  The format is " (tt "((NAME . SIGNATURE) ...)") ", but may change in the future to a list of objc:method records.")) "\n" (tr (td "class-method-list") (td "List of class methods.")) "\n" (tr (td "super-class") (td "Superclass of this class (as an objc:class).")) "\n" (tr (td "meta-class") (td "Metaclass of this class (as an objc:class).")) "\n" (tr (td "ivar-list") (td "List of all instance variables in this class (as objc:raw-ivar records).")) "\n" (tr (td "ivars") (td "List of ivars in this class defined in Scheme (as objc:ivar records).")) "\n" (tr (td "all-ivars") (td "Aggregate list of objc:ivar records from the class hierarchy."))) (p "A note on instance variables: the bridge generates " (tt "objc:ivar") " records only for ivars defined in Scheme.  However, " (tt "objc:raw-ivar") " records are available for all instance variables.  This API (" (tt "ivar-list / ivars / all-ivars") ") is new and subject to change."))
(def (sig (procedure "(objc:class->pointer CLASS)" (id objc:class->pointer))) (p "Return the raw pointer associated with objc:class CLASS."))
(def (sig (procedure "(objc:pointer->class ptr)" (id objc:pointer->class))) (p "Create a class from a raw class pointer (a " (tt "Class") ")."))
(def (sig (procedure "(objc:string->class STRING)" (id objc:string->class))) (p "Look up and return the Objective C class named STRING."))
(def (sig (syntax "(objc:define-method CLASS RT ARGS . BODY)" (id objc:define-method)) (syntax "(objc:define-class-method CLASS RT ARGS . BODY)" (id objc:define-class-method))) (p "Define an instance or class method in CLASS.") (table (@ (class "symbol-table")) (tr (td "CLASS") (td "An objc:class object representing the destination class.")) "\n" (tr (td "RT") (td "The return type of the method.")) "\n" (tr (td "ARGS") (td (tt "((KEYWORD TYPE VAR-NAME) ...)") " or " (tt "SYMBOL"))) "\n" (tr (td "BODY") (td "Body of a lambda comprising the method.  The parameters visible inside the lambda are self (a class or instance object), sel (the method selector), and the arguments given in ARGS."))) (p "Each list in ARGS adds a method argument of type TYPE, visible to the method body as VAR-NAME.  As in Objective C, each argument is associated with a KEYWORD and each KEYWORD is combined into a method name.  Hyphenated keywords are accepted, just like in method invocations.  A bare SYMBOL can be used as the method name (instead of a list) if no arguments are expected.") (p "TYPE should be a " (int-link "#types" "short typename") ", a symbol such as " (tt "INT") ".") (p "Within a method body, you can use " (tt "(@ super ...)") " to call a class or instance method of the superclass.  Note: " (tt "super") " is a reserved keyword, not a variable.") (p "Example:") (pre "\n (objc:define-method Rect VOID ((set-width: DBL my-w)\n                                (height:    DBL my-h))\n   (ivar-set! self w my-w)\n   (ivar-set! self h my-h))") (p "Method removal is not yet implemented, but redefining a method will override the old definition."))
(def (sig (syntax "(define-objc-class CLASS SUPERCLASS IVARS . METHODS)" (id define-objc-class))) (p "Defines CLASS (a symbol) with superclass SUPERCLASS (a symbol), instance variables IVARS, and methods METHODS.  The new classname is imported with " (tt "define-objc-classes") ".") (p "SUPERCLASS is looked up for you in the runtime, so it need not be imported.") (p "IVARS is a list of the form " (tt "((TYPE NAME) ...)") ", where TYPE is a " (int-link "#type-qualifiers" "type qualifier") " and NAME is a symbol representing the new variable name.  Each instance of CLASS will have a separate copy of these variables.") (p "METHODS are method definitions of the form " (tt "(define-[class-]method RT ARGS . BODY)") ", which are equivalent to calling " (tt "(objc:define-[class]-method CLASS RT ARGS . BODY)") " using the current CLASS.  These methods are defined in the lexical environment of the surrounding " (tt "define-objc-class") " expression.  As a simple consequence, you can surround the class definition with a " (tt "let") " statement and create \"static\" variables for the class.") (p "You can also use " (b "+") " as an alias for " (tt "define-class-method") " and " (b "-") " for " (tt "define-method") ".  These correspond to Objective C method definition syntax.") (pre "Example:\n\n (define-objc-class MyPoint NSObject ((DBL x)\n                                      (DBL y) \n                                      (slot: closure))\n   (define-method ID init\n     (print \"MyPoint init\")\n     (@ super init))\n   (- DBL getX @x)\n   (- DBL getY @y)\n   (- ID description\n      (sprintf \"<MyPoint: (~a, ~a)>\" @x @y))\n\n   (- VOID ((move-by-x: DBL a) (y: DBL b))\n     (set! @x (+ a @x))\n     (ivar-set! self y (+ b (ivar-ref self y))))  ;; more wordy\n\n   (- ID ((init-with-x: DBL a) (y: DBL b))\n      (let ((p (@ self init)))\n        (@ p move-by-x: a y: b)\n        (set! @closure (lambda (msg)\n                         (cond ((eq? msg 'initial-x) \n                                (print \"MyPoint: initial x was \" a))\n                               ((eq? msg 'initial-y) \n                                (print \"MyPoint: initial y was \" b)))))\n        p)))\n\n #;1> (define p (@ (@ MyPoint alloc) init-with-x: 3.4 y: 4.5))\n MyPoint init\n #;2> (@ p move-by-x: 2 y: 3)\n #<objc-instance <MyPoint: (5.4, 7.5)>>\n #;3> ((ivar-ref p closure) 'initial-x)\n MyPoint: initial x was 3.4"))
(def (sig (parameter "(objc:allow-class-redefinition) [default: #t]" (id objc:allow-class-redefinition))) (p "If #f, an error will occur when attempting to redefine an existing class with define-objc-class.") (p "If #t, redefinition is allowed and a warning will be printed."))
(def (sig (record "ns:rect" (id ns:rect))) (p (tt "ns:make-rect") " is provided as an alias for the default constructor " (tt "make-ns:rect") ".  The same is true for the other records.") (table (@ (class "symbol-table")) (tr (td "x") (td "X coordinate of origin (NSRect.origin.x)")) "\n" (tr (td "y") (td "Y coordinate of origin (NSRect.origin.y)")) "\n" (tr (td "width") (td "Width of rectangle (NSRect.size.width)")) "\n" (tr (td "height") (td "Height of rectangle (NSRect.size.height)"))))
(def (sig (record "ns:size" (id ns:size))) (table (@ (class "symbol-table")) (tr (td "width") (td "Width")) "\n" (tr (td "height") (td "Height"))))
(def (sig (record "ns:point" (id ns:point))) (table (@ (class "symbol-table")) (tr (td "x") (td "X coordinate")) "\n" (tr (td "y") (td "Y coordinate"))))
(def (sig (record "ns:range" (id ns:range))) (table (@ (class "symbol-table")) (tr (td "location") (td "Start index, 0-based")) "\n" (tr (td "length") (td "Length of range"))) (p "Other than the four exceptions above, struct, union, and array types cannot be sent to or received from Objective C."))
(def (sig (procedure "(objc:register-class CLASSNAME SUPERCLASS)" (id objc:register-class))) (p "Registers CLASSNAME (a string) having superclass SUPERCLASS (an objc:class) with the Objective C runtime.  An error is raised if CLASSNAME already exists."))
(def (sig (procedure "(objc:set-ivars! CLASS IVARS)" (id objc:set-ivars!))) (p "Defines in CLASS (an objc:class) the instance variables in IVARS (a list of objc:instance-var records).  The offset parameter of the instance variable records is ignored.") (p "Warning: all old instance variables in MyClass will be removed first. Also, we don't check for conflicts with superclass instance variables.  This should be remedied in a future release.") (pre "Example: \n(objc:set-ivars! MyClass (list (make-objc:raw-ivar \"jimmy\" objc:INT 0) \n                               (make-objc:raw-ivar \"cammy\" objc:DBL 0)"))
(def (sig (procedure "(objc:add-method CLASS METHOD TYPES PROC)" (id objc:add-method)) (procedure "(objc:add-class-method CLASS METHOD TYPES PROC)" (id objc:add-class-method))) (p "Adds a class or instance method to CLASS.") (table (@ (class "symbol-table")) (tr (td "METHOD") (td "Method name as a string (e.g. " (tt "\"setWidth:height:\"") ")")) "\n" (tr (td "TYPES") (td "List of encoded argument type strings (such as " (tt "objc:INT") " or \"@\").")) "\n" (tr (td "PROC") (td "Scheme procedure representing the method."))) (p "The structure of the TYPES list is " (tt "(RETURN-TYPE SELF SELECTOR METHOD-ARGS...)") ".") (p "You may add Scheme methods to pure Objective C classes; when class proxies are enabled, this will automatically taint the class so that safe calls are used.  Currently, a warning is printed when a class is tainted.") (pre "Transformation: \n(objc:define-method MyClass DBL ((sel1: INT i) (sel2: DBL d)) \n                                (print i) (+ i d)) \n=> \n(objc:add-method MyClass \"sel1:sel2:\"\n                 (list objc:DBL objc:ID objc:SEL objc:INT objc:DBL) \n                 (lambda (self sel i d) (print i) (+ i d))) \n"))
(def (sig (procedure "(objc:wrap X)" (id objc:wrap)) (procedure "(objc:unwrap X)" (id objc:unwrap))) (p "Wrap or unwrap the Scheme object X inside an Objective C instance (specifically, a " (tt "Scheme_Object_Wrapper") ") so that it can be passed as an " (tt "id") " type.  Essentially, these functions allow you to tunnel a Scheme object through the Objective C bridge, when both endpoints are written in Scheme.  At the moment, the resulting object cannot be accessed meaningfully from the Objective C side.") (p "These functions are also used to implement the " (tt "#:wrapper") " type qualifier for instance variables."))
(def (sig (record "objc:raw-ivar" (id objc:raw-ivar))) (p "A record describing an Objective C instance variable as seen from the Objective C (as opposed to Scheme) side.  Returned by " (tt "objc:class-ivar-list") ", and used by " (tt "objc:set-ivars!") ".") (table (@ (class "symbol-table")) (tr (td "name") (td "Name as a string.")) "\n" (tr (td "type") (td "Type as an encoded type string.")) "\n" (tr (td "offset") (td "Offset within class -- for debugging only."))))
(def (sig (record "objc:ivar" (id objc:ivar))) (p "A record describing Scheme's view of an Objective C instance variable.  At the moment, fields include those of " (tt "objc:raw-ivar") " with the following addition:") (table (@ (class "symbol-table")) (tr (td "function") (td "Keyword #:slot, #:wrapper, #:outlet, or #:ivar."))))
(def (sig (procedure "(with-autorelease-pool THUNK)" (id with-autorelease-pool))) (p "Creates an autorelease pool that lasts for the duration of the thunk.") (p "A global autorelease pool is created automatically at startup, one is wrapped around the main Application Kit event loop, one is wrapped around every call to Objective C, and memory management is generally otherwise automatic.  It is considered unlikely you will have to use this, unless you send Objective C messages directly inside a foreign-lambda."))
(def (sig (procedure "(objc:import-classes-at-toplevel!)" (id objc:import-classes-at-toplevel!))) (p "Import every class visible to the runtime, as if define-objc-classes had been run on all available classes.  Useful for debugging.  Note that some (rare) classes are not derived from NSObject, and will not respond to standard NSObject selectors, may throw exceptions, or may crash if used."))
(def (sig (procedure "(objc:get-class-list)" (id objc:get-class-list))) (p "Looks up and returns a list of all available classes.  At startup, the result of this call is stored in the variable " (tt "objc:classes") "."))
(def (sig (procedure "(ns:application-main)" (id ns:application-main))) (p "Starts the main event loop of a Cocoa-based application.  If any arguments are present on the command line, they will be passed to NSApplicationMain."))
(def (sig (procedure "(ns:beep)" (id ns:beep))) (p "Plays the default system sound using NSBeep."))
(def (sig (procedure "(ns:log FORMAT-STR ARGS...)" (id ns:log))) (p "Logs a message using NSLog.  The optional " (tt "ARGS") " are interpolated into " (tt "FORMAT-STR") " as in " (tt "printf") "."))
(def (sig (procedure "(ns:rect-fill RECT)" (id ns:rect-fill))) (p "Fills the passed RECT (an " (tt "ns:rect") ") with the current color, using NSRectFill."))
(def (sig (procedure "(cocoa:run)" (id cocoa:run))) (p "Send the run message to the global NSApplication object.  This is intended to be used during debugging, to restart the main application event loop after an error has returned you to the REPL."))
