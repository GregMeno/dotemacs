((tags "eggs") (p "This is version 0.5 of the " (b "objc") " extension library for Chicken Scheme.") (toc) (section 2 "Description" (p "Scheme to Objective C bridge")) (section 2 "Documentation" (p "This egg provides a basic interface to Objective C from Scheme.  You can invoke class and instance methods, access instance variables, and define Objective C classes directly in Scheme.") (p "This egg " (int-link "#Requirements" "requires Mac OS X and libffi") ".") (section 3 "Method invocation" (def (sig (syntax "(objc:send RECEIVER KEYWORD1 ARGUMENT1 ...)" (id objc:send))) (p "Sends the message KEYWORD1 ARGUMENT1 ... to RECEIVER, which is an " (tt "objc:instance") " or " (tt "objc:class") " object.  This follows the normal Objective C syntax, so the call " (tt "(objc:send myRect setWidth: 15.0 height: 20.0)") " invokes the method " (tt "setWidth:height:") " on myRect, with arguments 15.0 and 20.0.  If the method has no arguments, use a symbol instead of a keyword: " (tt "(objc:send NSScanner alloc)") ".")) (def (sig (syntax "(objc:send/safe RECEIVER KEYWORD1 ARGUMENT1 ...)" (id objc:send/safe))) (p "Identical to " (tt "(objc:send RECEIVER KEYWORD1 ARGUMENT1 ...)") ", but allows callbacks from Objective C into Scheme.  Safe calls are required when invoking any Objective C method that is either implemented in Scheme, or could itself invoke a method defined in Scheme.")) (def (sig (syntax "(objc:send/maybe-safe RECEIVER KEYWORD1 ARGUMENT1 ...)" (id objc:send/maybe-safe)) (parameter "(objc:optimize-callbacks) [default: #t]" (id objc:optimize-callbacks))) (p "Identical to " (tt "objc:send/safe") " when the object or class (or any superclass) is implemented in Scheme, and to " (tt "objc:send") " otherwise.  In general, this greatly improves invocation time for pure Objective C classes and objects, has a negligible impact on Scheme classes, and incurs a 10% penalty for Scheme instances.  This optimization can be disabled by setting the parameter " (tt "objc:optimize-callbacks") " to " (tt "#f") "---in which case a safe call will always be used.")) (def (sig (syntax "(@ RECEIVER KEYWORD ARGUMENT ...)" (id @))) (p "An abbreviation for " (tt "(objc:send/maybe-safe RECEIVER KEYWORD ARGUMENT ...)") ".  The older " (tt "@[...]") " form is deprecated.") (p "For enhanced readability, the bridge accepts hyphenated selector keywords and translates them into their Objective C counterparts by uppercasing any character after a hyphen, then removing the hyphens.  For example, the following are equivalent:") (pre "(@ NSDictionary dictionary-with-contents-of-file: name)\n(@ NSDictionary dictionaryWithContentsOfFile: name)")) (def (sig (read "@[RECEIVER KEYWORD ARGUMENT ...]" (id "@[RECEIVER KEYWORD ARGUMENT ...]"))) (p "Same as " (tt "objc:send/maybe-safe") ".  If the receiver is prefixed with the " (tt "unsafe:") " keyword, then this form expands into a " (tt "(objc:send ...)") " expression instead.  Prefixing with " (tt "safe:") " guarantees an " (tt "objc:send/safe") " call.") (p "This form is deprecated in favor of " (tt "(@ ...)") "."))) (section 3 "Instances" (def (sig (record "objc:instance" (id objc:instance))) (p "A wrapper for an instance of an Objective C class.  The object's " (tt "description") " method determines how this record is displayed.")) (def (sig (procedure "(objc:class-of ID)" (id objc:class-of))) (p "Return the class of objc:instance ID, obtained by sending ID a class message.  This procedure also accepts a class object, but the result will generally be the same object.")) (def (sig (procedure "(objc:instance->pointer OBJ)" (id objc:instance->pointer))) (p "Return the raw pointer associated with objc:instance OBJ.")) (def (sig (procedure "(objc:pointer->instance ptr)" (id objc:pointer->instance))) (p "Create an objc:instance from a raw instance pointer (an " (tt "id") ").  Implicitly retains the object, releasing it when the objc:instance is finalized."))) (section 3 "Strings" (def (sig (procedure "(objc:nsstring STRING)" (id objc:nsstring))) (p "Constructs a new NSString from STRING.  Currently assumes UTF8 encoding.")) (def (sig (read "@\"...\"" (id "@\"...\""))) (p "Equivalent to " (tt "(objc:nsstring \"...\")") ".")) (def (sig (procedure "(objc:nsstring->string STRING)" (id objc:nsstring->string))) (p "Converts an NSString into a Scheme string."))) (section 3 "Instance variables" (def (sig (procedure "(objc:ivar-ref OBJECT NAME)" (id objc:ivar-ref))) (p "Returns the value of OBJECT's instance variable NAME (which should be a string).") (p (int-link "#type-conversions" "Type conversion") " is performed on the result, based on the ivar's type.  When the ivar refers to a Scheme object (i.e., is a " (int-link "#type-qualifiers" ((tt "#:slot") " or " (tt "#:wrapper") ")")) ", the object is returned transparently.")) (def (sig (procedure "(objc:ivar-set! OBJECT NAME VALUE)" (id objc:ivar-set!))) (p "Sets the value of OBJECT's instance variable NAME to VALUE.") (p "Type conversion is performed on VALUE, based on the ivar type.  When the ivar is a " (tt "#:slot") " or a " (tt "#:wrapper") ",  VALUE can be any Scheme object.") (p (int-link "#memory-management" "Reference counts are automatically managed") " for " (tt "id") " types.") (p "A SRFI-17 setter is also provided, in the form") (pre "(set! (objc:ivar-ref OBJECT NAME) VALUE)")) (def (sig (syntax "(ivar-ref OBJECT NAME)" (id ivar-ref))) (p "Shorthand for " (tt "(objc:ivar-ref OBJECT (symbol->string NAME))") ".")) (def (sig (syntax "(ivar-set! OBJECT NAME VALUE)" (id ivar-set!))) (p "Shorthand for " (tt "(objc:ivar-set! OBJECT (symbol->string NAME) VALUE)") ".")) (def (sig (read "@VAR" (id "@VAR"))) (p "Intended for use within methods, this expands to " (tt "(objc:ivar-ref self \"VAR\")") ".") (p "Use " (tt "(set! @var value)") " to set an instance variable.") (pre "Examples: \n(objc:ivar-set! p \"x\" 3) \n(objc:ivar-ref p \"x\")     ; => 3 \n(ivar-ref p x)            ; => 3   \n(set! @x (vector 1 2 3))  ; when @x is a slot: \n@x                        ; => #(1 2 3)"))) (section 3 "Classes" (def (sig (syntax "(define-objc-classes NAME ...)" (id define-objc-classes))) (p "Locates the Objective C classes NAME ... and defines variables holding pointers to the class objects. NAME may be a symbol or a list of the form " (tt "(VARIABLE CLASSNAME)") ". For example, " (tt "(define-objc-classes NSTextView NSTask)") " is equivalent to") (pre "(begin\n  (define NSTextView (objc:string->class \"NSTextView\"))\n  (define NSTask (objc:string->class \"NSTask\")))")) (def (sig (record "objc:class" (id objc:class))) (p "A record representing an Objective C class.") (table (@ (class "symbol-table")) (tr (td "name") (td "Class name as a string.")) "\n" (tr (td "method-list") (td "List of instance methods.  The format is " (tt "((NAME . SIGNATURE) ...)") ", but may change in the future to a list of objc:method records.")) "\n" (tr (td "class-method-list") (td "List of class methods.")) "\n" (tr (td "super-class") (td "Superclass of this class (as an objc:class).")) "\n" (tr (td "meta-class") (td "Metaclass of this class (as an objc:class).")) "\n" (tr (td "ivar-list") (td "List of all instance variables in this class (as objc:raw-ivar records).")) "\n" (tr (td "ivars") (td "List of ivars in this class defined in Scheme (as objc:ivar records).")) "\n" (tr (td "all-ivars") (td "Aggregate list of objc:ivar records from the class hierarchy."))) (p "A note on instance variables: the bridge generates " (tt "objc:ivar") " records only for ivars defined in Scheme.  However, " (tt "objc:raw-ivar") " records are available for all instance variables.  This API (" (tt "ivar-list / ivars / all-ivars") ") is new and subject to change.")) (def (sig (procedure "(objc:class->pointer CLASS)" (id objc:class->pointer))) (p "Return the raw pointer associated with objc:class CLASS.")) (def (sig (procedure "(objc:pointer->class ptr)" (id objc:pointer->class))) (p "Create a class from a raw class pointer (a " (tt "Class") ").")) (def (sig (procedure "(objc:string->class STRING)" (id objc:string->class))) (p "Look up and return the Objective C class named STRING.")) (def (sig (syntax "(objc:define-method CLASS RT ARGS . BODY)" (id objc:define-method)) (syntax "(objc:define-class-method CLASS RT ARGS . BODY)" (id objc:define-class-method))) (p "Define an instance or class method in CLASS.") (table (@ (class "symbol-table")) (tr (td "CLASS") (td "An objc:class object representing the destination class.")) "\n" (tr (td "RT") (td "The return type of the method.")) "\n" (tr (td "ARGS") (td (tt "((KEYWORD TYPE VAR-NAME) ...)") " or " (tt "SYMBOL"))) "\n" (tr (td "BODY") (td "Body of a lambda comprising the method.  The parameters visible inside the lambda are self (a class or instance object), sel (the method selector), and the arguments given in ARGS."))) (p "Each list in ARGS adds a method argument of type TYPE, visible to the method body as VAR-NAME.  As in Objective C, each argument is associated with a KEYWORD and each KEYWORD is combined into a method name.  Hyphenated keywords are accepted, just like in method invocations.  A bare SYMBOL can be used as the method name (instead of a list) if no arguments are expected.") (p "TYPE should be a " (int-link "#types" "short typename") ", a symbol such as " (tt "INT") ".") (p "Within a method body, you can use " (tt "(@ super ...)") " to call a class or instance method of the superclass.  Note: " (tt "super") " is a reserved keyword, not a variable.") (p "Example:") (pre "\n (objc:define-method Rect VOID ((set-width: DBL my-w)\n                                (height:    DBL my-h))\n   (ivar-set! self w my-w)\n   (ivar-set! self h my-h))") (p "Method removal is not yet implemented, but redefining a method will override the old definition.")) (def (sig (syntax "(define-objc-class CLASS SUPERCLASS IVARS . METHODS)" (id define-objc-class))) (p "Defines CLASS (a symbol) with superclass SUPERCLASS (a symbol), instance variables IVARS, and methods METHODS.  The new classname is imported with " (tt "define-objc-classes") ".") (p "SUPERCLASS is looked up for you in the runtime, so it need not be imported.") (p "IVARS is a list of the form " (tt "((TYPE NAME) ...)") ", where TYPE is a " (int-link "#type-qualifiers" "type qualifier") " and NAME is a symbol representing the new variable name.  Each instance of CLASS will have a separate copy of these variables.") (p "METHODS are method definitions of the form " (tt "(define-[class-]method RT ARGS . BODY)") ", which are equivalent to calling " (tt "(objc:define-[class]-method CLASS RT ARGS . BODY)") " using the current CLASS.  These methods are defined in the lexical environment of the surrounding " (tt "define-objc-class") " expression.  As a simple consequence, you can surround the class definition with a " (tt "let") " statement and create \"static\" variables for the class.") (p "You can also use " (b "+") " as an alias for " (tt "define-class-method") " and " (b "-") " for " (tt "define-method") ".  These correspond to Objective C method definition syntax.") (pre "Example:\n\n (define-objc-class MyPoint NSObject ((DBL x)\n                                      (DBL y) \n                                      (slot: closure))\n   (define-method ID init\n     (print \"MyPoint init\")\n     (@ super init))\n   (- DBL getX @x)\n   (- DBL getY @y)\n   (- ID description\n      (sprintf \"<MyPoint: (~a, ~a)>\" @x @y))\n\n   (- VOID ((move-by-x: DBL a) (y: DBL b))\n     (set! @x (+ a @x))\n     (ivar-set! self y (+ b (ivar-ref self y))))  ;; more wordy\n\n   (- ID ((init-with-x: DBL a) (y: DBL b))\n      (let ((p (@ self init)))\n        (@ p move-by-x: a y: b)\n        (set! @closure (lambda (msg)\n                         (cond ((eq? msg 'initial-x) \n                                (print \"MyPoint: initial x was \" a))\n                               ((eq? msg 'initial-y) \n                                (print \"MyPoint: initial y was \" b)))))\n        p)))\n\n #;1> (define p (@ (@ MyPoint alloc) init-with-x: 3.4 y: 4.5))\n MyPoint init\n #;2> (@ p move-by-x: 2 y: 3)\n #<objc-instance <MyPoint: (5.4, 7.5)>>\n #;3> ((ivar-ref p closure) 'initial-x)\n MyPoint: initial x was 3.4")) (def (sig (parameter "(objc:allow-class-redefinition) [default: #t]" (id objc:allow-class-redefinition))) (p "If #f, an error will occur when attempting to redefine an existing class with define-objc-class.") (p "If #t, redefinition is allowed and a warning will be printed."))) (section 3 "Types" (p "Objective C is a typed language, and the bridge uses these types to decide how to pass values into and out of Objective C.  Each type is represented by a specific string and the bridge provides a variable containing each type string.  The variable names and their associated Objective C types are listed below.") (p (tt "objc:define-method") " uses short versions of the types below, with the " (tt "objc:") " prefix removed.  For example, use " (tt "ID") " instead of " (tt "objc:ID") ". The full names are generally used for lower-level methods such as " (tt "objc:add-method") " and " (tt "objc:set-ivars!") ".") (table (@ (class "symbol-table")) (tr (td "objc:ID") (td "id")) "\n" (tr (td "objc:CLASS") (td "Class")) "\n" (tr (td "objc:SEL") (td "SEL")) "\n" (tr (td "objc:INT") (td "int")) "\n" (tr (td "objc:DBL") (td "double")) "\n" (tr (td "objc:FLT") (td "float")) "\n" (tr (td "objc:CHR") (td "char")) "\n" (tr (td "objc:SHT") (td "short")) "\n" (tr (td "objc:LNG") (td "long")) "\n" (tr (td "objc:USHT") (td "unsigned short")) "\n" (tr (td "objc:UINT") (td "unsigned int")) "\n" (tr (td "objc:UCHR") (td "unsigned char")) "\n" (tr (td "objc:ULNG") (td "unsigned long")) "\n" (tr (td "objc:BOOL") (td "BOOL")) "\n" (tr (td "objc:PTR") (td "void *")) "\n" (tr (td "objc:CHARPTR") (td "char *")) "\n" (tr (td "objc:NSRECT") (td "NSRect")) "\n" (tr (td "objc:NSSIZE") (td "NSSize")) "\n" (tr (td "objc:NSPOINT") (td "NSPoint")) "\n" (tr (td "objc:NSRANGE") (td "NSRange")) "\n" (tr (td "objc:VOID") (td "void"))) (p "Instance variables defined in " (tt "define-objc-class") " use the type qualifiers in the following table.") (table (@ (class "symbol-table")) (tr (td "DBL, INT, etc.") (td "An " (tt "objc:DBL") ", " (tt "objc:INT") ", etc. type---use short typenames, as in " (tt "objc:define-method") ".")) "\n" (tr (td "ID") (td "An Objective C instance (objc:ID) with automatic " (int-link "#memory-management" "memory management") ".")) "\n" (tr (td "#:outlet") (td "An Interface Builder outlet (objc:ID).  Memory management is not performed.")) "\n" (tr (td "#:slot") (td "Holds a scheme object, such as a vector or closure.")) "\n" (tr (td "#:wrapper") (td "Holds a scheme object like #:slot, but is less efficient.")))) (section 3 "Type conversions" (p "Numeric types (such as double and int) are converted to and from Scheme numbers just as in Chicken's C FFI.") (p "Class types are wrapped in unique objc:class records when passed to Scheme---see " (int-link "#class-proxies" "Class Proxies") " for more details.") (p "An " (tt "id") ", or instance, type is almost always represented as an " (tt "objc:instance") " record, which is a thin wrapper around a pointer to the Objective C object.  There is generally no automatic conversion to or from Scheme objects, even when the object has a reasonable direct representation in Scheme.  For example, you may not pass the number \"3\" to a method expecting an " (tt "id") ", even though \"3\" could be represented as an " (tt "NSNumber") ".  Conversely, an NSNumber representing \"3\" remains an " (tt "objc:instance") " when returned to Scheme.") (p "There is one exception to this rule: you may pass a string to any method which expects an " (tt "id") ", and it will become an " (tt "NSString") ".  Of course, you can always perform conversions manually using Objective C methods---continuing the example above, an " (tt "(@ NSNumber number-with-int: 3)") " can indeed be passed as an " (tt "id") " argument.  The author has written convenience functions for NSNumber, NSDictionary, and NSArray which reduce the drudgery of conversion.  These should be available soon; " (link "http://3e8.org/zb" "check here for updates") ".") (p "Objective C lacks a boolean type; booleans are char types where zero is false and non-zero is true.  Since (char)0 is rare, we convert it to #f when passed to Scheme, which allows Scheme predicates to work without a special test.  We also transform #t and #f to (char)1 and (char)0 when passed to Objective C.  Other character values are passed through as-is.  Unsigned char values, on the other hand, never represent booleans and aren't transformed.") (p "Selectors are converted to strings when passed to Scheme, and strings converted back to selectors when passed to Objective C.  Note that selectors may be wrapped in objc:selector objects in the future.") (p "CHARPTR (char *) types are converted to Scheme strings, but conversion to CHARPTR is disabled.") (p "NSRect, NSPoint, NSSize and NSRange structures can be sent to and received from Objective C.  Each is represented by a record on the Scheme side.") (def (sig (record "ns:rect" (id ns:rect))) (p (tt "ns:make-rect") " is provided as an alias for the default constructor " (tt "make-ns:rect") ".  The same is true for the other records.") (table (@ (class "symbol-table")) (tr (td "x") (td "X coordinate of origin (NSRect.origin.x)")) "\n" (tr (td "y") (td "Y coordinate of origin (NSRect.origin.y)")) "\n" (tr (td "width") (td "Width of rectangle (NSRect.size.width)")) "\n" (tr (td "height") (td "Height of rectangle (NSRect.size.height)")))) (def (sig (record "ns:size" (id ns:size))) (table (@ (class "symbol-table")) (tr (td "width") (td "Width")) "\n" (tr (td "height") (td "Height")))) (def (sig (record "ns:point" (id ns:point))) (table (@ (class "symbol-table")) (tr (td "x") (td "X coordinate")) "\n" (tr (td "y") (td "Y coordinate")))) (def (sig (record "ns:range" (id ns:range))) (table (@ (class "symbol-table")) (tr (td "location") (td "Start index, 0-based")) "\n" (tr (td "length") (td "Length of range"))) (p "Other than the four exceptions above, struct, union, and array types cannot be sent to or received from Objective C."))) (section 3 "Memory management" (p "The bridge strives to handle memory management automatically.  In general terms, this is accomplished by implicitly retaining an instance object when it is passed into Scheme, and releasing it when the objc:instance is finalized.  The bridge knows that certain selectors, such as alloc and copy, by convention donate a retain reference to you, and adjusts its retain count accordingly.  Furthermore, passing an objc:instance into Objective C retains and autoreleases that object, which is necessary to ensure that short-lived objects (such as automatically created strings) remain valid until the end of a method invocation.  (Each invocation is wrapped in an autorelease pool, hence the autorelease.)") (p "In general, this means you don't have to worry about releasing, autoreleasing or retaining objects.  The expression " (tt "(let ((m [@ MyPoint alloc])) (void))") ", for example, incurs no memory penalty as " (tt "m") " is garbage collected like any other Scheme object.  This principle extends to NSStrings that are created by the bridge when converted from Scheme strings.  Additionally, you may return newly allocated objects from Scheme classes without autoreleasing them.") (p "Instance variables which hold Objective C objects---" (b "id") " types---are also managed automatically.  Those defined in a Scheme class are properly retained when using " (tt "objc:ivar-set!") ", and properly released in " (tt "dealloc") ".  You should use the " (tt "#:outlet") " type qualifier for Interface Builder outlets, which will turn off automatic management as IB expects.  Ivars defined in a pure Objective C class are never retained or released automatically, as these classes expect to manage memory themselves.  If you must access such a variable directly, you must manually send it retain and release messages (editor's note: the API for such is not exposed right now).") (p "There are some limitations.  Overriding memory-management selectors such as alloc, release, and dealloc is not supported (although alloc does appear to work fine, caveat emptor).  Sending an autorelease message has no effect due to the current implementation of method invocation.  Finally, although the author has tried to ensure automatic memory management works as advertised, certain cases (especially involving calls from Objective C to Scheme) have not been tested and may be problematic at this point.")) (section 3 "Class proxies" (p "In order to implement ivar memory management and transparent access to Scheme objects stored in ivars, the bridge needs to maintain metadata for each class defined in Scheme.  Enter the class proxy, a unique " (tt "objc:class") " record for each class.  Whenever a class pointer is passed into Scheme, this corresponding proxy is looked up and returned.  This means that Scheme can store information about classes beyond that available in the Objective C runtime.") (p "For pure Objective C classes, this proxy is generic, and springs into being dynamically the first time the class is referenced.  It doesn't contain any extra data; it simply notes the class is pure Objective C.") (p "For classes defined in Scheme, the proxy is created at class definition time, and contains (amongst other things) extended instance variable data, including type qualifiers such as slot: and outlet:.  " (tt "objc:ivar-set!") " will look up the object's class, find the appropriate ivar and notice any type qualifier.  Class proxies also keep track of which classes have Scheme implementations, used for minimizing safe callbacks.") (p "Instance proxies per se are not (yet) implemented.  Although objects are wrapped in objc:instance records, each is merely a non-unique wrapper around a pointer and contains no extra data.  Of course, since instance variables can hold Scheme objects, you can store as many \"proxy\" objects as you like inside any instance.  On the other hand, you have to manually access this data via ivar-ref or by sending the Objective C object a message, which can be cumbersome.  In practice, it may be useful to do this transparently, having an interchangeable proxy Scheme object and Objective C instance.  This is an active area of research.")) (section 3 "Lowlevel" (def (sig (procedure "(objc:register-class CLASSNAME SUPERCLASS)" (id objc:register-class))) (p "Registers CLASSNAME (a string) having superclass SUPERCLASS (an objc:class) with the Objective C runtime.  An error is raised if CLASSNAME already exists.")) (def (sig (procedure "(objc:set-ivars! CLASS IVARS)" (id objc:set-ivars!))) (p "Defines in CLASS (an objc:class) the instance variables in IVARS (a list of objc:instance-var records).  The offset parameter of the instance variable records is ignored.") (p "Warning: all old instance variables in MyClass will be removed first. Also, we don't check for conflicts with superclass instance variables.  This should be remedied in a future release.") (pre "Example: \n(objc:set-ivars! MyClass (list (make-objc:raw-ivar \"jimmy\" objc:INT 0) \n                               (make-objc:raw-ivar \"cammy\" objc:DBL 0)")) (def (sig (procedure "(objc:add-method CLASS METHOD TYPES PROC)" (id objc:add-method)) (procedure "(objc:add-class-method CLASS METHOD TYPES PROC)" (id objc:add-class-method))) (p "Adds a class or instance method to CLASS.") (table (@ (class "symbol-table")) (tr (td "METHOD") (td "Method name as a string (e.g. " (tt "\"setWidth:height:\"") ")")) "\n" (tr (td "TYPES") (td "List of encoded argument type strings (such as " (tt "objc:INT") " or \"@\").")) "\n" (tr (td "PROC") (td "Scheme procedure representing the method."))) (p "The structure of the TYPES list is " (tt "(RETURN-TYPE SELF SELECTOR METHOD-ARGS...)") ".") (p "You may add Scheme methods to pure Objective C classes; when class proxies are enabled, this will automatically taint the class so that safe calls are used.  Currently, a warning is printed when a class is tainted.") (pre "Transformation: \n(objc:define-method MyClass DBL ((sel1: INT i) (sel2: DBL d)) \n                                (print i) (+ i d)) \n=> \n(objc:add-method MyClass \"sel1:sel2:\"\n                 (list objc:DBL objc:ID objc:SEL objc:INT objc:DBL) \n                 (lambda (self sel i d) (print i) (+ i d))) \n")) (def (sig (procedure "(objc:wrap X)" (id objc:wrap)) (procedure "(objc:unwrap X)" (id objc:unwrap))) (p "Wrap or unwrap the Scheme object X inside an Objective C instance (specifically, a " (tt "Scheme_Object_Wrapper") ") so that it can be passed as an " (tt "id") " type.  Essentially, these functions allow you to tunnel a Scheme object through the Objective C bridge, when both endpoints are written in Scheme.  At the moment, the resulting object cannot be accessed meaningfully from the Objective C side.") (p "These functions are also used to implement the " (tt "#:wrapper") " type qualifier for instance variables.")) (def (sig (record "objc:raw-ivar" (id objc:raw-ivar))) (p "A record describing an Objective C instance variable as seen from the Objective C (as opposed to Scheme) side.  Returned by " (tt "objc:class-ivar-list") ", and used by " (tt "objc:set-ivars!") ".") (table (@ (class "symbol-table")) (tr (td "name") (td "Name as a string.")) "\n" (tr (td "type") (td "Type as an encoded type string.")) "\n" (tr (td "offset") (td "Offset within class -- for debugging only.")))) (def (sig (record "objc:ivar" (id objc:ivar))) (p "A record describing Scheme's view of an Objective C instance variable.  At the moment, fields include those of " (tt "objc:raw-ivar") " with the following addition:") (table (@ (class "symbol-table")) (tr (td "function") (td "Keyword #:slot, #:wrapper, #:outlet, or #:ivar.")))) (def (sig (procedure "(with-autorelease-pool THUNK)" (id with-autorelease-pool))) (p "Creates an autorelease pool that lasts for the duration of the thunk.") (p "A global autorelease pool is created automatically at startup, one is wrapped around the main Application Kit event loop, one is wrapped around every call to Objective C, and memory management is generally otherwise automatic.  It is considered unlikely you will have to use this, unless you send Objective C messages directly inside a foreign-lambda.")) (def (sig (procedure "(objc:import-classes-at-toplevel!)" (id objc:import-classes-at-toplevel!))) (p "Import every class visible to the runtime, as if define-objc-classes had been run on all available classes.  Useful for debugging.  Note that some (rare) classes are not derived from NSObject, and will not respond to standard NSObject selectors, may throw exceptions, or may crash if used.")) (def (sig (procedure "(objc:get-class-list)" (id objc:get-class-list))) (p "Looks up and returns a list of all available classes.  At startup, the result of this call is stored in the variable " (tt "objc:classes") ".")))) (section 2 "Cocoa" (p (tt "(require-extension cocoa)")) (p "It is possible to create Cocoa applications using this extension.  See " (link "http://3e8.org/zb/cocoa/creating-a-cocoa-app.html" "Creating a Cocoa Application in Chicken") " for a document which walks you through implementing Apple's famous Currency Converter application.") (p "Also, a working application is included in this egg.  Untar the egg, change to the " (tt "tests/") " directory, and type " (tt "make") ".  An application called Temperature Converter will be built.") (p "Some " (link "http://developer.apple.com/documentation/Cocoa/Reference/ApplicationKit/ObjC_classic/Functions/AppKitFunctions.html" "global Application Kit functions") ", such as NSRectFill, take structures which are passed by value.  However, the Chicken FFI only supports passing structs by pointers.  A workaround is provided in the egg; if you need to wrap such a function, see " (tt "ns:rect-fill") " in " (tt "cocoa.scm") " for an example.") (def (sig (procedure "(ns:application-main)" (id ns:application-main))) (p "Starts the main event loop of a Cocoa-based application.  If any arguments are present on the command line, they will be passed to NSApplicationMain.")) (def (sig (procedure "(ns:beep)" (id ns:beep))) (p "Plays the default system sound using NSBeep.")) (def (sig (procedure "(ns:log FORMAT-STR ARGS...)" (id ns:log))) (p "Logs a message using NSLog.  The optional " (tt "ARGS") " are interpolated into " (tt "FORMAT-STR") " as in " (tt "printf") ".")) (def (sig (procedure "(ns:rect-fill RECT)" (id ns:rect-fill))) (p "Fills the passed RECT (an " (tt "ns:rect") ") with the current color, using NSRectFill.")) (def (sig (procedure "(cocoa:run)" (id cocoa:run))) (p "Send the run message to the global NSApplication object.  This is intended to be used during debugging, to restart the main application event loop after an error has returned you to the REPL."))) (section 2 "About this egg" (section 3 "Requirements" (p (b "Mac OS X Intel or PPC") ".  This egg does not run on GNUStep.") (p (b "libffi") ".  Chicken itself need not be compiled with libffi support; libffi just needs to be installed on your system.  Install one of these:") (ul (li "On 10.5, libffi should already be installed.  The egg will try to use the system copy.") (li (link "http://3e8.org/pub/libffi-20071207.tgz" "libffi-20071207") ": Preferred build, from a recent " (link "http://3e8.org/pub/libffi-20071207-build.txt" "SVN snapshot") ".") (li (link "http://www.call-with-current-continuation.org/tarballs/libffi-3.tgz" "libffi-3 (Felix's build)") ".  Tried and true, but may not work on Leopard.") (li (link "http://sourceware.org/libffi" "libffi 2.1") ": last public release of libffi, several years old.  Probably unusable."))) (section 3 "Author" (p (link "http://3e8.org/zb" "Jim Ursetto") ", " (int-link "mailto:felix@call-with-current-continuation.org" "Felix Winkelmann"))) (section 3 "Version history" (dl (dt "0.5.0") (dd "Port to Chicken 4, with assistance from Alex Shinn.") (dt "0.4.3") (dd "Callback-safe context for " (tt "release") "; " (tt "add-method") " taints pure ObjC classes.  Verify egg on x86.") (dt "0.4") (dd "Class proxies, ivar refcounting, ivar Scheme objects, objc:wrap/unwrap, (@ ...) syntax, hyphenated selectors, callback optimization. " (link "http://3e8.org/zb/eggs/objc-04-changes.txt" "Detailed changelog.")) (dt "0.3") (dd "Enable struct support; change to ns: prefix.") (dt "0.2") (dd "Add objc:class-of and rename extension") (dt "0.1") (dd "Initial release"))) (section 3 "License" (pre "Copyright (c) 2005, 2006, 2007, 2008, 2009, 2010 Jim Ursetto.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  Redistributions of source code must retain the above copyright notice,\n  this list of conditions and the following disclaimer. Redistributions in\n  binary form must reproduce the above copyright notice, this list of\n  conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution. Neither the name of the\n  author nor the names of its contributors may be used to endorse or\n  promote products derived from this software without specific prior\n  written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\nEXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."))))