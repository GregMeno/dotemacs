((tags "manual") (section 2 "Unit srfi-14" (p "Character set library.  An abbreviated version of the SRFI is provided in this document.  Full documentation is available in the " (link "http://srfi.schemers.org/srfi-14/srfi-14.html" "original SRFI-14 document") ".") (p "On systems that support dynamic loading, the " (tt "srfi-14") " unit can be made available in the interpreter (" (tt "csi") ") by entering") (highlight scheme "(require-extension srfi-14)") (p "This library provides only the Latin-1 character set.  To get Unicode semantics, see the " (int-link "/egg/utf8" "utf8") " egg.  However, information on Unicode character sets is still provided in this document.")) (section 2 "Specification" (p "In the following procedure specifications:") (ul (li "A CS parameter is a character set. ") (li "An S parameter is a string. ") (li "A CHAR parameter is a character. ") (li "A CHAR-LIST parameter is a list of characters. ") (li "A PRED parameter is a unary character predicate procedure, returning a true/false value when applied to a character. ") (li "An OBJ parameter may be any value at all. ")) (p "Passing values to procedures with these parameters that do not satisfy these types is an error.") (p "Unless otherwise noted in the specification of a procedure, procedures always return character sets that are distinct (from the point of view of the linear-update operations) from the parameter character sets. For example, " (tt "char-set-adjoin") " is guaranteed to provide a fresh character set, even if it is not given any character parameters.") (p "Parameters given in square brackets are optional. Unless otherwise noted in the text describing the procedure, any prefix of these optional parameters may be supplied, from zero arguments to the full list. When a procedure returns multiple values, this is shown by listing the return values in square brackets, as well. So, for example, the procedure with signature") (pre "halts? F [X INIT-STORE] -> [BOOLEAN INTEGER]") (p "would take one (F), two (F, X) or three (F, X, INIT-STORE) input parameters, and return two values, a boolean and an integer.") (p "A parameter followed by \"" (tt "...") "\" means zero-or-more elements. So the procedure with the signature") (pre "sum-squares X ...  -> NUMBER") (p "takes zero or more arguments (X ...), while the procedure with signature") (pre "spell-check DOC DICT_1 DICT_2 ... -> STRING-LIST") (p "takes two required parameters (DOC and DICT_1) and zero or more optional parameters (DICT_2 ...).") (section 3 "General procedures" (def (sig (procedure "(char-set? obj) -> boolean" (id char-set?))) (p "Is the object OBJ a character set?")) (def (sig (procedure "(char-set= cs_1 ...) -> boolean" (id char-set=))) (p "Are the character sets equal?") (p "Boundary cases:") (pre "(char-set=) => TRUE\n(char-set= cs) => TRUE") (p "Rationale: transitive binary relations are generally extended to n-ary relations in Scheme, which enables clearer, more concise code to be written. While the zero-argument and one-argument cases will almost certainly not arise in first-order uses of such relations, they may well arise in higher-order cases or macro-generated code. " (i "E.g.,") " consider") (pre "(apply char-set= cset-list)") (p "This is well-defined if the list is empty or a singleton list. Hence we extend these relations to any number of arguments. Implementors have reported actual uses of n-ary relations in higher-order cases allowing for fewer than two arguments. The way of Scheme is to handle the general case; we provide the fully general extension.") (p "A counter-argument to this extension is that R5RS's transitive binary arithmetic relations (" (tt "=") ", " (tt "<") ", " (i "etc.") ") require at least two arguments, hence this decision is a break with the prior convention -- although it is at least one that is backwards-compatible.")) (def (sig (procedure "(char-set<= cs_1 ...) -> boolean" (id char-set<=))) (p "Returns true if every character set CS_I is a subset of character set CS_I+1.") (p "Boundary cases:") (pre "(char-set<=) => TRUE\n(char-set<= cs) => TRUE") (p "Rationale: See " (tt "char-set=") " for discussion of zero- and one-argument applications. Consider testing a list of char-sets for monotonicity with") (pre "(apply char-set<= cset-list)")) (def (sig (procedure "(char-set-hash cs [bound]) -> integer" (id char-set-hash))) (p "Compute a hash value for the character set CS. BOUND is a non-negative exact integer specifying the range of the hash function. A positive value restricts the return value to the range [0,BOUND).") (p "If BOUND is either zero or not given, the implementation may use an implementation-specific default value, chosen to be as large as is efficiently practical. For instance, the default range might be chosen for a given implementation to map all strings into the range of integers that can be represented with a single machine word.") (p "Invariant:") (pre "(char-set= cs_1 cs_2) => (= (char-set-hash cs_1 b) (char-set-hash cs_2 b))") (p "A legal but nonetheless discouraged implementation:") (pre "(define (char-set-hash cs . maybe-bound) 1)") (p "Rationale: allowing the user to specify an explicit bound simplifies user code by removing the mod operation that typically accompanies every hash computation, and also may allow the implementation of the hash function to exploit a reduced range to efficiently compute the hash value. " (i "E.g.") ", for small bounds, the hash function may be computed in a fashion such that intermediate values never overflow into bignum integers, allowing the implementor to provide a fixnum-specific \"fast path\" for computing the common cases very rapidly."))) (section 3 "Iterating over character sets" (def (sig (procedure "(char-set-cursor cset) -> cursor" (id char-set-cursor)) (procedure "(char-set-ref cset cursor) -> char" (id char-set-ref)) (procedure "(char-set-cursor-next cset cursor) -> cursor" (id char-set-cursor-next)) (procedure "(end-of-char-set? cursor) -> boolean" (id end-of-char-set?))) (p "Cursors are a low-level facility for iterating over the characters in a set. A cursor is a value that indexes a character in a char set. " (tt "char-set-cursor") " produces a new cursor for a given char set. The set element indexed by the cursor is fetched with " (tt "char-set-ref") ". A cursor index is incremented with " (tt "char-set-cursor-next") "; in this way, code can step through every character in a char set. Stepping a cursor \"past the end\" of a char set produces a cursor that answers true to " (tt "end-of-char-set?") ". It is an error to pass such a cursor to " (tt "char-set-ref") " or to " (tt "char-set-cursor-next") ".") (p "A cursor value may not be used in conjunction with a different character set; if it is passed to " (tt "char-set-ref") " or " (tt "char-set-cursor-next") " with a character set other than the one used to create it, the results and effects are undefined.") (p "Cursor values are " (i "not") " necessarily distinct from other types. They may be integers, linked lists, records, procedures or other values. This license is granted to allow cursors to be very \"lightweight\" values suitable for tight iteration, even in fairly simple implementations.") (p "Note that these primitives are necessary to export an iteration facility for char sets to loop macros.") (p "Example:") (pre "(define cs (char-set #\\G #\\a #\\T #\\e #\\c #\\h))\n \n;; Collect elts of CS into a list.\n(let lp ((cur (char-set-cursor cs)) (ans '()))\n  (if (end-of-char-set? cur) ans\n      (lp (char-set-cursor-next cs cur)\n          (cons (char-set-ref cs cur) ans))))\n  => (#\\G #\\T #\\a #\\c #\\e #\\h)\n \n;; Equivalently, using a list unfold (from SRFI 1):\n(unfold-right end-of-char-set? \n              (curry char-set-ref cs)\n\t      (curry char-set-cursor-next cs)\n\t      (char-set-cursor cs))\n  => (#\\G #\\T #\\a #\\c #\\e #\\h)") (p "Rationale: Note that the cursor API's four functions \"fit\" the functional protocol used by the unfolders provided by the list, string and char-set SRFIs (see the example above). By way of contrast, here is a simpler, two-function API that was rejected for failing this criterion. Besides " (tt "char-set-cursor") ", it provided a single function that mapped a cursor and a character set to two values, the indexed character and the next cursor. If the cursor had exhausted the character set, then this function returned false instead of the character value, and another end-of-char-set cursor. In this way, the other three functions of the current API were combined together.")) (def (sig (procedure "(char-set-fold kons knil cs) -> object" (id char-set-fold))) (p "This is the fundamental iterator for character sets. Applies the function KONS across the character set CS using initial state value KNIL. That is, if CS is the empty set, the procedure returns KNIL. Otherwise, some element C of CS is chosen; let CS' be the remaining, unchosen characters. The procedure returns") (pre "(char-set-fold KONS (KONS C KNIL) CS')") (p "Examples:") (pre ";; CHAR-SET-MEMBERS\n(lambda (cs) (char-set-fold cons '() cs))\n \n;; CHAR-SET-SIZE\n(lambda (cs) (char-set-fold (lambda (c i) (+ i 1)) 0 cs))\n \n;; How many vowels in the char set?\n(lambda (cs) \n  (char-set-fold (lambda (c i) (if (vowel? c) (+ i 1) i))\n                 0 cs))")) (def (sig (procedure "(char-set-unfold f p g seed [base-cs]) -> char-set" (id char-set-unfold)) (procedure "(char-set-unfold! f p g seed base-cs) -> char-set" (id char-set-unfold!))) (p "This is a fundamental constructor for char-sets.") (ul (li "G is used to generate a series of \"seed\" values from the initial seed: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ... ") (li "P tells us when to stop -- when it returns true when applied to one of these seed values. ") (li "F maps each seed value to a character. These characters are added to the base character set BASE-CS to form the result; BASE-CS defaults to the empty set. " (tt "char-set-unfold!") " adds the characters to BASE-CS in a linear-update -- it is allowed, but not required, to side-effect and use BASE-CS's storage to construct the result. ")) (p "More precisely, the following definitions hold, ignoring the optional-argument issues:") (pre "(define (char-set-unfold p f g seed base-cs) \n  (char-set-unfold! p f g seed (char-set-copy base-cs)))\n \n(define (char-set-unfold! p f g seed base-cs)\n  (let lp ((seed seed) (cs base-cs))\n        (if (p seed) cs                                 ; P says we are done.\n            (lp (g seed)                                ; Loop on (G SEED).\n                (char-set-adjoin! cs (f seed))))))      ; Add (F SEED) to set.") (p "(Note that the actual implementation may be more efficient.)") (p "Examples:") (pre "(port->char-set p) = (char-set-unfold eof-object? values\n                                      (lambda (x) (read-char p))\n                                      (read-char p))\n \n(list->char-set lis) = (char-set-unfold null? car cdr lis)")) (def (sig (procedure "(char-set-for-each proc cs) -> unspecified" (id char-set-for-each))) (p "Apply procedure PROC to each character in the character set CS. Note that the order in which PROC is applied to the characters in the set is not specified, and may even change from one procedure application to another.") (p "Nothing at all is specified about the value returned by this procedure; it is not even required to be consistent from call to call. It is simply required to be a value (or values) that may be passed to a command continuation, " (i "e.g.") " as the value of an expression appearing as a non-terminal subform of a " (tt "begin") " expression. Note that in R5RS, this restricts the procedure to returning a single value; non-R5RS systems may not even provide this restriction.")) (def (sig (procedure "(char-set-map proc cs) -> char-set" (id char-set-map))) (p "PROC is a char->char procedure. Apply it to all the characters in the char-set CS, and collect the results into a new character set.") (p "Essentially lifts PROC from a char->char procedure to a char-set -> char-set procedure.") (p "Example:") (pre "(char-set-map char-downcase cset)"))) (section 3 "Creating character sets" (def (sig (procedure "(char-set-copy cs) -> char-set" (id char-set-copy))) (p "Returns a copy of the character set CS. \"Copy\" means that if either the input parameter or the result value of this procedure is passed to one of the linear-update procedures described below, the other character set is guaranteed not to be altered.") (p "A system that provides pure-functional implementations of the linear-operator suite could implement this procedure as the identity function -- so copies are " (i "not") " guaranteed to be distinct by " (tt "eq?") ".")) (def (sig (procedure "(char-set char_1 ...) -> char-set" (id char-set))) (p "Return a character set containing the given characters.")) (def (sig (procedure "(list->char-set char-list [base-cs]) -> char-set" (id list->char-set)) (procedure "(list->char-set! char-list base-cs) -> char-set" (id list->char-set!))) (p "Return a character set containing the characters in the list of characters CHAR-LIST.") (p "If character set BASE-CS is provided, the characters from CHAR-LIST are added to it. " (tt "list->char-set!") " is allowed, but not required, to side-effect and reuse the storage in BASE-CS; " (tt "list->char-set") " produces a fresh character set.")) (def (sig (procedure "(string->char-set s [base-cs]) -> char-set" (id string->char-set)) (procedure "(string->char-set! s base-cs) -> char-set" (id string->char-set!))) (p "Return a character set containing the characters in the string S.") (p "If character set BASE-CS is provided, the characters from S are added to it. " (tt "string->char-set!") " is allowed, but not required, to side-effect and reuse the storage in BASE-CS; " (tt "string->char-set") " produces a fresh character set.")) (def (sig (procedure "(char-set-filter pred cs [base-cs]) -> char-set" (id char-set-filter)) (procedure "(char-set-filter! pred cs base-cs) -> char-set" (id char-set-filter!))) (p "Returns a character set containing every character C in CS such that " (tt "(PRED C)") " returns true.") (p "If character set BASE-CS is provided, the characters specified by PRED are added to it. " (tt "char-set-filter!") " is allowed, but not required, to side-effect and reuse the storage in BASE-CS; " (tt "char-set-filter") " produces a fresh character set.") (p "An implementation may not save away a reference to PRED and invoke it after " (tt "char-set-filter") " or " (tt "char-set-filter!") " returns -- that is, \"lazy,\" on-demand implementations are not allowed, as PRED may have external dependencies on mutable data or have other side-effects.") (p "Rationale: This procedure provides a means of converting a character predicate into its equivalent character set; the CS parameter allows the programmer to bound the predicate's domain. Programmers should be aware that filtering a character set such as " (tt "char-set:full") " could be a very expensive operation in an implementation that provided an extremely large character type, such as 32-bit Unicode. An earlier draft of this library provided a simple " (tt "predicate->char-set") " procedure, which was rejected in favor of " (tt "char-set-filter") " for this reason.")) (def (sig (procedure "(ucs-range->char-set lower upper [error? base-cs]) -> char-set" (id ucs-range->char-set)) (procedure "(ucs-range->char-set! lower upper error? base-cs) -> char-set" (id ucs-range->char-set!))) (p "LOWER and UPPER are exact non-negative integers; LOWER <= UPPER.") (p "Returns a character set containing every character whose ISO/IEC 10646 UCS-4 code lies in the half-open range [LOWER,UPPER).") (ul (li "If the requested range includes unassigned UCS values, these are silently ignored (the current UCS specification has \"holes\" in the space of assigned codes). ") (li "If the requested range includes \"private\" or \"user space\" codes, these are handled in an implementation-specific manner; however, a UCS- or Unicode-based Scheme implementation should pass them through transparently. ") (li "If any code from the requested range specifies a valid, assigned UCS character that has no corresponding representative in the implementation's character type, then (1) an error is raised if ERROR? is true, and (2) the code is ignored if ERROR? is false (the default). This might happen, for example, if the implementation uses ASCII characters, and the requested range includes non-ASCII characters. ")) (p "If character set BASE-CS is provided, the characters specified by the range are added to it. " (tt "ucs-range->char-set!") " is allowed, but not required, to side-effect and reuse the storage in BASE-CS; " (tt "ucs-range->char-set") " produces a fresh character set.") (p "Note that ASCII codes are a subset of the Latin-1 codes, which are in turn a subset of the 16-bit Unicode codes, which are themselves a subset of the 32-bit UCS-4 codes. We commit to a specific encoding in this routine, regardless of the underlying representation of characters, so that client code using this library will be portable. " (i "I.e.") ", a conformant Scheme implementation may use EBCDIC or SHIFT-JIS to encode characters; it must simply map the UCS characters from the given range into the native representation when possible, and report errors when not possible.")) (def (sig (procedure "(->char-set x) -> char-set" (id ->char-set))) (p "Coerces X into a char-set. X may be a string, character or char-set. A string is converted to the set of its constituent characters; a character is converted to a singleton set; a char-set is returned as-is. This procedure is intended for use by other procedures that want to provide \"user-friendly,\" wide-spectrum interfaces to their clients."))) (section 3 "Querying character sets" (def (sig (procedure "(char-set-size cs) -> integer" (id char-set-size))) (p "Returns the number of elements in character set CS.")) (def (sig (procedure "(char-set-count pred cs) -> integer" (id char-set-count))) (p "Apply PRED to the chars of character set CS, and return the number of chars that caused the predicate to return true.")) (def (sig (procedure "(char-set->list cs) -> character-list" (id char-set->list))) (p "This procedure returns a list of the members of character set CS. The order in which CS's characters appear in the list is not defined, and may be different from one call to another.")) (def (sig (procedure "(char-set->string cs) -> string" (id char-set->string))) (p "This procedure returns a string containing the members of character set CS. The order in which CS's characters appear in the string is not defined, and may be different from one call to another.")) (def (sig (procedure "(char-set-contains? cs char) -> boolean" (id char-set-contains?))) (p "This procedure tests CHAR for membership in character set CS.") (p "The MIT Scheme character-set package called this procedure CHAR-SET-MEMBER?, but the argument order isn't consistent with the name.")) (def (sig (procedure "(char-set-every pred cs) -> boolean" (id char-set-every)) (procedure "(char-set-any pred cs) -> boolean" (id char-set-any))) (p "The " (tt "char-set-every") " procedure returns true if predicate PRED returns true of every character in the character set CS. Likewise, " (tt "char-set-any") " applies PRED to every character in character set CS, and returns the first true value it finds. If no character produces a true value, it returns false. The order in which these procedures sequence through the elements of CS is not specified.") (p "Note that if you need to determine the actual character on which a predicate returns true, use " (tt "char-set-any") " and arrange for the predicate to return the character parameter as its true value, " (i "e.g.")) (pre "(char-set-any (lambda (c) (and (char-upper-case? c) c)) \n              cs)"))) (section 3 "Character-set algebra" (def (sig (procedure "(char-set-adjoin cs char_1 ...) -> char-set" (id char-set-adjoin)) (procedure "(char-set-delete cs char_1 ...) -> char-set" (id char-set-delete))) (p "Add/delete the CHAR_I characters to/from character set CS.")) (def (sig (procedure "(char-set-adjoin! cs char_1 ...) -> char-set" (id char-set-adjoin!)) (procedure "(char-set-delete! cs char_1 ...) -> char-set" (id char-set-delete!))) (p "Linear-update variants. These procedures are allowed, but not required, to side-effect their first parameter.")) (def (sig (procedure "(char-set-complement cs) -> char-set" (id char-set-complement)) (procedure "(char-set-union cs_1 ...) -> char-set" (id char-set-union)) (procedure "(char-set-intersection cs_1 ...) -> char-set" (id char-set-intersection)) (procedure "(char-set-difference cs_1 cs_2 ...) -> char-set" (id char-set-difference)) (procedure "(char-set-xor cs_1 ...) -> char-set" (id char-set-xor)) (procedure "(char-set-diff+intersection cs_1 cs_2 ...) -> [char-set char-set]" (id char-set-diff+intersection))) (p "These procedures implement set complement, union, intersection, difference, and exclusive-or for character sets. The union, intersection and xor operations are n-ary. The difference function is also n-ary, associates to the left (that is, it computes the difference between its first argument and the union of all the other arguments), and requires at least one argument.") (p "Boundary cases:") (pre "(char-set-union) => char-set:empty\n(char-set-intersection) => char-set:full\n(char-set-xor) => char-set:empty\n(char-set-difference CS) => CS") (p (tt "char-set-diff+intersection") " returns both the difference and the intersection of the arguments -- it partitions its first parameter. It is equivalent to") (pre "(values (char-set-difference CS_1 CS_2 ...)\n        (char-set-intersection CS_1 (char-set-union CS_2 ...)))") (p "but can be implemented more efficiently.") (p "Programmers should be aware that " (tt "char-set-complement") " could potentially be a very expensive operation in Scheme implementations that provide a very large character type, such as 32-bit Unicode. If this is a possibility, sets can be complimented with respect to a smaller universe using " (tt "char-set-difference") ".")) (def (sig (procedure "(char-set-complement! cs) -> char-set" (id char-set-complement!)) (procedure "(char-set-union! cs_1 cs_2 ...) -> char-set" (id char-set-union!)) (procedure "(char-set-intersection! cs_1 cs_2 ...) -> char-set" (id char-set-intersection!)) (procedure "(char-set-difference! cs_1 cs_2 ...) -> char-set" (id char-set-difference!)) (procedure "(char-set-xor! cs_1 cs_2 ...) -> char-set" (id char-set-xor!)) (procedure "(char-set-diff+intersection! cs_1 cs_2 cs_3 ...) -> [char-set char-set]" (id char-set-diff+intersection!))) (p "These are linear-update variants of the set-algebra functions. They are allowed, but not required, to side-effect their first (required) parameter.") (p (tt "char-set-diff+intersection!") " is allowed to side-effect both of its two required parameters, CS_1 and CS_2.")))) (section 2 "Standard character sets" (p "Several character sets are predefined for convenience:") (table (tr (td (tt "char-set:lower-case")) (td "Lower-case letters")) "\n" (tr (td (tt "char-set:upper-case")) (td "Upper-case letters")) "\n" (tr (td (tt "char-set:title-case")) (td "Title-case letters")) "\n" (tr (td (tt "char-set:letter")) (td "Letters")) "\n" (tr (td (tt "char-set:digit")) (td "Digits")) "\n" (tr (td (tt "char-set:letter+digit")) (td "Letters and digits")) "\n" (tr (td (tt "char-set:graphic")) (td "Printing characters except spaces")) "\n" (tr (td (tt "char-set:printing")) (td "Printing characters including spaces")) "\n" (tr (td (tt "char-set:whitespace")) (td "Whitespace characters")) "\n" (tr (td (tt "char-set:iso-control")) (td "The ISO control characters")) "\n" (tr (td (tt "char-set:punctuation")) (td "Punctuation characters")) "\n" (tr (td (tt "char-set:symbol")) (td "Symbol characters")) "\n" (tr (td (tt "char-set:hex-digit")) (td "A hexadecimal digit: 0-9, A-F, a-f")) "\n" (tr (td (tt "char-set:blank")) (td "Blank characters -- horizontal whitespace")) "\n" (tr (td (tt "char-set:ascii")) (td "All characters in the ASCII set.")) "\n" (tr (td (tt "char-set:empty")) (td "Empty set")) "\n" (tr (td (tt "char-set:full")) (td "All characters"))) (p "In Unicode Scheme implementations, the base character sets are compatible with Java's Unicode specifications. For ASCII or Latin-1, we simply restrict the Unicode set specifications to their first 128 or 256 codes, respectively.") (p "Here are the definitions for some of the sets in an ASCII implementation:") (table (tr (td (tt "char-set:lower-case")) (td "a-z")) "\n" (tr (td (tt "char-set:upper-case")) (td "A-Z")) "\n" (tr (td (tt "char-set:letter")) (td "A-Z and a-z")) "\n" (tr (td (tt "char-set:digit")) (td "0123456789")) "\n" (tr (td (tt "char-set:punctuation")) (td (tt "!\"#%&'()*,-./:;?@[\\]_{") "}")) "\n" (tr (td (tt "char-set:symbol")) (td (tt "$+<=>^`|~"))) "\n" (tr (td (tt "char-set:whitespace")) (td "Space, newline, tab, form feed, vertical tab, carriage return")) "\n" (tr (td (tt "char-set:blank")) (td "Space and tab")) "\n" (tr (td (tt "char-set:graphic")) (td "letter + digit + punctuation + symbol")) "\n" (tr (td (tt "char-set:printing")) (td "graphic + whitespace")) "\n" (tr (td (tt "char-set:iso-control")) (td "ASCII 0-31 and 127"))) (section 3 "Character set constants" (def (sig (constant "char-set:lower-case" (id char-set:lower-case))) (p "For Unicode, a character is lowercase if") (ul (li "it is not in the range [U+2000,U+2FFF], and ") (li "the Unicode attribute table does not give a lowercase mapping for it, and ") (li "at least one of the following is true: " (ul (li "the Unicode attribute table gives a mapping to uppercase for the character, or ") (li "the name for the character in the Unicode attribute table contains the words \"SMALL LETTER\" or \"SMALL LIGATURE\". ")))) (p "The lower-case ASCII characters are") (p "abcdefghijklmnopqrstuvwxyz") (p "Latin-1 adds another 33 lower-case characters to the ASCII set:") (table (tr (td "00B5") (td "MICRO SIGN")) "\n" (tr (td "00DF") (td "LATIN SMALL LETTER SHARP S")) "\n" (tr (td "00E0") (td "LATIN SMALL LETTER A WITH GRAVE")) "\n" (tr (td "00E1") (td "LATIN SMALL LETTER A WITH ACUTE")) "\n" (tr (td "00E2") (td "LATIN SMALL LETTER A WITH CIRCUMFLEX")) "\n" (tr (td "00E3") (td "LATIN SMALL LETTER A WITH TILDE")) "\n" (tr (td "00E4") (td "LATIN SMALL LETTER A WITH DIAERESIS")) "\n" (tr (td "00E5") (td "LATIN SMALL LETTER A WITH RING ABOVE")) "\n" (tr (td "00E6") (td "LATIN SMALL LETTER AE")) "\n" (tr (td "00E7") (td "LATIN SMALL LETTER C WITH CEDILLA")) "\n" (tr (td "00E8") (td "LATIN SMALL LETTER E WITH GRAVE")) "\n" (tr (td "00E9") (td "LATIN SMALL LETTER E WITH ACUTE")) "\n" (tr (td "00EA") (td "LATIN SMALL LETTER E WITH CIRCUMFLEX")) "\n" (tr (td "00EB") (td "LATIN SMALL LETTER E WITH DIAERESIS")) "\n" (tr (td "00EC") (td "LATIN SMALL LETTER I WITH GRAVE")) "\n" (tr (td "00ED") (td "LATIN SMALL LETTER I WITH ACUTE")) "\n" (tr (td "00EE") (td "LATIN SMALL LETTER I WITH CIRCUMFLEX")) "\n" (tr (td "00EF") (td "LATIN SMALL LETTER I WITH DIAERESIS")) "\n" (tr (td "00F0") (td "LATIN SMALL LETTER ETH")) "\n" (tr (td "00F1") (td "LATIN SMALL LETTER N WITH TILDE")) "\n" (tr (td "00F2") (td "LATIN SMALL LETTER O WITH GRAVE")) "\n" (tr (td "00F3") (td "LATIN SMALL LETTER O WITH ACUTE")) "\n" (tr (td "00F4") (td "LATIN SMALL LETTER O WITH CIRCUMFLEX")) "\n" (tr (td "00F5") (td "LATIN SMALL LETTER O WITH TILDE")) "\n" (tr (td "00F6") (td "LATIN SMALL LETTER O WITH DIAERESIS")) "\n" (tr (td "00F8") (td "LATIN SMALL LETTER O WITH STROKE")) "\n" (tr (td "00F9") (td "LATIN SMALL LETTER U WITH GRAVE")) "\n" (tr (td "00FA") (td "LATIN SMALL LETTER U WITH ACUTE")) "\n" (tr (td "00FB") (td "LATIN SMALL LETTER U WITH CIRCUMFLEX")) "\n" (tr (td "00FC") (td "LATIN SMALL LETTER U WITH DIAERESIS")) "\n" (tr (td "00FD") (td "LATIN SMALL LETTER Y WITH ACUTE")) "\n" (tr (td "00FE") (td "LATIN SMALL LETTER THORN")) "\n" (tr (td "00FF") (td "LATIN SMALL LETTER Y WITH DIAERESIS"))) (p "Note that three of these have no corresponding Latin-1 upper-case character:") (table (tr (td "00B5") (td "MICRO SIGN")) "\n" (tr (td "00DF") (td "LATIN SMALL LETTER SHARP S")) "\n" (tr (td "00FF") (td "LATIN SMALL LETTER Y WITH DIAERESIS"))) (p "(The compatibility micro character uppercases to the non-Latin-1 Greek capital mu; the German sharp s character uppercases to the pair of characters \"SS,\" and the capital y-with-diaeresis is non-Latin-1.)")) (def (sig (constant "char-set:upper-case" (id char-set:upper-case))) (p "For Unicode, a character is uppercase if") (ul (li "it is not in the range [U+2000,U+2FFF], and ") (li "the Unicode attribute table does not give an uppercase mapping for it (this excludes titlecase characters), and ") (li "at least one of the following is true: " (ul (li "the Unicode attribute table gives a mapping to lowercase for the character, or ") (li "the name for the character in the Unicode attribute table contains the words \"CAPITAL LETTER\" or \"CAPITAL LIGATURE\". ")))) (p "The upper-case ASCII characters are") (p "ABCDEFGHIJKLMNOPQRSTUVWXYZ") (p "Latin-1 adds another 30 upper-case characters to the ASCII set:") (table (tr (td "00C0") (td "LATIN CAPITAL LETTER A WITH GRAVE")) "\n" (tr (td "00C1") (td "LATIN CAPITAL LETTER A WITH ACUTE")) "\n" (tr (td "00C2") (td "LATIN CAPITAL LETTER A WITH CIRCUMFLEX")) "\n" (tr (td "00C3") (td "LATIN CAPITAL LETTER A WITH TILDE")) "\n" (tr (td "00C4") (td "LATIN CAPITAL LETTER A WITH DIAERESIS")) "\n" (tr (td "00C5") (td "LATIN CAPITAL LETTER A WITH RING ABOVE")) "\n" (tr (td "00C6") (td "LATIN CAPITAL LETTER AE")) "\n" (tr (td "00C7") (td "LATIN CAPITAL LETTER C WITH CEDILLA")) "\n" (tr (td "00C8") (td "LATIN CAPITAL LETTER E WITH GRAVE")) "\n" (tr (td "00C9") (td "LATIN CAPITAL LETTER E WITH ACUTE")) "\n" (tr (td "00CA") (td "LATIN CAPITAL LETTER E WITH CIRCUMFLEX")) "\n" (tr (td "00CB") (td "LATIN CAPITAL LETTER E WITH DIAERESIS")) "\n" (tr (td "00CC") (td "LATIN CAPITAL LETTER I WITH GRAVE")) "\n" (tr (td "00CD") (td "LATIN CAPITAL LETTER I WITH ACUTE")) "\n" (tr (td "00CE") (td "LATIN CAPITAL LETTER I WITH CIRCUMFLEX")) "\n" (tr (td "00CF") (td "LATIN CAPITAL LETTER I WITH DIAERESIS")) "\n" (tr (td "00D0") (td "LATIN CAPITAL LETTER ETH")) "\n" (tr (td "00D1") (td "LATIN CAPITAL LETTER N WITH TILDE")) "\n" (tr (td "00D2") (td "LATIN CAPITAL LETTER O WITH GRAVE")) "\n" (tr (td "00D3") (td "LATIN CAPITAL LETTER O WITH ACUTE")) "\n" (tr (td "00D4") (td "LATIN CAPITAL LETTER O WITH CIRCUMFLEX")) "\n" (tr (td "00D5") (td "LATIN CAPITAL LETTER O WITH TILDE")) "\n" (tr (td "00D6") (td "LATIN CAPITAL LETTER O WITH DIAERESIS")) "\n" (tr (td "00D8") (td "LATIN CAPITAL LETTER O WITH STROKE")) "\n" (tr (td "00D9") (td "LATIN CAPITAL LETTER U WITH GRAVE")) "\n" (tr (td "00DA") (td "LATIN CAPITAL LETTER U WITH ACUTE")) "\n" (tr (td "00DB") (td "LATIN CAPITAL LETTER U WITH CIRCUMFLEX")) "\n" (tr (td "00DC") (td "LATIN CAPITAL LETTER U WITH DIAERESIS")) "\n" (tr (td "00DD") (td "LATIN CAPITAL LETTER Y WITH ACUTE")) "\n" (tr (td "00DE") (td "LATIN CAPITAL LETTER THORN")))) (def (sig (constant "char-set:title-case" (id char-set:title-case))) (p "In Unicode, a character is titlecase if it has the category Lt in the character attribute database. There are very few of these characters; here is the entire 31-character list as of Unicode 3.0:") (table (tr (td "01C5") (td "LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON")) "\n" (tr (td "01C8") (td "LATIN CAPITAL LETTER L WITH SMALL LETTER J")) "\n" (tr (td "01CB") (td "LATIN CAPITAL LETTER N WITH SMALL LETTER J")) "\n" (tr (td "01F2") (td "LATIN CAPITAL LETTER D WITH SMALL LETTER Z")) "\n" (tr (td "1F88") (td "GREEK CAPITAL LETTER ALPHA WITH PSILI AND PROSGEGRAMMENI")) "\n" (tr (td "1F89") (td "GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI")) "\n" (tr (td "1F8A") (td "GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI")) "\n" (tr (td "1F8B") (td "GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI")) "\n" (tr (td "1F8C") (td "GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMENI")) "\n" (tr (td "1F8D") (td "GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMENI")) "\n" (tr (td "1F8E") (td "GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI")) "\n" (tr (td "1F8F") (td "GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI")) "\n" (tr (td "1F98") (td "GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI")) "\n" (tr (td "1F99") (td "GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI")) "\n" (tr (td "1F9A") (td "GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI")) "\n" (tr (td "1F9B") (td "GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI")) "\n" (tr (td "1F9C") (td "GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI")) "\n" (tr (td "1F9D") (td "GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI")) "\n" (tr (td "1F9E") (td "GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI")) "\n" (tr (td "1F9F") (td "GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI")) "\n" (tr (td "1FA8") (td "GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI")) "\n" (tr (td "1FA9") (td "GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI")) "\n" (tr (td "1FAA") (td "GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI")) "\n" (tr (td "1FAB") (td "GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI")) "\n" (tr (td "1FAC") (td "GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI")) "\n" (tr (td "1FAD") (td "GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI")) "\n" (tr (td "1FAE") (td "GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI")) "\n" (tr (td "1FAF") (td "GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI")) "\n" (tr (td "1FBC") (td "GREEK CAPITAL LETTER ALPHA WITH PROSGEGRAMMENI")) "\n" (tr (td "1FCC") (td "GREEK CAPITAL LETTER ETA WITH PROSGEGRAMMENI")) "\n" (tr (td "1FFC") (td "GREEK CAPITAL LETTER OMEGA WITH PROSGEGRAMMENI"))) (p "There are no ASCII or Latin-1 titlecase characters.")) (def (sig (constant "char-set:letter" (id char-set:letter))) (p "In Unicode, a letter is any character with one of the letter categories (Lu, Ll, Lt, Lm, Lo) in the Unicode character database.") (p "There are 52 ASCII letters") (p "abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ") (p "There are 117 Latin-1 letters. These are the 115 characters that are members of the Latin-1 " (tt "char-set:lower-case") " and " (tt "char-set:upper-case") " sets, plus") (table (tr (td "00AA") (td "FEMININE ORDINAL INDICATOR")) "\n" (tr (td "00BA") (td "MASCULINE ORDINAL INDICATOR"))) (p "(These two letters are considered lower-case by Unicode, but not by SRFI 14.)")) (def (sig (constant "char-set:digit" (id char-set:digit))) (p "In Unicode, a character is a digit if it has the category Nd in the character attribute database. In Latin-1 and ASCII, the only such characters are 0123456789. In Unicode, there are other digit characters in other code blocks, such as Gujarati digits and Tibetan digits.")) (def (sig (constant "char-set:hex-digit" (id char-set:hex-digit))) (p "The only hex digits are 0123456789abcdefABCDEF.")) (def (sig (constant "char-set:letter+digit" (id char-set:letter+digit))) (p "The union of " (tt "char-set:letter") " and " (tt "char-set:digit."))) (def (sig (constant "char-set:graphic" (id char-set:graphic))) (p "A graphic character is one that would put ink on paper. The ASCII and Latin-1 graphic characters are the members of") (table (tr (td (tt "char-set:letter"))) "\n" (tr (td (tt "char-set:digit"))) "\n" (tr (td (tt "char-set:punctuation"))) "\n" (tr (td (tt "char-set:symbol"))))) (def (sig (constant "char-set:printing" (id char-set:printing))) (p "A printing character is one that would occupy space when printed, " (i "i.e.") ", a graphic character or a space character. " (tt "char-set:printing") " is the union of " (tt "char-set:whitespace") " and " (tt "char-set:graphic."))) (def (sig (constant "char-set:whitespace" (id char-set:whitespace))) (p "In Unicode, a whitespace character is either") (ul (li "a character with one of the space, line, or paragraph separator categories (Zs, Zl or Zp) of the Unicode character database. ") (li "U+0009 Horizontal tabulation (\\t control-I) ") (li "U+000A Line feed (\\n control-J) ") (li "U+000B Vertical tabulation (\\v control-K) ") (li "U+000C Form feed (\\f control-L) ") (li "U+000D Carriage return (\\r control-M) ")) (p "There are 24 whitespace characters in Unicode 3.0:") (table (tr (td "0009") (td "HORIZONTAL TABULATION") (td "\\t control-I")) "\n" (tr (td "000A") (td "LINE FEED") (td "\\n control-J")) "\n" (tr (td "000B") (td "VERTICAL TABULATION") (td "\\v control-K")) "\n" (tr (td "000C") (td "FORM FEED") (td "\\f control-L")) "\n" (tr (td "000D") (td "CARRIAGE RETURN") (td "\\r control-M")) "\n" (tr (td "0020") (td "SPACE") (td "Zs")) "\n" (tr (td "00A0") (td "NO-BREAK SPACE") (td "Zs")) "\n" (tr (td "1680") (td "OGHAM SPACE MARK") (td "Zs")) "\n" (tr (td "2000") (td "EN QUAD") (td "Zs")) "\n" (tr (td "2001") (td "EM QUAD") (td "Zs")) "\n" (tr (td "2002") (td "EN SPACE") (td "Zs")) "\n" (tr (td "2003") (td "EM SPACE") (td "Zs")) "\n" (tr (td "2004") (td "THREE-PER-EM SPACE") (td "Zs")) "\n" (tr (td "2005") (td "FOUR-PER-EM SPACE") (td "Zs")) "\n" (tr (td "2006") (td "SIX-PER-EM SPACE") (td "Zs")) "\n" (tr (td "2007") (td "FIGURE SPACE") (td "Zs")) "\n" (tr (td "2008") (td "PUNCTUATION SPACE") (td "Zs")) "\n" (tr (td "2009") (td "THIN SPACE") (td "Zs")) "\n" (tr (td "200A") (td "HAIR SPACE") (td "Zs")) "\n" (tr (td "200B") (td "ZERO WIDTH SPACE") (td "Zs")) "\n" (tr (td "2028") (td "LINE SEPARATOR") (td "Zl")) "\n" (tr (td "2029") (td "PARAGRAPH SEPARATOR") (td "Zp")) "\n" (tr (td "202F") (td "NARROW NO-BREAK SPACE") (td "Zs")) "\n" (tr (td "3000") (td "IDEOGRAPHIC SPACE") (td "Zs"))) (p "The ASCII whitespace characters are the first six characters in the above list -- line feed, horizontal tabulation, vertical tabulation, form feed, carriage return, and space. These are also exactly the characters recognised by the Posix " (tt "isspace()") " procedure. Latin-1 adds the no-break space.")) (def (sig (constant "char-set:iso-control" (id char-set:iso-control))) (p "The ISO control characters are the Unicode/Latin-1 characters in the ranges [U+0000,U+001F] and [U+007F,U+009F].") (p "ASCII restricts this set to the characters in the range [U+0000,U+001F] plus the character U+007F.") (p "Note that Unicode defines other control characters which do not belong to this set (hence the qualifying prefix \"iso-\" in the name).")) (def (sig (constant "char-set:punctuation" (id char-set:punctuation))) (p "In Unicode, a punctuation character is any character that has one of the punctuation categories in the Unicode character database (Pc, Pd, Ps, Pe, Pi, Pf, or Po.)") (p "ASCII has 23 punctuation characters:") (pre "!\"#%&'()*,-./:;?@[\\]_{}") (p "Latin-1 adds six more:") (table (tr (td "00A1") (td "INVERTED EXCLAMATION MARK")) "\n" (tr (td "00AB") (td "LEFT-POINTING DOUBLE ANGLE QUOTATION MARK")) "\n" (tr (td "00AD") (td "SOFT HYPHEN")) "\n" (tr (td "00B7") (td "MIDDLE DOT")) "\n" (tr (td "00BB") (td "RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK")) "\n" (tr (td "00BF") (td "INVERTED QUESTION MARK"))) (p "Note that the nine ASCII characters " (tt "$+<=>^`|~") " are " (i "not") " punctuation. They are \"symbols.\"")) (def (sig (constant "char-set:symbol" (id char-set:symbol))) (p "In Unicode, a symbol is any character that has one of the symbol categories in the Unicode character database (Sm, Sc, Sk, or So). There are nine ASCII symbol characters:") (pre "$+<=>^`|~") (p "Latin-1 adds 18 more:") (table (tr (td "00A2") (td "CENT SIGN")) "\n" (tr (td "00A3") (td "POUND SIGN")) "\n" (tr (td "00A4") (td "CURRENCY SIGN")) "\n" (tr (td "00A5") (td "YEN SIGN")) "\n" (tr (td "00A6") (td "BROKEN BAR")) "\n" (tr (td "00A7") (td "SECTION SIGN")) "\n" (tr (td "00A8") (td "DIAERESIS")) "\n" (tr (td "00A9") (td "COPYRIGHT SIGN")) "\n" (tr (td "00AC") (td "NOT SIGN")) "\n" (tr (td "00AE") (td "REGISTERED SIGN")) "\n" (tr (td "00AF") (td "MACRON")) "\n" (tr (td "00B0") (td "DEGREE SIGN")) "\n" (tr (td "00B1") (td "PLUS-MINUS SIGN")) "\n" (tr (td "00B4") (td "ACUTE ACCENT")) "\n" (tr (td "00B6") (td "PILCROW SIGN")) "\n" (tr (td "00B8") (td "CEDILLA")) "\n" (tr (td "00D7") (td "MULTIPLICATION SIGN")) "\n" (tr (td "00F7") (td "DIVISION SIGN")))) (def (sig (constant "char-set:blank" (id char-set:blank))) (p "Blank chars are horizontal whitespace. In Unicode, a blank character is either") (ul (li "a character with the space separator category (Zs) in the Unicode character database. ") (li "U+0009 Horizontal tabulation (\\t control-I) ")) (p "There are eighteen blank characters in Unicode 3.0:") (table (tr (td "0009") (td "HORIZONTAL TABULATION") (td "\\t control-I")) "\n" (tr (td "0020") (td "SPACE") (td "Zs")) "\n" (tr (td "00A0") (td "NO-BREAK SPACE") (td "Zs")) "\n" (tr (td "1680") (td "OGHAM SPACE MARK") (td "Zs")) "\n" (tr (td "2000") (td "EN QUAD") (td "Zs")) "\n" (tr (td "2001") (td "EM QUAD") (td "Zs")) "\n" (tr (td "2002") (td "EN SPACE") (td "Zs")) "\n" (tr (td "2003") (td "EM SPACE") (td "Zs")) "\n" (tr (td "2004") (td "THREE-PER-EM SPACE") (td "Zs")) "\n" (tr (td "2005") (td "FOUR-PER-EM SPACE") (td "Zs")) "\n" (tr (td "2006") (td "SIX-PER-EM SPACE") (td "Zs")) "\n" (tr (td "2007") (td "FIGURE SPACE") (td "Zs")) "\n" (tr (td "2008") (td "PUNCTUATION SPACE") (td "Zs")) "\n" (tr (td "2009") (td "THIN SPACE") (td "Zs")) "\n" (tr (td "200A") (td "HAIR SPACE") (td "Zs")) "\n" (tr (td "200B") (td "ZERO WIDTH SPACE") (td "Zs")) "\n" (tr (td "202F") (td "NARROW NO-BREAK SPACE") (td "Zs")) "\n" (tr (td "3000") (td "IDEOGRAPHIC SPACE") (td "Zs"))) (p "The ASCII blank characters are the first two characters above -- horizontal tab and space. Latin-1 adds the no-break space.")) (hr) (p "Previous: " (int-link "Unit srfi-13")) (p "Next: " (int-link "Unit srfi-18")))))