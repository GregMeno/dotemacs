((tags "egg") (toc) (section 2 "Introduction" (p "Chicken Scheme procedures have attributes, aspects of the procedure object that can be operated upon. Such an attribute is known as a \"procedure decoration\".") (p "This extension provides a facility to perform procedure decoration operations.")) (section 2 "Documentation" (p "An interface for procedure decoration. Similar to the lolevel unit " (tt "extend-procedure") " interface but allowing many decorations, not just one.") (p "A " (tt "PREDICATE") " is a procedure of one argument, a procedure decoration. The predicate must return a truth value indicating whether the argument is a decoration of the proper kind.") (p "A " (tt "DECORATOR") " is a procedure of at least one argument, the current procedure decoration, which is " (tt "(void)") " initially. The decorator must return an object to replace the current decoration.")) (section 2 "Procedure Decorator" (p "A more sophisticated interface for procedure decoration.") (section 3 "make-procedure-decorator" (def (sig (procedure "(make-procedure-decorator PREDICATE DECORATOR RETRIEVER [#:initializer INITIALIZER] [#:replace? REPLACE?])" (id make-procedure-decorator))) (p "Returns a new " (tt "procedure-decorator") ".") (p "The " (tt "RETRIEVER") " is a procedure of at least one argument, the current procedure decoration, returning the procedure decoration object. Any following arguments are from the " (tt "procedure-decoration") " call that will invoke the " (tt "RETRIEVER") ".") (p "The " (tt "INITIALIZER") " is a procedure of varying arity, returning the procedure decoration initial object. The arguments are from the " (tt "decorate-procedure") " call that invokes the " (tt "INITIALIZER") ". The " (tt "INITIALIZER") " is invoked only once per procedure to decorate.") (p "The default " (tt "INITIALIZER") " is built from the " (tt "DECORATOR") ". The " (tt "DECORATOR") " will be called with a first argument of " (tt "(void)") ", and any other arguments from the " (tt "decorate-procedure") " call.") (p "The " (tt "REPLACE?") " flag determines whether the procedure object of a decorated procedure will be replaced (become). The default is " (tt "#f") "."))) (section 3 "procedure-decorator?" (def (sig (procedure "(procedure-decorator? OBJECT)" (id procedure-decorator?))) (p "Is the " (tt "OBJECT") " a " (tt "procedure-decorator") "?"))) (section 3 "decorate-procedure" (def (sig (procedure "(decorate-procedure PROCEDURE PROCEDURE-DECORATOR [ARGUMENTS ...])" (id decorate-procedure))) (p "Decorate the " (tt "PROCEDURE") " with the " (tt "PROCEDURE-DECORATOR") ".") (p "The " (tt "PROCEDURE-DECORATOR") " " (tt "INITIALIZER") " is called on the first invocation for " (tt "PROCEDURE") " and the " (tt "DECORATOR") " on all subsequent invocations.") (p "The optional " (tt "ARGUMENTS") " are passed to the invoked " (tt "PROCEDURE-DECORATOR") " constructor, as above.") (p "On the first invocation a " (tt "GC") " will be performed.") (p "Returns the decorated procedure."))) (section 3 "decorated-procedure?" (def (sig (procedure "(decorated-procedure? PROCEDURE PROCEDURE-DECORATOR)" (id decorated-procedure?))) (p "Is the " (tt "PROCEDURE") " a decorated by " (tt "PROCEDURE-DECORATOR") "?"))) (section 3 "procedure-decoration" (def (sig (procedure "(procedure-decoration PROCEDURE PROCEDURE-DECORATOR [ARGUMENTS ...])" (id procedure-decoration))) (p "Returns the procedure decoration of " (tt "PROCEDURE-DECORATOR") " for the " (tt "PROCEDURE") ".") (p "The optional " (tt "ARGUMENTS") " are passed to the " (tt "PROCEDURE-DECORATOR") " " (tt "RETRIEVER") "."))) (section 3 "procedure-decorator-getter-and-setter" (def (sig (procedure "(procedure-decorator-getter-and-setter PROCEDURE-DECORATOR)" (id procedure-decorator-getter-and-setter))) (p "Returns a single argument getter, and creates a two argument setter, for the " (tt "PROCEDURE-DECORATOR") ".") (p "The getter takes a " (tt "PROCEDURE") " argument. The setter takes " (tt "PROCEDURE") " and " (tt "OBJECT") " arguments.")))) (section 2 "Procedure Extender" (p "Not to be confused with the lolevel unit " (tt "extend-procedure") " interface.") (section 3 "make-procedure-extender" (def (sig (procedure "(make-procedure-extender TAG)" (id make-procedure-extender))) (p "Returns a simple " (tt "PROCEDURE-DECORATOR") " that recognizes its' decorations by the " (tt "TAG") " and accepts any object as a decoration.") (p "The " (tt "TAG") " is any object suitable for testing with " (tt "eq?") "."))) (section 3 "define-procedure-extender" (def (sig (syntax "(define-procedure-extender TAG [GETTER-NAME [PREDICATE-NAME]])" (id define-procedure-extender))) (p "Creates a functional interface for a " (tt "PROCEDURE-DECORATOR") " that uses the {{TAG} symbol.") (p "Defines the " (tt "PROCEDURE-DECORATOR") " as " (tt "TAG-decorator") ".") (p "Defines a procedure named " (tt "GETTER-NAME") " that takes one argument, a decorated procedure, and returns the procedure decoration. Creates a corresponding setter. The default " (tt "GETTER-NAME") " is " (tt "TAG-decoration") ".") (p "Defines a procedure named " (tt "PREDICATE-NAME") " that takes one argument, a procedure, and returns whether the procedure is decorated. The default " (tt "PREDICATE-NAME") " is " (tt "TAG-decorated?") ".")))) (section 2 "Lambda Decoration Interface" (p "A lower level interface for procedure decoration.") (section 3 "decorated-lambda?" (def (sig (procedure "(decorated-lambda? PROCEDURE PREDICATE)" (id decorated-lambda?))) (p "Is the " (tt "PROCEDURE") " decorated per the " (tt "PREDICATE") "?"))) (section 3 "lambda-decoration" (def (sig (procedure "(lambda-decoration PROCEDURE PREDICATE)" (id lambda-decoration))) (p "Returns an object per the " (tt "PREDICATE") " or " (tt "#f") "."))) (section 3 "decorate-lambda" (def (sig (procedure "(decorate-lambda PROCEDURE PREDICATE DECORATOR)" (id decorate-lambda))) (p "Decorate the " (tt "PROCEDURE") " per the " (tt "PREDICATE") " with the result of the " (tt "DECORATOR") ".") (p "Returns the decorated procedure.")))) (section 2 "Usage" (highlight scheme "(require-extension procedure-decoration)")) (section 2 "Examples") (section 2 "Notes" (ul (li "The " (tt "decorate-lambda") " interface decorated procedure is not the original procedure. Decorating procedure " (tt "foo") " will not change the procedure object of " (tt "foo") ", but return a new one.") (li "The " (tt "procedure-decorator") " interface can rewrite the procedure object. Decorating procedure " (tt "foo") " with a " (tt "REPLACE?") " " (tt "procedure-decorator") " changes the procedure object of " (tt "foo") "."))) (section 2 "Author" (p (int-link "/users/kon-lovett" "Kon Lovett"))) (section 2 "Requirements" (p (int-link "check-errors"))) (section 2 "Version history" (dl (dt "2.0.0") (dd "Initial Chicken 4 release"))) (section 2 "License" (p "Copyright (c) 2009 Kon Lovett.  All rights reserved.") (p "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:") (p "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.") (p "THE SOFTWARE IS PROVIDED ASIS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.")))