((tags "egg") (section 2 "lalr" (p "LALR(1) parser generator written in Scheme.") (toc)) (section 2 "Usage" (p "To generate the parser:") (pre "(require-extension lalr)\n\n;; this will only work in the interpreter\n(lalr-parser\n  grammar definition ... )\n") (p "To use the parser:") (pre "\n(include \"parser.grm.scm\") ;; file generated by lalr-parser macro\n\n(parser lexer parse-error) \n;; parser is the function defined in the grammar file\n;; lexer is a user-defined character-reading function\n;; parse-error is a user-defined error function")) (section 2 "Documentation" (p (tt "lalr") " implements an efficient algorithm for computing  lookahead sets, which is the same as the one used in Bison (GNU yacc):") (pre "Efficient Computation of LALR(1) Look-Ahead Set, F. DeRemer and T. Pennello, TOPLAS, vol. 4, no. 4, october 1982.") (p "The official documentation for " (tt "lalr") " can be found here: " (link "http://code.google.com/p/lalr-scm/") ". The following is taken from chapters 4 and 6 in the official documentation.") (section 3 "Defining a parser" (p "The file " (tt "lalr.scm") " declares a macro called " (tt "lalr-parser") ":") (pre "(lalr-parser [options] tokens rules ...)") (p "To use this macro, you must first load " (tt "lalr.scm") " in the Scheme interpreter via the " (tt "include") " special form. The macro will not work in the compiler.") (p "This macro, when given appropriate arguments, generates an LALR(1) parser. The macro accepts at least two arguments. The first is a list of symbols which represent the terminal symbols of the grammar. The remaining arguments are the grammar production rules.")) (section 3 "The grammar format" (p "The grammar is specified by first giving the list of terminals and the list of non-terminal definitions. Each non-terminal definition is a list where the first element is the non-terminal and the other elements are the right-hand sides (lists of grammar symbols). In addition to this, each right-hand side can be followed by a semantic action.") (p "For example, consider the following (yacc) grammar for a very simple expression language:") (pre "   e : e '+' t\n     | e '-' t\n     | t\n     ;\n   t : t '*' f\n     : t '/' f\n     | f\n     ;\n   f : ID\n     ;") (p "The same grammar, written for the scheme parser generator, would look like this (with semantic actions):") (pre "(define expr-parser\n  (lalr-parser\n   ; Terminal symbols\n   (ID + - * /)\n   ; Productions\n   (e (e + t)    : (+ $1 $3)\n      (e - t)    : (- $1 $3)\n      (t)        : $1)\n   (t (t * f)    : (* $1 $3)\n      (t / f)    : (/ $1 $3)\n      (f)        : $1)\n   (f (ID)       : $1)))") (p "In semantic actions, the symbol " (tt "$n") " refers to the synthesized attribute value of the nth symbol in the production. The value associated with the non-terminal on the left is the result of evaluating the semantic action (it defaults to " (tt "#f") ").") (section 4 "Operator precedence and associativity" (p "The above grammar implicitly handles operator precedences. It is also possible to explicitly assign precedences and associativity to terminal symbols and productions a la Yacc. Here is a modified (and augmented) version of the grammar:") (pre "(define expr-parser\n (lalr-parser\n  ; Terminal symbols\n  (ID\n   (left: + -)\n   (left: * /)\n   (nonassoc: uminus))\n  (e (e + e)              : (+ $1 $3)\n     (e - e)              : (- $1 $3)\n     (e * e)              : (* $1 $3)\n     (e / e)              : (/ $1 $3)\n     (- e (prec: uminus)) : (- $2)\n     (ID)                 : $1)))") (p "The " (tt "left:") " directive is used to specify a set of left-associative operators of the same precedence level, the " (tt "right:") " directive for right-associative operators, and " (tt "nonassoc:") " for operators that are not associative. Note the use of the (apparently) useless terminal " (tt "uminus") ". It is only defined in order to assign to the penultimate rule a precedence level higher than that of " (tt "*") " and " (tt "/") ". The " (tt "prec:") " directive can only appear as the last element of a rule. Finally, note that precedence levels are incremented from left to right, i.e. the precedence level of " (tt "+") " and " (tt "-") " is less than the precedence level of " (tt "*") " and " (tt "/") " since the formers appear first in the list of terminal symbols (token definitions).")) (section 4 "Options" (p "The following options are available.") (ul (li (tt "(output: name filename)") " - copies the parser to the given file. The parser is given the name name. ") (li (tt "(out-tables: filename) ") " - outputs the parsing tables in filename in a more readable format.") (li (tt "(expect: n)") " - don't warn about conflicts if there are " (tt "n") " or less conflicts.") (li (tt "(driver: glr)") " - generates a GLR parser instead of a regular LALR parser."))) (section 4 "Error recovery" (p "lalr implements a very simple error recovery strategy. A production can be of the form") (pre "  (rulename\n      ...\n      (error TERMINAL) : action-code)") (p "There can be several such productions for a single rulename.This will cause the parser to skip all the tokens produced by the lexer that are different than the given " (tt "TERMINAL") ". For a C-like language, one can synchronize on semicolons and closing curly brackets by writing error rules like these:") (pre "   (stmt\n      (expression SEMICOLON) : ...\n      (LBRACKET stmt RBRACKET) : ...\n      (error SEMICOLON)\n      (error RBRACKET))") (p "Conflicts in the grammar are handled in a conventional way. In the absence of precedence directives, Shift/Reduce conflicts are resolved by shifting, and Reduce/Reduce conflicts are resolved by choosing the rule listed first in the grammar definition."))) (section 3 "Using the parser" (p "The parser generated by the " (tt "lalr-parser macro") " is a function that takes two parameters. The first parameter is a lexical analyzer while the second is an error procedure. The lexical analyzer is zero-argument function (a thunk) invoked each time the parser needs to look-ahead in the token stream. A token is usually a pair whose " (tt "car") " is the symbol corresponding to the token (the same symbol as used in the grammar definition). The " (tt "cdr") " of the pair is the semantic value associated with the token. For example, a string token would have the " (tt "car") " set to " (tt "'string") " while the " (tt "cdr") " is set to the string value \"hello\".  The token may also be a plain symbol, such as " (tt "'NEWLINE") ", if it has no need of a semantic value.") (p "Once the end of file is encountered, the lexical analyzer must always return the symbol" (tt "'*eoi*") " each time it is invoked.") (p "The error procedure must be a function that accepts at least two parameters, a message and additional arguments to be printed."))) (section 2 "Examples" (pre " ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;;\n ;;; FILE: calc.grm\n ;;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;;\n ;;; Parser for simple calculator in Scheme.\n ;;;\n ;;; To use, run the command: \n ;;; \n ;;; csi < calc.grm\n ;;;\n ;;; This will create file `calc.grm.scm'. Then, to compile the\n ;;; calculator program, run: \n ;;;\n ;;; csc calc.scm\n ;;;\n ;;\n ;;\n ;; @created   \"Tue Jan  6 12:47:23 2004\"\n ;; @modified  \"Mon Oct 25 11:07:24 2004\"\n ;; @author    \"Dominique Boucher\"\n ;; @copyright \"Dominique Boucher\"\n ;;\n ;; Simple arithmetic calculator. \n ;; \n ;;   This program illustrates the use of the lalr-scm parser generator\n ;; for Scheme. It is NOT robust, since calling a function with \n ;; the wrong number of arguments may generate an error that will\n ;; cause the calculator to crash.\n\n\n  ;;;\n  ;;;;   The LALR(1) parser\n  ;;;\n\n  (require-extension lalr)\n\n  (define calc-parser\n    (lalr-parser\n\n     ;; --- Options \n     ;; output a parser, called calc-parser, in a separate file - calc.grm.scm, \n     (output:    calc-parser \"calc.grm.scm\")\n     ;; output the LALR table to calc.out\n     (out-table: \"calc.grm.out\")\n\n     ;; --- token definitions\n     (ID NUM NEWLINE  LPAREN RPAREN\n         (nonassoc: =)\n         (left: - +)\n         (left: * /)\n         (left: COMMA)\n         (nonassoc: uminus))\n\n     (lines    (lines line) : (display-result $2)\n               (line)       : (display-result $1))\n\n\n     ;; --- rules\n     (line     (NEWLINE)               : (void)\n  \t     (assign NEWLINE)        : $1\n               (expr   NEWLINE)        : $1\n               (error  NEWLINE)        : #f)\n\n     (assign   (ID = expr)             : (add-binding $1 $3))\n\n     (expr     (NUM)                   : $1\n               (ID)                    : (get-binding $1)\n  \t     (ID LPAREN RPAREN)      : (invoke-proc $1 (list))\n  \t     (ID LPAREN args RPAREN) : (invoke-proc $1 $3)\n  \t     (expr + expr)           : (+ $1 $3)\n               (expr - expr)           : (- $1 $3)\n               (expr * expr)           : (* $1 $3)\n               (expr / expr)           : (/ $1 $3)\n               (- expr (prec: uminus)) : (- $2)\n  \t     (LPAREN expr RPAREN)    : $2)\n\n     (args     (expr)                  : (list $1)\n               (args COMMA expr)       : (cons $3 $1))))\n \t\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;;\n  ;;; END FILE: calc.grm\n  ;;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;;\n  ;;; FILE: calc.scm\n  ;;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ;;;\n  ;;;; Simple calculator in Scheme\n  ;;;\n  ;;\n  ;; @created   \"Tue Jan  6 12:47:23 2004\"\n  ;; @modified  \"Mon Oct 25 11:07:24 2004\"\n  ;; @author    \"Dominique Boucher\"\n  ;; @copyright \"Dominique Boucher\"\n  ;;\n  ;; Simple arithmetic calculator. \n  ;; \n  ;;   This program illustrates the use of the lalr-scm parser generator\n  ;; for Scheme. It is NOT robust, since calling a function with \n  ;; the wrong number of arguments may generate an error that will\n  ;; cause the calculator to crash.\n\n  ;; parser\n\n  (include \"calc.grm.scm\")\n\n\n  ;;;\n  ;;;;   The lexer\n  ;;;\n\n\n  (define (make-lexer errorp)\n    (lambda ()\n      (letrec ((skip-spaces\n                (lambda ()\n                  (let loop ((c (peek-char)))\n                    (if (and (not (eof-object? c))\n                             (or (char=? c #\\space) (char=? c #\\tab)))\n                        (begin\n                          (read-char)\n                          (loop (peek-char)))))))\n               (read-number\n                (lambda (l)\n                  (let ((c (peek-char)))\n                    (if (char-numeric? c)\n                        (read-number (cons (read-char) l))\n                        (string->number (apply string (reverse l)))))))\n               (read-id\n                (lambda (l)\n                  (let ((c (peek-char)))\n                    (if (char-alphabetic? c)\n                        (read-id (cons (read-char) l))\n                        (string->symbol (apply string (reverse l))))))))\n\n        ;; -- skip spaces\n        (skip-spaces)\n        ;; -- read the next token\n        (let loop ((c (read-char)))\n          (cond\n           ((eof-object? c)      '*eoi*)\n           ((char=? c #\\newline) 'NEWLINE)\n           ((char=? c #\\+)       '+)\n           ((char=? c #\\-)       '-)\n           ((char=? c #\\*)       '*)\n           ((char=? c #\\/)       '/)\n           ((char=? c #\\=)       '=)\n           ((char=? c #\\,)       'COMMA)\n           ((char=? c #\\()       'LPAREN)\n           ((char=? c #\\))       'RPAREN)\n           ((char-numeric? c)    (cons 'NUM (read-number (list c))))\n           ((char-alphabetic? c) (cons 'ID  (read-id (list c))))\n           (else\n            (errorp \"PARSE ERROR : illegal character: \" c)\n            (skip-spaces)\n            (loop (read-char))))))))\n\n\n  (define (read-line)\n    (let loop ((c (read-char)))\n      (if (and (not (eof-object? c))\n               (not (char=? c #\\newline)))\n          (loop (read-char)))))\n\n\n  ;;;\n  ;;;;   Environment management\n  ;;;\n\n\n  (define *env* (list (cons '$$ 0)))\n\n\n  (define (init-bindings)\n    (set-cdr! *env* '())\n    (add-binding 'cos cos)\n    (add-binding 'sin sin)\n    (add-binding 'tan tan)\n    (add-binding 'expt expt)\n    (add-binding 'sqrt sqrt))\n\n\n  (define (add-binding var val)\n    (set! *env* (cons (cons var val) *env*))\n    val)\n\n\n  (define (get-binding var)\n    (let ((p (assq var *env*)))\n      (if p\n          (cdr p)\n          0)))\n\n\n  (define (invoke-proc proc-name args)\n    (let ((proc (get-binding proc-name)))\n      (if (procedure? proc)\n          (apply proc args)\n          (begin\n            (display \"ERROR: invalid procedure:\")\n            (display proc-name)\n            (newline)\n            0))))\n\n\n  ;; value display\n  (define (display-result v)\n    (if v\n        (begin\n          (display \"==> \")\n          (display v)\n          (newline))))\n\n  ;;;\n  ;;;;   The main program\n  ;;;\n\n\n  (define calc\n    (lambda ()\n      (call-with-current-continuation\n       (lambda (k)\n         (display \"********************************\") (newline)\n         (display \"*  Mini calculator in Scheme   *\") (newline)\n         (display \"*                              *\") (newline)\n         (display \"* Enter expressions followed   *\") (newline)\n         (display \"* by [RETURN] or 'quit()' to   *\") (newline)\n         (display \"* exit.                        *\") (newline)\n         (display \"********************************\") (newline)\n         (init-bindings)\n         (add-binding 'quit (lambda () (k #t)))\n         (letrec ((errorp\n                   (lambda args\n                     (for-each display args) (newline)))\n                  (start\n                   (lambda ()\n                     (calc-parser (make-lexer errorp) errorp))))\n           (start))))))\n\n  (calc)\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;;\n  ;;; END FILE: calc.scm\n  ;;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;")) (section 2 "About this egg" (section 3 "Author" (p "Dominique Boucher")) (section 3 "Version history" (dl (dt "2.3.2") (dd "Documentation converted to wiki format") (dt "2.3.1") (dd "Bug fix in lalr-driver to clear the input variable every time a parser is called") (dt "2.3.0") (dd "Updated to upstream version 2.3.0; functionality split in two modules") (dt "2.1.2") (dd "Error-handler is now called with complete token") (dt "2.1.1") (dd "Fixed missing syntax attribute in setup script"))) (section 3 "License" (pre "This program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License as\npublished by the Free Software Foundation; either version 2 of the\nLicense, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n02110-1301 USA\n\nA full copy of the GPL license can be found on Debian systems in \n/usr/share/common-licenses/GPL-2"))))