((tags "egg") (section 2 "stack" (toc)) (section 2 "Documentation" (p "The " (b "stack") " extension is a set of procedures and macros supporting LIFO queue operations.") (section 3 "make-stack" (def (sig (procedure "(make-stack) => STACK" (id make-stack))) (p "Returns a new " (tt "STACK") " object."))) (section 3 "list->stack" (def (sig (procedure "(list->stack LIST) => STACK" (id list->stack))) (p "Returns a new " (tt "STACK") " object with initial elements from the " (tt "LIST") ".") (p "The stack order is as " (tt "(apply stack-push! STACK (reverse LIST))") ". In other words " (tt "LIST") " should be in the desired LIFO order."))) (section 3 "stack?" (def (sig (procedure "(stack? OBJECT) => BOOLEAN" (id stack?))) (p "Is " (tt "OBJECT") " a stack?"))) (section 3 "stack-empty?" (def (sig (procedure "(stack-empty? STACK) => BOOLEAN" (id stack-empty?))) (p "Returns #t for an empty " (tt "STACK") ", #f otherwise."))) (section 3 "stack-count" (def (sig (procedure "(stack-count STACK) => NUMBER" (id stack-count))) (p "Returns the count of elements on the " (tt "STACK") "."))) (section 3 "stack-empty!" (def (sig (procedure "(stack-empty! STACK)" (id stack-empty!))) (p "Make " (tt "STACK") " empty."))) (section 3 "stack-peek" (def (sig (procedure "(stack-peek STACK [INDEX]) => OBJECT" (id stack-peek))) (p "Returns the element in " (tt "STACK") " at " (tt "INDEX") ".") (p (tt "INDEX") " must be in [0 " (tt "(stack-count) - 1") "]. " (tt "INDEX") " defaults to 0."))) (section 3 "stack-poke!" (def (sig (procedure "(stack-poke! STACK OBJECT [INDEX])" (id stack-poke!))) (p "Changes the " (tt "STACK") " element at " (tt "INDEX") " to " (tt "OBJECT") ".") (p (tt "INDEX") " must be in [0 " (tt "(stack-count) - 1") "]. " (tt "INDEX") " defaults to 0.") (p "The stack is modified in place."))) (section 3 "stack-push!" (def (sig (procedure "(stack-push! STACK OBJECT ...)" (id stack-push!))) (p "Pushes " (tt "OBJECT ...") " onto the " (tt "STACK") ".") (p "The stack is modified in place."))) (section 3 "stack-pop!" (def (sig (procedure "(stack-pop! STACK) => OBJECT" (id stack-pop!))) (p "Removes the top element from the " (tt "STACK") " and returns it.") (p "The stack is modified in place."))) (section 3 "stack-cut!" (def (sig (procedure "(stack-cut! STACK START [END]) => LIST" (id stack-cut!))) (p "Removes the " (tt "STACK") " elements from the indexes " (tt "START") " upto " (tt "END") " and returns a list of the stack elements.") (p "The " (tt "START") " must be in [0 " (tt "(stack-count) - 1") "].") (p "The " (tt "END") " must be in [" (tt "START") " " (tt "(stack-count)") "]. " (tt "END") " defaults to " (tt "(stack-count)") ".") (p "The stack is modified in place."))) (section 3 "stack->list" (def (sig (procedure "(stack->list STACK) => LIST" (id stack->list))) (p "Returns the " (tt "STACK") " as a new list, where the first element of the list is the top element of the stack."))) (section 3 "stack-fold" (def (sig (procedure "(stack-fold STACK PROCEDURE INITIAL) => OBJECT" (id stack-fold))) (p "Invokes the " (tt "PROCEDURE") " on each element of the " (tt "STACK") " and the accumulated result. Returns the accumulated result. The initial accumulated result is " (tt "INITIAL") ".") (p "Processing of the " (tt "STACK") " elements in order of top to bottom."))) (section 3 "stack-for-each" (def (sig (procedure "(stack-for-each STACK PROCEDURE)" (id stack-for-each))) (p "Invokes the " (tt "PROCEDURE") " on each element of the " (tt "STACK") ".") (p "Processing of the " (tt "STACK") " elements in order of top to bottom."))) (section 3 "stack-map" (def (sig (procedure "(stack-map STACK PROCEDURE) => LIST" (id stack-map))) (p "Invokes the " (tt "PROCEDURE") " on each element of the " (tt "STACK") ", collecting in a result " (tt "LIST") ".") (p "Processing of the " (tt "STACK") " elements in order of top to bottom.")))) (section 2 "Usage" (highlight scheme "(require-extension stack)") (p "or") (highlight scheme "(require-library stack)\n...\n(import stack)")) (section 2 "Examples") (section 2 "Notes") (section 2 "Requirements") (section 2 "Bugs and Limitations") (section 2 "Author" (p (int-link "/users/kon-lovett" "Kon Lovett"))) (section 2 "Version history" (dl (dt "2.0.0") (dd "Port to hygienic Chicken."))) (section 2 "License" (p "Copyright (C) 2009 Kon Lovett.  All rights reserved.") (p "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:") (p "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.") (p "THE SOFTWARE IS PROVIDED ASIS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.")))