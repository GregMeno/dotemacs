(index ("make-stack" 0) ("list->stack" 109) ("stack?" 421) ("stack-empty?" 522) ("stack-count" 660) ("stack-empty!" 794) ("stack-peek" 894) ("stack-poke!" 1137) ("stack-push!" 1435) ("stack-pop!" 1609) ("stack-cut!" 1790) ("stack->list" 2255) ("stack-fold" 2445) ("stack-for-each" 2804) ("stack-map" 3040))
(def (sig (procedure "(make-stack) => STACK" (id make-stack))) (p "Returns a new " (tt "STACK") " object."))
(def (sig (procedure "(list->stack LIST) => STACK" (id list->stack))) (p "Returns a new " (tt "STACK") " object with initial elements from the " (tt "LIST") ".") (p "The stack order is as " (tt "(apply stack-push! STACK (reverse LIST))") ". In other words " (tt "LIST") " should be in the desired LIFO order."))
(def (sig (procedure "(stack? OBJECT) => BOOLEAN" (id stack?))) (p "Is " (tt "OBJECT") " a stack?"))
(def (sig (procedure "(stack-empty? STACK) => BOOLEAN" (id stack-empty?))) (p "Returns #t for an empty " (tt "STACK") ", #f otherwise."))
(def (sig (procedure "(stack-count STACK) => NUMBER" (id stack-count))) (p "Returns the count of elements on the " (tt "STACK") "."))
(def (sig (procedure "(stack-empty! STACK)" (id stack-empty!))) (p "Make " (tt "STACK") " empty."))
(def (sig (procedure "(stack-peek STACK [INDEX]) => OBJECT" (id stack-peek))) (p "Returns the element in " (tt "STACK") " at " (tt "INDEX") ".") (p (tt "INDEX") " must be in [0 " (tt "(stack-count) - 1") "]. " (tt "INDEX") " defaults to 0."))
(def (sig (procedure "(stack-poke! STACK OBJECT [INDEX])" (id stack-poke!))) (p "Changes the " (tt "STACK") " element at " (tt "INDEX") " to " (tt "OBJECT") ".") (p (tt "INDEX") " must be in [0 " (tt "(stack-count) - 1") "]. " (tt "INDEX") " defaults to 0.") (p "The stack is modified in place."))
(def (sig (procedure "(stack-push! STACK OBJECT ...)" (id stack-push!))) (p "Pushes " (tt "OBJECT ...") " onto the " (tt "STACK") ".") (p "The stack is modified in place."))
(def (sig (procedure "(stack-pop! STACK) => OBJECT" (id stack-pop!))) (p "Removes the top element from the " (tt "STACK") " and returns it.") (p "The stack is modified in place."))
(def (sig (procedure "(stack-cut! STACK START [END]) => LIST" (id stack-cut!))) (p "Removes the " (tt "STACK") " elements from the indexes " (tt "START") " upto " (tt "END") " and returns a list of the stack elements.") (p "The " (tt "START") " must be in [0 " (tt "(stack-count) - 1") "].") (p "The " (tt "END") " must be in [" (tt "START") " " (tt "(stack-count)") "]. " (tt "END") " defaults to " (tt "(stack-count)") ".") (p "The stack is modified in place."))
(def (sig (procedure "(stack->list STACK) => LIST" (id stack->list))) (p "Returns the " (tt "STACK") " as a new list, where the first element of the list is the top element of the stack."))
(def (sig (procedure "(stack-fold STACK PROCEDURE INITIAL) => OBJECT" (id stack-fold))) (p "Invokes the " (tt "PROCEDURE") " on each element of the " (tt "STACK") " and the accumulated result. Returns the accumulated result. The initial accumulated result is " (tt "INITIAL") ".") (p "Processing of the " (tt "STACK") " elements in order of top to bottom."))
(def (sig (procedure "(stack-for-each STACK PROCEDURE)" (id stack-for-each))) (p "Invokes the " (tt "PROCEDURE") " on each element of the " (tt "STACK") ".") (p "Processing of the " (tt "STACK") " elements in order of top to bottom."))
(def (sig (procedure "(stack-map STACK PROCEDURE) => LIST" (id stack-map))) (p "Invokes the " (tt "PROCEDURE") " on each element of the " (tt "STACK") ", collecting in a result " (tt "LIST") ".") (p "Processing of the " (tt "STACK") " elements in order of top to bottom."))
