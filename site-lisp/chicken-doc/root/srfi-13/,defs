(index ("string-null?" 0) ("string-every" 101) ("string-any" 101) ("string-tabulate" 1544) ("string->list" 1845) ("reverse-list->string" 2033) ("string-join" 2467) ("string-copy" 4011) ("substring/shared" 4011) ("string-copy!" 5220) ("string-take" 5808) ("string-drop" 5808) ("string-take-right" 5808) ("string-drop-right" 5808) ("string-pad" 6835) ("string-pad-right" 6835) ("string-trim" 7502) ("string-trim-right" 7502) ("string-trim-both" 7502) ("string-fill!" 8608) ("string-compare" 8851) ("string-compare-ci" 8851) ("string=" 10404) ("string<>" 10404) ("string<" 10404) ("string>" 10404) ("string<=" 10404) ("string>=" 10404) ("string-ci=" 11545) ("string-ci<>" 11545) ("string-ci<" 11545) ("string-ci>" 11545) ("string-ci<=" 11545) ("string-ci>=" 11545) ("string-hash" 12494) ("string-hash-ci" 12494) ("string-prefix-length" 14652) ("string-suffix-length" 14652) ("string-prefix-length-ci" 14652) ("string-suffix-length-ci" 14652) ("string-prefix?" 15954) ("string-suffix?" 15954) ("string-prefix-ci?" 15954) ("string-suffix-ci?" 15954) ("string-index" 17041) ("string-index-right" 17041) ("string-skip" 17041) ("string-skip-right" 17041) ("string-count" 18717) ("string-contains" 19120) ("string-contains-ci" 19120) ("string-titlecase" 20547) ("string-titlecase!" 20547) ("string-upcase" 21609) ("string-upcase!" 21609) ("string-downcase" 21609) ("string-downcase!" 21609) ("string-reverse" 22420) ("string-reverse!" 22420) ("string-concatenate" 23302) ("string-concatenate/shared" 23742) ("string-append/shared" 23742) ("string-concatenate-reverse" 24304) ("string-concatenate-reverse/shared" 24304) ("string-map" 25776) ("string-map!" 25776) ("string-fold" 26234) ("string-fold-right" 26234) ("string-unfold" 28028) ("string-unfold-right" 30955) ("string-for-each" 33209) ("string-for-each-index" 33438) ("xsubstring" 33943) ("string-xcopy!" 35864) ("string-replace" 36252) ("string-tokenize" 37294) ("string-filter" 38264) ("string-delete" 38264) ("string-parse-start+end" 38889) ("string-parse-final-start+end" 38889) ("let-string-start+end" 40403) ("check-substring-spec" 41056) ("substring-spec-ok?" 41056) ("make-kmp-restart-vector" 41848) ("kmp-step" 44828) ("string-kmp-partial-search" 47390))
(def (sig (procedure "(string-null? s) -> boolean" (id string-null?))) (p "Is S the empty string?"))
(def (sig (procedure "(string-every char/char-set/pred s [start end]) -> value" (id string-every)) (procedure "(string-any char/char-set/pred s [start end]) -> value" (id string-any))) (p "Checks to see if the given criteria is true of every / any character in S, proceeding from left (index START) to right (index END).") (p "If CHAR/CHAR-SET/PRED is a character, it is tested for equality with the elements of S.") (p "If CHAR/CHAR-SET/PRED is a character set, the elements of S are tested for membership in the set.") (p "If CHAR/CHAR-SET/PRED is a predicate procedure, it is applied to the elements of S. The predicate is \"witness-generating:\"") (ul (li "If " (tt "string-any") " returns true, the returned true value is the one produced by the application of the predicate. ") (li "If " (tt "string-every") " returns true, the returned true value is the one produced by the final application of the predicate to S[END-1]. If " (tt "string-every") " is applied to an empty sequence of characters, it simply returns " (tt "#t") ". ")) (p "If " (tt "string-every") " or " (tt "string-any") " apply the predicate to the final element of the selected sequence (" (i "i.e.") ", S[END-1]), that final application is a tail call.") (p "The names of these procedures do not end with a question mark -- this is to indicate that, in the predicate case, they do not return a simple boolean (" (tt "#t") " or " (tt "#f") "), but a general value."))
(def (sig (procedure "(string-tabulate proc len) -> string" (id string-tabulate))) (p "PROC is an integer->char procedure. Construct a string of size LEN by applying PROC to each index to produce the corresponding string element. The order in which PROC is applied to the indices is not specified."))
(def (sig (procedure "(string->list s [start end]) -> char-list" (id string->list))) (p (tt "string->list") " is extended from the R5RS definition to take optional START/END arguments."))
(def (sig (procedure "(reverse-list->string char-list) -> string" (id reverse-list->string))) (p "An efficient implementation of " (tt "(compose list->string reverse)") ":") (pre "(reverse-list->string '(#\\a #\\B #\\c)) -> \"cBa\"") (p "This is a common idiom in the epilog of string-processing loops that accumulate an answer in a reverse-order list. (See also " (tt "string-concatenate-reverse") " for the \"chunked\" variant.)"))
(def (sig (procedure "(string-join string-list [delimiter grammar]) -> string" (id string-join))) (p "This procedure is a simple unparser --- it pastes strings together using the delimiter string.") (p "The GRAMMAR argument is a symbol that determines how the delimiter is used, and defaults to " (tt "'infix") ".") (ul (li (tt "'infix") " means an infix or separator grammar: insert the delimiter between list elements. An empty list will produce an empty string -- note, however, that parsing an empty string with an infix or separator grammar is ambiguous. Is it an empty list, or a list of one element, the empty string? ") (li (tt "'strict-infix") " means the same as " (tt "'infix") ", but will raise an error if given an empty list. ") (li (tt "'suffix") " means a suffix or terminator grammar: insert the delimiter after every list element. This grammar has no ambiguities. ") (li (tt "'prefix") " means a prefix grammar: insert the delimiter before every list element. This grammar has no ambiguities. ")) (p "The delimiter is the string used to delimit elements; it defaults to a single space \" \".") (pre "(string-join '(\"foo\" \"bar\" \"baz\") \":\")         => \"foo:bar:baz\"\n(string-join '(\"foo\" \"bar\" \"baz\") \":\" 'suffix) => \"foo:bar:baz:\"\n \n;; Infix grammar is ambiguous wrt empty list vs. empty string,\n(string-join '()   \":\") => \"\"\n(string-join '(\"\") \":\") => \"\"\n \n;; but suffix & prefix grammars are not.\n(string-join '()   \":\" 'suffix) => \"\"\n(string-join '(\"\") \":\" 'suffix) => \":\""))
(def (sig (procedure "(string-copy s [start end]) -> string" (id string-copy)) (procedure "(substring/shared s start [end]) -> string" (id substring/shared))) (p "[R5RS+] " (tt "substring/shared") " returns a string whose contents are the characters of S beginning with index START (inclusive) and ending with index END (exclusive). It differs from the R5RS " (tt "substring") " in two ways:") (ul (li "The END parameter is optional, not required. ") (li (tt "substring/shared") " may return a value that shares memory with S or is " (tt "eq?") " to S. ")) (p (tt "string-copy") " is extended from its R5RS definition by the addition of its optional START/END parameters. In contrast to " (tt "substring/shared") ", it is guaranteed to produce a freshly-allocated string.") (p "Use " (tt "string-copy") " when you want to indicate explicitly in your code that you wish to allocate new storage; use " (tt "substring/shared") " when you don't care if you get a fresh copy or share storage with the original string.") (pre "(string-copy \"Beta substitution\") => \"Beta substitution\"\n(string-copy \"Beta substitution\" 1 10) \n    => \"eta subst\"\n(string-copy \"Beta substitution\" 5) => \"substitution\""))
(def (sig (procedure "(string-copy! target tstart s [start end]) -> unspecified" (id string-copy!))) (p "Copy the sequence of characters from index range [START,END) in string S to string TARGET, beginning at index TSTART. The characters are copied left-to-right or right-to-left as needed -- the copy is guaranteed to work, even if TARGET and S are the same string.") (p "It is an error if the copy operation runs off the end of the target string, " (i "e.g.")) (pre "(string-copy! (string-copy \"Microsoft\") 0\n              \"Regional Microsoft Operating Companies\") => ''error''"))
(def (sig (procedure "(string-take s nchars) -> string" (id string-take)) (procedure "(string-drop s nchars) -> string" (id string-drop)) (procedure "(string-take-right s nchars) -> string" (id string-take-right)) (procedure "(string-drop-right s nchars) -> string" (id string-drop-right))) (p (tt "string-take") " returns the first NCHARS of S; " (tt "string-drop") " returns all but the first NCHARS of S. " (tt "string-take-right") " returns the last NCHARS of S; " (tt "string-drop-right") " returns all but the last NCHARS of S. If these procedures produce the entire string, they may return either S or a copy of S; in some implementations, proper substrings may share memory with S.") (pre "(string-take \"Pete Szilagyi\" 6) => \"Pete S\"\n(string-drop \"Pete Szilagyi\" 6) => \"zilagyi\"\n \n(string-take-right \"Beta rules\" 5) => \"rules\"\n(string-drop-right \"Beta rules\" 5) => \"Beta \"") (p "It is an error to take or drop more characters than are in the string:") (pre "(string-take \"foo\" 37) => ''error''"))
(def (sig (procedure "(string-pad s len [char start end]) -> string" (id string-pad)) (procedure "(string-pad-right s len [char start end]) -> string" (id string-pad-right))) (p "Build a string of length LEN comprised of S padded on the left (right) by as many occurrences of the character CHAR as needed. If S has more than LEN chars, it is truncated on the left (right) to length LEN. CHAR defaults to #\\space.") (p "If LEN <= END-START, the returned value is allowed to share storage with S, or be exactly S (if LEN = END-START).") (pre "(string-pad     \"325\" 5) => \"  325\"\n(string-pad   \"71325\" 5) => \"71325\"\n(string-pad \"8871325\" 5) => \"71325\""))
(def (sig (procedure "(string-trim s [char/char-set/pred start end]) -> string" (id string-trim)) (procedure "(string-trim-right s [char/char-set/pred start end]) -> string" (id string-trim-right)) (procedure "(string-trim-both s [char/char-set/pred start end]) -> string" (id string-trim-both))) (p "Trim S by skipping over all characters on the left / on the right / on both sides that satisfy the second parameter CHAR/CHAR-SET/PRED:") (ul (li "if it is a character CHAR, characters equal to CHAR are trimmed; ") (li "if it is a char set CS, characters contained in CS are trimmed; ") (li "if it is a predicate PRED, it is a test predicate that is applied to the characters in S; a character causing it to return true is skipped. ")) (p "CHAR/CHAR-SET/PRED defaults to the character set " (tt "char-set:whitespace") " defined in SRFI 14.") (p "If no trimming occurs, these functions may return either S or a copy of S; in some implementations, proper substrings may share memory with S.") (pre "(string-trim-both \"  The outlook wasn't brilliant,  \\n\\r\")\n    => \"The outlook wasn't brilliant,\""))
(def (sig (procedure "(string-fill! s char [start end]) -> unspecified" (id string-fill!))) (p "[R5RS+] Stores CHAR in every element of S.") (p (tt "string-fill") " is extended from the R5RS definition to take optional START/END arguments."))
(def (sig (procedure "(string-compare s1 s2 proc< proc= proc> [start1 end1 start2 end2]) -> values" (id string-compare)) (procedure "(string-compare-ci s1 s2 proc< proc= proc> [start1 end1 start2 end2]) -> values" (id string-compare-ci))) (p "Apply PROC<, PROC=, or PROC> to the mismatch index, depending upon whether S1 is less than, equal to, or greater than S2. The \"mismatch index\" is the largest index I such that for every 0 <= J < I, S1[J] = S2[J] -- that is, I is the first position that doesn't match.") (p (tt "string-compare-ci") " is the case-insensitive variant. Case-insensitive comparison is done by case-folding characters with the operation") (pre "(char-downcase (char-upcase C))") (p "where the two case-mapping operations are assumed to be 1-1, locale- and context-insensitive, and compatible with the 1-1 case mappings specified by Unicode's UnicodeData.txt table:") (p (link "ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt")) (p "The optional start/end indices restrict the comparison to the indicated substrings of S1 and S2. The mismatch index is always an index into S1; in the case of PROC=, it is always END1; we observe the protocol in this redundant case for uniformity.") (pre "(string-compare \"The cat in the hat\" \"abcdefgh\" \n                values values values\n                4 6         ; Select \"ca\" \n                2 4)        ; & \"cd\"\n    => 5    ; Index of S1's \"a\"") (p "Comparison is simply done on individual code-points of the string. True text collation is not handled by this SRFI."))
(def (sig (procedure "(string= s1 s2 [start1 end1 start2 end2]) -> boolean" (id string=)) (procedure "(string<> s1 s2 [start1 end1 start2 end2]) -> boolean" (id string<>)) (procedure "(string< s1 s2 [start1 end1 start2 end2]) -> boolean" (id string<)) (procedure "(string> s1 s2 [start1 end1 start2 end2]) -> boolean" (id string>)) (procedure "(string<= s1 s2 [start1 end1 start2 end2]) -> boolean" (id string<=)) (procedure "(string>= s1 s2 [start1 end1 start2 end2]) -> boolean" (id string>=))) (p "These procedures are the lexicographic extensions to strings of the corresponding orderings on characters. For example, " (tt "string<") " is the lexicographic ordering on strings induced by the ordering " (tt "char<?") " on characters. If two strings differ in length but are the same up to the length of the shorter string, the shorter string is considered to be lexicographically less than the longer string.") (p "The optional start/end indices restrict the comparison to the indicated substrings of S1 and S2.") (p "Comparison is simply done on individual code-points of the string. True text collation is not handled by this SRFI."))
(def (sig (procedure "(string-ci= s1 s2 [start1 end1 start2 end2]) -> boolean" (id string-ci=)) (procedure "(string-ci<> s1 s2 [start1 end1 start2 end2]) -> boolean" (id string-ci<>)) (procedure "(string-ci< s1 s2 [start1 end1 start2 end2]) -> boolean" (id string-ci<)) (procedure "(string-ci> s1 s2 [start1 end1 start2 end2]) -> boolean" (id string-ci>)) (procedure "(string-ci<= s1 s2 [start1 end1 start2 end2]) -> boolean" (id string-ci<=)) (procedure "(string-ci>= s1 s2 [start1 end1 start2 end2]) -> boolean" (id string-ci>=))) (p "Case-insensitive variants.") (p "Case-insensitive comparison is done by case-folding characters with the operation") (pre "(char-downcase (char-upcase C))") (p "where the two case-mapping operations are assumed to be 1-1, locale- and context-insensitive, and compatible with the 1-1 case mappings specified by Unicode's UnicodeData.txt table:") (p (link "ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt")))
(def (sig (procedure "(string-hash s [bound start end]) -> integer" (id string-hash)) (procedure "(string-hash-ci s [bound start end]) -> integer" (id string-hash-ci))) (p "Compute a hash value for the string S. BOUND is a non-negative exact integer specifying the range of the hash function. A positive value restricts the return value to the range [0,BOUND).") (p "If BOUND is either zero or not given, the implementation may use an implementation-specific default value, chosen to be as large as is efficiently practical. For instance, the default range might be chosen for a given implementation to map all strings into the range of integers that can be represented with a single machine word.") (p "The optional start/end indices restrict the hash operation to the indicated substring of S.") (p (tt "string-hash-ci") " is the case-insensitive variant. Case-insensitive comparison is done by case-folding characters with the operation") (pre "(char-downcase (char-upcase C))") (p "where the two case-mapping operations are assumed to be 1-1, locale- and context-insensitive, and compatible with the 1-1 case mappings specified by Unicode's UnicodeData.txt table:") (p (link "ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt")) (p "Invariants:") (pre "(<= 0 (string-hash s b) (- b 1)) ; When B > 0.\n(string=    s1 s2)  =>  (= (string-hash s1 b)    (string-hash s2 b))\n(string-ci= s1 s2)  =>  (= (string-hash-ci s1 b) (string-hash-ci s2 b))") (p "A legal but nonetheless discouraged implementation:") (pre "(define (string-hash    s . other-args) 1)\n(define (string-hash-ci s . other-args) 1)") (p "Rationale: allowing the user to specify an explicit bound simplifies user code by removing the mod operation that typically accompanies every hash computation, and also may allow the implementation of the hash function to exploit a reduced range to efficiently compute the hash value. " (i "E.g.") ", for small bounds, the hash function may be computed in a fashion such that intermediate values never overflow into bignum integers, allowing the implementor to provide a fixnum-specific \"fast path\" for computing the common cases very rapidly."))
(def (sig (procedure "(string-prefix-length s1 s2 [start1 end1 start2 end2]) -> integer" (id string-prefix-length)) (procedure "(string-suffix-length s1 s2 [start1 end1 start2 end2]) -> integer" (id string-suffix-length)) (procedure "(string-prefix-length-ci s1 s2 [start1 end1 start2 end2]) -> integer" (id string-prefix-length-ci)) (procedure "(string-suffix-length-ci s1 s2 [start1 end1 start2 end2]) -> integer" (id string-suffix-length-ci))) (p "Return the length of the longest common prefix/suffix of the two strings. For prefixes, this is equivalent to the \"mismatch index\" for the strings (modulo the STARTi index offsets).") (p "The optional start/end indices restrict the comparison to the indicated substrings of S1 and S2.") (p (tt "string-prefix-length-ci") " and " (tt "string-suffix-length-ci") " are the case-insensitive variants. Case-insensitive comparison is done by case-folding characters with the operation") (pre "(char-downcase (char-upcase c))") (p "where the two case-mapping operations are assumed to be 1-1, locale- and context-insensitive, and compatible with the 1-1 case mappings specified by Unicode's UnicodeData.txt table:") (p (link "ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt")) (p "Comparison is simply done on individual code-points of the string."))
(def (sig (procedure "(string-prefix? s1 s2 [start1 end1 start2 end2]) -> boolean" (id string-prefix?)) (procedure "(string-suffix? s1 s2 [start1 end1 start2 end2]) -> boolean" (id string-suffix?)) (procedure "(string-prefix-ci? s1 s2 [start1 end1 start2 end2]) -> boolean" (id string-prefix-ci?)) (procedure "(string-suffix-ci? s1 s2 [start1 end1 start2 end2]) -> boolean" (id string-suffix-ci?))) (p "Is S1 a prefix/suffix of S2?") (p "The optional start/end indices restrict the comparison to the indicated substrings of S1 and S2.") (p (tt "string-prefix-ci?") " and " (tt "string-suffix-ci?") " are the case-insensitive variants. Case-insensitive comparison is done by case-folding characters with the operation") (pre "(char-downcase (char-upcase c))") (p "where the two case-mapping operations are assumed to be 1-1, locale- and context-insensitive, and compatible with the 1-1 case mappings specified by Unicode's UnicodeData.txt table:") (p (link "ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt")) (p "Comparison is simply done on individual code-points of the string."))
(def (sig (procedure "(string-index s char/char-set/pred [start end]) -> integer or #f" (id string-index)) (procedure "(string-index-right s char/char-set/pred [start end]) -> integer or #f" (id string-index-right)) (procedure "(string-skip s char/char-set/pred [start end]) -> integer or #f" (id string-skip)) (procedure "(string-skip-right s char/char-set/pred [start end]) -> integer or #f" (id string-skip-right))) (p (tt "string-index") " (" (tt "string-index-right") ") searches through the string from the left (right), returning the index of the first occurrence of a character which") (ul (li "equals CHAR/CHAR-SET/PRED (if it is a character); ") (li "is in CHAR/CHAR-SET/PRED (if it is a character set); ") (li "satisfies the predicate CHAR/CHAR-SET/PRED (if it is a procedure). ")) (p "If no match is found, the functions return false.") (p "The START and END parameters specify the beginning and end indices of the search; the search includes the start index, but not the end index. Be careful of \"fencepost\" considerations: when searching right-to-left, the first index considered is") (p "END-1") (p "whereas when searching left-to-right, the first index considered is") (p "START") (p "That is, the start/end indices describe a same half-open interval [START,END) in these procedures that they do in all the other SRFI 13 procedures.") (p "The skip functions are similar, but use the complement of the criteria: they search for the first char that ''doesn't" (i " satisfy the test. ") "E.g.'', to skip over initial whitespace, say") (pre "(cond ((string-skip s char-set:whitespace) =>") (pre "       (lambda (i) ...)) ; s[i] is not whitespace.\n      ...)"))
(def (sig (procedure "(string-count s char/char-set/pred [start end]) -> integer" (id string-count))) (p "Return a count of the number of characters in S that satisfy the CHAR/CHAR-SET/PRED argument. If this argument is a procedure, it is applied to the character as a predicate; if it is a character set, the character is tested for membership; if it is a character, it is used in an equality test."))
(def (sig (procedure "(string-contains s1 s2 [start1 end1 start2 end2]) -> integer or false" (id string-contains)) (procedure "(string-contains-ci s1 s2 [start1 end1 start2 end2]) -> integer or false" (id string-contains-ci))) (p "Does string S1 contain string S2?") (p "Return the index in S1 where S2 occurs as a substring, or false. The optional start/end indices restrict the operation to the indicated substrings.") (p "The returned index is in the range [START1,END1). A successful match must lie entirely in the [START1,END1) range of S1.") (pre "(string-contains \"eek -- what a geek.\" \"ee\"\n                 12 18) ; Searches \"a geek\"\n    => 15") (p (tt "string-contains-ci") " is the case-insensitive variant. Case-insensitive comparison is done by case-folding characters with the operation") (pre "(char-downcase (char-upcase C))") (p "where the two case-mapping operations are assumed to be 1-1, locale- and context-insensitive, and compatible with the 1-1 case mappings specified by Unicode's UnicodeData.txt table:") (p (link "ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt")) (p "Comparison is simply done on individual code-points of the string.") (p "The names of these procedures do not end with a question mark -- this is to indicate that they do not return a simple boolean (" (tt "#t") " or " (tt "#f") "). Rather, they return either false (" (tt "#f") ") or an exact non-negative integer."))
(def (sig (procedure "(string-titlecase s [start end]) -> string" (id string-titlecase)) (procedure "(string-titlecase! s [start end]) -> unspecified" (id string-titlecase!))) (p "For every character C in the selected range of S, if C is preceded by a cased character, it is downcased; otherwise it is titlecased.") (p (tt "string-titlecase") " returns the result string and does not alter its S parameter. " (tt "string-titlecase!") " is the in-place side-effecting variant.") (pre "(string-titlecase \"--capitalize tHIS sentence.\") =>\n  \"--Capitalize This Sentence.\"\n \n(string-titlecase \"see Spot run. see Nix run.\") =>\n  \"See Spot Run. See Nix Run.\"\n \n(string-titlecase \"3com makes routers.\") =>\n  \"3Com Makes Routers.\"") (p "Note that if a START index is specified, then the character preceding S[START] has no effect on the titlecase decision for character S[START]:") (pre "(string-titlecase \"greasy fried chicken\" 2) => \"Easy Fried Chicken\"") (p "Titlecase and cased information must be compatible with the Unicode specification."))
(def (sig (procedure "(string-upcase s [start end]) -> string" (id string-upcase)) (procedure "(string-upcase! s [start end]) -> unspecified" (id string-upcase!)) (procedure "(string-downcase s [start end]) -> string" (id string-downcase)) (procedure "(string-downcase! s [start end]) -> unspecified" (id string-downcase!))) (p "Raise or lower the case of the alphabetic characters in the string.") (p (tt "string-upcase") " and " (tt "string-downcase") " return the result string and do not alter their S parameter. " (tt "string-upcase!") " and " (tt "string-downcase!") " are the in-place side-effecting variants.") (p "These procedures use the locale- and context-insensitive 1-1 case mappings defined by Unicode's UnicodeData.txt table:") (p (link "ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt")))
(def (sig (procedure "(string-reverse s [start end]) -> string" (id string-reverse)) (procedure "(string-reverse! s [start end]) -> unspecified" (id string-reverse!))) (p "Reverse the string.") (p (tt "string-reverse") " returns the result string and does not alter its S parameter. " (tt "string-reverse!") " is the in-place side-effecting variant.") (pre "(string-reverse \"Able was I ere I saw elba.\") \n    => \".able was I ere I saw elbA\"\n \n;;; In-place rotate-left, the Bell Labs way:\n(lambda (s i)\n  (let ((i (modulo i (string-length s))))\n    (string-reverse! s 0 i)\n    (string-reverse! s i)\n    (string-reverse! s)))") (p "Unicode note: Reversing a string simply reverses the sequence of code-points it contains. So a zero-width accent character A coming " (i "after") " a base character B in string S would come out " (i "before") " B in the reversed result."))
(def (sig (procedure "(string-concatenate string-list) -> string" (id string-concatenate))) (p "Append the elements of " (tt "string-list") " together into a single string. Guaranteed to return a freshly allocated string.") (p "Note that the " (tt "(apply string-append STRING-LIST)") " idiom is not robust for long lists of strings, as some Scheme implementations limit the number of arguments that may be passed to an n-ary procedure."))
(def (sig (procedure "(string-concatenate/shared string-list) -> string" (id string-concatenate/shared)) (procedure "(string-append/shared s_1 ...) -> string" (id string-append/shared))) (p "These two procedures are variants of " (tt "string-concatenate") " and " (tt "string-append") " that are permitted to return results that share storage with their parameters. In particular, if " (tt "string-append/shared") " is applied to just one argument, it may return exactly that argument, whereas " (tt "string-append") " is required to allocate a fresh string."))
(def (sig (procedure "(string-concatenate-reverse string-list [final-string end]) -> string" (id string-concatenate-reverse)) (procedure "(string-concatenate-reverse/shared string-list [final-string end]) -> string" (id string-concatenate-reverse/shared))) (p "With no optional arguments, these functions are equivalent to") (pre "(string-concatenate (reverse STRING-LIST))") (p "and") (pre "(string-concatenate/shared (reverse STRING-LIST))") (p "respectively.") (p "If the optional argument FINAL-STRING is specified, it is consed onto the beginning of STRING-LIST before performing the list-reverse and string-concatenate operations.") (p "If the optional argument END is given, only the first END characters of FINAL-STRING are added to the string list, thus producing") (pre "(string-concatenate \n  (reverse (cons (substring/shared FINAL-STRING 0 END)\n                 STRING-LIST)))") (p (i "E.g.")) (pre "(string-concatenate-reverse '(\" must be\" \"Hello, I\") \" going.XXXX\" 7)\n  => \"Hello, I must be going.\"") (p "This procedure is useful in the construction of procedures that accumulate character data into lists of string buffers, and wish to convert the accumulated data into a single string when done.") (p "Unicode note: Reversing a string simply reverses the sequence of code-points it contains. So a zero-width accent character AC coming " (i "after") " a base character BC in string S would come out " (i "before") " BC in the reversed result."))
(def (sig (procedure "(string-map proc s [start end]) -> string" (id string-map)) (procedure "(string-map! proc s [start end]) -> unspecified" (id string-map!))) (p "PROC is a char->char procedure; it is mapped over S.") (p (tt "string-map") " returns the result string and does not alter its S parameter. " (tt "string-map!") " is the in-place side-effecting variant.") (p "Note: The order in which PROC is applied to the elements of S is not specified."))
(def (sig (procedure "(string-fold kons knil s [start end]) -> value" (id string-fold)) (procedure "(string-fold-right kons knil s [start end]) -> value" (id string-fold-right))) (p "These are the fundamental iterators for strings.") (p "The left-fold operator maps the KONS procedure across the string from left to right") (pre "(... (KONS S[2] (KONS S[1] (KONS S[0] KNIL))))") (p "In other words, " (tt "string-fold") " obeys the (tail) recursion") (pre "(string-fold KONS KNIL S START END) =\n    (string-fold KONS (KONS S[START] KNIL) START+1 END)") (p "The right-fold operator maps the KONS procedure across the string from right to left") (pre "(KONS S[0] (... (KONS S[END-3] (KONS S[END-2] (KONS S[END-1] KNIL)))))") (p "obeying the (tail) recursion") (pre "(string-fold-right KONS KNIL S START END) =\n    (string-fold-right KONS (KONS S[END-1] KNIL) START END-1)") (p "Examples:") (pre ";;; Convert a string to a list of chars.\n(string-fold-right cons '() s)\n \n;;; Count the number of lower-case characters in a string.\n(string-fold (lambda (c count)\n               (if (char-lower-case? c)\n                   (+ count 1)\n                   count))\n             0\n             s)\n \n;;; Double every backslash character in S.\n(let* ((ans-len (string-fold (lambda (c sum)\n                               (+ sum (if (char=? c #\\\\) 2 1)))\n                             0 s))\n       (ans (make-string ans-len)))\n  (string-fold (lambda (c i)\n                 (let ((i (if (char=? c #\\\\)\n                              (begin (string-set! ans i #\\\\) (+ i 1))\n                              i)))\n                   (string-set! ans i c)\n                   (+ i 1)))\n               0 s)\n  ans)") (p "The right-fold combinator is sometimes called a \"catamorphism.\""))
(def (sig (procedure "(string-unfold p f g seed [base make-final]) -> string" (id string-unfold))) (p "This is a fundamental constructor for strings.") (ul (li "G is used to generate a series of \"seed\" values from the initial seed: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ... ") (li "P tells us when to stop -- when it returns true when applied to one of these seed values. ") (li "F maps each seed value to the corresponding character in the result string. These chars are assembled into the string in a left-to-right order. ") (li "BASE is the optional initial/leftmost portion of the constructed string; it defaults to the empty string \"\". ") (li "MAKE-FINAL is applied to the terminal seed value (on which P returns true) to produce the final/rightmost portion of the constructed string. It defaults to " (tt "(lambda (x) \"\")") ". ")) (p "More precisely, the following (simple, inefficient) definitions hold:") (pre ";;; Iterative\n(define (string-unfold p f g seed base make-final)\n  (let lp ((seed seed) (ans base))\n    (if (p seed) \n        (string-append ans (make-final seed))\n        (lp (g seed) (string-append ans (string (f seed)))))))\n                                    \n;;; Recursive\n(define (string-unfold p f g seed base make-final)\n  (string-append base\n                 (let recur ((seed seed))\n                   (if (p seed) (make-final seed)\n                       (string-append (string (f seed))\n                                      (recur (g seed)))))))") (p (tt "string-unfold") " is a fairly powerful string constructor -- you can use it to convert a list to a string, read a port into a string, reverse a string, copy a string, and so forth. Examples:") (pre "(port->string p) = (string-unfold eof-object? values\n                                  (lambda (x) (read-char p))\n                                  (read-char p))\n \n(list->string lis) = (string-unfold null? car cdr lis)\n \n(string-tabulate f size) = (string-unfold (lambda (i) (= i size)) f add1 0)") (p "To map F over a list LIS, producing a string:") (pre "(string-unfold null? (compose f car) cdr lis)") (p "Interested functional programmers may enjoy noting that " (tt "string-fold-right") " and " (tt "string-unfold") " are in some sense inverses. That is, given operations KNULL?, KAR, KDR, KONS, and KNIL satisfying") (pre "(KONS (KAR x) (KDR x)) = x  and (KNULL? KNIL) = #t") (p "then") (pre "(string-fold-right KONS KNIL (string-unfold KNULL? KAR KDR X)) = X") (p "and") (pre "(string-unfold KNULL? KAR KDR (string-fold-right KONS KNIL S)) = S.") (p "The final string constructed does not share storage with either BASE or the value produced by MAKE-FINAL.") (p "This combinator sometimes is called an \"anamorphism.\"") (p "Note: implementations should take care that runtime stack limits do not cause overflow when constructing large (" (i "e.g.") ", megabyte) strings with " (tt "string-unfold") "."))
(def (sig (procedure "(string-unfold-right p f g seed [base make-final]) -> string" (id string-unfold-right))) (p "This is a fundamental constructor for strings.") (ul (li "G is used to generate a series of \"seed\" values from the initial seed: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ... ") (li "P tells us when to stop -- when it returns true when applied to one of these seed values. ") (li "F maps each seed value to the corresponding character in the result string. These chars are assembled into the string in a right-to-left order. ") (li "BASE is the optional initial/rightmost portion of the constructed string; it defaults to the empty string \"\". ") (li "MAKE-FINAL is applied to the terminal seed value (on which P returns true) to produce the final/leftmost portion of the constructed string. It defaults to " (tt "(lambda (x) \"\")") ". ")) (p "More precisely, the following (simple, inefficient) definitions hold:") (pre ";;; Iterative\n(define (string-unfold-right p f g seed base make-final)\n  (let lp ((seed seed) (ans base))\n    (if (p seed) \n        (string-append (make-final seed) ans)\n        (lp (g seed) (string-append (string (f seed)) ans)))))\n \n;;; Recursive\n(define (string-unfold-right p f g seed base make-final)\n  (string-append (let recur ((seed seed))\n                   (if (p seed) (make-final seed)\n                       (string-append (recur (g seed))\n                                      (string (f seed)))))\n                 base))") (p "Interested functional programmers may enjoy noting that " (tt "string-fold") " and " (tt "string-unfold-right") " are in some sense inverses. That is, given operations KNULL?, KAR, KDR, KONS, and KNIL satisfying") (p (tt "(KONS (KAR X) (KDR X))") " = X and " (tt "(KNULL? KNIL)") " = #t") (p "then") (pre "(string-fold KONS KNIL (string-unfold-right KNULL? KAR KDR X)) = X") (p "and") (pre "(string-unfold-right KNULL? KAR KDR (string-fold KONS KNIL S)) = S.") (p "The final string constructed does not share storage with either BASE or the value produced by MAKE-FINAL.") (p "Note: implementations should take care that runtime stack limits do not cause overflow when constructing large (" (i "e.g.") ", megabyte) strings with " (tt "string-unfold-right.")))
(def (sig (procedure "(string-for-each proc s [start end]) -> unspecified" (id string-for-each))) (p "Apply PROC to each character in S. " (tt "string-for-each") " is required to iterate from START to END in increasing order."))
(def (sig (procedure "(string-for-each-index proc s [start end]) -> unspecified" (id string-for-each-index))) (p "Apply PROC to each index of S, in order. The optional START/END pairs restrict the endpoints of the loop. This is simply a method of looping over a string that is guaranteed to be safe and correct. Example:") (pre "(let* ((len (string-length s))\n       (ans (make-string len)))\n  (string-for-each-index\n      (lambda (i) (string-set! ans (- len i) (string-ref s i)))\n      s)\n  ans)"))
(def (sig (procedure "(xsubstring s from [to start end]) -> string" (id xsubstring))) (p "This is the \"extended substring\" procedure that implements replicated copying of a substring of some string.") (p "S is a string; START and END are optional arguments that demarcate a substring of S, defaulting to 0 and the length of S (" (i "i.e.") ", the whole string). Replicate this substring up and down index space, in both the positive and negative directions. For example, if S = \"abcdefg\", START=3, and END=6, then we have the conceptual bidirectionally-infinite string") (table (tr (td "...") (td "d") (td "e") (td "f") (td "d") (td "e") (td "f") (td "d") (td "e") (td "f") (td "d") (td "e") (td "f") (td "d") (td "e") (td "f") (td "d") (td "e") (td "f") (td "d") (td "...")) "\n" (tr (td "...") (td "-9") (td "-8") (td "-7") (td "-6") (td "-5") (td "-4") (td "-3") (td "-2") (td "-1") (td "0") (td "+1") (td "+2") (td "+3") (td "+4") (td "+5") (td "+6") (td "+7") (td "+8") (td "+9") (td "..."))) (p (tt "xsubstring") " returns the substring of this string beginning at index FROM, and ending at TO (which defaults to FROM+(END-START)).") (p "You can use " (tt "xsubstring") " to perform a variety of tasks:") (ul (li "To rotate a string left: " (tt "(xsubstring \"abcdef\" 2)") " => " (tt "\"cdefab\"") " ") (li "To rotate a string right: " (tt "(xsubstring \"abcdef\" -2)") " => " (tt "\"efabcd\"") " ") (li "To replicate a string: " (tt "(xsubstring \"abc\" 0 7)") " => " (tt "\"abcabca\"") " ")) (p "Note that") (ul (li "The FROM/TO indices give a half-open range -- the characters from index FROM up to, but not including, index TO. ") (li "The FROM/TO indices are not in terms of the index space for string S. They are in terms of the replicated index space of the substring defined by S, START, and END. ")) (p "It is an error if START=END -- although this is allowed by special dispensation when FROM=TO."))
(def (sig (procedure "(string-xcopy! target tstart s sfrom [sto start end]) -> unspecified" (id string-xcopy!))) (p "Exactly the same as " (tt "xsubstring,") " but the extracted text is written into the string TARGET starting at index TSTART. This operation is not defined if " (tt "(eq? TARGET S)") " or these two arguments share storage -- you cannot copy a string on top of itself."))
(def (sig (procedure "(string-replace s1 s2 start1 end1 [start2 end2]) -> string" (id string-replace))) (p "Returns") (pre "(string-append (substring/shared S1 0 START1)\n               (substring/shared S2 START2 END2)\n               (substring/shared S1 END1 (string-length S1)))") (p "That is, the segment of characters in S1 from START1 to END1 is replaced by the segment of characters in S2 from START2 to END2. If START1=END1, this simply splices the S2 characters into S1 at the specified index.") (p "Examples:") (pre "(string-replace \"The TCL programmer endured daily ridicule.\"\n                \"another miserable perl drone\" 4 7 8 22 ) =>\n    \"The miserable perl programmer endured daily ridicule.\"\n \n(string-replace \"It's easy to code it up in Scheme.\" \"lots of fun\" 5 9) =>\n    \"It's lots of fun to code it up in Scheme.\"\n \n(define (string-insert s i t) (string-replace s t i i))\n \n(string-insert \"It's easy to code it up in Scheme.\" 5 \"really \") =>\n    \"It's really easy to code it up in Scheme.\""))
(def (sig (procedure "(string-tokenize s [token-set start end]) -> list" (id string-tokenize))) (p "Split the string S into a list of substrings, where each substring is a maximal non-empty contiguous sequence of characters from the character set TOKEN-SET.") (ul (li "TOKEN-SET defaults to " (tt "char-set:graphic") " (see SRFI 14 for more on character sets and " (tt "char-set:graphic") "). ") (li "If START or END indices are provided, they restrict " (tt "string-tokenize") " to operating on the indicated substring of S. ")) (p "This function provides a minimal parsing facility for simple applications. More sophisticated parsers that handle quoting and backslash effects can easily be constructed using regular-expression systems; be careful not to use " (tt "string-tokenize") " in contexts where more serious parsing is needed.") (pre "(string-tokenize \"Help make programs run, run, RUN!\") =>\n  (\"Help\" \"make\" \"programs\" \"run,\" \"run,\" \"RUN!\")"))
(def (sig (procedure "(string-filter char/char-set/pred s [start end]) -> string" (id string-filter)) (procedure "(string-delete har/char-set/pred s [start end]) -> string" (id string-delete))) (p "Filter the string S, retaining only those characters that satisfy / do not satisfy the CHAR/CHAR-SET/PRED argument. If this argument is a procedure, it is applied to the character as a predicate; if it is a char-set, the character is tested for membership; if it is a character, it is used in an equality test.") (p "If the string is unaltered by the filtering operation, these functions may return either S or a copy of S."))
(def (sig (procedure "(string-parse-start+end proc s args) -> [rest start end]" (id string-parse-start+end)) (procedure "(string-parse-final-start+end proc s args) -> [start end]" (id string-parse-final-start+end))) (p (tt "string-parse-start+end") " may be used to parse a pair of optional START/END arguments from an argument list, defaulting them to 0 and the length of some string S, respectively. Let the length of string S be SLEN.") (ul (li "If ARGS = (), the function returns " (tt "(values '() 0 SLEN)") " ") (li "If ARGS = (I), I is checked to ensure it is an exact integer, and that 0 <= i <= SLEN. Returns " (tt "(values (cdr ARGS) I SLEN)") ". ") (li "If ARGS = " (tt "(I J ...)") ", I and J are checked to ensure they are exact integers, and that 0 <= I <= J <= SLEN. Returns " (tt "(values (cddr ARGS) I J)") ". ")) (p "If any of the checks fail, an error condition is raised, and PROC is used as part of the error condition -- it should be the client procedure whose argument list " (tt "string-parse-start+end") " is parsing.") (p (tt "string-parse-final-start+end") " is exactly the same, except that the args list passed to it is required to be of length two or less; if it is longer, an error condition is raised. It may be used when the optional START/END parameters are final arguments to the procedure.") (p "Note that in all cases, these functions ensure that S is a string (by necessity, since all cases apply " (tt "string-length") " to S either to default END or to bounds-check it)."))
(def (sig (procedure "(let-string-start+end (start end [rest]) proc-exp s-exp args-exp body ...) -> value(s)" (id let-string-start+end))) (p "[Syntax] Syntactic sugar for an application of " (tt "string-parse-start+end") " or " (tt "string-parse-final-start+end.")) (p "If a REST variable is given, the form is equivalent to") (pre "(call-with-values\n    (lambda () (string-parse-start+end PROC-EXP S-EXP ARGS-EXP))\n  (lambda (REST START END) BODY ...))") (p "If no REST variable is given, the form is equivalent to") (pre "(call-with-values\n    (lambda () (string-parse-final-start+end PROC-EXP S-EXP ARGS-EXP))\n  (lambda (START END) BODY ...))"))
(def (sig (procedure "(check-substring-spec proc s start end) -> unspecified" (id check-substring-spec)) (procedure "(substring-spec-ok? s start end) -> boolean" (id substring-spec-ok?))) (p "Check values S, START and END to ensure they specify a valid substring. This means that S is a string, START and END are exact integers, and 0 <= START <= END <= " (tt "(string-length S)")) (p "If the values are not proper") (ul (li (tt "check-substring-spec") " raises an error condition. PROC is used as part of the error condition, and should be the procedure whose parameters we are checking. ") (li (tt "substring-spec-ok?") " returns false. ")) (p "Otherwise, " (tt "substring-spec-ok?") " returns true, and " (tt "check-substring-spec") " simply returns (what it returns is not specified)."))
(def (sig (procedure "(make-kmp-restart-vector s [c= start end]) -> integer-vector" (id make-kmp-restart-vector))) (p "Build a Knuth-Morris-Pratt \"restart vector,\" which is useful for quickly searching character sequences for the occurrence of string S (or the substring of S demarcated by the optional START/END parameters, if provided). C= is a character-equality function used to construct the restart vector. It defaults to " (tt "char=?") "; use " (tt "char-ci=?") " instead for case-folded string search.") (p "The definition of the restart vector RV for string S is: If we have matched chars 0..I-1 of S against some search string SS, and S[I] doesn't match SS[K], then reset I := RV[I], and try again to match SS[K]. If RV[I] = -1, then punt SS[K] completely, and move on to SS[K+1] and S[0].") (p "In other words, if you have matched the first I chars of S, but the I+1'th char doesn't match, RV[I] tells you what the next-longest prefix of S is that you have matched.") (p "The following string-search function shows how a restart vector is used to search. Note the attractive feature of the search process: it is \"on line,\" that is, it never needs to back up and reconsider previously seen data. It simply consumes characters one-at-a-time until declaring a complete match or reaching the end of the sequence. Thus, it can be easily adapted to search other character sequences (such as ports) that do not provide random access to their contents.") (pre "(define (find-substring pattern source start end)\n  (let ((plen (string-length pattern))\n        (rv (make-kmp-restart-vector pattern)))\n \n    ;; The search loop. SJ & PJ are redundant state.\n    (let lp ((si start) (pi 0)\n             (sj (- end start))     ; (- end si)  -- how many chars left.\n             (pj plen))             ; (- plen pi) -- how many chars left.\n \n      (if (= pi plen) (- si plen)                   ; Win.\n \n          (and (<= pj sj)                           ; Lose.\n \n               (if (char=? (string-ref source si)           ; Test.\n                           (string-ref pattern pi))\n                   (lp (+ 1 si) (+ 1 pi) (- sj 1) (- pj 1)) ; Advance.\n \n                   (let ((pi (vector-ref rv pi)))           ; Retreat.\n                     (if (= pi -1)\n                         (lp (+ si 1)  0   (- sj 1)  plen)  ; Punt.\n                         (lp si        pi  sj        (- plen pi))))))))))") (p "The optional START/END parameters restrict the restart vector to the indicated substring of PAT; RV is END - START elements long. If START > 0, then RV is offset by START elements from PAT. That is, RV[I] describes pattern element PAT[I + START]. Elements of RV are themselves indices that range just over [0, END-START), " (i "not") " [START, END).") (p "Rationale: the actual value of RV is \"position independent\" -- it does not depend on where in the PAT string the pattern occurs, but only on the actual characters comprising the pattern."))
(def (sig (procedure "(kmp-step pat rv c i c= p-start) -> integer" (id kmp-step))) (p "This function encapsulates the work performed by one step of the KMP string search; it can be used to scan strings, input ports, or other on-line character sources for fixed strings.") (p "PAT is the non-empty string specifying the text for which we are searching. RV is the Knuth-Morris-Pratt restart vector for the pattern, as constructed by " (tt "make-kmp-restart-vector.") " The pattern begins at PAT[P-START], and is " (tt "(string-length RV)") " characters long. C= is the character-equality function used to construct the restart vector, typically " (tt "char=?") " or " (tt "char-ci=?") ".") (p "Suppose the pattern is N characters in length: PAT[P-START, P-START + N). We have already matched I characters: PAT[P-START, P-START + I). (P-START is typically zero.) C is the next character in the input stream. " (tt "kmp-step") " returns the new I value -- that is, how much of the pattern we have matched, " (i "including") " character C. When I reaches N, the entire pattern has been matched.") (p "Thus a typical search loop looks like this:") (pre "(let lp ((i 0))\n  (or (= i n)                           ; Win -- #t\n      (and (not (end-of-stream))        ; Lose -- #f\n           (lp (kmp-step pat rv (get-next-character) i char=? 0)))))") (p "Example:") (pre ";; Read chars from IPORT until we find string PAT or hit EOF.\n(define (port-skip pat iport)\n  (let* ((rv (make-kmp-restart-vector pat))\n         (patlen (string-length pat)))\n    (let lp ((i 0) (nchars 0))\n      (if (= i patlen) nchars                    ; Win -- nchars skipped\n          (let ((c (read-char iport)))\n            (if (eof-object? c) c                ; Fail -- EOF\n                (lp (kmp-step pat rv c i char=? 0) ; Continue\n                    (+ nchars 1))))))))") (p "This procedure could be defined as follows:") (pre "(define (kmp-step pat rv c i c= p-start)\n  (let lp ((i i))\n    (if (c= c (string-ref pat (+ i p-start)))     ; Match =>\n        (+ i 1)                                   ;   Done.\n        (let ((i (vector-ref rv i)))              ; Back up in PAT.\n          (if (= i -1) 0                          ; Can't back up more.\n              (lp i)))))))                        ; Keep going.") (p "Rationale: this procedure takes no optional arguments because it is intended as an inner-loop primitive and we do not want any run-time penalty for optional-argument parsing and defaulting, nor do we wish barriers to procedure integration/inlining."))
(def (sig (procedure "(string-kmp-partial-search pat rv s i [c= p-start s-start s-end]) -> integer" (id string-kmp-partial-search))) (p "Applies " (tt "kmp-step") " across S; optional S-START/S-END bounds parameters restrict search to a substring of S. The pattern is " (tt "(vector-length RV)") " characters long; optional P-START index indicates non-zero start of pattern in PAT.") (p "Suppose PLEN = " (tt "(vector-length RV)") " is the length of the pattern. I is an integer index into the pattern (that is, 0 <= I < PLEN) indicating how much of the pattern has already been matched. (This means the pattern must be non-empty -- PLEN > 0.)") (ul (li "On success, returns -J, where J is the index in S bounding the " (i "end") " of the pattern -- " (i "e.g.") ", a value that could be used as the END parameter in a call to " (tt "substring/shared") ". ") (li "On continue, returns the current search state I' (an index into RV) when the search reached the end of the string. This is a non-negative integer. ")) (p "Hence:") (ul (li "A negative return value indicates success, and says where in the string the match occured. ") (li "A non-negative return value provides the I to use for continued search in a following string. ")) (p "This utility is designed to allow searching for occurrences of a fixed string that might extend across multiple buffers of text. This is why, for example, we do not provide the index of the " (i "start") " of the match on success -- it may have occurred in a previous buffer.") (p "To search a character sequence that arrives in \"chunks,\" write a loop of this form:") (pre "(let lp ((i 0))\n  (and (not (end-of-data?))             ; Lose -- return #f.\n       (let* ((buf (get-next-chunk))    ; Get or fill up the buffer.\n              (i (string-kmp-partial-search pat rv buf i)))\n         (if (< i 0) (- i)              ; Win -- return end index.\n             (lp i)))))                 ; Keep looking.") (p "Modulo start/end optional-argument parsing, this procedure could be defined as follows:") (pre "(define (string-kmp-partial-search pat rv s i c= p-start s-start s-end)\n  (let ((patlen (vector-length rv)))\n    (let lp ((si s-start)       ; An index into S.\n             (vi i))            ; An index into RV.\n      (cond ((= vi patlen) (- si))      ; Win.\n            ((= si end) vi)             ; Ran off the end.\n            (else (lp (+ si 1)          ; Match s[si] & loop.\n                      (kmp-step pat rv (string-ref s si)\n                                vi c= p-start)))))))"))
