(index ("uri-reference" 0) ("absolute-uri" 318) ("uri-scheme" 794) ("uri-path" 794) ("uri-query" 794) ("uri-fragment" 794) ("uri-host" 794) ("uri-port" 794) ("uri-username" 794) ("uri-password" 794) ("update-uri" 1481) ("uri-reference?" 2150) ("absolute-uri?" 2516) ("uri?" 2632) ("relative-ref?" 2836) ("uri-path-absolute?" 3170) ("uri-path-relative?" 3316) ("uri-default-port?" 3461) ("uri-relative-to" 3627) ("uri-relative-from" 3825) ("form-urlencoded-separator" 4367) ("form-urlencode" 4367) ("form-urldecode" 4367) ("uri-encode-string" 6327) ("uri-decode-string" 6754) ("uri-normalize-case" 7022) ("uri-normalize-path-segments" 7160) ("uri->uri-generic" 7324) ("uri-generic->uri" 7324) ("uri->string" 7827) ("uri->list" 8166) ("char-set:gen-delims" 8382) ("char-set:sub-delims" 8556) ("char-set:uri-reserved" 8758) ("char-set:uri-unreserved" 8977))
(def (sig (procedure "(uri-reference STRING) => URI" (id uri-reference))) (p "A URI reference is either a URI or a relative reference (RFC 3986, Section 4.1).  If the given string's prefix does not match the syntax of a scheme followed by a colon separator, then the given string is parsed as a relative reference."))
(def (sig (procedure "(absolute-uri STRING) => URI" (id absolute-uri))) (p "Parses the given string as an absolute URI, in which no fragments are allowed.  If no URI scheme is found, or a fragment is detected, this raises an error.") (p "Absolute URIs are defined by RFC 3986 as non-relative URI references without a fragment (RFC 3986, Section 4.2).  Absolute URIs can be used as a base URI to resolve a relative-ref against, using " (tt "uri-relative-to") " (see below)."))
(def (sig (procedure "(uri-scheme uri-common) => symbol" (id uri-scheme)) (procedure "(uri-path uri-common) => list" (id uri-path)) (procedure "(uri-query uri-common) => alist" (id uri-query)) (procedure "(uri-fragment uri-common) => string" (id uri-fragment)) (procedure "(uri-host uri-common) => string" (id uri-host)) (procedure "(uri-port uri-common) => integer" (id uri-port)) (procedure "(uri-username uri-common) => string" (id uri-username)) (procedure "(uri-password uri-common) => string" (id uri-password))) (p "Accessors for " (tt "URI-common") " objects.") (p "If a component is not defined in the given URI-common, then the corresponding accessor returns " (tt "#f") "."))
(def (sig (procedure "(update-uri URI-common #!key scheme path query fragment host port username password) => URI-common" (id update-uri))) (p "Update the specified keys in the URI-common object in a functional way (ie, it creates a new copy with the modifications).") (p "Here's a nice tip: If you want to create an URI with only a few components set to dynamic values extracted from elsewhere, you can generally create an empty URI and update its constituent parts.") (p "You can do that like this:") (highlight scheme "(uri->string (update-uri (uri-reference \"\") path: '(\"example\" \"greeting\") query: '((hi . \"there\"))))\n => \"example/greeting?hi=there\""))
(def (sig (procedure "(uri-reference? URI) => BOOL" (id uri-reference?))) (p "Is the given object a URI reference?  " (b "All objects created by URI-common constructors are URI references") "; they are either URIs or relative references.  The constructors below are just more strict checking versions of " (tt "uri-reference") ".  They all create URI references."))
(def (sig (procedure "(absolute-uri? URI) => BOOL" (id absolute-uri?))) (p "Is the given object an absolute URI?"))
(def (sig (procedure "(uri? URI) => BOOL" (id uri?))) (p "Is the given object a URI?  URIs are all URI references that include a scheme part.  The other type of URI references are relative references."))
(def (sig (procedure "(relative-ref? URI) => BOOL" (id relative-ref?))) (p "Is the given object a relative reference?  Relative references are defined by RFC 3986 as URI references which are not URIs; they contain no URI scheme and can be resolved against an absolute URI to obtain a complete URI using " (tt "uri-relative-to") "."))
(def (sig (procedure "(uri-path-absolute? URI) => BOOL" (id uri-path-absolute?))) (p "Is the " (tt "URI") "'s path component an absolute path?"))
(def (sig (procedure "(uri-path-relative? URI) => BOOL" (id uri-path-relative?))) (p "Is the " (tt "URI") "'s path component a relative path?"))
(def (sig (procedure "(uri-default-port? URI) => BOOL" (id uri-default-port?))) (p "Is the " (tt "URI") "'s port the default port for the " (tt "URI") "'s scheme?"))
(def (sig (procedure "(uri-relative-to URI URI) => URI" (id uri-relative-to))) (p "Resolve the first URI as a reference relative to the second URI, returning a new URI (RFC 3986, Section 5.2.2)."))
(def (sig (procedure "(uri-relative-from URI URI) => URI" (id uri-relative-from))) (p "Constructs a new, possibly relative, URI which represents the location of the first URI with respect to the second URI.") (highlight scheme "(use uri-common)\n\n(uri->string (uri-relative-to (uri-reference \"../qux\") (uri-reference \"http://example.com/foo/bar/\")))\n => \"http://example.com/foo/qux\"\n\n(uri->string (uri-relative-from (uri-reference \"http://example.com/foo/qux\") (uri-reference \"http://example.com/foo/bar/\")))\n => \"../qux\""))
(def (sig (parameter "(form-urlencoded-separator [char-set/char/string])" (id form-urlencoded-separator)) (procedure "(form-urlencode alist #!key (separator (form-urlencoded-separator))) => string" (id form-urlencode)) (procedure "(form-urldecode string #!key (separator (form-urlencoded-separator))) => alist" (id form-urldecode))) (p "Encode or decode an alist using the encoding corresponding to the " (link "http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1" "form-urlencoded") " media type, using the given separator character(s).") (p "The alist contains key/value pairs corresponding to the values in the final urlencoded string.  If a value is " (tt "#f") ", the key will be " (b "omitted") " from the string.  If it is " (tt "#t") " the key will be present without a value. In all other cases, the value is converted to a string and urlencoded.  The keys are always converted to a string and urlencoded.") (p "When encoding, if " (tt "separator") " is a string, the first character will be used as the separator in the resulting querystring.  If it is a char-set, it will be converted to a string and its first character will be taken.  In either case, all of these characters are encoded if they occur inside the key/value pairs.") (p "When decoding, any character in the set (or string) will be seen as a separator.") (p "The separator defaults to the string " (tt "\";&\"") ".  This means that either semicolons or ampersands are allowed as separators when decoding an URI string, but semicolons are used when generating strings.") (p "If you would like to use a different separator, you should parameterize " (i "all") " calls to procedures that return an uri-common object.") (p "Examples:") (highlight scheme "(form-urlencode '((\"lemon\" . \"ade\") (sucks . #f) (rocks . #t) (number . 42)))\n=> \"lemon=ade;rocks;number=42\"\n\n(form-urldecode \"lemon=ade;rocks;number=42\")\n=> ((lemon . \"ade\") (rocks . #t) (number . \"42\"))"))
(def (sig (procedure "(uri-encode-string STRING [CHAR-SET]) => STRING" (id uri-encode-string))) (p "Returns the percent-encoded form of the given string.  The optional char-set argument controls which characters should be encoded. It defaults to the complement of " (tt "char-set:uri-unreserved") ". This is always safe, but often overly careful; it is allowed to leave certain characters unquoted depending on the context."))
(def (sig (procedure "(uri-decode-string STRING [CHAR-SET]) => STRING" (id uri-decode-string))) (p "Returns the decoded form of the given string.  The optional char-set argument controls which characters should be decoded.  It defaults to " (tt "char-set:full") "."))
(def (sig (procedure "(uri-normalize-case URI) => URI" (id uri-normalize-case))) (p "URI case normalization (RFC 3986 section 6.2.2.1)"))
(def (sig (procedure "(uri-normalize-path-segments URI) => URI" (id uri-normalize-path-segments))) (p "URI path segment normalization (RFC 3986 section 6.2.2.3)"))
(def (sig (procedure "(uri->uri-generic uri-common) => uri-generic" (id uri->uri-generic)) (procedure "(uri-generic->uri uri-common) => uri-common" (id uri-generic->uri))) (p "To convert between uri-generic and uri-common objects, use these procedures.  As stated above, this will allow you to retrieve the original encoding of the URI components, but once you update a component from the uri-common side, the original encoding is no longer available (the updated value replaces the original value)."))
(def (sig (procedure "(uri->string uri-common [userinfo]) => string" (id uri->string))) (p "Reconstructs the given URI into a string; uses a supplied function " (tt "LAMBDA USERNAME PASSWORD -> STRING") " to map the userinfo part of the URI.  If not given, it represents the userinfo as the username followed by " (tt "\":******\"") "."))
(def (sig (procedure "(uri->list URI USERINFO) => LIST" (id uri->list))) (p "Returns a list of the form " (tt "(SCHEME SPECIFIC FRAGMENT)") "; " (tt "SPECIFIC") " is of the form " (tt "(AUTHORITY PATH QUERY)") "."))
(def (sig (constant "char-set:gen-delims" (id char-set:gen-delims))) (p "Generic delimiters.") (pre " gen-delims  =  \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\""))
(def (sig (constant "char-set:sub-delims" (id char-set:sub-delims))) (p "Sub-delimiters.") (pre " sub-delims  =  \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\""))
(def (sig (constant "char-set:uri-reserved" (id char-set:uri-reserved))) (p "The union of " (tt "gen-delims") " and " (tt "sub-delims") "; all reserved URI characters.") (pre " reserved    =  gen-delims / sub-delims"))
(def (sig (constant "char-set:uri-unreserved" (id char-set:uri-unreserved))) (p "All unreserved characters that are allowed in a URI.") (pre " unreserved  =  ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"") (p "Note that this is _not_ the complement of " (tt "char-set:uri-reserved") "! There are several characters (even printable, noncontrol characters) which are not allowed at all in a URI."))
