((tags "eggs") (toc) (section 2 "uri-common" (section 3 "Description" (p "The " (tt "uri-common") " library provides simple and easy-to-use parsing and manipulation procedures for URIs using common schemes.") (p "These \"common schemes\" all have the following rules:") (ul (li "An empty path after the hostname is considered to be identical to the root path.") (li "All components are to be fully URI-decoded (so no percent-encoded characters in it).") (li "The query argument will be in " (link "http://www.w3.org/TR/xforms/#structure-model-submission" "application/x-www-form-urlencoded") " form.") (li "The port is automatically determined if it is omitted and the URI scheme is known."))) (section 3 "Library Procedures" (p "This library replaces most of the procedures in " (int-link "uri-generic") ". If you need to work with URIs on the uri-generic level or need to work with both uri-generic and uri-common URI objects, you will have to import and prefix or rename procedures.") (section 4 "Constructors and predicates" (p "These constructors fully decode their arguments, so afterwards it is impossible to distinguish between encoded delimiters and unencoded delimiters.  This makes uri-common objects decoding endpoints; no further decoding on the URI level is possible (of course, applications are free to decode further information inside the URI).  If for some reason, the original URI is still needed, it can be converted to a uri-generic.  However, updating a URI component causes this component's original encoding to be lost, so be careful!") (def (sig (procedure "(uri-reference STRING) => URI" (id uri-reference))) (p "A URI reference is either a URI or a relative reference (RFC 3986, Section 4.1).  If the given string's prefix does not match the syntax of a scheme followed by a colon separator, then the given string is parsed as a relative reference.")) (def (sig (procedure "(absolute-uri STRING) => URI" (id absolute-uri))) (p "Parses the given string as an absolute URI, in which no fragments are allowed.  If no URI scheme is found, or a fragment is detected, this raises an error.") (p "Absolute URIs are defined by RFC 3986 as non-relative URI references without a fragment (RFC 3986, Section 4.2).  Absolute URIs can be used as a base URI to resolve a relative-ref against, using " (tt "uri-relative-to") " (see below)."))) (section 4 "Accessors" (def (sig (procedure "(uri-scheme uri-common) => symbol" (id uri-scheme)) (procedure "(uri-path uri-common) => list" (id uri-path)) (procedure "(uri-query uri-common) => alist" (id uri-query)) (procedure "(uri-fragment uri-common) => string" (id uri-fragment)) (procedure "(uri-host uri-common) => string" (id uri-host)) (procedure "(uri-port uri-common) => integer" (id uri-port)) (procedure "(uri-username uri-common) => string" (id uri-username)) (procedure "(uri-password uri-common) => string" (id uri-password))) (p "Accessors for " (tt "URI-common") " objects.") (p "If a component is not defined in the given URI-common, then the corresponding accessor returns " (tt "#f") "."))) (section 4 "Updater" (def (sig (procedure "(update-uri URI-common #!key scheme path query fragment host port username password) => URI-common" (id update-uri))) (p "Update the specified keys in the URI-common object in a functional way (ie, it creates a new copy with the modifications).") (p "Here's a nice tip: If you want to create an URI with only a few components set to dynamic values extracted from elsewhere, you can generally create an empty URI and update its constituent parts.") (p "You can do that like this:") (highlight scheme "(uri->string (update-uri (uri-reference \"\") path: '(\"example\" \"greeting\") query: '((hi . \"there\"))))\n => \"example/greeting?hi=there\""))) (section 4 "Predicates" (p "There are several predicates to check whether objects are URI references (the most general type of an URI-like object), or more specific types of URIs like absolute URIs or relative references. The classification tree of URI-like objects looks a bit like this:") (pre "               uri-reference                         Anything defined by the RFC fits this\n               /           \\\n            uri             relative-ref             Scheme (uri) or no scheme (relative-ref)?\n            /               /        \\\n     absolute-uri    path-relative   path-absolute   No URI fragment(absolute-uri)? | path starts with a slash (path-absolute) or not (path-relative)?") (def (sig (procedure "(uri-reference? URI) => BOOL" (id uri-reference?))) (p "Is the given object a URI reference?  " (b "All objects created by URI-common constructors are URI references") "; they are either URIs or relative references.  The constructors below are just more strict checking versions of " (tt "uri-reference") ".  They all create URI references.")) (def (sig (procedure "(absolute-uri? URI) => BOOL" (id absolute-uri?))) (p "Is the given object an absolute URI?")) (def (sig (procedure "(uri? URI) => BOOL" (id uri?))) (p "Is the given object a URI?  URIs are all URI references that include a scheme part.  The other type of URI references are relative references.")) (def (sig (procedure "(relative-ref? URI) => BOOL" (id relative-ref?))) (p "Is the given object a relative reference?  Relative references are defined by RFC 3986 as URI references which are not URIs; they contain no URI scheme and can be resolved against an absolute URI to obtain a complete URI using " (tt "uri-relative-to") ".")) (def (sig (procedure "(uri-path-absolute? URI) => BOOL" (id uri-path-absolute?))) (p "Is the " (tt "URI") "'s path component an absolute path?")) (def (sig (procedure "(uri-path-relative? URI) => BOOL" (id uri-path-relative?))) (p "Is the " (tt "URI") "'s path component a relative path?")) (def (sig (procedure "(uri-default-port? URI) => BOOL" (id uri-default-port?))) (p "Is the " (tt "URI") "'s port the default port for the " (tt "URI") "'s scheme?"))) (section 4 "Reference Resolution" (def (sig (procedure "(uri-relative-to URI URI) => URI" (id uri-relative-to))) (p "Resolve the first URI as a reference relative to the second URI, returning a new URI (RFC 3986, Section 5.2.2).")) (def (sig (procedure "(uri-relative-from URI URI) => URI" (id uri-relative-from))) (p "Constructs a new, possibly relative, URI which represents the location of the first URI with respect to the second URI.") (highlight scheme "(use uri-common)\n\n(uri->string (uri-relative-to (uri-reference \"../qux\") (uri-reference \"http://example.com/foo/bar/\")))\n => \"http://example.com/foo/qux\"\n\n(uri->string (uri-relative-from (uri-reference \"http://example.com/foo/qux\") (uri-reference \"http://example.com/foo/bar/\")))\n => \"../qux\""))) (section 4 "Query encoding and decoding" (def (sig (parameter "(form-urlencoded-separator [char-set/char/string])" (id form-urlencoded-separator)) (procedure "(form-urlencode alist #!key (separator (form-urlencoded-separator))) => string" (id form-urlencode)) (procedure "(form-urldecode string #!key (separator (form-urlencoded-separator))) => alist" (id form-urldecode))) (p "Encode or decode an alist using the encoding corresponding to the " (link "http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1" "form-urlencoded") " media type, using the given separator character(s).") (p "The alist contains key/value pairs corresponding to the values in the final urlencoded string.  If a value is " (tt "#f") ", the key will be " (b "omitted") " from the string.  If it is " (tt "#t") " the key will be present without a value. In all other cases, the value is converted to a string and urlencoded.  The keys are always converted to a string and urlencoded.") (p "When encoding, if " (tt "separator") " is a string, the first character will be used as the separator in the resulting querystring.  If it is a char-set, it will be converted to a string and its first character will be taken.  In either case, all of these characters are encoded if they occur inside the key/value pairs.") (p "When decoding, any character in the set (or string) will be seen as a separator.") (p "The separator defaults to the string " (tt "\";&\"") ".  This means that either semicolons or ampersands are allowed as separators when decoding an URI string, but semicolons are used when generating strings.") (p "If you would like to use a different separator, you should parameterize " (i "all") " calls to procedures that return an uri-common object.") (p "Examples:") (highlight scheme "(form-urlencode '((\"lemon\" . \"ade\") (sucks . #f) (rocks . #t) (number . 42)))\n=> \"lemon=ade;rocks;number=42\"\n\n(form-urldecode \"lemon=ade;rocks;number=42\")\n=> ((lemon . \"ade\") (rocks . #t) (number . \"42\"))"))) (section 4 "String encoding and decoding" (p "A little more generic but also more level than encoding/decoding whole query strings/alists at a time, you can also encode and decode strings on an individual level.") (def (sig (procedure "(uri-encode-string STRING [CHAR-SET]) => STRING" (id uri-encode-string))) (p "Returns the percent-encoded form of the given string.  The optional char-set argument controls which characters should be encoded. It defaults to the complement of " (tt "char-set:uri-unreserved") ". This is always safe, but often overly careful; it is allowed to leave certain characters unquoted depending on the context.")) (def (sig (procedure "(uri-decode-string STRING [CHAR-SET]) => STRING" (id uri-decode-string))) (p "Returns the decoded form of the given string.  The optional char-set argument controls which characters should be decoded.  It defaults to " (tt "char-set:full") "."))) (section 4 "Normalization  " (def (sig (procedure "(uri-normalize-case URI) => URI" (id uri-normalize-case))) (p "URI case normalization (RFC 3986 section 6.2.2.1)")) (def (sig (procedure "(uri-normalize-path-segments URI) => URI" (id uri-normalize-path-segments))) (p "URI path segment normalization (RFC 3986 section 6.2.2.3)"))) (section 4 "uri-generic, string and list representation" (def (sig (procedure "(uri->uri-generic uri-common) => uri-generic" (id uri->uri-generic)) (procedure "(uri-generic->uri uri-common) => uri-common" (id uri-generic->uri))) (p "To convert between uri-generic and uri-common objects, use these procedures.  As stated above, this will allow you to retrieve the original encoding of the URI components, but once you update a component from the uri-common side, the original encoding is no longer available (the updated value replaces the original value).")) (def (sig (procedure "(uri->string uri-common [userinfo]) => string" (id uri->string))) (p "Reconstructs the given URI into a string; uses a supplied function " (tt "LAMBDA USERNAME PASSWORD -> STRING") " to map the userinfo part of the URI.  If not given, it represents the userinfo as the username followed by " (tt "\":******\"") ".")) (def (sig (procedure "(uri->list URI USERINFO) => LIST" (id uri->list))) (p "Returns a list of the form " (tt "(SCHEME SPECIFIC FRAGMENT)") "; " (tt "SPECIFIC") " is of the form " (tt "(AUTHORITY PATH QUERY)") "."))) (section 4 "Character sets" (p "As a convenience for further sub-parsers or other special-purpose URI handling code like separately URI-encoding strings, there are a couple of character sets exported by uri-common.") (def (sig (constant "char-set:gen-delims" (id char-set:gen-delims))) (p "Generic delimiters.") (pre " gen-delims  =  \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"")) (def (sig (constant "char-set:sub-delims" (id char-set:sub-delims))) (p "Sub-delimiters.") (pre " sub-delims  =  \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"")) (def (sig (constant "char-set:uri-reserved" (id char-set:uri-reserved))) (p "The union of " (tt "gen-delims") " and " (tt "sub-delims") "; all reserved URI characters.") (pre " reserved    =  gen-delims / sub-delims")) (def (sig (constant "char-set:uri-unreserved" (id char-set:uri-unreserved))) (p "All unreserved characters that are allowed in a URI.") (pre " unreserved  =  ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"") (p "Note that this is _not_ the complement of " (tt "char-set:uri-reserved") "! There are several characters (even printable, noncontrol characters) which are not allowed at all in a URI.")))) (section 3 "Requires" (ul (li (int-link "uri-generic")) (li (int-link "matchable")) (li (int-link "defstruct")))) (section 3 "Version History" (ul (li "1.2 re-exported " (tt "uri-encode-string") ", " (tt "uri-decode-string") " and the various charsets from uri-generic. Remove bogus charset encoding rules for fragments (fall back to normal uri encoding)") (li "1.1 Fixed x-www-form-urlencoded encoding so it encodes even characters that do not strictly need to be encoded according to the URI spec, but do according to the x-www-form-urlencoded spec.") (li "1.0 Fix a bug that caused empty lists to be treated differently from lists containing only false values in form-urlencode") (li "0.10 Fix urlencoded-separator first char selection in form-urlencode") (li "0.9 Automatically convert non-strings to strings in creating queries") (li "0.8 Actually export form-urlencoded-separator") (li "0.7 Fix silly bug in the predicates from 0.6 (it helps to test first...)") (li "0.6 Add predicates uri-path-relative? and uri-path-absolute?") (li "0.5 Add " (tt "uri-default-port?") " predicate procedure") (li "0.4 Add " (tt "uri->list") " conversion procedure") (li "0.3 Fix dependency info (requires at least uri-generic 2.1)") (li "0.2 Add predicates for URIs, absolute URIs and relative references, matching the ones in uri-generic.") (li "0.1 Initial Release"))) (section 3 "License" (pre " Copyright 2008-2010 Peter Bex\n All rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n \n Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n \n Redistributions in binary form must reproduce the above copyright\n notice, this list of conditions and the following disclaimer in the\n documentation and/or other materials provided with the distribution.\n \n Neither the name of the author nor the names of its contributors may\n be used to endorse or promote products derived from this software\n without specific prior written permission.\n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n OF THE POSSIBILITY OF SUCH DAMAGE."))))