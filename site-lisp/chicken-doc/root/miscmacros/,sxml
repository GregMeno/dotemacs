((tags "egg") (section 2 "miscmacros" (toc) (section 3 "Description" (p "Various useful little macros.")) (section 3 "Author" (p (int-link "/users/felix winkelmann" "felix winkelmann"))) (section 3 "Requirements" (p "None")) (section 3 "Documentation" (def (sig (syntax "(let/cc K BODY ...)" (id let/cc))) (p "Executes " (tt "BODY ...") " with " (tt "K") " bound to the current-continuation.")) (def (sig (syntax "(until TEST BODY ...)" (id until))) (p "Executes " (tt "BODY ...") " repeatedly while the expression " (tt "TEST") " returns " (tt "#f") ".")) (def (sig (syntax "(repeat TIMES BODY ...)" (id repeat))) (p "Executes " (tt "BODY ...") " " (tt "TIMES") " times.")) (def (sig (syntax "(repeat* TIMES BODY ...)" (id repeat*))) (p "Executes " (tt "BODY ...") " " (tt "TIMES") " times, with the variable " (tt "it") " bound to the count-down value.")) (def (sig (syntax "(dotimes (VAR TIMES [FINAL]) BODY ...)" (id dotimes))) (p "Executes " (tt "BODY ...") " " (tt "TIMES") " times, with the variable " (tt "VAR") " bound to the count-up value.") (p "Returns the result of the " (tt "FINAL") " expression or " (tt "(void)") " when no " (tt "FINAL") " expression.")) (def (sig (syntax "(while TEST BODY ...)" (id while))) (p "Executes " (tt "BODY ...") " repeatedly until the expression " (tt "TEST") " returns " (tt "#f") ".")) (def (sig (syntax "(while* TEST BODY ...)" (id while*))) (p "Executes " (tt "BODY ...") " repeatedly, with the result of " (tt "TEST") " bound to the variable " (tt "it") ", until the expression " (tt "TEST") " returns " (tt "#f") ".")) (def (sig (syntax "(if* X Y [Z])" (id if*))) (p "The " (i "anaphoric") " " (tt "if") ": if the expression " (tt "X") " evaluates to a true value, the expression " (tt "Y") " will be executed with the result of " (tt "X") " bound to the variable " (tt "it") ". If " (tt "X") " is false, then " (tt "Z") " (if supplied) will be evaluated:") (pre " (if* (> 3 1) it)                      ==> #t\n (if* (memq 'a '(b a c)) (cdr it) 99)  ==> (c)\n (if* #f it 1)                         ==> 1\n (if* #f #f)                           ==> #<unspecified>")) (def (sig (syntax "(push! X LOC)" (id push!))) (p "equivalent to") (pre " (set! LOC (cons X LOC))") (p "Note that " (tt "LOC") " may be any settable location.")) (def (sig (syntax "(pop! LOC)" (id pop!))) (p "Returns the first element from the list stored in the location " (tt "LOC") " and sets " (tt "LOC") " to the cdr of the previous value.")) (def (sig (syntax "(inc! LOC [AMOUNT])" (id inc!))) (p "Equivalent to " (tt "(set! LOC (+ LOC AMOUNT))") ". " (tt "AMOUNT") " defaults to 1. Returns the new value.")) (def (sig (syntax "(dec! LOC [AMOUNT])" (id dec!))) (p "Equivalent to " (tt "(set! LOC (- LOC AMOUNT))") ". " (tt "AMOUNT") " defaults to 1. Returns the new value.")) (def (sig (syntax "(ignore-errors BODY ...)" (id ignore-errors))) (p "Evaluates the expressions in " (tt "BODY ...") ". If any exceptions should be raised during execution of the body, then the exceptions will be caught, and " (tt "ignore-errors") " returns " (tt "#f") ".")) (def (sig (syntax "(begin0 BODY ...)" (id begin0))) (p "Evaluates " (tt "BODY ...") " just like " (tt "begin") ", but instead of returning the last value(s), " (tt "begin0") " returns the result (or the results) of the first expression in " (tt "BODY ...") ".")) (def (sig (syntax "(define-enum ->INT ->SYM ID ...)" (id define-enum))) (p "Defines an enumeration. The variables " (tt "ID, ...") " are bound to the exact integers " (tt "0, 1, ...") "  with " (tt "define-constant") ". " (tt "ID") " may also take the form " (tt "(ID N)") ", in which case the counter will be set to the exact integer " (tt "N") " for that variable, and continue upward normally from there.  A procedure named " (tt "->INT") " will be defined that takes a symbols and returns the respective integer. A procedure " (tt "->SYM") " will also be defined that takes an integer and returns the respective symbol (from the set of " (tt "ID") "s). If a symbol doesn't map to an integer (or vice versa), " (tt "#f") " is returned.")) (def (sig (syntax "(define-optionals ((VAR1 DEFAULT1) ...) ARGUMENTS)" (id define-optionals))) (p "Defines the globals " (tt "VAR1 ...") " with the values taken from the list " (tt "ARGUMENTS") ", or with " (tt "DEFAULT1 ...") ", if the list is shorter.")) (def (sig (syntax "(define-parameter VAR [VALUE [GUARD]])" (id define-parameter))) (p "Equivalent to") (pre " (define VAR (make-parameter VALUE [GUARD]))") (p (tt "VALUE") " defaults to " (tt "(void)") ".")) (def (sig (syntax "(ignore-values EXP)" (id ignore-values))) (p "Evaluates " (tt "EXP") " ignoring any return values. Returns an unspecified value.")) (def (sig (syntax "(modify-location LOC PROC)" (id modify-location))) (p "Expands into a call to PROC with two arguments: a zero-argument procedure for retrieving the value from the settable location LOC and a one argument procedure for setting the value of LOC. Care is taken to evaluate any subforms in LOC only once.") (p (tt "modify-location") " is intended to create modification macros for generalized locations (as in " (link "http://srfi.schemers.org/srfi-17" "SRFI-17") ".") (pre " (define-syntax-rule (increment! loc)\n   (modify-location\n     loc\n     (lambda (ref upd) (upd (add1 (ref)))) ) )\n \n (define x (vector 123))\n (increment! (vector-ref x (print 0)))   ; sets x to #(124) and prints \"0\" only once")) (def (sig (syntax "(modify! LOC PROC)" (id modify!))) (p "Modifies the contents of location LOC by applying the procedure PROC to it's contents and setting LOCs to the result. LOC may be any settable location.") (pre " (define-macro (increment! loc)\n   `(modify! ,loc add1) )")) (def (sig (syntax "(exchange! LOC1 LOC2)" (id exchange!))) (p "Exchanges the contents of the given locations. LOC1 and LOC2 may be any settable locations.")) (def (sig (syntax "(define-syntax-rule (NAME ARGUMENT ...) TEMPLATE)" (id define-syntax-rule))) (p "Shorthand for") (pre " (define-synax NAME\n   (syntax-rules ()\n     ((_ ARGUMENT ...) TEMPLATE)))")) (def (sig (syntax "(doto X FORM ...)" (id doto))) (p "Inserts the value of " (tt "X") " into the procedure-call forms " (tt "FORM ...") " as the first argument and returns that value:") (pre " (doto (some-data)\n   (init-data)\n   (show-data window)\n   (throw-away-data))\n \n =>\n \n (let ((tmp (some-data)))\n   (init-data tmp)\n   (show-data tmp window)\n   (throw-away-data tmp)\n   tmp)")) (def (sig (syntax "(ecase EXP ((LITERAL ...) BODY ...) ...)" (id ecase))) (p "Similar to " (tt "case") ", but signals an error if no clause matches."))) (section 3 "Changelog" (ul (li "2.91 Added " (tt "doto") " (contributed by Martin DeMello)") (li "2.9 " (tt "inc!") " and " (tt "dec!") " return the new value") (li "2.8 added " (tt "define-syntax-rule")) (li "2.7 added " (tt "import-only") " extension property and allowed optional increment/decrement for " (tt "inc!") " and " (tt "dec!")) (li "2.6 removed " (tt "-host") " option from setup script") (li "2.5 Add counter set capability to " (tt "define-enum") " [zbigniew]") (li "2.4 Added " (tt "modify!") " and " (tt "exchange!") " [felix]") (li "2.3 Added " (tt "dotimes") " [by Kon Lovett]") (li "2.2 Fixed bug in " (tt "pop!")) (li "2.1 Added " (tt "modify-location") " and made location-modification macros general for " (tt "set!") "table locations") (li "2.0 Added some simple looping constructs [by Kon Lovett]") (li "1.9 Added " (tt "while*") " [by Kon Lovett]") (li "1.8 Fixed bug in " (tt "if*") " [Thanks to Houman Zolfaghari]") (li "1.7 Added " (tt "ignore-values") " and " (tt "define-parameter")) (li "1.6 Fixed bug in " (tt "if*") " [Thanks to Michele Simionato]") (li "1.5 removed " (tt "shift!") " and " (tt "rotate!")) (li "1.4 " (tt "ignore-errors") " returns " (tt "#f") " on exception") (li "1.3 Added missing documentation for " (tt "define-optionals")) (li "1.2 Added " (tt "define-enum") " [by Alex Shinn]") (li "1.1 Added " (tt "inc!") " and " (tt "dec!")) (li "1.0 Initial release"))) (section 3 "License" (pre " Copyright (c) 2006-2010, The CHICKEN Team\n Copyright (c) 2004-2005, Felix L. Winkelmann\n All rights reserved.\n \n Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following\n conditions are met:\n \n   Redistributions of source code must retain the above copyright notice, this list of conditions and the following\n     disclaimer.\n   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following\n     disclaimer in the documentation and/or other materials provided with the distribution.\n   Neither the name of the author nor the names of its contributors may be used to endorse or promote\n     products derived from this software without specific prior written permission.\n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\n CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n POSSIBILITY OF SUCH DAMAGE."))))