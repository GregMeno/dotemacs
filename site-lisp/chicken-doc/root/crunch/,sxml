((tags "egg") (toc) (section 2 "crunch" (section 3 "Introduction" (p (b "crunch") " compiles a severely restricted statically typed subset of " (link "http://www.schemers.org/Documents/Standards/R5RS" "R5RS") " Scheme to C++. It can be used to generate standalone executables or code embedded into Scheme programs.") (p (i "This extension is highly experimental and likely to contain many bugs and incomplete functionality."))) (section 3 "Author" (p (int-link "/users/felix-winkelmann" "Felix Winkelmann"))) (section 3 "Requirements" (p (int-link "/eggref/4/miscmacros" "miscmacros") ", " (int-link "/eggref/4/defstruct" "defstruct") ", " (int-link "/eggref/4/defstruct" "matchable"))) (section 3 "Usage" (p "To use crunch in your Scheme code, simply wrap toplevel forms to be compiled in a " (tt "(crunch ...)") " expression. All toplevel procedure definitions are accessible as global or local (depending on the context where the " (tt "crunch") " form occurs) procedures callable from Scheme. The " (tt "crunch") " macro can only be used in compiled code. To use the macro, put") (pre " (import crunch)") (p "in your code.") (p "Alternatively, the " (tt "chicken-crunch") " program can be used to translate and compile code in the crunch Scheme dialect into C++. The generated code has no dependencies. Only the headerfile " (tt "crunch.h") " must be available and in your C++ compiler's include path. When installing this extension with " (tt "chicken-install") ", the file will be located in your default include path, usually " (tt "$PREFIX/include") ".") (p "The compiler can also be used through its procedural API, see " (tt "crunch-compile") ". In that case, load the runtime-part of the compiler with") (pre " (require-extension crunch-compiler)") (p "Crunched procedures are in every respect identical to C/C++ functions called via the usual CHICKEN foreign function interface. Crunch does not know anything about Scheme data or memory management. Translated code can call back into Scheme (see " (tt "define-crunch-callback") ") - callbacks are usually automatically detected and the generated Scheme wrapper function for a crunched procedure will be of the appropiate type, if required.") (p "Crunch uses its own macro expander, a modified version of Al Petrofsky's " (i "alexpander") ", a R5RS compliant implementation of " (tt "syntax-rules") " macros.") (p "No garbage collector is used. All dynamically allocated data (strings and number vectors) are managed using reference-counting.") (p "The dialect of R5RS Scheme supported is extremely limited. See " (i "Bugs and limitations") " for more information.") (p "Note that if you use the " (tt "crunch") " macro in your code, you must compile the file generated by chicken in C++ mode (just pass " (tt "-c++") " to " (tt "csc") " when compiling).") (p "To get maximum performance, inlining must be enabled in the C++ compiler when compiling crunch-generated code. The default optimization options do not enable inlining unless the default C compiler options have been overridden during installation of CHICKEN. Passing " (tt "-C -O3") " to " (tt "csc") " for crunched code will usually optimize the C++ code considerably.")) (section 3 "Programming interface" (section 4 "crunch-compile" (def (sig (procedure "(crunch-compile EXPRESSION [PORT debug: DBGMODE entry-point: SYMBOL])" (id crunch-compile))) (p "Compiles the toplevel expression " (tt "EXPRESSION") " into a C++ code, writing the generated code to " (tt "PORT") ", which defaults to the value of " (tt "(current-output-port)") ". If " (tt "DBGMODE") " is given, debugging output will be written to the current output port. " (tt "DBGMODE") " can be a boolean or a number between 1 and 3. Debug mode 1 shows some information about each compiled procedure, debug mode 3 generates loads of diagnostic output about the type-inferencing process and expanded code.") (p "If the entry-point name " (tt "SYMBOL") " is given, then the (normally hidden) toplevel variable of the same name holding a pointer to the associated C++ function can be accessed from C/C++ code, i.e. it is exposed under the same name. Note that the exposed variable is a " (i "pointer") " to a function.") (p "Each invocation of " (tt "crunch-compile") " creates its own private namespace, global variables are not visible in subsequent compilation runs in the same process. Syntax definitions " (i "are") " persistent over several invocations, though."))) (section 4 "crunch-expand" (def (sig (procedure "(crunch-expand EXPRESSION)" (id crunch-expand))) (p "Expands all macros in the given toplevel expression and returns the expansion."))) (section 4 "crunch" (def (sig (syntax "(crunch EXPRESSION ...)" (id crunch))) (p "Compiles the given toplevel expressions and expands into a set of function definitions and an invocation of compiled toplevel expressions in " (tt "EXPRESSION") ". The form can be used in a definition context but ends in a non-definition form (and so can with some macro systems not be followed by other definitions). Calls to Scheme callbacks are detected automatically and generate the appropriate " (tt "foreign-safe-lambda") " definition. The result of the executed toplevel code is unspecified."))) (section 4 "define-crunch-primitives" (def (sig (syntax "(define-crunch-primitives ((NAME ARGTYPE ...) -> RESULTTYPE [C-NAME]) ...)" (id define-crunch-primitives))) (p "Define additional primitives with the given names and argument- and result types. if " (tt "C-NAME") " is given, it specifies the name of the actual C/C++ function to be called. Otherwise " (tt "NAME") " is used."))) (section 4 "define-crunch-callback" (def (sig (syntax "(define-crunch-callback (NAME (ARGFTYPE1 VAR1) ...) RESULTFTYPE BODY ...)" (id define-crunch-callback))) (p "Equivalent to " (tt "define-external") ", but makes the callback accessible in subsequent translations of crunch code.") (p "Note that you have to pass " (tt "-emit-external-prototypes-first") " to " (tt "csc") " (or " (tt "chicken") ") when you use crunch callbacks to place function prototypes for the callbacks in front of code generated by crunch.")))) (section 3 "Standalone compiler" (p "The program " (tt "chicken-crunch") " can be used to generate a standalone program or module that has no CHICKEN dependencies.") (pre " usage: chicken-crunch OPTION | FILENAME ...\n   \n   -h            show this message\n   -o FILENAME   set output filename\n   -d            enable debug output\n   -dd           enable more debug output\n   -ddd          enable massive debug output\n   -cc CC        select C++ compiler (default: \"c++\")\n   -expand       only show code after expansion\n   -entry NAME   set entry-point procedure\n   -translate    only generate C++, don't compile\n   \n   All other options (arguments beginning with \"-\") are passed to\n   the C++ compiler. FILENAME may be \"-\", which reads source code\n   from stdin.") (p "Provided the file " (tt "crunch.h") " is in the include path, the generated C++ code can be compiled by itself. To link, you may have to add the " (tt "-lm") " switch to the linker, depending on the platform on which you are compiling the code.")) (section 3 "The type system" (p "Crunch performs type-inference to find out the types of local and global variables. It currently knows about these types:") (table (tr (th "Crunch type") (th "C type") (th "Description")) "\n" (tr (td (tt "int") " " (tt "short") " " (tt "long")) (td (tt "int") " " (tt "short") " " (tt "long")) (td "integer numbers")) "\n" (tr (td (tt "float") " " (tt "double")) (td (tt "float") " " (tt "double")) (td "floating point numbers")) "\n" (tr (td (tt "bool")) (td (tt "bool")) (td "boolean type")) "\n" (tr (td (tt "char")) (td (tt "char")) (td "characters")) "\n" (tr (td (tt "void")) (td (tt "void")) (td "the type of the \"unspecified\" value")) "\n" (tr (td (tt "c-string")) (td (tt "char *")) (td "strings")) "\n" (tr (td (tt "blob")) (td (tt "void *")) (td "a shapeless byte sequence")) "\n" (tr (td (tt "c-pointer")) (td (tt "void *")) (td "an opaque pointer")) "\n" (tr (td (tt "u8vector") " " (tt "s8vector") " " (tt "u16vector") " " (tt "s16vector") " " (tt "u32vector") " " (tt "s32vector") " " (tt "f32vector") "\n" (tt "f64vector")) "\n" (td (tt "unsigned char *") " " (tt "signed char *") " " (tt "unsigned short *") " " (tt "short *") " " (tt "unsigned int *") "\n" (tt "int *") " " (tt "float *") " " (tt "double *")) "\n" (td (link "http://srfi.schemers.org/srfi-4/" "SRFI-4") " homogenous number vectors"))) (p "Important: callbacks are likely to trigger a garbage collection, which will invalidate references to number-vectors or strings allocated in normal Scheme code. This does not apply to data allocated inside crunched code, which is not subject to garbage collection.") (p "Variables defined with " (tt "define") " or " (tt "set!") " or bound with " (tt "let") " or in a " (tt "lambda") " list can be declared to have a particular type by suffixing them with " (tt "::") " followed by a typename:") (highlight scheme "  (crunch\n    (let ((a::int (* 8 (sin 1))))\n      (display a::int)))               ; shows \"8\"") (p "Note that the name of variable really is " (tt "a::int") ", not " (tt "a") ". You usually don't need these declarations, though.") (p "Note also the absence of any other data types, in particular lists, vectors or record structures.") (p "Crunched functions may return results of the following types:") (pre " char\n int\n short\n long\n float\n double\n c-string\n c-pointer") (p "Polymorphic procedures are not supported.")) (section 3 "Available syntax" (p "The following non-standard macros are provided:") (pre " cond-expand\n when\n unless\n switch\n rec") (p (tt "cond-expand") " recognizes the feature identifiers " (tt "crunch") ", " (tt "srfi-0") ", " (tt "highlevel-macros") " and " (tt "syntax-rules") ". When code is compiled to a standalone program with " (tt "chicken-crunch") ", the feature identifier " (tt "crunch-standalone") " is defined as well.")) (section 3 "Available primitives" (p "All primitives take a fixed number of arguments, optional or \"rest\" arguments are not supported.  Primitives may not be redefined. Uses of primitives in non-operator position are treated as " (tt "(lambda (tmp1 ...) (<primitive> tmp1 ...))") ".") (p "Argument type abbreviations:") (table (tr (td "O O1 O2") (td "any data object")) "\n" (tr (td "X Y") (td "number")) "\n" (tr (td "N N1 N2") (td "integer")) "\n" (tr (td "K K1 K2") (td "positive integer")) "\n" (tr (td "R R1 R2") (td "inexact number")) "\n" (tr (td "S S1 S2") (td "string")) "\n" (tr (td "C C1 C2") (td "character")) "\n" (tr (td "B") (td "blob")) "\n" (tr (td "U8 S8 U16 S16 U32 S32 F32 F64") (td "SRFI-4 number vector")) "\n" (tr (td "P") (td "pointer"))) (p "The following R5RS procedures are provided:") (pre " (not O)") (pre " (eq? O1 O2)\n (eqv? O1 O2)\n (equal? O1 O2)") (pre " (+ X Y)\n (- X Y)\n (* X Y)\n (/ X Y)\n (= X Y)\n (> X Y)\n (< X Y)\n (>= X Y)\n (<= X Y)\n (abs X)\n (acos R)\n (asin R)\n (atan R)\n (ceiling X)\n (cos R)\n (display O)\n (even? N)\n (exact? X)\n (exact->inexact X)\n (exp R)\n (expt R1 R2)\n (floor X)\n (inexact? X)\n (inexact->exact X)\n (integer? X)\n (log R)\n (max X Y)\n (min X Y)\n (modulo N1 N2)\n (negative? X)\n (odd? N)\n (positive? X)\n (quotient N1 N2)\n (remainder N1 N2)\n (round X)\n (sin R)\n (sqrt X)\n (tan R)\n (truncate X)\n (zero? X)") (p (tt "max") ", " (tt "min") " and " (tt "expt") " are not exactness preserving. " (tt "expt") " always returns an inexact result.") (pre " (char=? C1 C2)\n (char>? C1 C2)\n (char<? C1 C2)\n (char>=? C1 C2)\n (char<=? C1 C2)\n (char->integer C)\n (char-alphabetic? C)\n (char-ci=? C1 C2)\n (char-ci>? C1 C2)\n (char-ci<? C1 C2)\n (char-ci>=? C1 C2)\n (char-ci<=? C1 C2)\n (char-downcase C)\n (char-lower-case? C)\n (char-numeric? C)\n (char-upper-case? C)\n (char-upcase C)\n (char-whitespace? C)\n (integer->char K)") (pre " (number->string X K)\n (make-string N C)\n (string=? S1 S2)\n (string>? S1 S2)\n (string<? S1 S2)\n (string>=? S1 S2)\n (string<=? S1 S2)\n (string->number S K)\n (string-ci=? S1 S2)\n (string-ci>? S1 S2)\n (string-ci<? S1 S2)\n (string-ci>=? S1 S2)\n (string-ci<=? S1 S2)\n (string-append S1 S2)\n (string-copy S)\n (string-fill! S1 C)\n (string-length S)\n (string-ref S K)\n (string-set! S K C)\n (substring S K1 K2)") (p (tt "string->number") " does not detect invalid numerical syntax and simply wraps " (tt "strtol(3)") "/" (tt "strtod(3)") ".  If a radix different from 10 is given, the result will always be converted with " (tt "strtol(3)") ".") (p (tt "number->string") " ignores the radix argument if the converted number is inexact.") (pre " (display X)\n (newline)\n (write-char C)") (p (tt "write-char") ", " (tt "display") " and " (tt "newline") " always write to stdout.") (p "Non-R5RS procedures (see the " (int-link "/man/4" "The User's Manual") " for more information):") (pre " (add1 X)\n (atan2 R1 R2)\n (arithmetic-shift N1 N2)\n (bitwise-and N1 N2)\n (bitwise-ior N1 N2)\n (bitwise-not N)\n (bitwise-xor N1 N2)\n (sub1 X)") (pre " (f32vector-length F32)\n (f32vector-ref F32 K)\n (f32vector-set! F32 K R)\n (f64vector-length F64)\n (f64vector-ref F64 K)\n (f64vector-set! F64 K R)\n (make-f32vector K R)\n (make-f64vector K R)\n (make-s16vector K N)\n (make-s32vector K N)\n (make-s8vector K N)\n (make-u16vector K1 K2)\n (make-u32vector K1 K2)\n (make-u8vector K1 K2)\n (s16vector-length S16)\n (s16vector-ref S16 K)\n (s16vector-set! S16 K N)\n (s32vector-length S32)\n (s32vector-ref S32 K)\n (s32vector-set! S32 K N)\n (s8vector-length S8)\n (s8vector-ref S8 K)\n (s8vector-set! S8 K N)\n (subf32vector F32 K1 K2)\n (subf64vector F64 K1 K2)\n (subs16vector S16 K1 K2)\n (subs32vector S32 K1 K2)\n (subs8vector S8 K1 K2)\n (subu16vector U16 K1 K2)\n (subu32vector U32 K1 K2)\n (subu8vector U8 K1 K2)\n (u16vector-length U16)\n (u16vector-ref U16 K)\n (u16vector-set! U16 K1 K2)\n (u32vector-length U32)\n (u32vector-ref U32 K)\n (u32vector-set! U32 K1 K2)\n (u8vector-length U8)\n (u8vector-ref U8 K)\n (u8vector-set! U8 K1 K2)") (pre " (blob->f32vector B)\n (blob->f32vector/shared B)\n (blob->f64vector B)\n (blob->f64vector/shared B)\n (blob->s16vector B)\n (blob->s16vector/shared B)\n (blob->s32vector B)\n (blob->s32vector/shared B)\n (blob->s8vector B)\n (blob->s8vector/shared B)\n (blob->string B)\n (blob->string/shared B)\n (blob->u16vector B)\n (blob->u16vector/shared B)\n (blob->u32vector B)\n (blob->u32vector/shared B)\n (blob->u8vector B)\n (blob->u8vector/shared B)\n (f32vector->blob F32)\n (f32vector->blob/shared F32)\n (f64vector->blob F64)\n (f64vector->blob/shared F64)\n (s16vector->blob S16)\n (s16vector->blob/shared S16)\n (s32vector->blob S32)\n (s32vector->blob/shared S32)\n (s8vector->blob S8)\n (s8vector->blob/shared S8)\n (string->blob S)\n (string->blob/shared S)\n (u16vector->blob U16)\n (u16vector->blob/shared U16)\n (u32vector->blob U32)\n (u32vector->blob/shared U32)\n (u8vector->blob U8)\n (u8vector->blob/shared U8)") (p "The " (tt ".../shared") " conversion procedures return data objects that share the actual storage with the argument objects, this can be used for interesting applications.") (pre " (flush-output)") (pre " (void)\n (error S)\n (exit N)\n (argc)\n (argv-ref K)") (p (tt "error") " shows a message and invokes " (tt "abort(3)") ". " (tt "argc") " returns the number of arguments passed to the process (including the program name) and " (tt "argv-ref") " returns the command line argument with the given index (or the program name, when the index is zero).") (pre " (pointer-u8-ref P N)\n (pointer-s8-ref P N) \n (pointer-u16-ref P N) \n (pointer-s16-ref P N) \n (pointer-u32-ref P N) \n (pointer-s32-ref P N) \n (pointer-f32-ref P N) \n (pointer-f64-ref P N) \n (pointer-u8-set! P N1 N2) \n (pointer-s8-set! P N1 N2) \n (pointer-u16-set! P N1 N2) \n (pointer-s16-set! P N1 N2) \n (pointer-u32-set! P N1 N2) \n (pointer-s32-set! P N1 N2) \n (pointer-f32-set! P N R) \n (pointer-f64-set! P N R) ")) (section 3 "Notes" (ul (li "Pass " (tt "-DDBGALLOC") " to the C++ compiler (either through " (tt "chicken-crunch") " or to " (tt "csc") " via " (tt "-C -DDBGALLOC") ") to see log messages about the allocation and de-allocation of dynamic number vectors or strings.") (li "Runtime errors invoke " (tt "abort(3)") " and thus can not be caught."))) (section 3 "Bugs and limitations" (ul (li "Lexical scope is not supported, only references to global variables and variables local to the current " (tt "lambda") " construct (including " (tt "let") " bound variables) are visible. Expressions of the form " (tt "((lambda (...) ...) ...)") " are converted in the corresponding " (tt "let") " construct.") (li "Local procedures are not available") (li (tt "letrec") " is not supported (it makes no sense without local procedures)") (li "Continuations are not supported.") (li "Multiple values are not supported.") (li "Tail calls are only detected in self-recursive functions.") (li "Rest-arguments (dotted lambda lists) are not supported.") (li "Numeric overflow of fixnum operations is not detected.") (li "Nearly no error checks are made at runtime.") (li "Named " (tt "let") " is always assumed to be a looping construct, calls to the loop variable " (b "must") " be in tail position.") (li (tt "do") " and named " (tt "let") " loops always return an unspecified value.") (li "The correctness of the C++ template code is unclear. C++ is insane.") (li "If a homogenous number vector or string is passed from Scheme to C++ code generated by crunch, then the length of the passed array is not known and the associated " (tt "...-length") " primitive and primitives that require the length of the vector will abort.") (li "Type-related errors do not always produce particularly useful context information") (li "Error messages are generally pretty bad"))) (section 3 "Examples" (highlight scheme "(use crunch)\n\n(crunch\n  (define (string-reverse str)\n    (let* ((n (string-length str))\n              (s2 (make-string n #\\space)))\n         (do ((i 0 (add1 i)))\n             ((>= i n))\n           (string-set! s2 (sub1 (- n i)) (string-ref str i)))\n         s2)) )\n\n(print (string-reverse \"this is a test!\"))")) (section 3 "License" (pre "Copyright (c) 2007-2009, Felix L. Winkelmann\nThe \"alexpander\" is Copyright (c) 2002-2004, Al Petrofsky\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer. \n Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the \n   documentation and/or other materials provided with the distribution. \n Neither the name of the author nor the names of its contributors\n   may be used to endorse or promote products derived from this\n   software without specific prior written permission. \n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")) (section 3 "Version history" (dl (dt "0.7.6") (dd "fixed bug in installation script (thanks to Jim Pryor)") (dt "0.7.5") (dd "fixed bug related to callbacks with " (tt "void") " result type") (dt "0.7.4") (dd "removed unused test files") (dt "0.7.3") (dd "two bugfixes (Thanks to Jeronimo)") (dt "0.7.2") (dd "fixed silly mistake") (dt "0.7.1") (dd "fixed bug in setup script") (dt "0.7") (dd "ported to CHICKEN 4") (dt "0.6") (dd "updated to newest alexpander") (dt "0.5") (dd "fixed buggy formatting directive") (dt "0.4") (dd "support for libarena by Ivan Raikov") (dt "0.3") (dd "fixed bugs in character handling [thanks to Alex Shinn]") (dt "0.2") (dd "fixed bugs in naming of " (tt "char->integer") " and " (tt "integer->char")) (dt "0.1") (dd "initial release")))))