((tags "manual") (toc) (section 2 "Unit srfi-69" (p "CHICKEN implements SRFI 69 with SRFI 90 extensions. For more information, see " (link "http://srfi.schemers.org/srfi-69/srfi-69.html" "SRFI-69") " and " (link "http://srfi.schemers.org/srfi-90/srfi-90.html" "SRFI-90") ".") (section 3 "Hash Table Procedures" (section 4 "make-hash-table" (def (sig (procedure "(make-hash-table [TEST HASH SIZE] [#:test TEST] [#:hash HASH] [#:size SIZE] [#:initial INITIAL] [#:min-load MIN-LOAD] [#:max-load MAX-LOAD] [#:weak-keys WEAK-KEYS] [#:weak-values WEAK-VALUES])" (id make-hash-table))) (p "Returns a new " (tt "HASH-TABLE") " with the supplied configuration.") (dl (dt (tt "TEST")) (dd "The equivalence function.") (dt (tt "HASH")) (dd "The hash function.") (dt (tt "SIZE")) (dd "The expected number of table elements.") (dt (tt "INITIAL")) (dd "The default initial value.") (dt (tt "MIN-LOAD")) (dd "The minimum load factor. A " (tt "flonum") " in (0.0 1.0).") (dt (tt "MAX-LOAD")) (dd "The maximum load factor. A " (tt "flonum") " in (0.0 1.0).") (dt (tt "WEAK-KEYS")) (dd "Use weak references for keys. (Ignored)") (dt (tt "WEAK-VALUES")) (dd "Use weak references for values. (Ignored)")))) (section 4 "alist->hash-table" (def (sig (procedure "(alist->hash-table A-LIST [#:test TEST] [#:hash HASH] [#:size SIZE] [#:initial INITIAL] [#:min-load MIN-LOAD] [#:max-load MAX-LOAD] [#:weak-keys WEAK-KEYS] [#:weak-values WEAK-VALUES])" (id alist->hash-table))) (p "Returns a new " (tt "HASH-TABLE") ". The " (tt "HASH-TABLE") " is populated from the " (tt "A-LIST") ". The keyword arguments are per " (tt "make-hash-table") "."))) (section 4 "hash-table?" (def (sig (procedure "(hash-table? OBJECT)" (id hash-table?))) (p "Is the " (tt "OBJECT") " a " (tt "hash-table") "?"))) (section 4 "hash-table-size" (def (sig (procedure "(hash-table-size HASH-TABLE)" (id hash-table-size))) (p "The " (tt "HASH-TABLE") " size."))) (section 4 "hash-table-equivalence-function" (def (sig (procedure "(hash-table-equivalence-function HASH-TABLE)" (id hash-table-equivalence-function))) (p "The " (tt "HASH-TABLE") " " (tt "equivalence-function") "."))) (section 4 "hash-table-hash-function" (def (sig (procedure "(hash-table-hash-function HASH-TABLE)" (id hash-table-hash-function))) (p "The " (tt "HASH-TABLE") " " (tt "hash-function") "."))) (section 4 "hash-table-min-load" (def (sig (procedure "(hash-table-min-load HASH-TABLE)" (id hash-table-min-load))) (p "The " (tt "HASH-TABLE") " minimum load factor."))) (section 4 "hash-table-max-load" (def (sig (procedure "(hash-table-max-load HASH-TABLE)" (id hash-table-max-load))) (p "The " (tt "HASH-TABLE") " maximum load factor."))) (section 4 "hash-table-weak-keys" (def (sig (procedure "(hash-table-weak-keys HASH-TABLE)" (id hash-table-weak-keys))) (p "Does the " (tt "HASH-TABLE") " weak references for keys?"))) (section 4 "hash-table-weak-values" (def (sig (procedure "(hash-table-weak-values HASH-TABLE)" (id hash-table-weak-values))) (p "Does the " (tt "HASH-TABLE") " weak references for values?"))) (section 4 "hash-table-has-initial?" (def (sig (procedure "(hash-table-has-initial? HASH-TABLE)" (id hash-table-has-initial?))) (p "Does the " (tt "HASH-TABLE") " have a default initial value?"))) (section 4 "hash-table-initial" (def (sig (procedure "(hash-table-initial HASH-TABLE)" (id hash-table-initial))) (p "The " (tt "HASH-TABLE") " default initial value."))) (section 4 "hash-table-keys" (def (sig (procedure "(hash-table-keys HASH-TABLE)" (id hash-table-keys))) (p "Returns a list of the keys in the " (tt "HASH-TABLE") " population."))) (section 4 "hash-table-values" (def (sig (procedure "(hash-table-values HASH-TABLE)" (id hash-table-values))) (p "Returns a list of the values in the " (tt "HASH-TABLE") " population."))) (section 4 "hash-table->alist" (def (sig (procedure "(hash-table->alist HASH-TABLE)" (id hash-table->alist))) (p "Returns the population of the " (tt "HASH-TABLE") " as an " (tt "a-list") "."))) (section 4 "hash-table-ref" (def (sig (procedure "(hash-table-ref HASH-TABLE KEY)" (id hash-table-ref))) (p "Returns the " (tt "VALUE") " for the " (tt "KEY") " in the " (tt "HASH-TABLE") ".") (p "Aborts with an exception when the " (tt "KEY") " is missing."))) (section 4 "hash-table-ref/default" (def (sig (procedure "(hash-table-ref/default HASH-TABLE KEY DEFAULT)" (id hash-table-ref/default))) (p "Returns the " (tt "VALUE") " for the " (tt "KEY") " in the " (tt "HASH-TABLE") ", or the " (tt "DEFAULT") " when the " (tt "KEY") " is missing."))) (section 4 "hash-table-exists?" (def (sig (procedure "(hash-table-exists? HASH-TABLE KEY)" (id hash-table-exists?))) (p "Does the " (tt "KEY") " exist in the " (tt "HASH-TABLE") "?"))) (section 4 "hash-table-set!" (def (sig (procedure "(hash-table-set! HASH-TABLE KEY VALUE)" (id hash-table-set!))) (p "Set the " (tt "VALUE") " for the " (tt "KEY") " in the " (tt "HASH-TABLE") ".") (p "A setter for " (tt "hash-table-ref") " is defined, so") (highlight scheme "(set! (hash-table-ref HASH-TABLE KEY) VALUE)") (p "is equivalent to") (highlight scheme "(hash-table-set! HASH-TABLE KEY VALUE)"))) (section 4 "hash-table-update!" (def (sig (procedure "(hash-table-update! HASH-TABLE KEY [UPDATE-FUNCTION [DEFAULT-VALUE-FUNCTION]])" (id hash-table-update!))) (p "Sets or replaces the " (tt "VALUE") " for " (tt "KEY") " in the " (tt "HASH-TABLE") ".") (p "The " (tt "UPDATE-FUNCTION") " takes the existing " (tt "VALUE") " for " (tt "KEY") " and returns the new " (tt "VALUE") ". The default is " (tt "identity")) (p "The " (tt "DEFAULT-VALUE-FUNCTION") " is called when the entry for " (tt "KEY") " is missing. The default uses the " (tt "(hash-table-initial-value)") ", if provided. Otherwise aborts with an exception.") (p "Returns the new " (tt "VALUE") "."))) (section 4 "hash-table-update!/default" (def (sig (procedure "(hash-table-update!/default HASH-TABLE KEY UPDATE-FUNCTION DEFAULT-VALUE)" (id hash-table-update!/default))) (p "Sets or replaces the " (tt "VALUE") " for " (tt "KEY") " in the " (tt "HASH-TABLE") ".") (p "The " (tt "UPDATE-FUNCTION") " takes the existing " (tt "VALUE") " for " (tt "KEY") " and returns the new " (tt "VALUE") ".") (p "The " (tt "DEFAULT-VALUE") " is used when the entry for " (tt "KEY") " is missing.") (p "Returns the new " (tt "VALUE") "."))) (section 4 "hash-table-copy" (def (sig (procedure "(hash-table-copy HASH-TABLE)" (id hash-table-copy))) (p "Returns a shallow copy of the " (tt "HASH-TABLE") "."))) (section 4 "hash-table-delete!" (def (sig (procedure "(hash-table-delete! HASH-TABLE KEY)" (id hash-table-delete!))) (p "Deletes the entry for " (tt "KEY") " in the " (tt "HASH-TABLE") "."))) (section 4 "hash-table-remove!" (def (sig (procedure "(hash-table-remove! HASH-TABLE PROC)" (id hash-table-remove!))) (p "Calls " (tt "PROC") " for all entries in " (tt "HASH-TABLE") " with the key and value of each entry. If " (tt "PROC") " returns true, then that entry is removed."))) (section 4 "hash-table-clear!" (def (sig (procedure "(hash-table-clear! HASH-TABLE)" (id hash-table-clear!))) (p "Deletes all entries in " (tt "HASH-TABLE") "."))) (section 4 "hash-table-merge" (def (sig (procedure "(hash-table-merge HASH-TABLE-1 HASH-TABLE-2)" (id hash-table-merge))) (p "Returns a new " (tt "HASH-TABLE") " with the union of " (tt "HASH-TABLE-1") " and " (tt "HASH-TABLE-2") "."))) (section 4 "hash-table-merge!" (def (sig (procedure "(hash-table-merge! HASH-TABLE-1 HASH-TABLE-2)" (id hash-table-merge!))) (p "Returns " (tt "HASH-TABLE-1") " as the union of " (tt "HASH-TABLE-1") " and " (tt "HASH-TABLE-2") "."))) (section 4 "hash-table-map" (def (sig (procedure "(hash-table-map HASH-TABLE FUNC)" (id hash-table-map))) (p "Calls " (tt "FUNC") " for all entries in " (tt "HASH-TABLE") " with the key and value of each entry.") (p "Returns a list of the results of each call."))) (section 4 "hash-table-fold" (def (sig (procedure "(hash-table-fold HASH-TABLE FUNC INIT)" (id hash-table-fold))) (p "Calls " (tt "FUNC") " for all entries in " (tt "HASH-TABLE") " with the key and value of each entry, and the current folded value. The initial folded value is " (tt "INIT") ".") (p "Returns the final folded value."))) (section 4 "hash-table-for-each" (def (sig (procedure "(hash-table-for-each HASH-TABLE PROC)" (id hash-table-for-each))) (p "Calls " (tt "PROC") " for all entries in " (tt "HASH-TABLE") " with the key and value of each entry."))) (section 4 "hash-table-walk" (def (sig (procedure "(hash-table-walk HASH-TABLE PROC)" (id hash-table-walk))) (p "Calls " (tt "PROC") " for all entries in " (tt "HASH-TABLE") " with the key and value of each entry.")))) (section 3 "Hashing Functions" (p "All hash functions return a " (tt "fixnum") " in the range [0 " (tt "BOUND") ").") (section 4 "number-hash" (def (sig (procedure "(number-hash NUMBER [BOUND])" (id number-hash))) (p "For use with " (tt "=") " as a " (tt "hash-table-equivalence-function") "."))) (section 4 "object-uid-hash" (def (sig (procedure "(object-uid-hash OBJECT [BOUND])" (id object-uid-hash))) (p "Currently a synonym for " (tt "equal?-hash") "."))) (section 4 "symbol-hash" (def (sig (procedure "(symbol-hash SYMBOL [BOUND])" (id symbol-hash))) (p "For use with " (tt "eq?") " as a " (tt "hash-table-equivalence-function") "."))) (section 4 "keyword-hash" (def (sig (procedure "(keyword-hash KEYWORD [BOUND])" (id keyword-hash))) (p "For use with " (tt "eq?") " as a " (tt "hash-table-equivalence-function") "."))) (section 4 "string-hash" (def (sig (procedure "(string-hash STRING [BOUND START END])" (id string-hash))) (p "For use with " (tt "string=?") " as a " (tt "hash-table-equivalence-function") ". The optional " (tt "START") " and " (tt "END") " arguments may be given to limit the hash calculation to a specific sub-section of " (tt "STRING") "."))) (section 4 "string-ci-hash" (def (sig (procedure "(string-hash-ci STRING [BOUND START END])" (id string-hash-ci)) (procedure "(string-ci-hash STRING [BOUND START END])" (id string-ci-hash))) (p "For use with " (tt "string-ci=?") " as a " (tt "hash-table-equivalence-function") "."))) (section 4 "eq?-hash" (def (sig (procedure "(eq?-hash OBJECT [BOUND])" (id eq?-hash))) (p "For use with " (tt "eq?") " as a " (tt "hash-table-equivalence-function") "."))) (section 4 "eqv?-hash" (def (sig (procedure "(eqv?-hash OBJECT [BOUND])" (id eqv?-hash))) (p "For use with " (tt "eqv?") " as a " (tt "hash-table-equivalence-function") "."))) (section 4 "equal?-hash" (def (sig (procedure "(equal?-hash OBJECT [BOUND])" (id equal?-hash))) (p "For use with " (tt "equal?") " as a " (tt "hash-table-equivalence-function") "."))) (section 4 "hash" (def (sig (procedure "(hash OBJECT [BOUND])" (id hash))) (p "Synonym for " (tt "equal?-hash") "."))) (section 4 "hash-by-identity" (def (sig (procedure "(hash-by-identity OBJECT [BOUND])" (id hash-by-identity))) (p "Synonym for " (tt "eq?-hash") ".") (p "Previous: " (int-link "Unit srfi-18") " Next: " (int-link "Unit posix")))))))