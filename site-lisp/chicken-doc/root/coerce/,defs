(index ("type-of" 0) ("type-of-extended?" 580) ("type-of-extend!" 748) ("type-of-composite-extension!" 926) ("type-of-extension-remove!" 1204) ("coerce" 1367) ("coerce-all" 1924) ("make-case-coerce" 2222) ("case-coerce" 2661) ("coerce-extended?" 3680) ("coerce-extend!" 3846) ("coerce-composite-extension!" 4542) ("coerce-extension-remove!" 5096))
(def (sig (procedure "(type-of OBJECT) => TYPE-TAG" (id type-of))) (p "Returns a type tag for the type of " (tt "OBJECT") ".") (p "Built-in type tags are " (tt "unspecified") " (" (tt "void") "), " (tt "boolean") ", " (tt "port") ", " (tt "char") ", " (tt "number") ", " (tt "string") ", " (tt "keyword") ", " (tt "symbol") ", " (tt "pair") ", " (tt "list") ", " (tt "blob") ", " (tt "procedure") ", " (tt "pointer") ", " (tt "locative") ", and " (tt "vector") ". A " (tt "record-instance") " type tag is the " (tt "record-instance-tag") ". The catch-all is " (tt "object") "."))
(def (sig (procedure "(type-of-extended? TYPE-TAG) => BOOLEAN" (id type-of-extended?))) (p "Is the domain extended to cover the type identifier " (tt "TYPE-TAG") "."))
(def (sig (procedure "(type-of-extend! TYPE-TAG TYPE-PRED)" (id type-of-extend!))) (p "Extends the domain of type-of with the type definition " (tt "(TYPE-TAG TYPE-PRED)") "."))
(def (sig (procedure "(type-of-composite-extension! TYPE-TAG TYPE-PRED)" (id type-of-composite-extension!))) (p "Extends the domain of an existing type-of extension.") (p "Should the new " (tt "TYPE-PRED") " and existing TYPE-PRED be " (tt "eq?") " the operation is ignored."))
(def (sig (procedure "(type-of-extension-remove! TYPE-TAG)" (id type-of-extension-remove!))) (p "Delete any existing type-of extension for " (tt "TYPE-TAG") "."))
(def (sig (procedure "(coerce OBJECT TYPE-TAG [DEFAULT-PROC]) => OBJECT" (id coerce))) (p "Converts " (tt "OBJECT") " to a value of " (tt "TYPE-TAG") ".") (p (tt "DEFAULT-PROC") " is a procedure with the signature " (tt "(OBJECT TYPE-TAG -> OBJECT)") " and is invoked when coercion fails. The default is to signal an error.") (p "Built-in types are " (tt "boolean") ", " (tt "port") ", " (tt "char") ", " (tt "number") ", " (tt "string") ", " (tt "keyword") ", " (tt "symbol") ", " (tt "pair") ", " (tt "blob") ", " (tt "list") ", and " (tt "vector") "."))
(def (sig (procedure "(coerce-all (OBJECT...) (TYPE-TAG...) [DEFAULT-PROC]) => LIST" (id coerce-all))) (p "Returns a list of every element of the " (tt "(OBJECT...)") " coerced to the corresponding element of the " (tt "(TYPE-TAG...)") ".") (p (tt "DEFAULT-PROC") " is as for " (tt "coerce") "."))
(def (sig (procedure "(make-case-coerce CONVERTOR [ALIST]) => PROCEDURE" (id make-case-coerce))) (p "Returns a coercion procedure for use with " (tt "extend-coerce")) (p (tt "CONVERTOR") " is a coercion procedure with the signature " (tt "(OBJECT TYPE-TAG ON-ERROR -> object)") ". " (tt "ON-ERROR") " is a procedure/0 that is invoked when all else fails.") (p (tt "ALIST") " here is a list of " (tt "(TYPE-TAG . (OBJECT -> OBJECT)") "."))
(def (sig (syntax "(case-coerce CASE ...) => PROCEDURE" (id case-coerce))) (p "Returns a coercion procedure for use with " (tt "extend-coerce") ".") (p (tt "CASE") " is of the form " (tt "((TYPE-TAG ...) EXPRESSION ...)") ", or " (tt "(else EXPRESSION ...)") ".") (p "The variable " (tt "object") " is bound to the object to coerce within the scope of " (tt "CASE ...") ".") (p "The variable " (tt "on-error") " is bound to a thunk within the scope of " (tt "CASE ...") "} to invoke upon failure.") (highlight scheme "(define (unspecified? obj) (eq? (void) obj))\n\n(define unspecified-coerce\n  (case-coerce\n    ((char)     #\\nul)\n    ((number)   +nan)\n    ((string)   \"\")\n    ((symbol)   '||)\n    ((list)     (list))\n    ((vector)   (vector))))\n\n(coerce-extend! 'unspecified unspecified? unspecified-coerce)\n\n(type-of (void)) ;=> unspecified\n\n(coerce-extend! 'string\n  string?\n  (case-coerce ((unspecified) (if (string=? \"\" object) (void) (on-error)))))\n\n(coerce \"\" 'unspecified) ;=> (void)"))
(def (sig (procedure "(coerce-extended? TYPE-TAG) => BOOLEAN" (id coerce-extended?))) (p "Is the domain extended to cover the type identifier " (tt "TYPE-TAG") "."))
(def (sig (procedure "(coerce-extend! TYPE-TAG TYPE-PRED CONVERTOR)" (id coerce-extend!))) (p "Extends the domain of coerce with the type definition " (tt "(TYPE-TAG TYPE-PRED CONVERTOR)") ".") (p (tt "TYPE-PRED") " is a procedure, " (tt "(object -> boolean)") ", testing whether the argument is a type.") (p (tt "CONVERTOR") " is a procedure, " (tt "(object symbol on-error -> object)") ", converting from the type to a result type.") (p "The " (tt "CONVERTOR") " " (b "must") " invoke " (tt "(on-error)") " when conversion not possible. Usually " (tt "case-coerce") " would be used to create the " (tt "CONVERTOR") ", which automatically handles calling of the " (tt "on-error") " argument."))
(def (sig (procedure "(coerce-composite-extension! TYPE-TAG TYPE-PRED CONVERTOR)" (id coerce-composite-extension!))) (p "Extends the domain of an existing coerce extension.") (p (tt "TYPE-TAG") ", " (tt "TYPE-PRED") ", and " (tt "CONVERTOR") " are as for " (tt "extend-coerce") ".") (p "The new " (tt "CONVERTOR") " is try'ed before the existing procedure, then the existing procedure is try'ed \"on-error\".") (p "Should the new " (tt "TYPE-PRED") " and existing TYPE-PRED be " (tt "eq?") " the TYPE-PREDs are not \"composited\" using " (tt "or") "."))
(def (sig (procedure "(coerce-extension-remove! TYPE-TAG)" (id coerce-extension-remove!))) (p "Delete any existing coerce extension for the type identifier " (tt "TYPE-TAG") "."))
