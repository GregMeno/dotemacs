((tags "egg") (section 2 "coerce" (p "Type Identity & Coercion") (toc)) (section 2 "Documentation" (p "A Chicken specific version of the SLIB \"coerce.scm\" module, which implements object type conversion.") (p "The major difference here is the ability to extend the type domain.") (p (tt "TYPE-TAG") " is a " (tt "symbol") ".") (p (tt "TYPE-PRED") " is a procedure, " (tt "(object -> boolean)") ", testing whether the argument is a type.") (section 3 "type-of" (p "Determine the type of an object.") (section 4 "Usage" (highlight scheme "(require-extension type-of)\n(require-extension type-extend)")) (section 4 "type-of" (def (sig (procedure "(type-of OBJECT) => TYPE-TAG" (id type-of))) (p "Returns a type tag for the type of " (tt "OBJECT") ".") (p "Built-in type tags are " (tt "unspecified") " (" (tt "void") "), " (tt "boolean") ", " (tt "port") ", " (tt "char") ", " (tt "number") ", " (tt "string") ", " (tt "keyword") ", " (tt "symbol") ", " (tt "pair") ", " (tt "list") ", " (tt "blob") ", " (tt "procedure") ", " (tt "pointer") ", " (tt "locative") ", and " (tt "vector") ". A " (tt "record-instance") " type tag is the " (tt "record-instance-tag") ". The catch-all is " (tt "object") "."))) (section 4 "type-of-extended?" (def (sig (procedure "(type-of-extended? TYPE-TAG) => BOOLEAN" (id type-of-extended?))) (p "Is the domain extended to cover the type identifier " (tt "TYPE-TAG") "."))) (section 4 "type-of-extend!" (def (sig (procedure "(type-of-extend! TYPE-TAG TYPE-PRED)" (id type-of-extend!))) (p "Extends the domain of type-of with the type definition " (tt "(TYPE-TAG TYPE-PRED)") "."))) (section 4 "type-of-composite-extension!" (def (sig (procedure "(type-of-composite-extension! TYPE-TAG TYPE-PRED)" (id type-of-composite-extension!))) (p "Extends the domain of an existing type-of extension.") (p "Should the new " (tt "TYPE-PRED") " and existing TYPE-PRED be " (tt "eq?") " the operation is ignored."))) (section 4 "type-of-extension-remove!" (def (sig (procedure "(type-of-extension-remove! TYPE-TAG)" (id type-of-extension-remove!))) (p "Delete any existing type-of extension for " (tt "TYPE-TAG") ".")))) (section 3 "coerce" (p "Translate an object into another type representation.") (section 4 "Usage" (highlight scheme "(require-extension coerce)\n(require-extension type-extend)")) (section 4 "coerce" (def (sig (procedure "(coerce OBJECT TYPE-TAG [DEFAULT-PROC]) => OBJECT" (id coerce))) (p "Converts " (tt "OBJECT") " to a value of " (tt "TYPE-TAG") ".") (p (tt "DEFAULT-PROC") " is a procedure with the signature " (tt "(OBJECT TYPE-TAG -> OBJECT)") " and is invoked when coercion fails. The default is to signal an error.") (p "Built-in types are " (tt "boolean") ", " (tt "port") ", " (tt "char") ", " (tt "number") ", " (tt "string") ", " (tt "keyword") ", " (tt "symbol") ", " (tt "pair") ", " (tt "blob") ", " (tt "list") ", and " (tt "vector") "."))) (section 4 "coerce-all" (def (sig (procedure "(coerce-all (OBJECT...) (TYPE-TAG...) [DEFAULT-PROC]) => LIST" (id coerce-all))) (p "Returns a list of every element of the " (tt "(OBJECT...)") " coerced to the corresponding element of the " (tt "(TYPE-TAG...)") ".") (p (tt "DEFAULT-PROC") " is as for " (tt "coerce") "."))) (section 4 "make-case-coerce" (def (sig (procedure "(make-case-coerce CONVERTOR [ALIST]) => PROCEDURE" (id make-case-coerce))) (p "Returns a coercion procedure for use with " (tt "extend-coerce")) (p (tt "CONVERTOR") " is a coercion procedure with the signature " (tt "(OBJECT TYPE-TAG ON-ERROR -> object)") ". " (tt "ON-ERROR") " is a procedure/0 that is invoked when all else fails.") (p (tt "ALIST") " here is a list of " (tt "(TYPE-TAG . (OBJECT -> OBJECT)") "."))) (section 4 "case-coerce" (def (sig (syntax "(case-coerce CASE ...) => PROCEDURE" (id case-coerce))) (p "Returns a coercion procedure for use with " (tt "extend-coerce") ".") (p (tt "CASE") " is of the form " (tt "((TYPE-TAG ...) EXPRESSION ...)") ", or " (tt "(else EXPRESSION ...)") ".") (p "The variable " (tt "object") " is bound to the object to coerce within the scope of " (tt "CASE ...") ".") (p "The variable " (tt "on-error") " is bound to a thunk within the scope of " (tt "CASE ...") "} to invoke upon failure.") (highlight scheme "(define (unspecified? obj) (eq? (void) obj))\n\n(define unspecified-coerce\n  (case-coerce\n    ((char)     #\\nul)\n    ((number)   +nan)\n    ((string)   \"\")\n    ((symbol)   '||)\n    ((list)     (list))\n    ((vector)   (vector))))\n\n(coerce-extend! 'unspecified unspecified? unspecified-coerce)\n\n(type-of (void)) ;=> unspecified\n\n(coerce-extend! 'string\n  string?\n  (case-coerce ((unspecified) (if (string=? \"\" object) (void) (on-error)))))\n\n(coerce \"\" 'unspecified) ;=> (void)"))) (section 4 "coerce-extended?" (def (sig (procedure "(coerce-extended? TYPE-TAG) => BOOLEAN" (id coerce-extended?))) (p "Is the domain extended to cover the type identifier " (tt "TYPE-TAG") "."))) (section 4 "coerce-extend!" (def (sig (procedure "(coerce-extend! TYPE-TAG TYPE-PRED CONVERTOR)" (id coerce-extend!))) (p "Extends the domain of coerce with the type definition " (tt "(TYPE-TAG TYPE-PRED CONVERTOR)") ".") (p (tt "TYPE-PRED") " is a procedure, " (tt "(object -> boolean)") ", testing whether the argument is a type.") (p (tt "CONVERTOR") " is a procedure, " (tt "(object symbol on-error -> object)") ", converting from the type to a result type.") (p "The " (tt "CONVERTOR") " " (b "must") " invoke " (tt "(on-error)") " when conversion not possible. Usually " (tt "case-coerce") " would be used to create the " (tt "CONVERTOR") ", which automatically handles calling of the " (tt "on-error") " argument."))) (section 4 "coerce-composite-extension!" (def (sig (procedure "(coerce-composite-extension! TYPE-TAG TYPE-PRED CONVERTOR)" (id coerce-composite-extension!))) (p "Extends the domain of an existing coerce extension.") (p (tt "TYPE-TAG") ", " (tt "TYPE-PRED") ", and " (tt "CONVERTOR") " are as for " (tt "extend-coerce") ".") (p "The new " (tt "CONVERTOR") " is try'ed before the existing procedure, then the existing procedure is try'ed \"on-error\".") (p "Should the new " (tt "TYPE-PRED") " and existing TYPE-PRED be " (tt "eq?") " the TYPE-PREDs are not \"composited\" using " (tt "or") "."))) (section 4 "coerce-extension-remove!" (def (sig (procedure "(coerce-extension-remove! TYPE-TAG)" (id coerce-extension-remove!))) (p "Delete any existing coerce extension for the type identifier " (tt "TYPE-TAG") "."))))) (section 2 "Usage" (highlight scheme "(require-extension coerce)")) (section 2 "Examples") (section 2 "Notes" (ul (li "When extending a type using " (tt "type-of-extend!") " no corresponding extension is made for " (tt "coerce") ". Please use " (tt "coerce-extend!") " should this be required.") (li "The coercion of a composite object to a scalar often makes little sense.") (li "The coercion of a scalar object to a composite is usually just to box the object with the specified composite.") (li "Renames some procedures from the Chicken 3 version."))) (section 2 "Requirements" (p (int-link "miscmacros") " " (int-link "lookup-table"))) (section 2 "Bugs and Limitations" (ul (li "Cannot know before attempt if coercion possible."))) (section 2 "Author" (p (int-link "/users/kon-lovett" "Kon Lovett"))) (section 2 "Version history" (dl (dt "1.1.0") (dd "Added " (tt "pointer") " & " (tt "locative") ". Catch-all is " (tt "object") ".") (dt "1.0.0") (dd "Initial Chicken 4 release."))) (section 2 "License" (p "Copyright (C) 2009 Kon Lovett.  All rights reserved.") (p "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:") (p "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.") (p "THE SOFTWARE IS PROVIDED ASIS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.") (p "\"coerce.scm\" Scheme Implementation of COMMON-LISP COERCE and TYPE-OF. Copyright (C) 1995, 2001 Aubrey Jaffer") (p "Permission to copy this software, to modify it, to redistribute it, to distribute modified versions, and to use it for any purpose is granted, subject to the following restrictions and understandings.") (p "1.  Any copy made of this software must include this copyright notice in full.") (p "2.  I have made no warranty or representation that the operation of this software will be error-free, and I am under no obligation to provide any services, by way of maintenance, update, or otherwise.") (p "3.  In conjunction with products arising from the use of this material, there shall be no use of my name in any advertising, promotional, or sales literature without prior written consent in each case.")))