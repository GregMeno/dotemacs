((tags "egg") (section 2 "rb-tree" (p "Sorted dictionary data structures based on red-black trees.") (toc)) (section 2 "Usage" (p "(require-extension rb-tree)")) (section 2 "Documentation" (p "The " (tt "rb-tree") " library is based on the SML/NJ library implementation of red-black trees, which is in turn based on Chris Okasaki's implementation of red-black trees.  The delete function is based on the description in Cormen, Leiserson, and Rivest.") (p "The present implementation code defines persistent and ephemeral map objects that implements an ordered dictionary mapping of keys to values. The map objects respond to a variety of query and update messages, including methods for finding the minimum and maximum keys and their associated values as well as traversing the tree in an ascending or descending order of keys.") (p "Looking up an arbitrary or the min/max keys, and deleting the min/max keys require no more key comparisons than the depth of the tree, which is " (tt "O(log n)") " where " (tt "n") " is the total number of keys in the tree.") (section 3 "Procedures" (section 4 "Ephemeral map procedures" (p "The ephemeral object is created by procedure " (tt "make-ephemeral-map") ":") (def (sig (procedure "make-ephemeral-map:: KEY-COMPARE-PROC [insdel-key-compare: KEY-COMPARE-PROC]  -> SELECTOR" (id make-ephemeral-map))) (p "where KEY-COMPARE-PROC is a user-supplied function that takes two keys and returns a negative, positive, or zero number depending on how the first key compares to the second.") (p "Optional keyword argument " (tt "insdel-key-compare") " can be used to specify different key comparison predicates for the insertion and deletion operations.") (p "The returned selector procedure can take one of the following arguments:") (dl (dt (tt "get")) (dd "returns a procedure " (tt "LAMBDA KEY . DEFAULT-CLAUSE") " which searches the red-black tree for an association with a given " (tt "KEY") ", and returns a (key . value) pair of the found association. If an association with " (tt "KEY") " cannot be located in the red-black tree, the PROC returns the result of evaluating the " (tt "DEFAULT-CLAUSE") ". If the default clause is omitted, an error is signalled. " (tt "KEY") " must be comparable to the keys in the red-black tree by a key-compare predicate (which has been specified when the red-black tree was created)") (dt (tt "get-value")) (dd "returns a procedure " (tt "LAMBDA KEY . DEFAULT-CLAUSE") " which searches the red-black tree for an association with a given " (tt "KEY") ", and returns the value of (key . value) pair of the found association. If an association with " (tt "KEY") " cannot be located in the red-black tree, the PROC returns the result of evaluating the " (tt "DEFAULT-CLAUSE") ". If the default clause is omitted, an error is signalled. " (tt "KEY") " must be comparable to the keys in the red-black tree by a key-compare predicate (which has been specified when the red-black tree was created)") (dt (tt "get-min")) (dd "returns a (key . value) pair for an association in the red-black tree with the smallest key. If the red-black tree is empty, an error is signalled.") (dt (tt "delete-min!")) (dd "removes the min key and the corresponding association from the red-black tree. Returns a (key . value) pair of the removed association. If the red-black tree is empty, an error is signalled. ") (dt (tt "get-max")) (dd "returns a (key . value) pair for an association in the red-black tree with the largest key. If the red-black tree is empty, an error is signalled.") (dt (tt "delete-max!")) (dd "removes the max key and the corresponding association from the red-black tree. Returns a (key . value) pair of the removed association. If the red-black tree is empty, an error is signalled.") (dt (tt "empty?")) (dd "returns " (tt "#t") " if the red-black tree is empty") (dt (tt "size")) (dd "returns the size (the number of associations) in the red-black tree") (dt (tt "depth")) (dd "returns the depth of the tree. It requires the complete traversal of the tree, so use sparingly") (dt (tt "clear!")) (dd "removes all associations from the red-black tree (thus making it empty)") (dt (tt "put!")) (dd "returns a procedure " (tt "LAMBDA KEY VALUE") " which, given a " (tt "KEY") " and a " (tt "VALUE") ", adds the corresponding association to the red-black tree. If an association with the same " (tt "KEY") " already exists, its value is replaced with the " (tt "VALUE") " (and the old (key . value) association is returned). Otherwise, the return value is " (tt "#f") ".") (dt (tt "put")) (dd "pure variant of " (tt "PUT!") "; it returns a new red-black tree object that contains the given association, while the original red-black tree object is unmodified. ") (dt (tt "delete!")) (dd "returns a procedure " (tt "LAMBDA KEY . DEFAULT-CLAUSE") " which searches the red-black tree for an association with a given " (tt "KEY") ", deletes it, and returns a (key . value) pair of the found and deleted association. If an association with the KEY cannot be located in the red-black tree, the " (tt "PROC") " returns the result of evaluating " (tt "DEFAULT-CLAUSE") ". If the default clause is omitted, an error is signalled. ") (dt (tt "delete")) (dd "pure variant of " (tt "DELETE!") "; if the specified key is found, it returns a new red-black tree object that no longer contains the association specified by that key, while the original red-black tree object is unmodified. If the key is not found, the behavior of this procedure is identical to " (tt "DELETE!") ". ") (dt (tt "for-each-ascending")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure PROC to each (key . value) association of the red-black tree, from the one with the smallest key all the way to the one with the max key, in an ascending order of keys. ") (dt (tt "for-each-descending")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure " (tt "PROC") "to each (key . value) association of the red-black tree, in the descending order of keys. ") (dt (tt "map")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure " (tt "PROC") "to the value component of each association in the red-black tree, in the ascending order of keys, and will construct a copy of the tree that contains the values returned by that procedure.") (dt (tt "mapi")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure " (tt "PROC") "to each (key . value) association in the red-black tree, in the ascending order of keys, and will construct a copy of the tree that contains the values returned by that procedure.") (dt (tt "fold")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-1 (PROC value-2 ... (PROC value-n INITIAL)") ". ") (dt (tt "foldi")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-1 value-1 (PROC key-2 value-2 ... (PROC key-n value-n INITIAL)") ". ") (dt (tt "fold-right")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the ascending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-n . value-n) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-n ... (PROC value-2 (PROC value-1 INITIAL)") ". ") (dt (tt "foldi-right")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the ascending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-n . value-n) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-n value-n ... (PROC key-2 value-2 (PROC key-1 value-1 INITIAL)") ". ") (dt (tt "fold-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-i ... (PROC value-n INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " holds true for all " (tt "x = (value-n) ... (value-i)") ". In other words, this function acts like " (tt "fold") " on the ordered subset of the values " (tt "x") " in the tree such that " (tt "(PRED x)") " is true. ") (dt (tt "foldi-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-i value-i ... (PROC key-n value-n INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED xk x)") " holds true for all " (tt "x = (value-n) ... (value-i)") " and " (tt "xk = (key-n) ... (key-i)") ". In other words, this function acts like " (tt "foldi") " on the ordered subset of the key-value pairs " (tt "(k . x)") " in the tree such that " (tt "(PRED k x)") " is true. ") (dt (tt "fold-right-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the ascending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-n . value-n) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-1 ... (PROC value-i INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " holds true for all " (tt "x = (value-1) ... (value-i)") ". In other words, this function acts like " (tt "fold-right") " on the ordered subset of the values " (tt "x") " in the tree such that " (tt "(PRED x)") " is true. ") (dt (tt "foldi-right-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-1 value-1 ... (PROC key-i value-i INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED xk x)") " holds true for all " (tt "x = (value-1) ... (value-i)") " and " (tt "xk = (key-1) ... (key-i)") ". In other words, this function acts like " (tt "foldi-right") " on the ordered subset of the key-value pairs " (tt "(k . x)") " in the tree such that " (tt "(PRED k x)") " is true. ") (dt (tt "fold-limit")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-i ... (PROC value-n INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " does not hold true for all " (tt "x = (PROC value-n INITIAL)  ... (PROC (value-i) (PROC value-(i-1)...") ". ") (dt (tt "fold-right-limit")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-i . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-i ... (PROC value-1 INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " does not hold true for all " (tt "x = (PROC value-1 INITIAL)  ... (PROC (value-i) (PROC value-(i-1)...") ". ")))) (section 4 "Persistent map procedures" (p "The persistent object is created by procedure " (tt "make-persistent-map") ":") (def (sig (procedure "make-persistent-map:: KEY-COMPARE-PROC [insdel-key-compare: KEY-COMPARE-PROC]  -> SELECTOR" (id make-persistent-map))) (p "where KEY-COMPARE-PROC is a user-supplied function that takes two keys and returns a negative, positive, or zero number depending on how the first key compares to the second.") (p "Optional keyword argument " (tt "insdel-key-compare") " can be used to specify different key comparison predicates for the insertion and deletion operations.") (p "The returned selector procedure can take one of the following arguments:") (dl (dt (tt "get")) (dd "returns a procedure " (tt "LAMBDA KEY . DEFAULT-CLAUSE") " which searches the red-black tree for an association with a given " (tt "KEY") ", and returns a (key . value) pair of the found association. If an association with " (tt "KEY") " cannot be located in the red-black tree, the PROC returns the result of evaluating the " (tt "DEFAULT-CLAUSE") ". If the default clause is omitted, an error is signalled. " (tt "KEY") " must be comparable to the keys in the red-black tree by a key-compare predicate (which has been specified when the red-black tree was created)") (dt (tt "get-value")) (dd "returns a procedure " (tt "LAMBDA KEY . DEFAULT-CLAUSE") " which searches the red-black tree for an association with a given " (tt "KEY") ", and returns the value of (key . value) pair of the found association. If an association with " (tt "KEY") " cannot be located in the red-black tree, the PROC returns the result of evaluating the " (tt "DEFAULT-CLAUSE") ". If the default clause is omitted, an error is signalled. " (tt "KEY") " must be comparable to the keys in the red-black tree by a key-compare predicate (which has been specified when the red-black tree was created)") (dt (tt "get-min")) (dd "returns a (key . value) pair for an association in the red-black tree with the smallest key. If the red-black tree is empty, an error is signalled.") (dt (tt "delete-min!")) (dd "removes the min key and the corresponding association from the red-black tree. Returns a (key . value) pair of the removed association. If the red-black tree is empty, an error is signalled. ") (dt (tt "get-max")) (dd "returns a (key . value) pair for an association in the red-black tree with the largest key. If the red-black tree is empty, an error is signalled.") (dt (tt "delete-max!")) (dd "removes the max key and the corresponding association from the red-black tree. Returns a (key . value) pair of the removed association. If the red-black tree is empty, an error is signalled.") (dt (tt "empty?")) (dd "returns " (tt "#t") " if the red-black tree is empty") (dt (tt "size")) (dd "returns the size (the number of associations) in the red-black tree") (dt (tt "depth")) (dd "returns the depth of the tree. It requires the complete traversal of the tree, so use sparingly") (dt (tt "put")) (dd "pure variant of " (tt "PUT!") "; it returns a new red-black tree object that contains the given association, while the original red-black tree object is unmodified. ") (dt (tt "delete")) (dd "pure variant of " (tt "DELETE!") "; if the specified key is found, it returns a new red-black tree object that no longer contains the association specified by that key, while the original red-black tree object is unmodified. If the key is not found, the behavior of this procedure is identical to " (tt "DELETE!") ". ") (dt (tt "for-each-ascending")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure PROC to each (key . value) association of the red-black tree, from the one with the smallest key all the way to the one with the max key, in an ascending order of keys. ") (dt (tt "for-each-descending")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure " (tt "PROC") "to each (key . value) association of the red-black tree, in the descending order of keys. ") (dt (tt "map")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure " (tt "PROC") "to the value component of each association in the red-black tree, in the ascending order of keys, and will construct a copy of the tree that contains the values returned by that procedure.") (dt (tt "mapi")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure " (tt "PROC") "to each (key . value) association in the red-black tree, in the ascending order of keys, and will construct a copy of the tree that contains the values returned by that procedure.") (dt (tt "fold")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-1 (PROC value-2 ... (PROC value-n INITIAL)") ". ") (dt (tt "foldi")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-1 value-1 (PROC key-2 value-2 ... (PROC key-n value-n INITIAL)") ". ") (dt (tt "fold-right")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the ascending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-n . value-n) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-n ... (PROC value-2 (PROC value-1 INITIAL)") ". ") (dt (tt "foldi-right")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the ascending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-n . value-n) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-n value-n ... (PROC key-2 value-2 (PROC key-1 value-1 INITIAL)") ". ") (dt (tt "fold-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-i ... (PROC value-n INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " holds true for all " (tt "x = (value-n) ... (value-i)") ". In other words, this function acts like " (tt "fold") " on the ordered subset of the values " (tt "x") " in the tree such that " (tt "(PRED x)") " is true. ") (dt (tt "foldi-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-i value-i ... (PROC key-n value-n INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED xk x)") " holds true for all " (tt "x = (value-n) ... (value-i)") " and " (tt "xk = (key-n) ... (key-i)") ". In other words, this function acts like " (tt "foldi") " on the ordered subset of the key-value pairs " (tt "(k . x)") " in the tree such that " (tt "(PRED k x)") " is true. ") (dt (tt "fold-right-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the ascending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-n . value-n) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-1 ... (PROC value-i INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " holds true for all " (tt "x = (value-1) ... (value-i)") ". In other words, this function acts like " (tt "fold-right") " on the ordered subset of the values " (tt "x") " in the tree such that " (tt "(PRED x)") " is true. ") (dt (tt "foldi-right-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-1 value-1 ... (PROC key-i value-i INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED xk x)") " holds true for all " (tt "x = (value-1) ... (value-i)") " and " (tt "xk = (key-1) ... (key-i)") ". In other words, this function acts like " (tt "foldi-right") " on the ordered subset of the key-value pairs " (tt "(k . x)") " in the tree such that " (tt "(PRED k x)") " is true. ") (dt (tt "fold-limit")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-i ... (PROC value-n INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " does not hold true for all " (tt "x = (PROC value-n INITIAL)  ... (PROC (value-i) (PROC value-(i-1)...") ". ") (dt (tt "fold-right-limit")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-i . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-i ... (PROC value-1 INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " does not hold true for all " (tt "x = (PROC value-1 INITIAL)  ... (PROC (value-i) (PROC value-(i-1)...") ". ")))))) (section 2 "Examples" (pre ";; \"--> Sorting of a set of numbers via a red-black tree\" \n\n(define (++ x) (fx+ 1 x))\n(define (-- x) (fx- x 1))\n\n(let\n  ((min-key -1) (max-key 10)\n   (m (make-ephemeral-map (lambda (x y) (- x y))))\n   ;; a hard-wired association between a key and a value\n   (compute-assoc (lambda (key) (cons key (++ key)))))\n\n  ;; loading a sequence [min-key .. max-key] in ascending order\n  (do ((i min-key (++ i))) ((> i max-key))\n    ((m 'put!) i (cdr (compute-assoc i))))\n\n  (print \"the tree depth is \" (m 'depth) \"\\n\")\n\n  (print ((m 'get) (++ min-key)))\n\n  (print ((m 'get) (++ min-key) 'notfound))\n\n  ;; checking traversing in ascending order\n  (let ((expected-key min-key))\n    ((m 'for-each-ascending)\n      (lambda (association)\n        (print (equal? association (compute-assoc expected-key)))\n        (set! expected-key (++ expected-key)))))\n\n  ;; clearing the m and reloading the same sequence in\n  ;; descending order\n  (m 'clear!)\n  (do ((i max-key (-- i))) ((< i min-key))\n     ((m 'put!) i (cdr (compute-assoc i))))\n\n  (print \"the tree depth is \" (m 'depth) \"\\n\")\n\n  ;; checking traversing in descending order\n  (let ((expected-key max-key))\n    ((m 'for-each-descending)\n      (lambda (association)\n        (print (equal? association (compute-assoc expected-key)))\n        (set! expected-key (-- expected-key))))))")) (section 2 "About this egg" (section 3 "Author" (p (int-link "/users/ivan-raikov" "Ivan Raikov"))) (section 3 "Version history" (dl (dt "4.0") (dd "Divided API in persistent and ephemeral maps") (dt "3.1") (dd "Added get-value operation") (dt "3.0") (dd "Ability to specify different predicates for lookup, insert, delete operations") (dt "2.9") (dd "Documentation converted to wiki format") (dt "2.8") (dd "Added matchable as dependency") (dt "2.7") (dd "Bug fix in dispatch-on-key") (dt "2.6") (dd "Ported to Chicken 4") (dt "2.5") (dd "Fixes to for-each-ascending/descending") (dt "2.3") (dd "Build script updated for better cross-platform compatibility") (dt "2.2") (dd "Added fold-limit procedures") (dt "2.1") (dd "Added fold-partial procedures") (dt "2.0") (dd "Added side-effect-free put and delete procedures") (dt "1.0") (dd "Initial release"))) (section 3 "License" (pre "Copyright 2007-2010 Ivan Raikov and the Okinawa Institute of Science and Technology.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or (at\nyour option) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nA full copy of the GPL license can be found at\n<http://www.gnu.org/licenses/>."))))