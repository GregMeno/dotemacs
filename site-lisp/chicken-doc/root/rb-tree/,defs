(index ("make-ephemeral-map" 0) ("make-persistent-map" 10762))
(def (sig (procedure "make-ephemeral-map:: KEY-COMPARE-PROC [insdel-key-compare: KEY-COMPARE-PROC]  -> SELECTOR" (id make-ephemeral-map))) (p "where KEY-COMPARE-PROC is a user-supplied function that takes two keys and returns a negative, positive, or zero number depending on how the first key compares to the second.") (p "Optional keyword argument " (tt "insdel-key-compare") " can be used to specify different key comparison predicates for the insertion and deletion operations.") (p "The returned selector procedure can take one of the following arguments:") (dl (dt (tt "get")) (dd "returns a procedure " (tt "LAMBDA KEY . DEFAULT-CLAUSE") " which searches the red-black tree for an association with a given " (tt "KEY") ", and returns a (key . value) pair of the found association. If an association with " (tt "KEY") " cannot be located in the red-black tree, the PROC returns the result of evaluating the " (tt "DEFAULT-CLAUSE") ". If the default clause is omitted, an error is signalled. " (tt "KEY") " must be comparable to the keys in the red-black tree by a key-compare predicate (which has been specified when the red-black tree was created)") (dt (tt "get-value")) (dd "returns a procedure " (tt "LAMBDA KEY . DEFAULT-CLAUSE") " which searches the red-black tree for an association with a given " (tt "KEY") ", and returns the value of (key . value) pair of the found association. If an association with " (tt "KEY") " cannot be located in the red-black tree, the PROC returns the result of evaluating the " (tt "DEFAULT-CLAUSE") ". If the default clause is omitted, an error is signalled. " (tt "KEY") " must be comparable to the keys in the red-black tree by a key-compare predicate (which has been specified when the red-black tree was created)") (dt (tt "get-min")) (dd "returns a (key . value) pair for an association in the red-black tree with the smallest key. If the red-black tree is empty, an error is signalled.") (dt (tt "delete-min!")) (dd "removes the min key and the corresponding association from the red-black tree. Returns a (key . value) pair of the removed association. If the red-black tree is empty, an error is signalled. ") (dt (tt "get-max")) (dd "returns a (key . value) pair for an association in the red-black tree with the largest key. If the red-black tree is empty, an error is signalled.") (dt (tt "delete-max!")) (dd "removes the max key and the corresponding association from the red-black tree. Returns a (key . value) pair of the removed association. If the red-black tree is empty, an error is signalled.") (dt (tt "empty?")) (dd "returns " (tt "#t") " if the red-black tree is empty") (dt (tt "size")) (dd "returns the size (the number of associations) in the red-black tree") (dt (tt "depth")) (dd "returns the depth of the tree. It requires the complete traversal of the tree, so use sparingly") (dt (tt "clear!")) (dd "removes all associations from the red-black tree (thus making it empty)") (dt (tt "put!")) (dd "returns a procedure " (tt "LAMBDA KEY VALUE") " which, given a " (tt "KEY") " and a " (tt "VALUE") ", adds the corresponding association to the red-black tree. If an association with the same " (tt "KEY") " already exists, its value is replaced with the " (tt "VALUE") " (and the old (key . value) association is returned). Otherwise, the return value is " (tt "#f") ".") (dt (tt "put")) (dd "pure variant of " (tt "PUT!") "; it returns a new red-black tree object that contains the given association, while the original red-black tree object is unmodified. ") (dt (tt "delete!")) (dd "returns a procedure " (tt "LAMBDA KEY . DEFAULT-CLAUSE") " which searches the red-black tree for an association with a given " (tt "KEY") ", deletes it, and returns a (key . value) pair of the found and deleted association. If an association with the KEY cannot be located in the red-black tree, the " (tt "PROC") " returns the result of evaluating " (tt "DEFAULT-CLAUSE") ". If the default clause is omitted, an error is signalled. ") (dt (tt "delete")) (dd "pure variant of " (tt "DELETE!") "; if the specified key is found, it returns a new red-black tree object that no longer contains the association specified by that key, while the original red-black tree object is unmodified. If the key is not found, the behavior of this procedure is identical to " (tt "DELETE!") ". ") (dt (tt "for-each-ascending")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure PROC to each (key . value) association of the red-black tree, from the one with the smallest key all the way to the one with the max key, in an ascending order of keys. ") (dt (tt "for-each-descending")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure " (tt "PROC") "to each (key . value) association of the red-black tree, in the descending order of keys. ") (dt (tt "map")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure " (tt "PROC") "to the value component of each association in the red-black tree, in the ascending order of keys, and will construct a copy of the tree that contains the values returned by that procedure.") (dt (tt "mapi")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure " (tt "PROC") "to each (key . value) association in the red-black tree, in the ascending order of keys, and will construct a copy of the tree that contains the values returned by that procedure.") (dt (tt "fold")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-1 (PROC value-2 ... (PROC value-n INITIAL)") ". ") (dt (tt "foldi")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-1 value-1 (PROC key-2 value-2 ... (PROC key-n value-n INITIAL)") ". ") (dt (tt "fold-right")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the ascending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-n . value-n) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-n ... (PROC value-2 (PROC value-1 INITIAL)") ". ") (dt (tt "foldi-right")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the ascending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-n . value-n) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-n value-n ... (PROC key-2 value-2 (PROC key-1 value-1 INITIAL)") ". ") (dt (tt "fold-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-i ... (PROC value-n INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " holds true for all " (tt "x = (value-n) ... (value-i)") ". In other words, this function acts like " (tt "fold") " on the ordered subset of the values " (tt "x") " in the tree such that " (tt "(PRED x)") " is true. ") (dt (tt "foldi-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-i value-i ... (PROC key-n value-n INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED xk x)") " holds true for all " (tt "x = (value-n) ... (value-i)") " and " (tt "xk = (key-n) ... (key-i)") ". In other words, this function acts like " (tt "foldi") " on the ordered subset of the key-value pairs " (tt "(k . x)") " in the tree such that " (tt "(PRED k x)") " is true. ") (dt (tt "fold-right-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the ascending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-n . value-n) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-1 ... (PROC value-i INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " holds true for all " (tt "x = (value-1) ... (value-i)") ". In other words, this function acts like " (tt "fold-right") " on the ordered subset of the values " (tt "x") " in the tree such that " (tt "(PRED x)") " is true. ") (dt (tt "foldi-right-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-1 value-1 ... (PROC key-i value-i INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED xk x)") " holds true for all " (tt "x = (value-1) ... (value-i)") " and " (tt "xk = (key-1) ... (key-i)") ". In other words, this function acts like " (tt "foldi-right") " on the ordered subset of the key-value pairs " (tt "(k . x)") " in the tree such that " (tt "(PRED k x)") " is true. ") (dt (tt "fold-limit")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-i ... (PROC value-n INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " does not hold true for all " (tt "x = (PROC value-n INITIAL)  ... (PROC (value-i) (PROC value-(i-1)...") ". ") (dt (tt "fold-right-limit")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-i . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-i ... (PROC value-1 INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " does not hold true for all " (tt "x = (PROC value-1 INITIAL)  ... (PROC (value-i) (PROC value-(i-1)...") ". ")))
(def (sig (procedure "make-persistent-map:: KEY-COMPARE-PROC [insdel-key-compare: KEY-COMPARE-PROC]  -> SELECTOR" (id make-persistent-map))) (p "where KEY-COMPARE-PROC is a user-supplied function that takes two keys and returns a negative, positive, or zero number depending on how the first key compares to the second.") (p "Optional keyword argument " (tt "insdel-key-compare") " can be used to specify different key comparison predicates for the insertion and deletion operations.") (p "The returned selector procedure can take one of the following arguments:") (dl (dt (tt "get")) (dd "returns a procedure " (tt "LAMBDA KEY . DEFAULT-CLAUSE") " which searches the red-black tree for an association with a given " (tt "KEY") ", and returns a (key . value) pair of the found association. If an association with " (tt "KEY") " cannot be located in the red-black tree, the PROC returns the result of evaluating the " (tt "DEFAULT-CLAUSE") ". If the default clause is omitted, an error is signalled. " (tt "KEY") " must be comparable to the keys in the red-black tree by a key-compare predicate (which has been specified when the red-black tree was created)") (dt (tt "get-value")) (dd "returns a procedure " (tt "LAMBDA KEY . DEFAULT-CLAUSE") " which searches the red-black tree for an association with a given " (tt "KEY") ", and returns the value of (key . value) pair of the found association. If an association with " (tt "KEY") " cannot be located in the red-black tree, the PROC returns the result of evaluating the " (tt "DEFAULT-CLAUSE") ". If the default clause is omitted, an error is signalled. " (tt "KEY") " must be comparable to the keys in the red-black tree by a key-compare predicate (which has been specified when the red-black tree was created)") (dt (tt "get-min")) (dd "returns a (key . value) pair for an association in the red-black tree with the smallest key. If the red-black tree is empty, an error is signalled.") (dt (tt "delete-min!")) (dd "removes the min key and the corresponding association from the red-black tree. Returns a (key . value) pair of the removed association. If the red-black tree is empty, an error is signalled. ") (dt (tt "get-max")) (dd "returns a (key . value) pair for an association in the red-black tree with the largest key. If the red-black tree is empty, an error is signalled.") (dt (tt "delete-max!")) (dd "removes the max key and the corresponding association from the red-black tree. Returns a (key . value) pair of the removed association. If the red-black tree is empty, an error is signalled.") (dt (tt "empty?")) (dd "returns " (tt "#t") " if the red-black tree is empty") (dt (tt "size")) (dd "returns the size (the number of associations) in the red-black tree") (dt (tt "depth")) (dd "returns the depth of the tree. It requires the complete traversal of the tree, so use sparingly") (dt (tt "put")) (dd "pure variant of " (tt "PUT!") "; it returns a new red-black tree object that contains the given association, while the original red-black tree object is unmodified. ") (dt (tt "delete")) (dd "pure variant of " (tt "DELETE!") "; if the specified key is found, it returns a new red-black tree object that no longer contains the association specified by that key, while the original red-black tree object is unmodified. If the key is not found, the behavior of this procedure is identical to " (tt "DELETE!") ". ") (dt (tt "for-each-ascending")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure PROC to each (key . value) association of the red-black tree, from the one with the smallest key all the way to the one with the max key, in an ascending order of keys. ") (dt (tt "for-each-descending")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure " (tt "PROC") "to each (key . value) association of the red-black tree, in the descending order of keys. ") (dt (tt "map")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure " (tt "PROC") "to the value component of each association in the red-black tree, in the ascending order of keys, and will construct a copy of the tree that contains the values returned by that procedure.") (dt (tt "mapi")) (dd "returns a procedure " (tt "LAMBDA PROC") " that will apply the given procedure " (tt "PROC") "to each (key . value) association in the red-black tree, in the ascending order of keys, and will construct a copy of the tree that contains the values returned by that procedure.") (dt (tt "fold")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-1 (PROC value-2 ... (PROC value-n INITIAL)") ". ") (dt (tt "foldi")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-1 value-1 (PROC key-2 value-2 ... (PROC key-n value-n INITIAL)") ". ") (dt (tt "fold-right")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the ascending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-n . value-n) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-n ... (PROC value-2 (PROC value-1 INITIAL)") ". ") (dt (tt "foldi-right")) (dd "returns a procedure " (tt "LAMBDA PROC INITIAL") " such that, given the associations in the tree ordered by the ascending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-n . value-n) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-n value-n ... (PROC key-2 value-2 (PROC key-1 value-1 INITIAL)") ". ") (dt (tt "fold-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-i ... (PROC value-n INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " holds true for all " (tt "x = (value-n) ... (value-i)") ". In other words, this function acts like " (tt "fold") " on the ordered subset of the values " (tt "x") " in the tree such that " (tt "(PRED x)") " is true. ") (dt (tt "foldi-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-i value-i ... (PROC key-n value-n INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED xk x)") " holds true for all " (tt "x = (value-n) ... (value-i)") " and " (tt "xk = (key-n) ... (key-i)") ". In other words, this function acts like " (tt "foldi") " on the ordered subset of the key-value pairs " (tt "(k . x)") " in the tree such that " (tt "(PRED k x)") " is true. ") (dt (tt "fold-right-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the ascending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-n . value-n) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-1 ... (PROC value-i INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " holds true for all " (tt "x = (value-1) ... (value-i)") ". In other words, this function acts like " (tt "fold-right") " on the ordered subset of the values " (tt "x") " in the tree such that " (tt "(PRED x)") " is true. ") (dt (tt "foldi-right-partial")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC key-1 value-1 ... (PROC key-i value-i INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED xk x)") " holds true for all " (tt "x = (value-1) ... (value-i)") " and " (tt "xk = (key-1) ... (key-i)") ". In other words, this function acts like " (tt "foldi-right") " on the ordered subset of the key-value pairs " (tt "(k . x)") " in the tree such that " (tt "(PRED k x)") " is true. ") (dt (tt "fold-limit")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-n . value-n) ... (key-2 . value-2) (key-1 . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-i ... (PROC value-n INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " does not hold true for all " (tt "x = (PROC value-n INITIAL)  ... (PROC (value-i) (PROC value-(i-1)...") ". ") (dt (tt "fold-right-limit")) (dd "returns a procedure " (tt "LAMBDA PRED PROC INITIAL") " such that, given the associations in the tree ordered by the descending order of keys: " (tt "(key-1 . value-1) (key-2 . value-2) ... (key-i . value-1) ") " the procedure returns the result of the successive function applications " (tt "(PROC value-i ... (PROC value-1 INITIAL)") ", where " (tt "i <= n") " and " (tt "(PRED x)") " does not hold true for all " (tt "x = (PROC value-1 INITIAL)  ... (PROC (value-i) (PROC value-(i-1)...") ". ")))
