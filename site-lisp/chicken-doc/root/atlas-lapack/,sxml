((tags "egg") (section 2 "atlas-lapack" (p "An interface to the LAPACK routines implemented in ATLAS.") (toc)) (section 2 "Usage" (p "(require-extension atlas-lapack)")) (section 2 "Documentation" (p (link "http://math-atlas.sourceforge.net/" "ATLAS") " stands for Automatically Tuned Linear Algebra Software. Its purpose is to provide portably optimal linear algebra routines. The current version provides a complete " (link "http://www.netlib.org/blas" "BLAS") " API (for both C and Fortran77), and a very small subset of the " (link "http://www.netlib.org/lapack" "LAPACK") " API. Please see the documentation for the " (int-link "blas") " egg for definitions of the ORDER, UPLO, DIAG and TRANSPOSE datatypes.") (section 3 "Naming conventions for routines" (p "Every routine in the LAPACK library comes in four flavors, each prefixed by the letters S, D, C, and Z, respectively. Each letter indicates the format of input data:") (ul (li "S stands for single-precision (32-bit IEEE floating point numbers), ") (li "D stands for double-precision (64-bit IEEE floating point numbers), ") (li "C stands for complex numbers (represented by pairs of 32-bit IEEE floating point numbers), ") (li "Z stands for double complex numbers (represented by pairs of 64-bit IEEE floating point numbers)")) (p "In addition, each ATLAS-LAPACK routine in this egg comes in three flavors:") (ul (li "Safe, pure (prefix: " (b "atlas-lapack:") ") " (i "Safe") " routines check the sizes of their input arguments. For example, if a routine is supplied arguments that indicate that an input matrix is of dimensions " (i "M") "-by-" (i "N") ", then the argument corresponding to that matrix is checked that it is of size " (i "M * N") ".")) (p (i "Pure") " routines do not alter their arguments in any way. A new matrix or vector is allocated for the return value of the routine.") (ul (li "Safe, destructive (prefix: " (b "atlas-lapack:") ", suffix: !) " (i "Safe") " routines check the sizes of their input arguments. For example, if a routine is supplied arguments that indicate that an input matrix is of dimensions " (i "M") "-by-" (i "N") ", then the argument corresponding to that matrix is checked that it is of size " (i "M * N") ".")) (p (i "Destructive") " routines can modify some or all of their arguments. They  are given names ending in exclamation mark. The matrix factorization routines in LAPACK overwrite the input matrix argument with the result of the factorization, and the linear system solvers overwrite the right-hand side vector with the system solution. Please consult the LAPACK documentation to determine which functions modify their input arguments.") (ul (li "Unsafe, destructive (prefix: " (b "unsafe-atlas-lapack:") ", suffix: !) " (i "Unsafe") " routines do not check the sizes of their input arguments. They invoke the corresponding ATLAS-LAPACK routines directly. Unsafe routines do not have pure variants.")) (p "For example, function " (i "xGESV") " (N-by-N linear system solver) comes in the following variants:") (table (tr (th (b "LAPACK name")) (th (b "Safe, pure")) (th (b "Safe, destructive")) (th (b "Unsafe, destructive"))) "\n" (tr (td (i "SGESV")) (td (i "atlas-lapack:sgesv")) (td (i "atlas-lapack:sgesv!")) (td (i "unsafe-atlas-lapack:sgesv!"))) "\n" (tr (td (i "DGESV")) (td (i "atlas-lapack:dgesv")) (td (i "atlas-lapack:dgesv!")) (td (i "unsafe-atlas-lapack:dgesv!"))) "\n" (tr (td (i "CGESV")) (td (i "atlas-lapack:cgesv")) (td (i "atlas-lapack:cgesv!")) (td (i "unsafe-atlas-lapack:cgesv!"))) "\n" (tr (td (i "ZGESV")) (td (i "atlas-lapack:zgesv")) (td (i "atlas-lapack:zgesv!")) (td (i "unsafe-atlas-lapack:zgesv!"))))) (section 3 "LAPACK driver routines" (section 4 "General linear system solving" (def (sig (procedure "atlas-lapack:sgesv:: ORDER * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR * F32VECTOR * S32VECTOR" (id atlas-lapack:sgesv)))) (def (sig (procedure "atlas-lapack:dgesv:: ORDER * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR * F64VECTOR * S32VECTOR" (id atlas-lapack:dgesv)))) (def (sig (procedure "atlas-lapack:cgesv:: ORDER * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR * F32VECTOR * S32VECTOR" (id atlas-lapack:cgesv)))) (def (sig (procedure "atlas-lapack:zgesv:: ORDER * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR * F64VECTOR * S32VECTOR" (id atlas-lapack:zgesv))) (p "The routines compute the solution to a system of linear equations " (i "A * X = B") ", where " (i "A") " is an N-by-N matrix and " (i "X") " and " (i "B") " are N-by-NRHS matrices. Optional arguments " (i "LDA") " and " (i "LDB") " are the leading dimensions of arrays " (i "A") " and " (i "B") ", respectively. LU decomposition with partial pivoting and row interchanges is used to factor " (i "A") " as " (i "A = P * L * U") ", where " (i "P") " is a permutation matrix, " (i "L") " is unit lower triangular, and " (i "U") " is upper triangular. The factored form of " (i "A") " is then used to solve the system. The return values are:") (ol (li "a matrix containing the factors " (i "L") " and " (i "U") " from the factorization " (i "A = P*L*U") "; ") (li "the N-by-NRHS solution matrix " (i "X")) (li "a vector with pivot indices:  for 1 <= i <= min(M,N), row " (i "i") " of the matrix " (i "A") " was interchanged with row pivot(" (i "i") ")")))) (section 4 "Symmetric positive definite linear system solving" (def (sig (procedure "atlas-lapack:sposv:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR * F32VECTOR" (id atlas-lapack:sposv)))) (def (sig (procedure "atlas-lapack:dposv:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR * F64VECTOR" (id atlas-lapack:dposv)))) (def (sig (procedure "atlas-lapack:cposv:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR * F32VECTOR" (id atlas-lapack:cposv)))) (def (sig (procedure "atlas-lapack:zposv:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR * F64VECTOR" (id atlas-lapack:zposv))) (p "The routines compute the solution to a system of linear equations " (i "A * X = B") ", where " (i "A") " is an N-by-N symmetric positive definite matrix and " (i "X") " and " (i "B") " are N-by-NRHS matrices. Optional arguments " (i "LDA") " and " (i "LDB") " are the leading dimensions of arrays " (i "A") " and " (i "B") ", respectively. Cholesky decomposition is used to factor " (i "A") " as") (ul (li (i "A = U**T * U") "     if UPLO = " (b "blas:Upper")) (li (i "A = L  * L**T") "     if UPLO = " (b "blas:Lower") " where " (i "U") " is an upper triangular, and " (i "L") " is a lower triangular matrix. The factored form of " (i "A") " is then used to solve the system. The return values are:") (li "the factor " (i "U") " or " (i "L") "from the Cholesky factorization, depending on the value of argument UPLO.") (li "the N-by-NRHS solution matrix " (i "X")))))) (section 3 "LAPACK computational routines" (section 4 "General matrix factorization" (def (sig (procedure "atlas-lapack:sgetrf:: ORDER * M * N * A * [LDA] -> F32VECTOR * S32VECTOR" (id atlas-lapack:sgetrf)))) (def (sig (procedure "atlas-lapack:dgetrf:: ORDER * M * N * A * [LDA] -> F64VECTOR * S32VECTOR" (id atlas-lapack:dgetrf)))) (def (sig (procedure "atlas-lapack:cgetrf:: ORDER * M * N * A * [LDA] -> F32VECTOR * S32VECTOR" (id atlas-lapack:cgetrf)))) (def (sig (procedure "atlas-lapack:zgetrf:: ORDER * M * N * A * [LDA] -> F64VECTOR * S32VECTOR" (id atlas-lapack:zgetrf))) (p "These routines compute an LU factorization of a general M-by-N matrix " (i "A") " using partial pivoting with row interchanges. Optional argument " (i "LDA") " is the leading dimension of array " (i "A") ". The return values are:") (ol (li "a matrix containing the factors " (i "L") " and " (i "U") " from the factorization " (i "A = P*L*U") "; ") (li "a vector with pivot indices:  for 1 <= i <= min(M,N), row " (i "i") " of the matrix was interchanged with row pivot(" (i "i") ")")))) (section 4 "General linear system solving using factorization" (def (sig (procedure "atlas-lapack:sgetrs:: ORDER * TRANSPOSE * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR" (id atlas-lapack:sgetrs)))) (def (sig (procedure "atlas-lapack:dgetrs:: ORDER * TRANSPOSE * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR" (id atlas-lapack:dgetrs)))) (def (sig (procedure "atlas-lapack:cgetrs:: ORDER * TRANSPOSE * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR" (id atlas-lapack:cgetrs)))) (def (sig (procedure "atlas-lapack:zgetrs:: ORDER * TRANSPOSE * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR" (id atlas-lapack:zgetrs))) (p "These routines solve a system of linear equations " (i "A * X  = B") " or ''A' * X = B" (i " with a general N-by-N matrix ") "A" (i " using the LU factorization computed by the xGETRF routines. Argument ") "NRHS" (i " is the number of right-hand sides (i.e. number of columns in ") "B" (i "). Optional arguments ") "LDA" (i " and ") "LDB" (i " are the leading dimensions of arrays ") "A" (i " and ") "B" (i ", respectively. The return value is the solution matrix ") "X''."))) (section 4 "General matrix invert using factorization" (def (sig (procedure "atlas-lapack:sgetri:: ORDER * N * A * PIVOT * [LDA] -> F32VECTOR" (id atlas-lapack:sgetri)))) (def (sig (procedure "atlas-lapack:dgetri:: ORDER * N * A * PIVOT * [LDA] -> F64VECTOR" (id atlas-lapack:dgetri)))) (def (sig (procedure "atlas-lapack:cgetri:: ORDER * N * A * PIVOT * [LDA] -> F32VECTOR" (id atlas-lapack:cgetri)))) (def (sig (procedure "atlas-lapack:zgetri:: ORDER * N * A * PIVOT * [LDA] -> F64VECTOR" (id atlas-lapack:zgetri))) (p "These routines compute the inverse of a matrix using the LU factorization computed by the xGETRF routines. Argument " (i "A") " must contain the factors L and U from the LU factorization computed by xGETRF. Argument " (i "PIVOT") " must be the pivot vector returned by the factorization routine. Optional argument " (i "LDA") " is the leading dimension of array " (i "A") ". The return value is the inverse of the original matrix " (i "A") "."))) (section 4 "Symmetric positive definite matrix factorization" (def (sig (procedure "atlas-lapack:spotrf:: ORDER * UPLO * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:spotrf)))) (def (sig (procedure "atlas-lapack:dpotrf:: ORDER * UPLO * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:dpotrf)))) (def (sig (procedure "atlas-lapack:cpotrf:: ORDER * UPLO * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:cpotrf)))) (def (sig (procedure "atlas-lapack:zpotrf:: ORDER * UPLO * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:zpotrf))) (p "These routines compute the Cholesky factorization of a symmetric positive definite matrix " (i "A") ". The factorization has the form:") (ul (li (i "A = U**T * U") "     if UPLO = " (b "blas:Upper")) (li (i "A = L  * L**T") "     if UPLO = " (b "blas:Lower") " where " (i "U") " is an upper triangular, and " (i "L") " is a lower triangular matrix. Optional argument " (i "LDA") " is the leading dimension of array " (i "A") ". The return value is the factor " (i "U") " or " (i "L") "from the Cholesky factorization, depending on the value of argument UPLO.")))) (section 4 "Symmetric positive definite matrix solving using factorization" (def (sig (procedure "atlas-lapack:spotrs:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR" (id atlas-lapack:spotrs)))) (def (sig (procedure "atlas-lapack:dpotrs:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR" (id atlas-lapack:dpotrs)))) (def (sig (procedure "atlas-lapack:cpotrs:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR" (id atlas-lapack:cpotrs)))) (def (sig (procedure "atlas-lapack:zpotrs:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR" (id atlas-lapack:zpotrs))) (p "These routines solve a system of linear equations " (i "A * X = B") " with a  symmetric positive definite matrix " (i "A") " using the Cholesky factorization computed by the xPOTRF routines. Argument " (i "A") " is the triangular factor " (i "U") " or " (i "L") " as computed by xPOTRF. Argument " (i "NRHS") " is the number of right-hand sides (i.e. number of columns in " (i "B") "). Argument UPLO indicates whether upper or lower triangle of A is stored (" (b "blas:Upper") " or " (b "blas:Lower") "). Optional arguments " (i "LDA") " and " (i "LDB") " are the leading dimensions of arrays " (i "A") " and " (i "B") ", respectively. The return value is the solution matrix " (i "X") "."))) (section 4 "Symmetric positive definite matrix invert using factorization" (def (sig (procedure "atlas-lapack:spotri:: ORDER * UPLO * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:spotri)))) (def (sig (procedure "atlas-lapack:dpotri:: ORDER * UPLO * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:dpotri)))) (def (sig (procedure "atlas-lapack:cpotri:: ORDER * UPLO * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:cpotri)))) (def (sig (procedure "atlas-lapack:zpotri:: ORDER * UPLO * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:zpotri))) (p "These routines compute the inverse of a symmetric positive definite matrix " (i "A") " using the Cholesky factorization " (i "A = U**T*U") " or " (i "A = L*L**T") " computed by xPOTRF. Argument " (i "A") " is the triangular factor " (i "U") " or " (i "L") " as computed by xPOTRF. Argument UPLO indicates whether upper or lower triangle of A is stored (" (b "blas:Upper") " or " (b "blas:Lower") "). Optional argument " (i "LDA") " is the leading dimension of array " (i "A") ". The return value is the upper or lower triangle of the inverse of " (i "A") "."))) (section 4 "Triangular matrix invert" (def (sig (procedure "atlas-lapack:strtri:: ORDER * UPLO * DIAG * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:strtri)))) (def (sig (procedure "atlas-lapack:dtrtri:: ORDER * UPLO * DIAG * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:dtrtri)))) (def (sig (procedure "atlas-lapack:ctrtri:: ORDER * UPLO * DIAG * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:ctrtri)))) (def (sig (procedure "atlas-lapack:ztrtri:: ORDER * UPLO * DIAG * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:ztrtri))) (p "These routines compute the inverse of a triangular matrix " (i "A") ". Argument " (i "A") " is the triangular factor " (i "U") " or " (i "L") " as computed by xPOTRF. Argument UPLO indicates whether upper or lower triangle of A is stored (" (b "blas:Upper") " or " (b "blas:Lower") "). Argument DIAG indicates whether A is non-unit triangular or unit triangular (" (b "blas:NonUnit") " or " (b "blas:Unit") "). Optional argument " (i "LDA") " is the leading dimension of array " (i "A") ". The return value is the triangular inverse of the input matrix, in the same storage format."))) (section 4 "Auxilliary routines" (def (sig (procedure "atlas-lapack:slauum:: ORDER * UPLO * DIAG * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:slauum)))) (def (sig (procedure "atlas-lapack:dlauum:: ORDER * UPLO * DIAG * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:dlauum)))) (def (sig (procedure "atlas-lapack:clauum:: ORDER * UPLO * DIAG * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:clauum)))) (def (sig (procedure "atlas-lapack:zlauum:: ORDER * UPLO * DIAG * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:zlauum))) (p "These routines compute the product " (i "U * U") "' or ''L' * L" (i ", where the triangular factor ") "U" (i " or ") "L" (i " is stored in the upper or lower triangular part of the array ") "A" (i ". Argument UPLO indicates whether upper or lower triangle of A is stored (") "'blas:Upper" (b " or ") "blas:Lower'" (i "). Optional argument ") "LDA" (i " is the leading dimension of array ") "A''. The return value is the lower triangle of the lower triangular product,  or the upper triangle of upper triangular product, in the respective storage format."))))) (section 2 "Examples" (pre "\n(use srfi-4 blas atlas-lapack)\n\n(define order blas:ColMajor)\n(define n 4)\n(define nrhs 1)\n\n;; Solve the equations\n;;\n;; Ax = b,\n;;\n;; where A is the general matrix\n\n(define A (f64vector 1.8   5.25   1.58 -1.11  ;; column-major order\n\t\t     2.88  -2.95 -2.69 -0.66 \n\t\t     2.05  -0.95 -2.90 -0.59 \n\t\t     -0.89 -3.80 -1.04  0.80))\n;;\n;; and b is\n;;\n(define b (f64vector 9.52 24.35 0.77 -6.22))\n\n;; A and b are not modified\n(define-values (LU x piv) (atlas-lapack:dgesv order n nrhs A b))\n\n;; A is overwritten with its LU decomposition, and \n;; b is overwritten with the solution of the system\n(atlas-lapack:dgesv! order n nrhs A b)\n")) (section 2 "About this egg" (section 3 "Author" (p (int-link "/users/ivan-raikov" "Ivan Raikov"))) (section 3 "Version history" (dl (dt "1.12") (dd "Switched to wiki documentation") (dt "1.11") (dd "Ported to Chicken 4") (dt "1.10") (dd "Bug fix in the detection of ATLAS library") (dt "1.9") (dd "Added build system support for libraries linked with f2c") (dt "1.8") (dd "Build script updated for better cross-platform compatibility") (dt "1.7") (dd "Fixed a bug in the trtri interface") (dt "1.6") (dd "Changed matrix copying code to use BLAS routines instead of object-copy") (dt "1.5") (dd "License upgrade to GPL v3") (dt "1.4") (dd "Added -latlas to the compiler options in the setup script") (dt "1.3") (dd "Minor changes in the setup script") (dt "1.2") (dd "Bug fix in the setup script") (dt "1.1") (dd "Created safe/unsafe variants of each routine, added optional leading dimensions") (dt "1.0") (dd "Initial release"))) (section 3 "Requirements" (p (int-link "blas"))) (section 3 "License" (pre "Copyright 2007-2010 Ivan Raikov and the Okinawa Institute of Science and Technology\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or (at\nyour option) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nA full copy of the GPL license can be found at\n<http://www.gnu.org/licenses/>."))))