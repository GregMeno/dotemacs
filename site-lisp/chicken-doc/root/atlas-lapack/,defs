(index ("atlas-lapack:sgesv" 0) ("atlas-lapack:dgesv" 149) ("atlas-lapack:cgesv" 298) ("atlas-lapack:zgesv" 447) ("atlas-lapack:sposv" 1551) ("atlas-lapack:dposv" 1695) ("atlas-lapack:cposv" 1839) ("atlas-lapack:zposv" 1983) ("atlas-lapack:sgetrf" 2998) ("atlas-lapack:dgetrf" 3122) ("atlas-lapack:cgetrf" 3246) ("atlas-lapack:zgetrf" 3370) ("atlas-lapack:sgetrs" 3983) ("atlas-lapack:dgetrs" 4122) ("atlas-lapack:cgetrs" 4261) ("atlas-lapack:zgetrs" 4400) ("atlas-lapack:sgetri" 5018) ("atlas-lapack:dgetri" 5134) ("atlas-lapack:cgetri" 5250) ("atlas-lapack:zgetri" 5366) ("atlas-lapack:spotrf" 5931) ("atlas-lapack:dpotrf" 6046) ("atlas-lapack:cpotrf" 6161) ("atlas-lapack:zpotrf" 6276) ("atlas-lapack:spotrs" 6957) ("atlas-lapack:dpotrs" 7091) ("atlas-lapack:cpotrs" 7225) ("atlas-lapack:zpotrs" 7359) ("atlas-lapack:spotri" 8188) ("atlas-lapack:dpotri" 8303) ("atlas-lapack:cpotri" 8418) ("atlas-lapack:zpotri" 8533) ("atlas-lapack:strtri" 9212) ("atlas-lapack:dtrtri" 9334) ("atlas-lapack:ctrtri" 9456) ("atlas-lapack:ztrtri" 9578) ("atlas-lapack:slauum" 10288) ("atlas-lapack:dlauum" 10410) ("atlas-lapack:clauum" 10532) ("atlas-lapack:zlauum" 10654))
(def (sig (procedure "atlas-lapack:sgesv:: ORDER * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR * F32VECTOR * S32VECTOR" (id atlas-lapack:sgesv))))
(def (sig (procedure "atlas-lapack:dgesv:: ORDER * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR * F64VECTOR * S32VECTOR" (id atlas-lapack:dgesv))))
(def (sig (procedure "atlas-lapack:cgesv:: ORDER * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR * F32VECTOR * S32VECTOR" (id atlas-lapack:cgesv))))
(def (sig (procedure "atlas-lapack:zgesv:: ORDER * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR * F64VECTOR * S32VECTOR" (id atlas-lapack:zgesv))) (p "The routines compute the solution to a system of linear equations " (i "A * X = B") ", where " (i "A") " is an N-by-N matrix and " (i "X") " and " (i "B") " are N-by-NRHS matrices. Optional arguments " (i "LDA") " and " (i "LDB") " are the leading dimensions of arrays " (i "A") " and " (i "B") ", respectively. LU decomposition with partial pivoting and row interchanges is used to factor " (i "A") " as " (i "A = P * L * U") ", where " (i "P") " is a permutation matrix, " (i "L") " is unit lower triangular, and " (i "U") " is upper triangular. The factored form of " (i "A") " is then used to solve the system. The return values are:") (ol (li "a matrix containing the factors " (i "L") " and " (i "U") " from the factorization " (i "A = P*L*U") "; ") (li "the N-by-NRHS solution matrix " (i "X")) (li "a vector with pivot indices:  for 1 <= i <= min(M,N), row " (i "i") " of the matrix " (i "A") " was interchanged with row pivot(" (i "i") ")")))
(def (sig (procedure "atlas-lapack:sposv:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR * F32VECTOR" (id atlas-lapack:sposv))))
(def (sig (procedure "atlas-lapack:dposv:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR * F64VECTOR" (id atlas-lapack:dposv))))
(def (sig (procedure "atlas-lapack:cposv:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR * F32VECTOR" (id atlas-lapack:cposv))))
(def (sig (procedure "atlas-lapack:zposv:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR * F64VECTOR" (id atlas-lapack:zposv))) (p "The routines compute the solution to a system of linear equations " (i "A * X = B") ", where " (i "A") " is an N-by-N symmetric positive definite matrix and " (i "X") " and " (i "B") " are N-by-NRHS matrices. Optional arguments " (i "LDA") " and " (i "LDB") " are the leading dimensions of arrays " (i "A") " and " (i "B") ", respectively. Cholesky decomposition is used to factor " (i "A") " as") (ul (li (i "A = U**T * U") "     if UPLO = " (b "blas:Upper")) (li (i "A = L  * L**T") "     if UPLO = " (b "blas:Lower") " where " (i "U") " is an upper triangular, and " (i "L") " is a lower triangular matrix. The factored form of " (i "A") " is then used to solve the system. The return values are:") (li "the factor " (i "U") " or " (i "L") "from the Cholesky factorization, depending on the value of argument UPLO.") (li "the N-by-NRHS solution matrix " (i "X"))))
(def (sig (procedure "atlas-lapack:sgetrf:: ORDER * M * N * A * [LDA] -> F32VECTOR * S32VECTOR" (id atlas-lapack:sgetrf))))
(def (sig (procedure "atlas-lapack:dgetrf:: ORDER * M * N * A * [LDA] -> F64VECTOR * S32VECTOR" (id atlas-lapack:dgetrf))))
(def (sig (procedure "atlas-lapack:cgetrf:: ORDER * M * N * A * [LDA] -> F32VECTOR * S32VECTOR" (id atlas-lapack:cgetrf))))
(def (sig (procedure "atlas-lapack:zgetrf:: ORDER * M * N * A * [LDA] -> F64VECTOR * S32VECTOR" (id atlas-lapack:zgetrf))) (p "These routines compute an LU factorization of a general M-by-N matrix " (i "A") " using partial pivoting with row interchanges. Optional argument " (i "LDA") " is the leading dimension of array " (i "A") ". The return values are:") (ol (li "a matrix containing the factors " (i "L") " and " (i "U") " from the factorization " (i "A = P*L*U") "; ") (li "a vector with pivot indices:  for 1 <= i <= min(M,N), row " (i "i") " of the matrix was interchanged with row pivot(" (i "i") ")")))
(def (sig (procedure "atlas-lapack:sgetrs:: ORDER * TRANSPOSE * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR" (id atlas-lapack:sgetrs))))
(def (sig (procedure "atlas-lapack:dgetrs:: ORDER * TRANSPOSE * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR" (id atlas-lapack:dgetrs))))
(def (sig (procedure "atlas-lapack:cgetrs:: ORDER * TRANSPOSE * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR" (id atlas-lapack:cgetrs))))
(def (sig (procedure "atlas-lapack:zgetrs:: ORDER * TRANSPOSE * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR" (id atlas-lapack:zgetrs))) (p "These routines solve a system of linear equations " (i "A * X  = B") " or ''A' * X = B" (i " with a general N-by-N matrix ") "A" (i " using the LU factorization computed by the xGETRF routines. Argument ") "NRHS" (i " is the number of right-hand sides (i.e. number of columns in ") "B" (i "). Optional arguments ") "LDA" (i " and ") "LDB" (i " are the leading dimensions of arrays ") "A" (i " and ") "B" (i ", respectively. The return value is the solution matrix ") "X''."))
(def (sig (procedure "atlas-lapack:sgetri:: ORDER * N * A * PIVOT * [LDA] -> F32VECTOR" (id atlas-lapack:sgetri))))
(def (sig (procedure "atlas-lapack:dgetri:: ORDER * N * A * PIVOT * [LDA] -> F64VECTOR" (id atlas-lapack:dgetri))))
(def (sig (procedure "atlas-lapack:cgetri:: ORDER * N * A * PIVOT * [LDA] -> F32VECTOR" (id atlas-lapack:cgetri))))
(def (sig (procedure "atlas-lapack:zgetri:: ORDER * N * A * PIVOT * [LDA] -> F64VECTOR" (id atlas-lapack:zgetri))) (p "These routines compute the inverse of a matrix using the LU factorization computed by the xGETRF routines. Argument " (i "A") " must contain the factors L and U from the LU factorization computed by xGETRF. Argument " (i "PIVOT") " must be the pivot vector returned by the factorization routine. Optional argument " (i "LDA") " is the leading dimension of array " (i "A") ". The return value is the inverse of the original matrix " (i "A") "."))
(def (sig (procedure "atlas-lapack:spotrf:: ORDER * UPLO * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:spotrf))))
(def (sig (procedure "atlas-lapack:dpotrf:: ORDER * UPLO * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:dpotrf))))
(def (sig (procedure "atlas-lapack:cpotrf:: ORDER * UPLO * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:cpotrf))))
(def (sig (procedure "atlas-lapack:zpotrf:: ORDER * UPLO * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:zpotrf))) (p "These routines compute the Cholesky factorization of a symmetric positive definite matrix " (i "A") ". The factorization has the form:") (ul (li (i "A = U**T * U") "     if UPLO = " (b "blas:Upper")) (li (i "A = L  * L**T") "     if UPLO = " (b "blas:Lower") " where " (i "U") " is an upper triangular, and " (i "L") " is a lower triangular matrix. Optional argument " (i "LDA") " is the leading dimension of array " (i "A") ". The return value is the factor " (i "U") " or " (i "L") "from the Cholesky factorization, depending on the value of argument UPLO.")))
(def (sig (procedure "atlas-lapack:spotrs:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR" (id atlas-lapack:spotrs))))
(def (sig (procedure "atlas-lapack:dpotrs:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR" (id atlas-lapack:dpotrs))))
(def (sig (procedure "atlas-lapack:cpotrs:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F32VECTOR" (id atlas-lapack:cpotrs))))
(def (sig (procedure "atlas-lapack:zpotrs:: ORDER * UPLO * N * NRHS * A * B * [LDA] * [LDB] -> F64VECTOR" (id atlas-lapack:zpotrs))) (p "These routines solve a system of linear equations " (i "A * X = B") " with a  symmetric positive definite matrix " (i "A") " using the Cholesky factorization computed by the xPOTRF routines. Argument " (i "A") " is the triangular factor " (i "U") " or " (i "L") " as computed by xPOTRF. Argument " (i "NRHS") " is the number of right-hand sides (i.e. number of columns in " (i "B") "). Argument UPLO indicates whether upper or lower triangle of A is stored (" (b "blas:Upper") " or " (b "blas:Lower") "). Optional arguments " (i "LDA") " and " (i "LDB") " are the leading dimensions of arrays " (i "A") " and " (i "B") ", respectively. The return value is the solution matrix " (i "X") "."))
(def (sig (procedure "atlas-lapack:spotri:: ORDER * UPLO * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:spotri))))
(def (sig (procedure "atlas-lapack:dpotri:: ORDER * UPLO * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:dpotri))))
(def (sig (procedure "atlas-lapack:cpotri:: ORDER * UPLO * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:cpotri))))
(def (sig (procedure "atlas-lapack:zpotri:: ORDER * UPLO * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:zpotri))) (p "These routines compute the inverse of a symmetric positive definite matrix " (i "A") " using the Cholesky factorization " (i "A = U**T*U") " or " (i "A = L*L**T") " computed by xPOTRF. Argument " (i "A") " is the triangular factor " (i "U") " or " (i "L") " as computed by xPOTRF. Argument UPLO indicates whether upper or lower triangle of A is stored (" (b "blas:Upper") " or " (b "blas:Lower") "). Optional argument " (i "LDA") " is the leading dimension of array " (i "A") ". The return value is the upper or lower triangle of the inverse of " (i "A") "."))
(def (sig (procedure "atlas-lapack:strtri:: ORDER * UPLO * DIAG * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:strtri))))
(def (sig (procedure "atlas-lapack:dtrtri:: ORDER * UPLO * DIAG * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:dtrtri))))
(def (sig (procedure "atlas-lapack:ctrtri:: ORDER * UPLO * DIAG * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:ctrtri))))
(def (sig (procedure "atlas-lapack:ztrtri:: ORDER * UPLO * DIAG * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:ztrtri))) (p "These routines compute the inverse of a triangular matrix " (i "A") ". Argument " (i "A") " is the triangular factor " (i "U") " or " (i "L") " as computed by xPOTRF. Argument UPLO indicates whether upper or lower triangle of A is stored (" (b "blas:Upper") " or " (b "blas:Lower") "). Argument DIAG indicates whether A is non-unit triangular or unit triangular (" (b "blas:NonUnit") " or " (b "blas:Unit") "). Optional argument " (i "LDA") " is the leading dimension of array " (i "A") ". The return value is the triangular inverse of the input matrix, in the same storage format."))
(def (sig (procedure "atlas-lapack:slauum:: ORDER * UPLO * DIAG * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:slauum))))
(def (sig (procedure "atlas-lapack:dlauum:: ORDER * UPLO * DIAG * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:dlauum))))
(def (sig (procedure "atlas-lapack:clauum:: ORDER * UPLO * DIAG * N * A * [LDA] -> F32VECTOR" (id atlas-lapack:clauum))))
(def (sig (procedure "atlas-lapack:zlauum:: ORDER * UPLO * DIAG * N * A * [LDA] -> F64VECTOR" (id atlas-lapack:zlauum))) (p "These routines compute the product " (i "U * U") "' or ''L' * L" (i ", where the triangular factor ") "U" (i " or ") "L" (i " is stored in the upper or lower triangular part of the array ") "A" (i ". Argument UPLO indicates whether upper or lower triangle of A is stored (") "'blas:Upper" (b " or ") "blas:Lower'" (i "). Optional argument ") "LDA" (i " is the leading dimension of array ") "A''. The return value is the lower triangle of the lower triangular product,  or the upper triangle of upper triangular product, in the respective storage format."))
