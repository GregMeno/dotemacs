(index ("randomize" 0) ("random" 305) ("fprintf" 1260) ("printf" 1260) ("sprintf" 1260) ("format" 2777) ("pretty-print" 3168) ("pp" 3168) ("pretty-print-width" 3392) ("read-byte" 3555) ("write-byte" 3555) ("read-file" 3847) ("read-line" 4570) ("write-line" 4570) ("read-lines" 5145) ("read-string" 5521) ("read-string!" 5521) ("write-string" 5521) ("read-token" 6477))
(def (sig (procedure "(randomize [SEED])" (id randomize))) (p "Set random-number seed. If " (tt "SEED") " (an " (tt "exact integer") ") is not supplied, the current time is used. On startup (when Unit " (tt "extras") " is initialized), the random number generator is initialized with the current time."))
(def (sig (procedure "(random N)" (id random))) (p "Returns a pseudo-random " (tt "integer") " in " (tt "[0, N-1]") ". " (tt "N") " is an " (tt "integer") ".") (p "On Windows, " (tt "N") " and the random value are " (tt "exact integer") ".") (p (b "Warning") ": This procedure uses " (i "rand(3)") " internally and exhibits its deficiencies, including low quality pseudo-randomness:") (ul (li "On Windows and Solaris, only 32768 unique random values can be generated in the range " (tt "[0, N-1]") ".  If " (tt "N >= 32768") ", there will be gaps in the result set.") (li "On Mac OS X, Windows and some other platforms, little variance in output is seen with nearby seeds.  Since the random generator is seeded with " (tt "current-seconds") " at startup, new processes may see similar or identical random sequences for up to a minute.") (li "On Linux, " (i "rand(3)") " is an alias to " (i "random(3)") ", which provides output of reasonable quality.")))
(def (sig (procedure "(fprintf PORT FORMATSTRING [ARG...])" (id fprintf)) (procedure "(printf FORMATSTRING [ARG...])" (id printf)) (procedure "(sprintf FORMATSTRING [ARG...])" (id sprintf))) (p "Simple formatted output to a given port (" (tt "fprintf") "), the value of " (tt "(current-output-port)") " (" (tt "printf") "), or a string (" (tt "sprintf") ").  The " (tt "FORMATSTRING") " can contain any sequence of characters.  There must be at least as many " (tt "ARG") " arguments given as there are format directives that require an argument in " (tt "FORMATSTRING") ".  Extra " (tt "ARG") " arguments are ignored.  The character `~' prefixes special formatting directives:") (table (tr (td "~%") (td "\nwrite newline character\n")) (tr (td " ~N") (td "\nthe same as " (tt "~%") "\n")) (tr (td " ~S") (td "\nwrite the next argument\n")) (tr (td " ~A") (td "\ndisplay the next argument\n")) (tr (td " ~\\n") (td "\nskip all whitespace in the format-string until the next non-whitespace character\n")) (tr (td " ~B") (td "\nwrite the next argument as a binary number\n")) (tr (td " ~O") (td "\nwrite the next argument as an octal number\n")) (tr (td " ~X") (td "\nwrite the next argument as a hexadecimal number\n")) (tr (td " ~C") (td "\nwrite the next argument as a character\n")) (tr (td " ~~") (td "\ndisplay `~'\n")) (tr (td " ~!") (td "\nflush all pending output\n")) (tr (td " ~?") (td "\ninvoke formatted output routine recursively with the next two arguments as format-string and list of parameters\n"))))
(def (sig (procedure "(format [DESTINATION] FORMATSTRING [ARG...])" (id format))) (p "The parameters " (tt "FORMATSTRING") " and " (tt "ARG...") " are as for " (tt "printf") ".") (p "The optional " (tt "DESTINATION") ", when supplied, performs:") (dl (dt (tt "#f")) (dd (tt "sprintf")) (dt (tt "#t")) (dd (tt "printf")) (dt (tt "output-port")) (dd (tt "fprintf")) (dt) (dd (tt "sprintf"))))
(def (sig (procedure "(pretty-print EXP [PORT])" (id pretty-print)) (procedure "(pp EXP [PORT])" (id pp))) (p "Print expression nicely formatted. " (tt "PORT") " defaults to the value of " (tt "(current-output-port)") "."))
(def (sig (parameter "pretty-print-width" (id pretty-print-width))) (p "Specifies the maximal line-width for pretty printing, after which line wrap will occur."))
(def (sig (procedure "(read-byte [PORT])" (id read-byte)) (procedure "(write-byte BYTE [PORT])" (id write-byte))) (p "Read/write a byte to the port given in " (tt "PORT") ", which default to the values of " (tt "(current-input-port)") " and " (tt "(current-output-port)") ", respectively."))
(def (sig (procedure "(read-file [FILE-OR-PORT [READER [MAXCOUNT]]])" (id read-file))) (p "Returns a list containing all toplevel expressions read from the file or port " (tt "FILE-OR-PORT") ". If no argument is given, input is read from the port that is the current value of " (tt "(current-input-port)") ". After all expressions are read, and if the argument is a port, then the port will not be closed. The " (tt "READER") " argument specifies the procedure used to read expressions from the given file or port and defaults to " (tt "read") ". The reader procedure will be called with a single argument (an input port). If " (tt "MAXCOUNT") " is given then only up to " (tt "MAXCOUNT") " expressions will be read in."))
(def (sig (procedure "(read-line [PORT [LIMIT]])" (id read-line)) (procedure "(write-line STRING [PORT])" (id write-line))) (p "Line-input and -output. " (tt "PORT") " defaults to the value of " (tt "(current-input-port)") " and " (tt "(current-output-port)") ", respectively. If the optional argument " (tt "LIMIT") " is given and not " (tt "#f") ", then " (tt "read-line") " reads at most " (tt "LIMIT") " characters per line. " (tt "read-line") " returns a string without the terminating newline and " (tt "write-line") " adds a terminating newline  before outputting."))
(def (sig (procedure "(read-lines [PORT [MAX]])" (id read-lines))) (p "Read " (tt "MAX") " or fewer lines from " (tt "PORT") ". " (tt "PORT") " defaults to the value of " (tt "(current-input-port)") ". " (tt "PORT") " may optionally be a string naming a file. Returns a list of strings, each string representing a line read, not including any line separation character(s)."))
(def (sig (procedure "(read-string [NUM [PORT]])" (id read-string)) (procedure "(read-string! NUM STRING [PORT [START]])" (id read-string!)) (procedure "(write-string STRING [NUM [PORT]])" (id write-string))) (p "Read or write " (tt "NUM") " characters from/to " (tt "PORT") ", which defaults to the value of " (tt "(current-input-port)") " or " (tt "(current-output-port)") ", respectively. If " (tt "NUM") " is " (tt "#f") " or not given, then all data up to the end-of-file is read, or, in the case of " (tt "write-string") " the whole string is written. If no more input is available, " (tt "read-string") " returns the empty string. " (tt "read-string!") " reads destructively into the given " (tt "STRING") " argument, but never more characters than would fit into " (tt "STRING") ". If " (tt "START") " is given, then the read characters are stored starting at that position. " (tt "read-string!") " returns the actual number of characters read."))
(def (sig (procedure "(read-token PREDICATE [PORT])" (id read-token))) (p "Reads characters from " (tt "PORT") " (which defaults to the value of " (tt "(current-input-port)") ") and calls the procedure " (tt "PREDICATE") " with each character until " (tt "PREDICATE") " returns false. Returns a string with the accumulated characters."))
