((tags "egg") (section 2 "dbus" (toc) (section 3 "Overview" (p "This is a binding for libdbus 1.0 (and hopefully 1.2.x).  DBus is a popular IPC (inter-process communication) protocol which is often used between system components (for example hald informs applications when new hardware becomes available, gpsd informs apps when the location has changed, or an application requests gsmd to place a phone call).")) (section 3 "Goals & status" (table (tr (th "Goal") (th "Achieved?")) "\n" (tr (td "send signals (messages)") (td "yes")) "\n" (tr (td "call methods in other processes, and get the return values") (td "yes")) "\n" (tr (td "call methods in other processes asynchronously, and the return values come back to a callback later") (td)) "\n" (tr (td "register a procedure as a handler which will be called when a signal (message) is received") (td "yes")) "\n" (tr (td "register a procedure as a method which can be called from another process") (td "yes")) "\n" (tr (td "assign a path to a TinyClos object and map applicable generic functions as dbus methods") (td)) "\n" (tr (td "create proxy methods matching remote methods") (td "yes")) "\n" (tr (td "create proxy objects matching remote objects (so that all the remote object's applicable methods are made into local proxy methods)") (td)) "\n" (tr (td "discover services locally") (td "yes")) "\n" (tr (td "discover services on nearby machines") (td "impossible with dbus-daemon as-is")) "\n" (tr (td "discover methods and signals provided by services") (td "XML only so far")) "\n" (tr (td "registered methods and signal-handlers are automatically included in the Introspectable interface implementation") (td)) "\n" (tr (td "user code to do any of the above should be minimal: abstract away the orthogonal extra steps (open a connection, start a polling thread, etc.)") (td "yes")) "\n" (tr (td "support all DBus data types for method parameters and return values") (td)))) (section 3 "Author" (p (int-link "Shawn Rutledge"))) (section 3 "Requirements" (p (link "http://dbus.freedesktop.org/" "libdbus and its headers") "; " (link "http://srfi.schemers.org/srfi-18/srfi-18.html" "SRFI-18"))) (section 3 "Download" (p (link "http://www.call-with-current-continuation.org/eggs/dbus.egg" "dbus.egg"))) (section 3 "License" (p "libdbus has historically had a GPL license.  The " (link "http://www.freedesktop.org/wiki/Software/dbus" "dbus homepage") " refers to an incomplete \"planned X11/MIT license change due to a couple of license holders who have yet to respond. For the most part this license change is being pursued to simplify licensing issues and fix a couple of licensing corner cases. When this happens D-Bus will be released under the 1.2.0 version.\"  So this egg is released under the MIT license, however if you link it with a version prior to 1.2.0, then you are probably bound by the terms of the GPL.")) (section 3 "Version" (p "As of version 0.8, it seems to be working for the limited use cases of sending and receiving method calls, but the interface should not be considered \"frozen\" yet.")) (section 3 "DBus in general" (p "These are the definitions of the (confusing, redundant) terminology used in DBus, as the author understands them:") (dl (dt "bus") (dd "The aggregator and dispatcher of messages between processes.  The usual choices are system bus, session bus or an app-specific bus.  This egg uses the session bus by default.  It is the same bus used by desktop session services, like KDE components for example.  Accessing the system bus requires special permission.  An app-specific bus does not promote application interoperability.  So that leaves the session bus as generally being the most appropriate.") (dt "service") (dd "looks like a reversed domain name.  The destination of a message.  Sometimes called the \"bus name\" because a process can request to change the default connection-instance-name to this name instead, so that other processes can find the \"service\" being offered.  The service name is not included with signals though, only with method calls.") (dt "path") (dd "think of it like the path part of a URL.  Perhaps a unique path maps to a unique object.") (dt "interface") (dd "a partitioned set of methods which is being offered, like a Java interface or an abstract class.") (dt "member name") (dd "also called method name, or the name of the signal or message.") (dt "signal") (dd "a one-to-many notification from one process to any other(s) which happen to be listening for that particular notification.  A reply is not necessarily required.") (dt "method") (dd "a function to be invoked when a particular message is received.  (This is typical object-oriented terminology.)  The return value(s) from the method are sent back as another message.") (dt "message") (dd "the DBus-protocol representation of a signal or a method passing across the DBus connection between two processes.")) (p "And this egg introduces one more:") (dl (dt "context") (dd "a combination of bus, service, interface and path.  That and a method name will get you a unique identifier for a callback (AKA method or message handler).")) (p "Some of those would seem to be optional, because the total namespace ends up much deeper than e.g. a URL.  However not enough testing has been done to confirm that if you leave out the service and the interface, for example, you won't miss them.  Also it's not yet clear which of those ought to be \"discoverable\" in the sense that you can enumerate what is available on a particular bus.") (p "Use dbus-monitor to see all the dbus traffic (on the session bus by default).") (p "A many-to-many \"bus\" exists as a running dbus-daemon process.  Each application which is interested in using that bus connects to the daemon via Unix-domain sockets.  The daemon collects incoming messages and dispatches them to the connected processes which have expressed interest in receiving particular categories of messages.  Usually there is one running instance of dbus-daemon for the system bus, and one running instance for each session bus: each user who is logged in and running a desktop session is typically running one instance of the daemon.") (p "A one-to-one application-specific bus can bypass the daemon: one app connects directly to the other.  But this is not a flexible service-oriented approach to IPC, so it is not usually done, and this egg does not support it.")) (section 3 "Data types" (p "DBus protocol (unlike XML, for example) allows sending real native datatypes across the connection.  In fact it provides more data types than does Chicken.  So when you pass some parameters along with a method call, these are the default conversions:") (table (tr (th "Chicken data type") (th "DBus data type")) "\n" (tr (td "fixnum") (td "DBUS_TYPE_INT32")) "\n" (tr (td "flonum") (td "DBUS_TYPE_DOUBLE")) "\n" (tr (td "boolean") (td "DBUS_TYPE_BOOLEAN")) "\n" (tr (td "vector") (td "DBUS_TYPE_ARRAY")) "\n" (tr (td "anything else") (td "DBUS_TYPE_STRING"))) (p "When a DBus message is received, the parameters are converted similarly, but unsupported DBus types will be converted to #f.") (p "Watch out for cases when Chicken converts an integer to a flonum, because it was too large to fit in a fixnum.  It will go across the DBus connection as a double, which might not be what you wanted.") (p "It is planned to support requests for conversion to other DBUS types, in case you need to interface with an existing service that requires datatypes other than the typical ones above.  DBus supports variants and structs; these conversions are not done yet.")) (section 3 "Exported functions" (p "dbus:make-context : glom together a bus, service, interface and path into an object that you can conveniently hold for later use.  The choices for bus are dbus:session-bus (which is the default if you don't specify it), dbus:system-bus and dbus:starter-bus.  The service, interface and path can be given as strings or symbols.  Symbols would be preferred; if you provide strings, dbus:make-context will convert them to symbols.  The default for path is \"/\" so if you don't need a hierarchical organization of \"objects\", you don't need to specify it.") (p "dbus:send : send a message, and don't bother waiting for the response.") (p "dbus:make-sender : wrap dbus:send in a lambda, which you can then use like any local function.  The return value from the function thus created is not yet defined.  (Maybe should be #f or an error message?  or is it better to use exceptions when something cannot be sent?)") (p "dbus:call : call a remote method, wait for the reply, and receive the return values from the remote method, as a list.  Note that since this is a blocking call (it waits for the reply), it's not suitable for implementing the " (link "http://en.wikipedia.org/wiki/Actor_model" "actor model") " or anything similarly lightweight/low-latency.") (p "dbus:make-method-proxy : wrap dbus:call in a lambda, which you can then use like any local function.  The return value from the function thus created will be the list of return values from the remote method.") (p "dbus:register-signal-handler : provide a handler to be called when the current process receives a DBus signal which matches the given context and the given signal name.  Start a SRFI-18 thread to poll for incoming signals (unless polling has been disabled on this bus).") (p "dbus:register-method : provide a handler (a method body) to be called when the current process receives a DBus message which matches the given context and the given method-name.  Start a SRFI-18 thread to poll for incoming messages (unless polling has been disabled on this bus).") (p "dbus:enable-polling-thread! : enable or disable the polling thread for a particular bus, and set the polling interval in seconds") (p "dbus:poll-for-message : check once whether any incoming DBus message is waiting on a particular bus, and if so, dispatch it to the appropriate callback (which you have previously registered using dbus:register-method).  Returns #t if it received a message, #f if not.") (p "dbus:discover-services : get a list of service names available on a bus") (p "dbus:discover-api-xml : get the XML API \"documentation\" provided by the Introspectable interface of a service, if that interface is implemented")) (section 3 "Examples" (p "These are in the examples subdirectory in svn, and included with the egg too.") (section 4 "Examples you can test with QT" (p "QT includes a DBUS remote-controlled car example.  E.g. it might be located in /usr/share/qt4/examples/qdbus/remotecontrolledcar/car depending on your distro.  If you run the car, you can cause the wheels of the car to turn to the right by doing this:") (highlight scheme "(use dbus)\n(define rc-car-context (dbus:make-context\n        service: 'com.trolltech.CarExample\n        interface: 'com.trolltech.Examples.CarInterface\n        path: '/Car))\n(dbus:send rc-car-context \"turnRight\")") (p "That example called a method but it did not expect any return values.") (p "Now suppose you want to simulate the car, so you can use the above example to control your own car rather than the QT one.  And suppose you want to poll for messages manually rather than via the default SRFI-18 polling thread:") (highlight scheme "(use dbus)\n\n(define (turn-right) (printf \"car is turning to the right~%\"))\n(define (turn-left) (printf \"car is turning to the left~%\"))\n\n(define rc-car-context (dbus:make-context\n\tservice: 'com.trolltech.CarExample\n\tpath: '/Car\n\tinterface: 'com.trolltech.Examples.CarInterface ))\n\n(dbus:enable-polling-thread enable: #f)\n\n(dbus:register-method rc-car-context \"turnRight\" turn-right)\n(dbus:register-method rc-car-context \"turnLeft\" turn-left)\n\n(let loop ()\n\t(dbus:poll-for-message)\n\t(loop))") (p "dbus:register-method starts a polling loop the first time that it is called with a context specifying a particular bus.  (And if you register methods on multiple buses, there must be a polling thread for each.)  So you can then run the program above which does dbus:send, and you will see the appropriate printf statement execute asynchronously when the message is received.  However the polling thread is subject to the usual limitations of Chicken threads: if there is any blocking I/O, which is waiting for something, then all threads are blocked.  That means you should not use the readline egg for example, because the polling thread will be blocked between each time that you type something and hit Enter.") (p "If the polling thread doesn't work, and you would prefer to poll manually, you can call (dbus:enable-polling-thread! enable: #f) to stop the thread (or to prevent it from being started when you register a new method), and then call dbus:poll-for-message periodically.  Both of those functions can take an optional bus: parameter (which defaults to dbus:session-bus, naturally).  dbus:poll-for-message can also take an optional timeout: parameter (which is 0 by default, so that it is a non-blocking call).")) (section 4 "Examples based on the DBus Tutorial" (p "The next example, taken from the " (link "http://dbus.freedesktop.org/doc/dbus/libdbus-tutorial.html" "DBus tutorial") ", shows how to deal with return values.  First the \"listener\" program which will answer the query:") (highlight scheme "(use dbus)\n(define (query . params)\n        (printf \"got a query; params: ~s~%\" params)\n        ;; the response to the query:\n        `(#t 42))\n(define ctxt (dbus:make-context\n        service: 'test.method.server\n        interface: 'test.method.Type\n        path: '/test/method/Object))\n(dbus:register-method ctxt \"Method\" query)") (p "And now the program which sends a query and prints out the response:") (highlight scheme "(use dbus)\n(define ctxt (dbus:make-context\n        service: 'test.method.server\n        interface: 'test.method.Type\n        path: '/test/method/Object))\n(let ([response (dbus:send-and-await-reply ctxt \"Method\" \"query\"\n                \"What is the meaning of life, the universe and everything?\") ])\n(printf \"sent a very important query with a known answer; got flippant response ~s~%\" response)\n        (if (and (list? response) (eq? 42 (cadr response)))\n                (printf \"bingo!~%\")\n                (printf \"and the answer is wrong too!  Bad supercomputer, bad!~%\")))") (p "What do you get if you combine a remote-controlled mobile thingy with a supercomputer capable of deep thought?  A paranoid android of course!  This example in the test directory handles both kinds of messages from the two examples above (the query and the turnLeft/turnRight commands) and proves that one polling thread is enough to handle multiple, completely different contexts, on a single bus.  So registering more than one method is low-cost compared to registering the first one.")))))