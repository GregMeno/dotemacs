((tags "egg" "ffi") (toc) (section 2 "bind" (p "Generates wrappers from C/C++ source code.") (section 3 "Usage" (pre " (require-extension bind)")) (section 3 "Requirements" (ul (li (int-link "silex")) (li (int-link "matchable")) (li (int-link "coops")) (li (int-link "regex")))) (section 3 "Documentation" (p "This extension provides a parser for a restricted subset of C and C++ that allows the easy generation of foreign variable declarations, procedure bindings and C++ class wrappers. The parser is invoked via the " (tt "bind") " form, which extracts binding information and generates the necessary code. An example:") (highlight scheme "(bind \"double sin(double);\")\n\n(print (sin 3.14))") (p "The parser would generate code that is equivalent to") (pre " (define sin (foreign-lambda double \"sin\" double))") (p "Another example, here using C++. Consider the following class:") (pre "// file: foo.h\n\nclass Foo {\n private:\n  int x_;\n public:\n  Foo(int x);\n  void setX(int x);\n  int getX();\n};") (p "To generate a wrapper class that provides generic functions for the constructor and the " (tt "setX") " and " (tt "getX") " methods, we can use the following class definition:") (pre "; file: test-foo.scm") (pre "(require-extension bind coops cplusplus-object)\n\n(bind \"#include \\\"Foo.h\\\"\")\n\n(define x (make-instance <Foo> 99))\n(print (getX x))              ; prints ''99''\n(setX x 42)\n(print (getX x))              ; prints ''42''\n(destroy x)") (p "Provided the file " (tt "foo.o") " contains the implementation of the class " (tt "Foo") ", the given example could be compiled like this (assuming a UNIX like environment):") (pre "% csc test-foo.scm foo.o -c++") (p "To use the C++ interface, the " (int-link "coops") " extension is needed. Additionally, the class " (tt "<c++-object>") " must be available, which is provided in the " (tt "cplusplus-object") " extension.") (p "To use this facility, you can either use the syntactic forms provided by the " (tt "bind") " extension or run the " (tt "chicken-bind") " standalone program to process a C/C++ file and generate a file containing wrapper code which then can be compiled with the CHICKEN compiler.") (p "As a debugging aid, you can pass " (tt "-debug F") " to the Scheme compiler to see the generated wrapper code.") (p (tt "chicken-bind") " accepts a number of command-line options to enable/disable various options, enter") (pre " % chicken-bind -help") (p "for more information.")) (section 3 "General operation" (p "The parser will generally perform the following functions:") (ul (li "Translate macro, enum-definitions and constants into " (tt "define-foreign-variable") " or " (tt "define-constant") " forms") (li "Translate function prototypes into " (tt "foreign-lambda") " forms") (li "Translate variable declarations into accessor procedures") (li "Handle (very) basic preprocessor operations") (li "Translate simple C++ class definitions into " (tt "coops") " wrapper classes and methods")) (p "Basic token-substitution of macros defined via " (tt "#define") " is performed. The preprocessor commands " (tt "#ifdef") ", " (tt "#ifndef") ", " (tt "#else") ", " (tt "#endif") ", " (tt "#undef") " and " (tt "#error") " are handled. The preprocessor commands " (tt "#if") " and " (tt "#elif") " are not supported and will signal an error when encountered by the parser, because C expressions (even if constant) are not parsed.  The preprocessor command " (tt "#pragma") " is allowed but will be ignored.") (p "During processing of C code, the macro " (tt "CHICKEN") " is defined (similar to the C compiler option " (tt "-DCHICKEN") ").") (p "Macro- and type-definitions are available in subsequent " (tt "bind") " declarations.  C variables declared generate a procedure with zero or one argument with the same name as the variable. When called with no arguments, the procedure returns the current value of the variable. When called with an argument, then the variable is set to the value of that argument.  C and C++ style comments are supported. Variables declared as " (tt "const") " will generate normal Scheme variables, bound to the initial value of the variable.") (p "Function-, member-function and constructor/destructor definitions may be preceded by the " (tt "___safe") " qualifier, which marks the function as (possibly) performing a callback into Scheme. If a wrapped function calls back into Scheme code, and " (tt "___safe") " has not been given very strange and hard to debug problems will occur.") (p "Functions and member functions prefixed with " (tt "___discard") " and a result type that maps to a Scheme string (" (tt "c-string") "), will have their result type changed to " (tt "c-string*") " instead.") (p "Constants (as declared by " (tt "#define") " or " (tt "enum") ") are not visible outside of the current Compilation units unless the " (tt "export-constants") " option has been enabled.  Only numeric or character constants are directly supported.") (p "Function-arguments may be preceded by " (tt "___in") ", " (tt "___out") " and " (tt "___inout") " qualifiers to specify values that are passed by reference to a function, or returned by reference. Only basic types (booleans, numbers and characters) can be passed using this method.  During the call a pointer to a temporary piece of storage containing the initial value (or a random value, for " (tt "___out") " parameters) will be allocated and passed to the wrapped function. This piece of storage is subject to garbage collection and will move, should a callback into Scheme occur that triggers a garbage collection. Multiple " (tt "__out") " and " (tt "___inout") " parameters will be returned as multiple values, preceded by the normal return value of thhe function (if not " (tt "void") "). Here is a simple example:") (pre "(bind* #<<EOF\n#ifndef CHICKEN\n#include <math.h>\n#endif") (pre "double modf(double x, ___out double *iptr);\nEOF\n)") (pre "(let-values ([(frac int) (modf 33.44)])\n  ...)") (p "Function-arguments may be preceded by " (tt "___length(ID)") ", where " (tt "ID") " designates the name of another argument that must refer to a number vector or string argument. The value of the former argument will be computed at run-time and thus can be omitted:") (pre "(require-extension srfi-4)") (pre "(bind* #<<EOF\ndouble sumarray(double *arr, ___length(arr) int len)\n{\n  double sum = 0;") (pre "  while(len--) sum += *(arr++);") (pre "  return sum;\n}\nEOF\n)") (pre "(print (sumarray (f64vector 33 44 55.66)))") (p "The length variable may be positioned anywhere in the argument list. Length markers may only be specified for arguments passed as SRFI-4 byte-vectors, byte-vectors (as provided by the " (tt "lolevel") " library unit) or strings.") (p "Structure and union definitions containing actual field declarations generate getter procedures (and SRFI-17 setters when declared " (tt "___mutable") " or the " (tt "mutable-fields") " option has been enabled) The names of these procedures are computed by concatenating the struct (or union) name, a hyphen (" (tt "\"-\"") ") and the field name. Structure definitions with fields may not be used in positions where a type specifier is normally expected. The field accessors operate on struct/union pointers only.  Additionally a zero-argument procedure named " (tt "make-<structname>") " will be generated that allocates enough storage to hold an instance of the structure (or union). Prefixing the definition with " (tt "___abstract") " will omit the creation procedure.") (pre "(bind* #<<EOF\nstruct My_struct { int x; ___mutable float y; };") (pre "typedef struct My_struct My_struct;") (pre "My_struct *make_struct(int x, float y) \n{\n  My_struct *s = (My_struct *)malloc(sizeof(My_struct));\n  s->x = x;\n  s->y = y;\n  return s;\n}\nEOF\n)") (p "will generate the following definitions:") (pre "(make-My_struct) -> PTR\n(My_struct-x PTR) -> INT\n(My_struct-y PTR) -> FLOAT\n(set! (My_struct-y PTR) FLOAT)\n(make_struct INT FLOAT) -> PTR") (p "Nested structs or unions are not supported (but pointers to nested structs/unions are).") (p "All specially handled tokens preceded with " (tt "___") " are defined as C macros in the headerfile " (tt "chicken.h") " and will usually expand into nothing, so they don't invalidate the processed source code.") (p "C++ " (tt "namespace") " declarations of the form " (tt "namespace NAME @{... @") "} recognized but will be completely ignored.") (p "Keep in mind that this is not a fully general C/C++ parser. Taking an arbitrary headerfile and feeding it to " (tt "bind") " will in most cases not work or generate riduculuous amounts of code. This FFI facility is for carefully written headerfiles, and for declarations directly embedded into Scheme code.")) (section 3 "Syntactic forms" (section 4 "bind" (def (sig (syntax "(bind STRING ...)" (id bind))) (p "Parses the C code in " (tt "STRING ...") " and expands into wrapper code providing access to the declarations defined in it."))) (section 4 "bind*" (def (sig (syntax "(bind* STRING ...)" (id bind*))) (p "Similar to " (tt "bind") ", but also embeds the code in the generated Scheme expansion using " (tt "foreign-declare") "."))) (section 4 "bind-type" (def (sig (syntax "(bind-type TYPENAME SCHEMETYPE [CONVERTARGUMENT [CONVERTRESULT]])" (id bind-type))) (p "Declares a foreign type transformation, similar to " (tt "define-foreign-type") ". There should be two to four arguments: a C typename, a Scheme foreign type specifier and optional argument- and result-value conversion procedures.") (pre ";;;; foreign type that converts to unicode (assumes 4-byte wchar_t):\n;\n; - Note: this is rather kludgy and is only meant to demonstrate the `bind.type'\n;         syntax") (pre "(require-extension srfi-4 bind)") (pre "(define mbstowcs (foreign-lambda int \"mbstowcs\" nonnull-u32vector c-string int))") (pre "(define (str->ustr str)\n  (let* ([len (string-length str)]\n         [us (make-u32vector (add1 len) 0)] )\n    (mbstowcs us str len)\n    us) )") (pre "(bind-type unicode nonnull-u32vector str->ustr)") (pre "(bind* #<<EOF\nstatic void foo(unicode ws)\n{\n  printf(\"%ls\\n\", ws);\n}\nEOF\n)") (pre "(foo \"this is a test!\")"))) (section 4 "bind-opaque-type" (def (sig (syntax "(bind-opaque-type TYPENAME SCHEMETYPE)" (id bind-opaque-type))) (p "Similar to " (tt "bind-type") ", but provides automatic argument- and result conversions to wrap a value into a structure:") (pre "(bind-opaque-type myfile (pointer \"FILE\"))") (pre "(bind \"myfile fopen(char *, char *);\")") (pre "(fopen \"somefile\" \"r\")   ==> <myfile>") (p (tt "(bind-opaque-type TYPENAME TYPE)") " is basically equivalent to " (tt "(bind-type TYPENAME TYPE TYPE->RECORD RECORD->TYPE)") " where " (tt "TYPE->RECORD") " and " (tt "RECORD->TYPE") " are compiler-generated conversion functions that wrap objects of type " (tt "TYPE") " into a record and back."))) (section 4 "bind-file" (def (sig (syntax "(bind-file FILENAME ...)" (id bind-file))) (p "Reads the content of the given files and generates wrappers using " (tt "bind") ". Note that " (tt "FILENAME ...") " is not evaluated."))) (section 4 "bind-file*" (def (sig (syntax "(bind-file* FILENAME ...)" (id bind-file*))) (p "Reads the content of the given files and generates wrappers using " (tt "bind*") ".") (pre ""))) (section 4 "bind-rename" (def (sig (syntax "(bind-rename CNAME SCHEMENAME)" (id bind-rename))) (p "Defines to what a certain C/C++ name should be renamed. " (tt "CNAME") " specifies the C/C++ identifier occurring in the parsed text and " (tt "SCHEMENAME") " gives the name used in generated wrapper code."))) (section 4 "bind-rename/pattern" (def (sig (syntax "(bind-rename/pattern REGEX REPLACEMENT)" (id bind-rename/pattern))) (p "Declares a renaming pattern to be used for C/C++ identifiers occuring in bound code. " (tt "REGEX") " should be a string or SRE and replacement a string, which may optionally contain back-references to matched sub-patterns."))) (section 4 "bind-options" (def (sig (syntax "(bind-options OPTION VALUE ...)" (id bind-options))) (p "Enables various translation options, where " (tt "OPTION") " is a keyword and VALUE is a value given to that option. Note that " (tt "VALUE") " is not evaluated.") (p "Possible options are:")) (section 5 "export-constants" (pre "export-constants: BOOLEAN") (p "Define global variables for constant-declarations (with " (tt "#define") " or " (tt "enum") "), making the constant available outside the current compilation unit.")) (section 5 "class-finalizers" (pre "class-finalizers: BOOLEAN") (p "Automatically generates calls to " (tt "set-finalizer!") " so that any unused references to instances of subsequently defined C++ class wrappers will be destroyed. This should be used with care: if the embedded C++ object which is represented by the reclaimed " (tt "coops") " instance is still in use in foreign code, unpredictable things will happen.")) (section 5 "mutable-fields" (pre "mutable-fields: BOOLEAN") (p "Specifies that all struct or union fields should generate setter procedures (the default is to generate only setter procedures for fields declared " (tt "___mutable") ").")) (section 5 "constructor-name" (pre "constructor-name: STRING") (p "Specifies an alternative name for constructor methods (the default is " (tt "constructor") "), a default-method for which is defined in the " (tt "cplusplus-object") " extension.")) (section 5 "destructor-name" (pre "destructor-name: STRING") (p "Specifies an alternative name for destructor methods (the default is " (tt "destructor") "), a default-method for which is defined in the " (tt "cplusplus-object") " extension.")) (section 5 "exception-handler" (pre "exception-handler: STRING") (p "Defines C++ code to be executed when an exception is triggered inside a C++ class member function. The code should be one or more " (tt "catch") " forms that perform any actions that should be taken in case an exception is thrown by the wrapped member function:") (pre "(bind-options exception-handler: \"catch(...) { return 0; }\")") (pre "(bind* #<<EOF\nclass Foo {\n public:\n  Foo *bar(bool f) { if(f) throw 123; else return this; }\n};\nEOF\n)") (pre "(define f1 (new <Foo>))\n(print (bar f1 #f))\n(print (bar f1 #t))\n(delete f1)") (p "will print " (tt "<Foo>") " and " (tt "#f") ", respectively.")) (section 5 "full-specialization" (pre "full-specialization: BOOLEAN") (p "Enables " (i "full specialization") " mode. In this mode all wrappers for functions, member functions and static member functions are created as fully specialized " (tt "coops") " methods. This can be used to handle overloaded C++ functions properly. Only a certain set of foreign argument types can be mapped to " (tt "coops") " classes, as listed in the following table:") (table (tr (th "Type") (th "Class")) "\n" (tr (td "char") (td (tt "<char>"))) "\n" (tr (td "bool") (td (tt "<bool>"))) "\n" (tr (td "c-string") (td (tt "<string>"))) "\n" (tr (td "unsigned-char") (td (tt "<exact>"))) "\n" (tr (td "byte") (td (tt "<exact>"))) "\n" (tr (td "unsigned-byte") (td (tt "<exact>"))) "\n" (tr (td "[unsigned-]int") (td (tt "<exact>"))) "\n" (tr (td "[unsigned-]short") (td (tt "<exact>"))) "\n" (tr (td "[unsigned-]long") (td (tt "<integer>"))) "\n" (tr (td "[unsigned-]integer") (td (tt "<integer>"))) "\n" (tr (td "float") (td (tt "<inexact>"))) "\n" (tr (td "double") (td (tt "<inexact>"))) "\n" (tr (td "number") (td (tt "<number>"))) "\n" (tr (td "(enum _)char") (td (tt "<exact>"))) "\n" (tr (td "(const T)char") (td "(as T)")) "\n" (tr (td "(function ...)") (td (tt "<pointer>"))) "\n" (tr (td "c-pointer") (td (tt "<pointer>"))) "\n" (tr (td "(pointer _)") (td (tt "<pointer>"))) "\n" (tr (td "(c-pointer _)") (td (tt "<pointer>"))) "\n" (tr (td "u8vector") (td (tt "<u8vector>"))) "\n" (tr (td "s8vector") (td (tt "<s8vector>"))) "\n" (tr (td "u16vector") (td (tt "<u16vector>"))) "\n" (tr (td "s16vector") (td (tt "<s16vector>"))) "\n" (tr (td "u32vector") (td (tt "<u32vector>"))) "\n" (tr (td "s32vector") (td (tt "<s32vector>"))) "\n" (tr (td "f32vector") (td (tt "<f32vector>"))) "\n" (tr (td "f64vector") (td (tt "<f64vector>")))) (p "All other foreign types are specialized as " (tt "#t") ".") (p "Full specialization can be enabled globally, or only for sections of code by enclosing it in") (pre "(bind-options full-specialization: #t)") (pre "(bind #<<EOF\n...\nint foo(int x);\nint foo(char *x);\n...\nEOF\n)") (pre "(bind-options full-specialization: #f)") (p "Alternatively, member function definitions may be prefixed by " (tt "___specialize") " for specializing only specific members.")) (section 5 "prefix" (pre " prefix: STRING") (p "Sets a prefix that should be be added to all generated Scheme identifiers. For example") (pre "(bind-options prefix: \"mylib:\")") (pre "(bind \"#define SOME_CONST 42\")") (p "would generate the following code:") (pre "(define-constant mylib:SOME_CONST 42)") (p "To switch prefixing off, use the value " (tt "#f") ". Prefixes are not applied to Class names.")) (section 5 "default-renaming" (pre "default_renaming: STRING") (p "Chooses a standard name-transformation, converting underscores (" (tt "_") ") to hyphens (" (tt "-") ") and transforming " (i "CamelCase") " into " (i "camel-case") ". All uppercase characters are also converted to lowercase. The result is prefixed with the argument " (tt "STRING") " (equivalent to the " (tt "prefix") " ption)."))) (section 4 "bind-include-path" (def (sig (syntax "(bind-include-path STRING ...)" (id bind-include-path))) (p "Appends the paths given in " (tt "STRING ...") " to the list of available include paths to be searched when an " (tt "#include ...") " form is processed by " (tt "bind") ".")))) (section 3 "Grammar" (p "The parser understand the following grammar:") (pre "PROGRAM = PPCOMMAND\n        | DECLARATION \";\"\n\nPPCOMMAND = \"#define\" ID [TOKEN ...]\n          | \"#ifdef\" ID\n          | \"#ifndef\" ID\n          | \"#else\"\n          | \"#endif\"\n          | \"#undef\" ID\n          | \"#error\" TOKEN ...\n          | \"#include\" INCLUDEFILE\n          | \"#import\" INCLUDEFILE\n          | \"#pragma\" TOKEN ...\n\nDECLARATION = FUNCTION\n            | VARIABLE\n            | ENUM\n            | TYPEDEF\n            | CLASS\n            | CONSTANT\n            | STRUCT\n            | NAMESPACE\n            | USING\n\nSTRUCT = (\"struct\" | \"union\") ID [\"{\" {[\"___mutable\"] TYPE {\"*\"} ID {\",\" {\"*\"} ID}} \"}]\n\nNAMESPACE = \"namespace\" ID \"{\" DECLARATION ... \"}\"\n\nUSING = \"using\" \"namespace\" ID\n\nINCLUDEFILE = \"\\\"\" ... \"\\\"\"\n            | \"<\" ... \">\"\n\nFUNCTION = {\"___safe\" | \"___specialize\" | \"___discard\"} [STORAGE] TYPE ID \"(\" ARGTYPE \",\" ... \")\" [CODE]\n         | {\"___safe\" | \"___specialize\" | \"___discard\"} [STORAGE] TYPE ID \"(\" \"void\" \")\" [CODE]\n\nARGTYPE = [IOQUALIFIER] TYPE [ID [\"=\" NUMBER]]\n\nIOQUALIFIER = \"___in\" | \"___out\" | \"___inout\" | LENQUALIFIER\n\nLENQUALIFIER = \"___length\" \"(\" ID \")\"\n\nVARIABLE = [STORAGE] ENTITY [\"=\" INITDATA]\n\nENTITY = TYPE ID [\"[\" ... \"]\"]\n\nSTORAGE = \"extern\" | \"static\" | \"volatile\" | \"inline\"\n\nCONSTANT = \"const\" TYPE ID \"=\" INITDATA\n\nENUM = \"enum\" \"{\" ID [\"=\" (NUMBER | ID)] \",\" ... \"}\"\n\nTYPEDEF = \"typedef\" TYPE [\"*\" ...] [ID]\n\nTYPE = [\"const\"] BASICTYPE [(\"*\" ... | \"&\" | \"<\" TYPE \",\" ... \">\" | \"(\" \"*\" [ID] \")\" \"(\" TYPE \",\" ... \")\")]\n\nBASICTYPE = [\"unsigned\" | \"signed\"] \"int\" \n          | [\"unsigned\" | \"signed\"] \"char\" \n          | [\"unsigned\" | \"signed\"] \"short\" [\"int\"]\n          | [\"unsigned\" | \"signed\"] \"long\" [\"int\"]\n          | [\"unsigned\" | \"signed\"] \"___byte\" \n          | \"size_t\"\n          | \"float\"\n          | \"double\"\n          | \"void\"\n          | \"bool\"\n          | \"___bool\"\n          | \"___scheme_value\"\n          | \"___scheme_pointer\"\n          | \"___byte_vector\"\n          | \"___pointer_vector\"\n          | \"___pointer\" TYPE \"*\"\n          | \"C_word\"\n          | \"___fixnum\"\n          | \"___number\"\n          | \"___symbol\"\n          | \"___u32\"\n          | \"___s32\"\n          | \"___s64\"\n          | \"__int64\"\n          | \"int64_t\"\n          | \"uint32_t\"\n          | \"uint64_t\"\n          | \"struct\" ID\n          | \"union\" ID\n          | \"enum\" ID\n          | ID\n\nCLASS = [\"___abstract\"] \"class\" ID [\":\" [QUALIFIER] ID \",\" ...] \"{\" MEMBER ... \"}\"\n\nMEMBER = [QUALIFIER \":\"] [\"virtual\"] (MEMBERVARIABLE | CONSTRUCTOR | DESTRUCTOR | MEMBERFUNCTION)\n\nMEMBERVARIABLE = TYPE ID [\"=\" INITDATA]\n\nMEMBERFUNCTION = {\"___safe\" | \"static\" | \"___specialize\" | \"___discard\"} TYPE ID \"(\" ARGTYPE \",\" ... \")\" [\"const\"] [\"=\" \"0\"] [CODE]\n               | {\"___safe\" | \"static\" | \"___specialize\" | \"___discard\"} TYPE ID \"(\" \"void\" \")\" [\"const\"] [\"=\" \"0\"] [CODE]\n\nCONSTRUCTOR = [\"___safe\"] [\"explicit\"] ID \"(\" ARGTYPE \",\" ... \")\" [BASECONSTRUCTORS] [CODE]\n\nDESTRUCTOR = [\"___safe\"] \"~\" ID \"(\" [\"void\"] \")\" [CODE]\n\nQUALIFIER = (\"public\" | \"private\" | \"protected\")\n\nNUMBER = <a C integer or floating-point number, in decimal, octal or hexadecimal notation>\n\nINITDATA = <everything up to end of chunk>\n\nBASECONSTRUCTORS = <everything up to end of chunk>\n\nCODE = <everything up to end of chunk>") (p "The following table shows how argument-types are translated:") (table (tr (th "C type") (th "Scheme type")) "\n" (tr (td "[unsigned] char") (td "char")) "\n" (tr (td "[unsigned] short") (td "[unsigned-]short")) "\n" (tr (td "[unsigned] int") (td "[unsigned-]integer")) "\n" (tr (td "[unsigned] long") (td "[unsigned-]long")) "\n" (tr (td "___u32") (td "unsigned-integer32\n")) (tr (td "___s32") (td "integer32\n")) (tr (td "___s64") (td "integer64\n")) (tr (td "int64_t") (td "integer64\n")) (tr (td "__int64") (td "integer64\n")) (tr (td "uint32_t") (td "unsigned-integer32\n")) (tr (td "uint64_t") (td "unsigned-integer64\n")) (tr (td "float") (td "float\n")) (tr (td "double") (td "double\n")) (tr (td "size_t") (td "unsigned-integer\n")) (tr (td "bool") (td "int\n")) (tr (td "___bool") (td "int\n")) (tr (td "___fixnum") (td "int\n")) (tr (td "___number") (td "number\n")) (tr (td "___symbol") (td "symbol\n")) (tr (td "___scheme_value") (td "scheme-object\n")) (tr (td "C_word") (td "scheme-object\n")) (tr (td "___scheme_pointer") (td "scheme-pointer\n")) "\n" (tr (td " char *") (td "c-string")) "\n" (tr (td "signed char *") (td "s8vector")) "\n" (tr (td "[signed] short *") (td "s16vector")) "\n" (tr (td " [signed] int *") (td "s32vector")) "\n" (tr (td " [signed] long *") (td "s32vector")) "\n" (tr (td " unsigned char *") (td "u8vector")) "\n" (tr (td " unsigned short *") (td "u16vector")) "\n" (tr (td " unsigned int *") (td "u32vector")) "\n" (tr (td " unsigned long *") (td "u32vector")) "\n" (tr (td " float *") (td "f32vector")) "\n" (tr (td " double *") (td "f64vector")) "\n" (tr (td "___byte_vector") (td "byte-vector")) "\n" (tr (td "___pointer_vector") (td "pointer-vector")) "\n" (tr (td " CLASS *") (td "(instance CLASS <CLASS>)")) "\n" (tr (td " CLASS &") (td "(instance-ref CLASS <CLASS>)")) "\n" (tr (td " TYPE *") (td "(pointer TYPE)")) "\n" (tr (td " TYPE &") (td "(ref TYPE)")) "\n" (tr (td " TYPE<T1, ...>") (td "(template TYPE T1 ...)")) "\n" (tr (td " TYPE1 (*)(TYPE2, ...)") (td "(function TYPE1 (TYPE2 ...))"))) (p "The following table shows how result-types are translated:") (table (tr (th "C type                 ") (th "Scheme type")) "\n" (tr (td "void                   ") (td "void")) "\n" (tr (td "[unsigned] char        ") (td "char")) "\n" (tr (td "[unsigned] short       ") (td "[unsigned-]short")) "\n" (tr (td "[unsigned] int         ") (td "[unsigned-]integer")) "\n" (tr (td "[unsigned] long        ") (td "[unsigned-]long")) "\n" (tr (td "___u32                 ") (td "unsigned-integer32")) "\n" (tr (td "___s32                 ") (td "integer32")) "\n" (tr (td "___s64                 ") (td "integer64")) "\n" (tr (td "int64_t                ") (td "integer64")) "\n" (tr (td "__int64                ") (td "integer64")) "\n" (tr (td "uint64_t               ") (td "unsigned-integer64")) "\n" (tr (td "__uint64               ") (td "unsigned-integer64")) "\n" (tr (td "float                  ") (td "float")) "\n" (tr (td "double                 ") (td "double")) "\n" (tr (td "size_t                 ") (td "unsigned-integer")) "\n" (tr (td "bool                   ") (td "bool")) "\n" (tr (td "___bool                ") (td "bool")) "\n" (tr (td "___fixnum              ") (td "int")) "\n" (tr (td "___number              ") (td "number")) "\n" (tr (td "___symbol              ") (td "symbol")) "\n" (tr (td "___scheme_value        ") (td "scheme-object")) "\n" (tr (td "char *                 ") (td "c-string")) "\n" (tr (td "TYPE *                 ") (td "(pointer TYPE)")) "\n" (tr (td "TYPE &                 ") (td "(ref TYPE)")) "\n" (tr (td "TYPE<T1, ...>       ") (td "(template TYPE T1 ...)")) "\n" (tr (td "TYPE1 (*)(TYPE2, ...)  ") (td "(function TYPE1 (TYPE2 ...))")) "\n" (tr (td "CLASS *                ") (td "(instance CLASS <CLASS>)")) "\n" (tr (td "CLASS &                ") (td "(instance-ref CLASS <CLASS>)"))) (p "The " (tt "___pointer") " argument marker disables automatic simplification of pointers to number-vectors: normally arguments of type " (tt "int *") " are handled as SRFI-4 " (tt "s32vector") " number vectors. To force treatment as a pointer argument, precede the argument type with " (tt "___pointer") ".")) (section 3 "C notes" (p "Foreign variable definitions for macros are not exported from the current compilation unit, but definitions for C variables and functions are.") (p (tt "bind") " does not embed the text into the generated C file, use " (tt "bind*") " for that.") (p "Functions with variable number of arguments are not supported.")) (section 3 "C++ notes" (p "Each C++ class defines a " (tt "coops") " class, which is a subclass of " (tt "<c++-object>") ". Instances of this class contain a single slot named " (tt "this") ", which holds a pointer to a heap-allocated C++ instance.  The name of the " (tt "coops") " class is obtained by putting the C++ classname between angled brackets (" (tt "<...>") ").  " (tt "coops") " classes are not seen by C++ code.") (p "The C++ constructor is invoked by the " (tt "constructor") " generic, which accepts as many arguments as the constructor. If no constructor is defined, a default-constructor will be provided taking no arguments.") (p "To release the storage allocated for a C++ instance invoke the " (tt "delete") " generic (the name can be changed by using the " (tt "destructor-name") " option).") (p "Static member functions are wrapped in a Scheme procedure named " (tt "<class>::<member>") ".") (p "Member variables and non-public member functions are ignored.") (p "Virtual member functions are not seen by C++ code. Overriding a virtual member function with a " (tt "coops") " method will not work when the member function is called by C++.") (p "Operator functions and default arguments are not supported.") (p "Exceptions must be explicitly handled by user code and may not be thrown beyond an invocation of C++ by Scheme code.") (p "Generally, the following interface to the creation and destruction of wrapped C++ instances is provided:") (section 4 "constructor" (def (sig (procedure "(constructor CLASS INITARGS)" (id constructor))) (p "A generic function that, when invoked will construct a C++ object represented by the class " (tt "CLASS") ", which should inherit from " (tt "<c++-object>") ". " (tt "INITARGS") " is a list of arguments that should be passed to the constructor and which must match the argument types for the wrapped constructor."))) (section 4 "destructor" (def (sig (procedure "(destructor OBJECT)" (id destructor))) (p "A generic function that, when invoked will destroy the wrapped C++ object " (tt "OBJECT") ".")) (section 5 "new" (def (sig (procedure "(new CLASS ARG1 ...)" (id new))) (p "A convenience procedure that invokes the " (tt "constructor") " generic function for " (tt "CLASS") "."))) (section 5 "delete" (def (sig (procedure "(delete OBJECT)" (id delete))) (p "A convenience procedure that invokes the " (tt "destructor") " generic method of " (tt "OBJECT") ".")))))) (section 2 "Authors" (p (int-link "/users/felix winkelmann" "felix winkelmann"))) (section 2 "License" (p "This code is placed into the public domain.")) (section 2 "Version History" (dl (dt "0.92") (dd "fixed use of deprecated " (tt "pointer") " type in CHICKEN 4.6.4; fixed testcase") (dt "0.91") (dd "various bugfixes (thanks to Christian Kellermann)") (dt "0.9") (dd "using bind in interpreted code shows suitable error message") (dt "0.7") (dd "added " (int-link "regex") " dependency") (dt "0.6") (dd "commit screwup") (dt "0.6") (dd "fixed bug in variable access procedure generation") (dt "0.5") (dd "support for pointer-vectors and unsigned in32/int64 (the latter might not work)") (dt "0.4") (dd "added renaming options to " (tt "chicken-bind")) (dt "0.3") (dd "fixed typo in bind-translator.scm (thanks to Shawn Rutledge)") (dt "0.2") (dd "fixed bug in " (tt "chicken-bind") " and added " (tt "-parse") " option") (dt "0.1") (dd "imported modified " (int-link "easyffi")))))