(index ("bind" 0) ("bind*" 182) ("bind-type" 362) ("bind-opaque-type" 1349) ("bind-file" 2019) ("bind-file*" 2223) ("bind-rename" 2387) ("bind-rename/pattern" 2670) ("bind-options" 2988) ("bind-include-path" 3257) ("constructor" 3513) ("destructor" 3904) ("new" 4065) ("delete" 4230))
(def (sig (syntax "(bind STRING ...)" (id bind))) (p "Parses the C code in " (tt "STRING ...") " and expands into wrapper code providing access to the declarations defined in it."))
(def (sig (syntax "(bind* STRING ...)" (id bind*))) (p "Similar to " (tt "bind") ", but also embeds the code in the generated Scheme expansion using " (tt "foreign-declare") "."))
(def (sig (syntax "(bind-type TYPENAME SCHEMETYPE [CONVERTARGUMENT [CONVERTRESULT]])" (id bind-type))) (p "Declares a foreign type transformation, similar to " (tt "define-foreign-type") ". There should be two to four arguments: a C typename, a Scheme foreign type specifier and optional argument- and result-value conversion procedures.") (pre ";;;; foreign type that converts to unicode (assumes 4-byte wchar_t):\n;\n; - Note: this is rather kludgy and is only meant to demonstrate the `bind.type'\n;         syntax") (pre "(require-extension srfi-4 bind)") (pre "(define mbstowcs (foreign-lambda int \"mbstowcs\" nonnull-u32vector c-string int))") (pre "(define (str->ustr str)\n  (let* ([len (string-length str)]\n         [us (make-u32vector (add1 len) 0)] )\n    (mbstowcs us str len)\n    us) )") (pre "(bind-type unicode nonnull-u32vector str->ustr)") (pre "(bind* #<<EOF\nstatic void foo(unicode ws)\n{\n  printf(\"%ls\\n\", ws);\n}\nEOF\n)") (pre "(foo \"this is a test!\")"))
(def (sig (syntax "(bind-opaque-type TYPENAME SCHEMETYPE)" (id bind-opaque-type))) (p "Similar to " (tt "bind-type") ", but provides automatic argument- and result conversions to wrap a value into a structure:") (pre "(bind-opaque-type myfile (pointer \"FILE\"))") (pre "(bind \"myfile fopen(char *, char *);\")") (pre "(fopen \"somefile\" \"r\")   ==> <myfile>") (p (tt "(bind-opaque-type TYPENAME TYPE)") " is basically equivalent to " (tt "(bind-type TYPENAME TYPE TYPE->RECORD RECORD->TYPE)") " where " (tt "TYPE->RECORD") " and " (tt "RECORD->TYPE") " are compiler-generated conversion functions that wrap objects of type " (tt "TYPE") " into a record and back."))
(def (sig (syntax "(bind-file FILENAME ...)" (id bind-file))) (p "Reads the content of the given files and generates wrappers using " (tt "bind") ". Note that " (tt "FILENAME ...") " is not evaluated."))
(def (sig (syntax "(bind-file* FILENAME ...)" (id bind-file*))) (p "Reads the content of the given files and generates wrappers using " (tt "bind*") ".") (pre ""))
(def (sig (syntax "(bind-rename CNAME SCHEMENAME)" (id bind-rename))) (p "Defines to what a certain C/C++ name should be renamed. " (tt "CNAME") " specifies the C/C++ identifier occurring in the parsed text and " (tt "SCHEMENAME") " gives the name used in generated wrapper code."))
(def (sig (syntax "(bind-rename/pattern REGEX REPLACEMENT)" (id bind-rename/pattern))) (p "Declares a renaming pattern to be used for C/C++ identifiers occuring in bound code. " (tt "REGEX") " should be a string or SRE and replacement a string, which may optionally contain back-references to matched sub-patterns."))
(def (sig (syntax "(bind-options OPTION VALUE ...)" (id bind-options))) (p "Enables various translation options, where " (tt "OPTION") " is a keyword and VALUE is a value given to that option. Note that " (tt "VALUE") " is not evaluated.") (p "Possible options are:"))
(def (sig (syntax "(bind-include-path STRING ...)" (id bind-include-path))) (p "Appends the paths given in " (tt "STRING ...") " to the list of available include paths to be searched when an " (tt "#include ...") " form is processed by " (tt "bind") "."))
(def (sig (procedure "(constructor CLASS INITARGS)" (id constructor))) (p "A generic function that, when invoked will construct a C++ object represented by the class " (tt "CLASS") ", which should inherit from " (tt "<c++-object>") ". " (tt "INITARGS") " is a list of arguments that should be passed to the constructor and which must match the argument types for the wrapped constructor."))
(def (sig (procedure "(destructor OBJECT)" (id destructor))) (p "A generic function that, when invoked will destroy the wrapped C++ object " (tt "OBJECT") "."))
(def (sig (procedure "(new CLASS ARG1 ...)" (id new))) (p "A convenience procedure that invokes the " (tt "constructor") " generic function for " (tt "CLASS") "."))
(def (sig (procedure "(delete OBJECT)" (id delete))) (p "A convenience procedure that invokes the " (tt "destructor") " generic method of " (tt "OBJECT") "."))
