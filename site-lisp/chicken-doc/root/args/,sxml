((tags "eggs") (p (i "args") " provides command-line argument handling, implemented on top of " (link "http://srfi.schemers.org/srfi-37/srfi-37.html" "SRFI 37's args-fold") ".") (toc) (section 2 "Documentation" (p "This extension provides a wrapper around SRFI 37 (args-fold). The main goal is to let the user parse command-line arguments without having to write a lot of similar support code every time.") (p "By default, options and operands (non-options) are collected into two lists and returned by the parser, and unrecognized options complain and display help. Therefore, it is very possible not to write any option-procs, operand-procs, or unrecognized-procs as required by SRFI 37. However, the capability to customize is there should you need it.") (p "Additionally, the help text for your options can be generated for you, so your options and usage information don't get out of sync.") (section 3 "Creating options" (def (sig (syntax "(args:make-option (OPTION-NAME ...) ARG-DATA DOCSTRING [BODY])" (id args:make-option))) (p "Make an " (tt "args:option") " record, suitable for passing to " (tt "args:parse") ".") (p (tt "OPTION-NAME ...") " is a sequence of short or long option names. They must be literal symbols; single-character symbols become short options, and longer symbols become long options. So " (tt "(args:make-option (c cookie) ...)") " specifies a short option " (tt "-c") " and long option " (tt "--cookie") ". Under the hood, " (tt "(c cookie)") " becomes " (tt "'(#\\c \"cookie\")") ", as expected by SRFI 37's " (tt "OPTION") ".") (p (tt "ARG-DATA") " is either a pair " (tt "(ARG-TYPE ARG-NAME)") " or a plain keyword " (tt "ARG-TYPE") ". " (tt "ARG-TYPE") " is a keyword that specifies whether the option takes an argument:") (table (@ (class "symbol-table")) (tr (td "#:required") (td "Argument is required")) "\n" (tr (td "#:optional") (td "Argument is optional")) "\n" (tr (td "#:none") (td "No argument (actually, any other value than #:required or #:optional is interpreted as #:none)"))) (p (tt "ARG-NAME") ", if provided, is a string specifying the name of the argument. This name is used in the help text produced by args:usage.") (p (tt "DOCSTRING") " is the help text.") (p (tt "BODY") " is an optional sequence of statements executed when this option is encountered. Behind the scenes, " (tt "BODY") " is wrapped in code which adds the current option and its argument to the final options alist. So, simply leave " (tt "BODY") " blank and options will be collected for you.") (p (tt "BODY") " is an option-processor as defined in SRFI 37, and has access to the variables " (tt "OPT") " (the current #<option>), " (tt "NAME") " (the option name) and " (tt "ARG") " (argument value or " (tt "#f") ")."))) (section 3 "Parsing the command line" (def (sig (procedure "(args:parse ARGS OPTIONS-LIST [OPTIONALS])" (id args:parse))) (p "Parse " (tt "ARGS") ", a list of command-line arguments given as strings, and return two values: an alist of option names (symbols) and their values, and a list of operands (non-option arguments).") (p "Operands are returned in order, but options are returned in reverse order. Duplicate options are retained in the options alist, so this lets " (tt "assq") " find the " (i "last") " occurrence of any duplicate option on the command line. A (name . value) pair is added for each alias of every option found, so any alias is a valid lookup key.") (p (tt "OPTIONS-LIST") " is a list of accepted options, each created by args:make-option.") (p (tt "OPTIONALS") " is an optional sequence of keywords and values:") (table (@ (class "symbol-table")) (tr (td "#:operand-proc " (tt "PROC")) (td "calls " (tt "PROC") " for each operand, with arguments " (tt "OPERAND") " " (tt "OPTIONS") " " (tt "OPERANDS") ".  PROC must return the next seeds, " (tt "(values OPTIONS OPERANDS)") ".")) "\n" (tr (td "#:unrecognized-proc " (tt "PROC")) (td "calls " (tt "PROC") " for each unrecognized option, with arguments " (tt "OPTION") " " (tt "NAME") " " (tt "ARG") " " (tt "OPTIONS") " " (tt "OPERANDS")))) (p "The default operand-proc is a no-op, and the default unrecognized-proc issues an error message and calls the help option's processor. See the args-fold documentation for usage information and an explanation of the procedure arguments; " (tt "OPTIONS") " and " (tt "OPERANDS") " are seed values.")) (def (sig (parameter "(args:help-options [default: (\"help\" #\\h #\\?)])" (id args:help-options))) (p "List of option names (strings or single characters, as in SRFI 37) to be considered 'help' options, in order of preference. " (tt "args:parse") " uses this to select a help option from the option list it is passed. This is currently used only for unrecognized options, for which the help option is automatically invoked."))) (section 3 "Usage information" (p "Well-behaved programs display help or usage text when invoked with an option such as --help. " (tt "args:usage") " will generate a formatted list of options in the GNU style, from a list of " (tt "args:options") ". Around this you might place a descriptive header and footer.") (def (sig (procedure "(args:usage OPTION-LIST)" (id args:usage))) (p "Generate a formatted list of options from " (tt "OPTION-LIST") ", and return a string suitable for embedding into help text. The single string consists of multiple lines, with a newline at the end of each line. Thus, a typical use would be " (tt "(print (args:usage opts))."))) (def (sig (parameter "(args:width [default: 25])" (id args:width))) (p "Width of the left (option) column. We don't automatically format this column based on the length of the longest option, but you can set its width manually.")) (def (sig (parameter "(args:separator [default: \", \"])" (id args:separator))) (p "The string separator inserted between multiple options on the same line.")) (def (sig (parameter "(args:indent [default: 1])" (id args:indent))) (p "Number of spaces to indent the options from the left."))) (section 3 "Operands and unrecognized options (advanced)" (p "These are suitable for use with " (tt "#:operand-proc") " or " (tt "#:unrecognized-proc") " in " (tt "args:parse") ". Most users will probably not customize these procedures themselves, but a couple useful prefabricated ones are provided.") (def (sig (procedure "(args:ignore-unrecognized-options)" (id args:ignore-unrecognized-options))) (p "Silently ignore unrecognized options, and omit from the options alist.")) (def (sig (procedure "(args:accept-unrecognized-options)" (id args:accept-unrecognized-options))) (p "Silently add unrecognized options to the options alist.")))) (section 2 "Examples" (pre "(use args)\n\n(define opts\n (list (args:make-option (c cookie)    #:none     \"give me cookie\"\n         (print \"cookie was tasty\"))\n       (args:make-option (d)           (optional: \"LEVEL\")  \"debug level [default: 1]\")\n       (args:make-option (e elephant)  #:required \"flatten the argument\"\n         (print \"elephant: arg is \" arg))\n       (args:make-option (f file)      (required: \"NAME\")   \"parse file NAME\")\n       (args:make-option (v V version) #:none     \"Display version\"\n         (print \"args-example $Revision: 1.3 $\")\n         (exit))\n       (args:make-option (abc)         #:none     \"Recite the alphabet\")\n       (args:make-option (h help)      #:none     \"Display this text\"\n         (usage))))\n\n(define (usage)\n (with-output-to-port (current-error-port)\n   (lambda ()\n     (print \"Usage: \" (car (argv)) \" [options...] [files...]\")\n     (newline)\n     (print (args:usage opts))\n     (print \"Report bugs to zbigniewsz at gmail.\")))\n (exit 1))\n\n(receive (options operands)\n    (args:parse (command-line-arguments) opts)\n  (print \"-e -> \" (alist-ref 'elephant options))) ;; 'e or 'elephant both work") (p "If command line is " (tt "--cookie -e test -e hello") ":") (pre "  cookie was tasty\n  elephant: arg is test\n  elephant: arg is hello\n  -e -> hello\n") (p "If command line is " (tt "--cookie -e test --foo") ":") (pre "cookie was tasty\nelephant: arg is test\n./args-example: unrecognized option: foo\nUsage: ./args-example [options...] [files...]\n\n -c, --cookie             give me cookie\n -d [LEVEL]               debug level [default: 1]\n -e, --elephant=ARG       flatten the argument\n -f, --file=NAME          parse file NAME\n -v, -V, --version        Display version\n     --abc                Recite the alphabet\n -h, --help               Display this text\n\nReport bugs to zbigniewsz at gmail.") (p "Using indent 5, width 35 and a single space for the separator:") (pre "#;> (print (parameterize ((args:separator \" \")\n                          (args:indent 5)\n                          (args:width 35))\n             (args:usage opts)))\n\n     -c --cookie                        give me cookie\n     -d [LEVEL]                         debug level [default: 1]\n     -e --elephant=ARG                  flatten the argument\n     -f --file=NAME                     parse file NAME\n     -v -V --version                    Display version\n        --abc                           Recite the alphabet\n     -h --help                          Display this text") (p "Additional examples can be found in " (int-link "args-examples.scm" "args-examples.scm") ".")) (section 2 "Bugs" (p "The name " (tt "args:make-option") " is verbose.")) (section 2 "About this egg" (section 3 "Author" (p (link "http://3e8.org/zb" "Jim Ursetto"))) (section 3 "Version history" (dl (dt "1.4.2") (dd "Accept numerical args, drop args:make-operand-proc (zb)") (dt "1.4") (dd "Ported to Chicken 4 [Ivan Raikov]") (dt "1.3") (dd "check for presence of required option arguments [Ivan Raikov]") (dt "1.2") (dd "commify tail-recursive (Ivan Shmakov); add args:separator, args:indent (zb)") (dt "1.1") (dd "Fix exports (Felix, Kon)") (dt "1.0") (dd "Initial release"))) (section 3 "Requirements" (p (int-link "srfi-37"))) (section 3 "License" (pre "Copyright (c) 2005-2010 Jim Ursetto.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  Redistributions of source code must retain the above copyright notice,\n  this list of conditions and the following disclaimer. Redistributions in\n  binary form must reproduce the above copyright notice, this list of\n  conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution. Neither the name of the\n  author nor the names of its contributors may be used to endorse or\n  promote products derived from this software without specific prior\n  written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\nEXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."))))