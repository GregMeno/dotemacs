((tags "egg") (section 2 "probdist" (p "Probability density functions.") (toc)) (section 2 "Usage" (ul (li "(require-extension sampled-pdf)") (li "(require-extension normal-pdf)"))) (section 2 "Documentation" (p (tt "probdist") " is a library of routines to compute univariate or multivariate normal probability function for a given mean and covariance; and to approximate an arbitrary probability distribution as a weighted set of samples (sampled PDF).") (p "This code is based on code in the " (tt "dysii") " project by Lawrence Murray.") (p "The sampled PDF algorithm is based on the paper by Kitagawa:") (pre "Monte Carlo Filter and Smoother for Non-Gaussian Nonlinear State Space Models_, Journal of Computational and Graphical Statistics, 1996, 5, 1-25.") (section 3 "Normal PDF" (pre "(define-datatype normal-pdf normal-pdf? (NormalPDF S mu sigma R sigmaInv sigmaDet ZI mu-zero? ))") (p "A representation of a normal PDF:") (dl (dt (tt "S")) (dd "number of dimensions") (dt (tt "mu")) (dd "expectation") (dt (tt "sigma")) (dd "covariance") (dt (tt "R")) (dd "upper triangular Cholesky decomposition of covariance matrix") (dt (tt "sigmaInv")) (dd "inverse of covariance matrix") (dt (tt "sigmaDet")) (dd "determinant of covariance matrix") (dt (tt "ZI")) (dd "the constant factor " (tt "(2*pi)^(-S/2) / prod(diag(R))")) (dt (tt "mu-zero?")) (dd "true if expectation is zero")) (def (sig (procedure "make-normal-pdf:: S * MU * SIGMA -> NORMAL-PDF" (id make-normal-pdf))) (p "Creates a new normal PDF object with the specified dimension, expectation, and covariance. If the dimension " (tt "S") " is 1, then the expectation " (tt "MU") " and the covariance " (tt "SIGMA") " must be scalars; otherwise, they must be SRFI-4 " (tt "f64") " vectors. In the latter case, " (tt "MU") " must be a vector of size " (tt "S") ", and " (tt "SIGMA") " must be a matrix of size " (tt "S x S") ".")) (def (sig (procedure "normal-pdf:density:: NORMAL-PDF * X -> DENSITY" (id normal-pdf:density))) (p "Computes the density of the distribution at the given point " (tt "X") ". If the dimension " (tt "S") " of the distribution is 1, then " (tt "X") " must be a scalar, otherwise it must be an SRFI-4 " (tt "f64") " vector of length " (tt "S") ".")) (def (sig (procedure "normal-pdf:sample:: NORMAL-PDF * X -> SAMPLE" (id normal-pdf:sample))) (p "Sample from the distribution. Let " (tt "X") " be a sample from a standard normal distribution. Then the sample is " (tt "SAMPLE = MU + R*X") ", where " (tt "R") " is the upper triangular Cholesky decomposition of the covariance matrix.")) (def (sig (procedure "normal-pdf:expectation:: NORMAL-PDF -> MU" (id normal-pdf:expectation))) (p "Return the expectation value of the distribution (scalar or f64vector).")) (def (sig (procedure "normal-pdf:covariance:: NORMAL-PDF -> SIGMA" (id normal-pdf:covariance))) (p "Return the covariance value of the distribution (scalar or f64vector)."))) (section 3 "Sampled PDF" (pre "(define-datatype sampled-pdf sampled-pdf? (SampledPDF N W WXS MU SIGMA))") (p "A representation of a weighted sampled PDF:") (dl (dt (tt "N")) (dd "sample set size") (dt (tt "W")) (dd "total weight of the sample set") (dt (tt "wxs")) (dd "weighted samples (see below)") (dt (tt "mu")) (dd "expectation") (dt (tt "sigma")) (dd "covariance")) (pre "(define-datatype weighted-samples weighted-samples? (WeightedSamples S senv make-senv))") (p "A representation of weighted samples:") (dl (dt (tt "S")) (dd "number of dimensions") (dt (tt "senv")) (dd "an ordered dictionary data structure that follows the API of " (int-link "rb-tree" "rb-tree")) (dt "make-senv") (dd "a procedure to create an empty samples dictionary")) (def (sig (procedure "make-sampled-pdf:: S * MAKE-SENV * XS [* WS * XCAR * XCDR * XNULL?] -> SAMPLED-PDF" (id make-sampled-pdf))) (p "Creates a new sampled PDF object with the specified dimension, samples environment creation procedure that follows the API of make-rb-tree, and weighted samples. The samples can be specified in one of two ways. If both " (tt "XS") " and " (tt "WS") " are provided, then " (tt "XS") " is a sequence that contains the samples, and " (tt "WS") " is a sequence that contains the corresponding weights. If only " (tt "XS") " is provided, or " (tt "WS") " is false, then " (tt "XS") " must consist of cons cells, where the car is the weight, and the cdr is the sample. Optional arguments " (tt "XCAR XCDR XNULL?") " could be used for sequences other than lists (e.g. streams).")) (def (sig (procedure "sampled-pdf:expectation:: SAMPLED-PDF -> MU" (id sampled-pdf:expectation))) (p "Return the expectation value of the distribution (scalar or f64vector).")) (def (sig (procedure "sampled-pdf:covariance:: SAMPLED-PDF -> SIGMA" (id sampled-pdf:covariance))) (p "Return the covariance value of the distribution (scalar or f64vector).")) (def (sig (procedure "sampled-pdf:find-sample:: U * SAMPLED-PDF -> X" (id sampled-pdf:find-sample))) (p "Given a number " (tt "u in [0,1]") ", returns the sample " (tt "x(i)") "such that " (tt "\\sum_{j=1}^{i-1} w_j < Wu <= \\sum_{j=1}^{i} w_j") ", where " (tt "W") " is the total weight of the sample set.")) (def (sig (procedure "sampled-pdf:normalize:: SAMPLED-PDF -> SAMPLED-PDF" (id sampled-pdf:normalize))) (p "Normalizes the sample weights to sum to 1.")) (def (sig (procedure "sampled-pdf:resample:: MAKE-SENV * SAMPLED-PDF [ * M] -> SAMPLED-PDF" (id sampled-pdf:resample))) (p "Resamples the distribution. This produces a new approximation of the same distribution using a set of equally weighted sample points. Sample points are selected using the deterministic resampling method given in the appendix of Kitagawa. Optional argument " (tt "M") " is the number of samples to take for the new distribution. If not given, defaults to the number of samples in the existing distribution.")))) (section 2 "Examples" (pre ";;\n;; Multivariate test of normal-pdf.\n;;\n;; This test creates a 3-dimensional normal distribution with a\n;; random mean and variance. It then samples from this distribution\n;; and calculates the sample mean and variance for comparison.\n;;\n\n(require-extension srfi-1)\n(require-extension srfi-4)\n(require-extension srfi-4-utils)\n(require-extension matrix-utils)\n(require-extension blas)\n(require-extension normal-pdf)\n(require-extension random-mtzig)\n\n(define-utility-matrices f64)\n\n;; Number of samples \n(define N 100000)\n\n;; Number of dimensions (sample size)\n(define S 3)\n\n\n(define (f64vector-scale a x)\n  (let ((n (f64vector-length x)))\n    (blas:dscal n a x)))\n\n(define (f64vector-sum x y)\n  (let ((n (f64vector-length x)))\n    (blas:daxpy n 1.0 x y)))\n\n(define (f64vector-sub x y)\n  (let ((n (f64vector-length x)))\n    (blas:daxpy n -1.0 y x)))\n\n(define (f64vector-mul a b)\n  (f64vector-map (lambda (v1 v2) (* v1 v2)) a b))\n\n\n(define f64matrix-map (make-matrix-map f64vector-ref f64vector-set!))\n\n(define (upper M N A)\n  (f64matrix-map blas:RowMajor M N A (lambda (i j v) (if (>= j i) v 0.0))))\n\n;;\n;;  Computes the arithmetic mean of a list of f64 vectors using the\n;;  recurrence relation mean_(n) = mean(n-1) + (v[n] -\n;;  mean(n-1))/(n+1)\n;;\n(define (mean s vs)\n    (let loop ((i 0) (vs vs) (mean (make-f64vector s 0.0)))\n      (if (null? vs)  mean\n\t  (loop (fx+ 1 i) (cdr vs)\n\t\t(let ((d (f64vector-sub (car vs) mean)))\n\t\t  (f64vector-sum mean (f64vector-scale (/ 1 (+ 1 i)) d)))))))\n\n(define (covariance s vs mean)\n   (let* ((cov  (matrix-zeros S S)))\n     (let ((ds (map (lambda (x) (f64vector-sub x mean)) vs)))\n       (let ((n (fold (lambda (d n) \n\t\t\t(blas:dsyr! blas:RowMajor blas:Upper s 1.0 d cov)\n\t\t\t(fx+ 1 n)) 0 ds)))\n\t (f64vector-scale (/ 1 (- n 1)) cov)))))\n\t\t\t \n      \n;; Given a vector of values in the range [0..1], scale all values in\n;; the vector to the specified range.\n(define (f64vector-urange x lo hi)\n  (if (< lo hi) (let ((d (- hi lo)))\n\t\t  (f64vector-map (lambda (x) (+ lo (* d x))) x))))\n\n(define rng  (random-mtzig:init))\n\n;;  distribution parameters\n(define mu     (f64vector-urange (random-mtzig:f64vector-randu! S rng) -5 5))\n(define sigma  (let ((x (f64vector-urange (random-mtzig:f64vector-randu! (* S S) rng) 0 5)))\n\t\t (blas:dgemm! blas:RowMajor blas:NoTrans blas:Trans S S S \n\t\t\t      1.0 x x 0.0 (make-f64vector (* S S)))))\n\n\n(define gpdf  (begin\n\t\t(print \"mu = \" mu)\n\t\t(print \"sigma = \" sigma)\n\t\t(make-normal-pdf S mu sigma)))\n\n(define input (list-tabulate N (lambda (i) (random-mtzig:f64vector-randn! S rng))))\n\n(define samples\n  (let loop ((i 0) (input input) (samples (list)))\n    (if (null? input)  samples\n\t(let ((samples (cons (normal-pdf:sample gpdf  (car input))  samples)))\n\t  (loop (fx+ 1 i) (cdr input) samples)))))\n\n(if (<= N 100) (print \"input = \" input))\n(if (<= N 100) (print \"samples = \" samples))\n\n;; test for mean and covariance equality to one decimal place\n(equal? (f64vector-map (lambda (x) (truncate (* 10 x))) mu)\n\t(f64vector-map (lambda (x) (truncate (* 10 x))) \n\t\t       (mean S samples)))\n\n(equal? (f64vector-map (lambda (x) (truncate (* 10 x))) (upper S S sigma))\n\t(f64vector-map (lambda (x) (truncate (* 10 x)))\n\t\t       (covariance S samples (mean S samples))))\n")) (section 2 "About this egg" (section 3 "Author" (p (int-link "/users/ivan-raikov" "Ivan Raikov"))) (section 3 "Version history" (dl (dt "1.6") (dd "Documentation converted to wiki format") (dt "1.5") (dd "Ported to Chicken 4.") (dt "1.4") (dd "Added some error checking in make-normal-pdf and a record printer for the normal-pdf datatype.") (dt "1.3") (dd "Build script updated for better cross-platform compatibility") (dt "1.2") (dd "More metafile fixes") (dt "1.1") (dd "Metafile fixes") (dt "1.0") (dd "Initial release"))) (section 3 "License" (pre "Copyright 2007-2010 Ivan Raikov and the Okinawa Institute of Science and Technology.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or (at\nyour option) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nA full copy of the GPL license can be found at\n<http://www.gnu.org/licenses/>."))))