(index ("quotient&remainder" 0) ("quotient&modulo" 293) ("conj" 451) ("bignum?" 549) ("ratnum?" 642) ("cplxnum?" 713) ("rectnum?" 788) ("compnum?" 918) ("cflonum?" 1002) ("cintnum?" 1110))
(def (sig (procedure "(quotient&remainder A B)" (id quotient&remainder))) (p "Return the quotient " (i "and") " the remainder of A divided by B.") (p "This is especially useful for bignums, since both numbers are derived simultaneously.  This saves performing the division algorithm twice."))
(def (sig (procedure "(quotient&modulo A B)" (id quotient&modulo))) (p "Like " (tt "quotient&remainder") ", except return the modulo instead of remainder."))
(def (sig (procedure "(conj Z)" (id conj))) (p "Returns the conjugate of the complex number Z."))
(def (sig (procedure "(bignum? X)" (id bignum?))) (p "Is X an extended-precision integer?"))
(def (sig (procedure "(ratnum? X)" (id ratnum?))) (p "Is X a ratio?"))
(def (sig (procedure "(cplxnum? X)" (id cplxnum?))) (p "Is X a complex?"))
(def (sig (procedure "(rectnum? X)" (id rectnum?))) (p "Is X an exact-complex? (Treats an integer-floatingpoint as \"exact\".)"))
(def (sig (procedure "(compnum? X)" (id compnum?))) (p "Is X an inexact-complex?"))
(def (sig (procedure "(cflonum? X)" (id cflonum?))) (p "Is X a floatingpoint-complex or a floatingpoint?"))
(def (sig (procedure "(cintnum? X)" (id cintnum?))) (p "Is X an integer-complex or an integer?"))
