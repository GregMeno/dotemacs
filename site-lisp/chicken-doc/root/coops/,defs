(index ("define-class" 0) ("make-class" 1076) ("class-name" 1454) ("subclass?" 1599) ("make" 1817) ("class-of" 2187) ("generic-procedure?" 2338) ("define-generic" 2506) ("define-method" 3216) ("make-generic-procedure" 5028) ("slot-value" 5565) ("slot-initialized?" 5878) ("print-object" 6078) ("define-primitive-class" 6226))
(def (sig (syntax "(define-class CLASSNAME [(SUPERCLASS ...) [(SLOTSPEC ...) CLASSOPTION ...]])" (id define-class))) (p "Defines a COOPS class and assigns it to the variable " (tt "CLASSNAME") " (which should be a symbol).  " (tt "(SUPERCLASS ...)") " is a list of expressions evaluating to classes from which the newly defined class should inherit. If no superclasses are given or the superclass list is empty, then " (tt "<standard-object>") " is assumed to be the default superclass.") (p (tt "SLOTSPEC") " specifies a slot (commonly called an instance variable) and should be either a symbol naming the slot or a list of the form " (tt "(SLOTNAME SLOTOPTION1 OPTIONVALUE1 ...)") ".  The syntax " (tt "(SLOTNAME INITFORM)") " is also a valid " (tt "SLOTSPEC") " and is equivalent to " (tt "(SLOTNAME initform: INITFORM)") ".") (p "An instance always contains all the slots of all superclasses in addition to its own slots.") (p "Classes are first-class values and are actually instances themselves, of the class " (tt "<standard-class>") " (see below for more details)."))
(def (sig (syntax "(make-class [CLASSNAME] (SUPERCLASS ...) [(SLOTNAME ...) [METACLASS]])" (id make-class))) (p "Defines a class. " (tt "define-class") " is syntactic sugar around this form and is usually preferred. " (tt "make-class") " allows the creation of " (i "anonymous") " (that is: unnamed) classes.") (p "Note that " (tt "make-class") " is syntax, not a procedure."))
(def (sig (procedure "(class-name CLASS)" (id class-name))) (p "Returns the name of " (tt "CLASS") ", if it has one, or " (tt "#f") " it not."))
(def (sig (procedure "(subclass? CLASS1 CLASS2)" (id subclass?))) (p "Returns " (tt "#t") " if " (tt "CLASS1") " is equal to " (tt "CLASS2") " or if it is a subclass of " (tt "CLASS2") " or " (tt "#f") " otherwise."))
(def (sig (procedure "(make CLASS SLOTNAME1 INITFORM1 ...)" (id make))) (p "Creates an instance of the " (tt "CLASS") " and initializes the slots given in the remaining arguments. The new instance is returned. Slots not given which have been declared to have an " (tt "initform:") " will be initialized by evaluating that form. All other slots will be uninitialized."))
(def (sig (procedure "(class-of X)" (id class-of))) (p "Returns the class of " (tt "X") " or " (tt "#t") " if " (tt "X") " is not a class instance."))
(def (sig (procedure "(generic-procedure? X)" (id generic-procedure?))) (p "Returns " (tt "#t") " if " (tt "X") " is a generic procedure or " (tt "#f") " otherwise."))
(def (sig (syntax "(define-generic (NAME ARGUMENT ...))" (id define-generic))) (p "Defines a generic procedure, a procedure specialized for one or more argument types. " (tt "ARGUMENT ...") " defines the number of specialized arguments this generic procedure shoud use to dispatch to the correct method. The generic procedure may receive additional arguments, but those will not be used to determine the method. This form is roughly equivalent to") (highlight scheme "(define NAME\n  (make-generic-procedure ARGUMENT ...))") (p "You can use the syntax") (highlight scheme "(define-generic ((setter NAME) ARGUMENT ...))") (p "to define a SRFI-17 setter on " (tt "NAME") " that is itself a generic procedure."))
(def (sig (syntax "(define-method (NAME [QUALIFIER] [(ARGUMENT1 CLASS1) ...] ...) BODY ...)" (id define-method))) (p "Defines a method specialized for arguments of the classes " (tt "CLASS1 ...") " on the generic procedure " (tt "NAME") ". If " (tt "NAME") " holds a method for the same argument classes, the previously defined method is replaced.") (p "If no generic procedure has previously been defined for " (tt "NAME") ", then a generic procedure definition is done implicitly. Whether it can be assumed a definition exists is assumed to be the case when one of the following holds true:") (ul (li (tt "NAME") " is an imported value binding") (li "a generic procedure has been defined with " (tt "(define-generic NAME ...)") " in the same  compilation unit or the same interpreter session and is lexically visible")) (highlight scheme "(define-method ((setter NAME) ...) BODY ...)") (p "is allowed and supported.") (p (tt "QUALIFIER") " may be one of the keywords " (tt "primary:") ", " (tt "before:") ", " (tt "after:") " or " (tt "around:") " and mark the method as being either a primary (default) method, a method that is called before or after the primary method or a method that is \"wrapped\" around more specific methods. " (tt "before:") " methods are invoked from most specific to least specific. " (tt "after:") " methods are invoked from least specific to most specific. " (tt "around:") " methods can chose to invoke the next most specific method with the same arguments by calling " (tt "(call-next-method)") " with no arguments.") (p "All arguments of the form " (tt "(ARGUMENT CLASS)") " are specialized up to the first occurrence of a plain symbol or until a \"rest\"-argument or extended lambda-list marker (" (tt "#!rest") ", " (tt "#!optional") " or " (tt "#!key") ") is encountered."))
(def (sig (syntax "(make-generic-procedure ARGUMENT ...)" (id make-generic-procedure))) (p "Creates a generic procedure, a procedure decorated with a hidden generic procedure object of class " (tt "<generic-procedure>") ". " (tt "ARGUMENT ...") " is the list of specialized arguments this procedure should receive. Methods for this generic procedure may accept more required or optional arguments, but the number of specialized arguments must be the same.") (p "Note that " (tt "make-generic-procedure") " is syntax, not a procedure."))
(def (sig (procedure "(slot-value OBJECT SLOTNAME)" (id slot-value))) (p "Returns the slot named " (tt "SLOTNAME") " of the class instance " (tt "OBJECT") ", signalling an error if no such slot exists.") (highlight scheme "(set! (slot-value OBJECT SLOTNAME) VAL)") (p "can be used to assign a value to a slot."))
(def (sig (procedure "(slot-initialized? OBJECT SLOTNAME)" (id slot-initialized?))) (p "Returns " (tt "#t") " if " (tt "OBJECT") " has a slot named " (tt "SLOTNAME") " or " (tt "#f") " ortherwise."))
(def (sig (procedure "(print-object OBJECT PORT)" (id print-object))) (p "A generic procedure that is invoked when " (tt "OBJECT") " is printed."))
(def (sig (syntax "(define-primitive-class NAME [(SUPERCLASS ...)] PREDICATE)" (id define-primitive-class))) (p "Defines a primitive class of with the name " (tt "NAME") " and the given list of superclasses. If no superclasses are specified, then the superclass list defaults to " (tt "(%lt;primitive-object>)") ". " (tt "PREDICATE") " should be a procedure of one argument determining whether the argument is a member of the newly defined primitive class.") (p "The predicate should be referentially transparent."))
