((tags "egg") (toc) (section 2 "coops" (section 3 "Introduction" (p "COOPS is an object system for Scheme that provides") (ul (li "classes with multiple inheritance;") (li "generic procedures;") (li "methods that can specialize on one or more arguments (" (i "multimethods") ");") (li "before, after, and around auxiliary methods in addition to primary methods;") (li "call-next-method and next-method? in primary and around methods; and") (li "standard method combination (the default \"demon\" protocol used in CLOS).") (li "SRFI-17 " (i "setters") " as generic procedures"))) (section 3 "Usage" (highlight scheme "(require-extension coops)") (p "and optionally") (highlight scheme "(require-extension coops-primitive-objects)")) (section 3 "Requirements" (p (int-link "/eggref/4/matchable" "matchable") " " (int-link "/eggref/4/record-variants" "record-variants"))) (section 3 "Reference" (p "COOPS provides classes, generic functions and methods, similar in style and use to the classic Lisp object systems like Flavors, Loops or CLOS. For general information about object-oriented programming in the context of Lisp, consult one of the various books and guides available to the subject.") (section 4 "Classes" (section 5 "define-class" (def (sig (syntax "(define-class CLASSNAME [(SUPERCLASS ...) [(SLOTSPEC ...) CLASSOPTION ...]])" (id define-class))) (p "Defines a COOPS class and assigns it to the variable " (tt "CLASSNAME") " (which should be a symbol).  " (tt "(SUPERCLASS ...)") " is a list of expressions evaluating to classes from which the newly defined class should inherit. If no superclasses are given or the superclass list is empty, then " (tt "<standard-object>") " is assumed to be the default superclass.") (p (tt "SLOTSPEC") " specifies a slot (commonly called an instance variable) and should be either a symbol naming the slot or a list of the form " (tt "(SLOTNAME SLOTOPTION1 OPTIONVALUE1 ...)") ".  The syntax " (tt "(SLOTNAME INITFORM)") " is also a valid " (tt "SLOTSPEC") " and is equivalent to " (tt "(SLOTNAME initform: INITFORM)") ".") (p "An instance always contains all the slots of all superclasses in addition to its own slots.") (p "Classes are first-class values and are actually instances themselves, of the class " (tt "<standard-class>") " (see below for more details).")) (section 6 "Slot options" (section 7 "reader:" (pre " [slot option] reader: NAME") (p "Defines a method on the generic procedure " (tt "NAME") " that takes an instance of the defined class as its sole argument and returns the value of the instance slot with the same name. This is equivalent to") (highlight scheme "(define-method (NAME (obj CLASSNAME)) (slot-value obj 'NAME))")) (section 7 "writer:" (pre " [slot option] writer: NAME") (p "Defines a method on the generic procedure " (tt "NAME") " that takes as arguments an instance of the defined class argument and a value and assigns the value to the instance slot with the same name. This is equivalent to") (highlight scheme "(define-method (NAME (obj CLASSNAME) val) (set! (slot-value obj 'NAME) val))")) (section 7 "accessor:" (pre " [slot option] accessor: NAME") (p "Similar to") (highlight scheme "(begin\n  (define-method (NAME (obj CLASSNAME)) (slot-value obj 'NAME))\n  (define-method ((setter NAME) (obj CLASSNAME) val) (set! (slot-value obj 'NAME) val)))") (p "So, we are defining a generic procedure method for accessing the slot, together with a " (i "setter") " that allows assigning new values to the slot with the syntax") (highlight scheme "(set! (NAME obj) val)")) (section 7 "initform:" (pre " [slot option] initform: EXPRESSION") (p "If an instance of the defined class is created and this slot has not been given an initialization argument, then " (tt "EXPRESSION") " will be evaluated and the result assigned to the slot."))) (section 6 "Class options" (section 7 "metaclass:" (pre " [class option] metaclass: CLASS") (p "The class of which the newly defined class should be an instance (classes are instances, too). The default meta-class is " (tt "<standard-class>") ". Use this option if you feel adventurous.")))) (section 5 "make-class" (def (sig (syntax "(make-class [CLASSNAME] (SUPERCLASS ...) [(SLOTNAME ...) [METACLASS]])" (id make-class))) (p "Defines a class. " (tt "define-class") " is syntactic sugar around this form and is usually preferred. " (tt "make-class") " allows the creation of " (i "anonymous") " (that is: unnamed) classes.") (p "Note that " (tt "make-class") " is syntax, not a procedure."))) (section 5 "class-name" (def (sig (procedure "(class-name CLASS)" (id class-name))) (p "Returns the name of " (tt "CLASS") ", if it has one, or " (tt "#f") " it not."))) (section 5 "subclass?" (def (sig (procedure "(subclass? CLASS1 CLASS2)" (id subclass?))) (p "Returns " (tt "#t") " if " (tt "CLASS1") " is equal to " (tt "CLASS2") " or if it is a subclass of " (tt "CLASS2") " or " (tt "#f") " otherwise.")))) (section 4 "Instance creation" (section 5 "make" (def (sig (procedure "(make CLASS SLOTNAME1 INITFORM1 ...)" (id make))) (p "Creates an instance of the " (tt "CLASS") " and initializes the slots given in the remaining arguments. The new instance is returned. Slots not given which have been declared to have an " (tt "initform:") " will be initialized by evaluating that form. All other slots will be uninitialized."))) (section 5 "class-of" (def (sig (procedure "(class-of X)" (id class-of))) (p "Returns the class of " (tt "X") " or " (tt "#t") " if " (tt "X") " is not a class instance."))) (section 5 "initialize-instance" (p "<generic>(initialize-instance OBJECT)</generic>") (p "A generic procedure that is automatically invoked after a call to " (tt "make") " and which initializes the remaining slots of " (tt "OBJECT") " to initforms given in the class definition."))) (section 4 "Generic procedures" (p "Generic procedures a like normal procedures but contain a hidden reference to a generic procedure object that holds additional information like method-tables, etc. You can define generic procedures excpicitly with the " (tt "define-generic") " and " (tt "make-generic-procedure") " syntactic forms or implicitly by using " (tt "define-method") ".") (p (tt "slot-value") " and " (tt "class-of") " can be used on generic procedures and will transparently access the generic procedure object")) (section 4 "generic-procedure?" (def (sig (procedure "(generic-procedure? X)" (id generic-procedure?))) (p "Returns " (tt "#t") " if " (tt "X") " is a generic procedure or " (tt "#f") " otherwise."))) (section 4 "define-generic" (def (sig (syntax "(define-generic (NAME ARGUMENT ...))" (id define-generic))) (p "Defines a generic procedure, a procedure specialized for one or more argument types. " (tt "ARGUMENT ...") " defines the number of specialized arguments this generic procedure shoud use to dispatch to the correct method. The generic procedure may receive additional arguments, but those will not be used to determine the method. This form is roughly equivalent to") (highlight scheme "(define NAME\n  (make-generic-procedure ARGUMENT ...))") (p "You can use the syntax") (highlight scheme "(define-generic ((setter NAME) ARGUMENT ...))") (p "to define a SRFI-17 setter on " (tt "NAME") " that is itself a generic procedure."))) (section 4 "define-method" (def (sig (syntax "(define-method (NAME [QUALIFIER] [(ARGUMENT1 CLASS1) ...] ...) BODY ...)" (id define-method))) (p "Defines a method specialized for arguments of the classes " (tt "CLASS1 ...") " on the generic procedure " (tt "NAME") ". If " (tt "NAME") " holds a method for the same argument classes, the previously defined method is replaced.") (p "If no generic procedure has previously been defined for " (tt "NAME") ", then a generic procedure definition is done implicitly. Whether it can be assumed a definition exists is assumed to be the case when one of the following holds true:") (ul (li (tt "NAME") " is an imported value binding") (li "a generic procedure has been defined with " (tt "(define-generic NAME ...)") " in the same  compilation unit or the same interpreter session and is lexically visible")) (highlight scheme "(define-method ((setter NAME) ...) BODY ...)") (p "is allowed and supported.") (p (tt "QUALIFIER") " may be one of the keywords " (tt "primary:") ", " (tt "before:") ", " (tt "after:") " or " (tt "around:") " and mark the method as being either a primary (default) method, a method that is called before or after the primary method or a method that is \"wrapped\" around more specific methods. " (tt "before:") " methods are invoked from most specific to least specific. " (tt "after:") " methods are invoked from least specific to most specific. " (tt "around:") " methods can chose to invoke the next most specific method with the same arguments by calling " (tt "(call-next-method)") " with no arguments.") (p "All arguments of the form " (tt "(ARGUMENT CLASS)") " are specialized up to the first occurrence of a plain symbol or until a \"rest\"-argument or extended lambda-list marker (" (tt "#!rest") ", " (tt "#!optional") " or " (tt "#!key") ") is encountered."))) (section 4 "make-generic-procedure" (def (sig (syntax "(make-generic-procedure ARGUMENT ...)" (id make-generic-procedure))) (p "Creates a generic procedure, a procedure decorated with a hidden generic procedure object of class " (tt "<generic-procedure>") ". " (tt "ARGUMENT ...") " is the list of specialized arguments this procedure should receive. Methods for this generic procedure may accept more required or optional arguments, but the number of specialized arguments must be the same.") (p "Note that " (tt "make-generic-procedure") " is syntax, not a procedure."))) (section 4 "Slot access" (section 5 "slot-value" (def (sig (procedure "(slot-value OBJECT SLOTNAME)" (id slot-value))) (p "Returns the slot named " (tt "SLOTNAME") " of the class instance " (tt "OBJECT") ", signalling an error if no such slot exists.") (highlight scheme "(set! (slot-value OBJECT SLOTNAME) VAL)") (p "can be used to assign a value to a slot."))) (section 5 "slot-initialized?" (def (sig (procedure "(slot-initialized? OBJECT SLOTNAME)" (id slot-initialized?))) (p "Returns " (tt "#t") " if " (tt "OBJECT") " has a slot named " (tt "SLOTNAME") " or " (tt "#f") " ortherwise.")))) (section 4 "Predefined classes" (section 5 "<standard-object>" (pre " [class] <standard-object>") (p "The base class of classes defined with " (tt "define-class") ".")) (section 5 "<standard-class>" (pre " [class] <standard-class>") (p "The class of classes (classes are class instances themselves). This implies that " (tt "<standard-class>") " is an instance of itself.")) (section 5 "<generic-procedure>" (pre " [class] <generic-procedure>") (p "A subclass of " (tt "<procedure>") " that is the class of generic procedure objects.")) (section 5 "#t" (p "The superclass of all other classes."))) (section 4 "Predefined generic procedures" (section 5 "print-object" (def (sig (procedure "(print-object OBJECT PORT)" (id print-object))) (p "A generic procedure that is invoked when " (tt "OBJECT") " is printed.")))) (section 4 "Primitive classes" (p (i "Primitive") " classes are classes representing primitive data objects like numbers, strings and record structures. To be able to define generic procedures specialized on these types, primitive classes can be defined and associated with a predicate that returns a true value for objects that should be considered of the type represented by the class.") (section 5 "define-primitive-class" (def (sig (syntax "(define-primitive-class NAME [(SUPERCLASS ...)] PREDICATE)" (id define-primitive-class))) (p "Defines a primitive class of with the name " (tt "NAME") " and the given list of superclasses. If no superclasses are specified, then the superclass list defaults to " (tt "(%lt;primitive-object>)") ". " (tt "PREDICATE") " should be a procedure of one argument determining whether the argument is a member of the newly defined primitive class.") (p "The predicate should be referentially transparent."))) (section 5 "Predefined primitive classes" (p "The extension " (tt "coops-primitive-objects") " defines additional classes that allow defining generic procedures on objects used in the CHICKEN core libraries") (pre " [class] <primitive-object>") (p "This is the base class of all primitive object classes.") (p "Other classes deriving from " (tt "<primitive-object>") ":") (table (tr (th "Class") (th "Object type") (th "Superclasses")) "\n" (tr (td (tt "<immediate>")) (td "Any immediate object") (td (tt "<primitive-object>"))) "\n" (tr (td (tt "<boolean>")) (td (tt "#t") " or " (tt "#f")) (td (tt "<immediate>"))) "\n" (tr (td (tt "<eof-object>")) (td "end of file") (td (tt "<immediate>"))) "\n" (tr (td (tt "<char>")) (td "Characters") (td (tt "<immediate>"))) "\n" (tr (td (tt "<record>")) (td "Record instances") (td (tt "<primitive-object>"))) "\n" (tr (td (tt "<sequence>")) (td) (td (tt "<primitive-object>"))) "\n" (tr (td (tt "<list>")) (td) (td (tt "<sequence>"))) "\n" (tr (td (tt "<null>")) (td "The empty list") (td (tt "<immediate> <list>"))) "\n" (tr (td (tt "<pair>")) (td) (td (tt "<list>"))) "\n" (tr (td (tt "<vector>")) (td "Vectors") (td (tt "<sequence>"))) "\n" (tr (td (tt "<number-vector>")) (td "SRFI-4 vectors") (td (tt "<sequence> <record>"))) "\n" (tr (td (tt "<u8vector>")) (td) (td (tt "<number-vector>"))) "\n" (tr (td (tt "<s8vector>")) (td) (td (tt "<number-vector>"))) "\n" (tr (td (tt "<u16vector>")) (td) (td (tt "<number-vector>"))) "\n" (tr (td (tt "<s16vector>")) (td) (td (tt "<number-vector>"))) "\n" (tr (td (tt "<u32vector>")) (td) (td (tt "<number-vector>"))) "\n" (tr (td (tt "<s32vector>")) (td) (td (tt "<number-vector>"))) "\n" (tr (td (tt "<f32vector>")) (td) (td (tt "<number-vector>"))) "\n" (tr (td (tt "<f64vector>")) (td) (td (tt "<number-vector>"))) "\n" (tr (td (tt "<string>")) (td) (td (tt "<sequence>"))) "\n" (tr (td (tt "<char-set>")) (td "SRFI-13 char sets") (td (tt "<sequence> <record>"))) "\n" (tr (td (tt "<symbol>")) (td) (td (tt "<primitive-object>"))) "\n" (tr (td (tt "<keyword>")) (td "Keyword symbols") (td (tt "<symbol>"))) "\n" (tr (td (tt "<number>")) (td) (td (tt "<primitive-object>"))) "\n" (tr (td (tt "<integer>")) (td) (td (tt "<number>"))) "\n" (tr (td (tt "<exact-number>")) (td) (td (tt "<integer>"))) "\n" (tr (td (tt "<inexact-number>")) (td) (td (tt "<number>"))) "\n" (tr (td (tt "<fixnum>")) (td) (td (tt "<exact-number> <immediate>"))) "\n" (tr (td (tt "<flonum>")) (td) (td (tt "<inexact-number>"))) "\n" (tr (td (tt "<thread>")) (td "SRFI-18 thread") (td (tt "<record>"))) "\n" (tr (td (tt "<mutex>")) (td "SRFI-18 mutex") (td (tt "<record>"))) "\n" (tr (td (tt "<condition-variable>")) (td "SRFI-18 condition variables") (td (tt "<record>"))) "\n" (tr (td (tt "<condition>")) (td "Condition objects") (td (tt "<record>"))) "\n" (tr (td (tt "<tcp-listener>")) (td) (td (tt "<record>"))) "\n" (tr (td (tt "<continuation>")) (td) (td (tt "<record>"))) "\n" (tr (td (tt "<regexp>")) (td "Regular expression") (td (tt "<record>"))) "\n" (tr (td (tt "<pointer>")) (td "Machine pointer") (td (tt "<primitive-object>"))) "\n" (tr (td (tt "<locative>")) (td) (td (tt "<record>"))) "\n" (tr (td (tt "<promise>")) (td "created with " (tt "delay")) (td (tt "<record>"))) "\n" (tr (td (tt "<queue>")) (td) (td (tt "<sequence> <record>"))) "\n" (tr (td (tt "<hash-table>")) (td) (td (tt "<sequence> <record>"))) "\n" (tr (td (tt "<blob>")) (td) (td (tt "<primitive-object>"))) "\n" (tr (td (tt "<port>")) (td) (td (tt "<record>"))) "\n" (tr (td (tt "<stream-port>")) (td "file port") (td (tt "<port>"))) "\n" (tr (td (tt "<custom-port>")) (td) (td (tt "<port>"))) "\n" (tr (td (tt "<string-port>")) (td) (td (tt "<port>"))) "\n" (tr (td (tt "<tcp-port>")) (td) (td (tt "<port>"))) "\n" (tr (td (tt "<procedure>")) (td) (td (tt "<primitive-object>"))))))) (section 3 "Bugs and limitations" (ul (li (tt "define-generic") ", " (tt "define-method") " and " (tt "make-generic-procedure") " to currently not check for argument-list congruence, so it is important to make sure that the number of specialized arguments is always correct for the given generic procedure."))) (section 3 "Examples" (p "A simple class:") (highlight scheme "(define-class <stack> ()\n  ((content '())))              ; or \"(content initform: '())\"\n\n(define-method (push (val #t) (stack <stack>))\n  (set! (slot-value stack 'content) (cons val (slot-value stack 'content))))\n\n(define-method (pop (stack <stack>))\n  (let* ((c (slot-value stack 'content))\n         (x (car c)))\n    (set! (slot-value stack 'content) (cdr c))\n    x))\n\n(define-method (empty? (stack <stack>))\n  (null? (slot-value stack 'content)))") (p "A subclass of " (tt "<stack>") ", with logging:") (highlight scheme "(define-class <stack-with-logging> (<stack>)\n  ((logfile initform: (current-output-port) accessor: stack-logfile)))\n\n(define-method (push before: (val #t) (stack <stack-with-logging>))\n  (with-output-to-port (stack-logfile stack)  ; uses accessor method\n    (lambda () (print \"stack: pushing \" val))))\n\n(define-method (pop before: (stack <stack-with-logging>))\n  (with-output-to-port (stack-logfile stack)\n    (lambda ()\n      (print \"stack: popping \" (car (slot-value stack 'content))))))\n\n(define-method ((setter stack-logfile) before: (stack <stack-with-logging>) file)\n  (print \"stack: setting logfile to \" file))")) (section 3 "Author" (p "COOPS is based on " (link "http://www.ccs.neu.edu/home/dorai/scmobj/scmobj.html" "ScmObj") " by Dorai Sitaram and was ported to CHICKEN and heavily extended by " (int-link "felix winkelmann"))) (section 3 "License" (pre "Copyright (c) 1996, Dorai Sitaram\nAll rights reserved.") (pre "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following\nconditions are met:") (pre "  Redistributions of source code must retain the above copyright notice, this list of conditions and the following\n    disclaimer. \n  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following\n    disclaimer in the documentation and/or other materials provided with the distribution. \n  Neither the name of the author nor the names of its contributors may be used to endorse or promote\n    products derived from this software without specific prior written permission. ") (pre "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\nOR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\nOTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.")) (section 3 "Version History" (dl (dt "1.1") (dd "made " (tt "<pair>") " and " (tt "<null>") " subclasses of " (tt "<list>")) (dt "1.0") (dd "proper initform-handling for all classes") (dt "0.9") (dd "metaclass-related bugfixes (thanks to Peter Lane)") (dt "0.8") (dd "fixed bug related to initforms and inheritance") (dt "0.7") (dd "added type-check in internal slot-lookup procedure (thanks to Kon Lovett)") (dt "0.6") (dd "removed declaration which is broken on older CHICKENs (4.5.1)") (dt "0.5") (dd "added type-check in " (tt "make") " (thanks to Peter Lane)") (dt "0.4") (dd "added " (tt "<integer>") " class to " (tt "coops-primitive-objects")) (dt "0.3") (dd "added license to .meta file") (dt "0.2") (dd "performance tweaks, fix for 4.5.2 dependency (thanks to Mario)") (dt "0.1") (dd "initial release")))))