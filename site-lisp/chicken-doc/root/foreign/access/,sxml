((tags "manual") (toc) (section 2 "Accessing external objects" (section 3 "foreign-code" (def (sig (syntax "(foreign-code STRING ...)" (id foreign-code))) (p "Executes the embedded C/C++ code " (tt "STRING ...") ", which should be a sequence of C statements, which are executed and return an unspecified result.") (highlight scheme "(foreign-code \"doSomeInitStuff();\")     =>  #<unspecified>") (p "Code wrapped inside " (tt "foreign-code") " may not invoke callbacks into Scheme."))) (section 3 "foreign-value" (def (sig (syntax "(foreign-value CODE TYPE)" (id foreign-value))) (p "Evaluates the embedded C/C++ expression " (tt "CODE") " (which may be a string or symbol), returning a value of type given in the foreign-type specifier " (tt "TYPE") ".") (highlight scheme "(print (foreign-value \"my_version_string\" c-string))"))) (section 3 "foreign-declare" (def (sig (syntax "(foreign-declare STRING ...)" (id foreign-declare))) (p "Include given strings verbatim into header of generated file."))) (section 3 "define-foreign-type" (def (sig (syntax "(define-foreign-type NAME TYPE [ARGCONVERT [RETCONVERT]])" (id define-foreign-type))) (p "Defines an alias for " (tt "TYPE") " with the name " (tt "NAME") " (a symbol). " (tt "TYPE") " may be a type-specifier or a string naming a C type. The namespace of foreign type specifiers is separate from the normal Scheme namespace.  The optional arguments " (tt "ARGCONVERT") " and " (tt "RETCONVERT") " should evaluate to procedures that map argument- and result-values to a value that can be transformed to " (tt "TYPE") ":") (highlight scheme "(define-foreign-type char-vector \n  nonnull-c-string\n  (compose list->string vector->list)\n  (compose list->vector string->list) )\n\n(define strlen\n  (foreign-lambda int \"strlen\" char-vector) )\n\n(strlen '#(#\\a #\\b #\\c))                      ==> 3\n\n(define memset\n  (foreign-lambda char-vector \"memset\" char-vector char int) )\n\n(memset '#(#_ #_ #_) #\\X 3)                ==> #(#\\X #\\X #\\X)") (p "Foreign type-definitions are only visible in the compilation-unit in which they are defined, so use " (tt "include") " to use the same definitions in multiple files."))) (section 3 "define-foreign-variable" (def (sig (syntax "(define-foreign-variable NAME TYPE [STRING])" (id define-foreign-variable))) (p "Defines a foreign variable of name " (tt "NAME") " (a symbol). " (tt "STRING") " should be the real name of a foreign variable or parameterless macro. If " (tt "STRING") " is not given, then the variable name " (tt "NAME") " will be converted to a string and used instead. All references and assignments (via " (tt "set!") ") are modified to correctly convert values between Scheme and C representation. This foreign variable can only be accessed in the current compilation unit, but the name can be lexically shadowed.  Note that " (tt "STRING") " can name an arbitrary C expression. If no assignments are performed, then " (tt "STRING") " doesn't even have to specify an lvalue. See that " (tt "define-foreign-variable") " will not generate C declarations or memory allocation code; use it to include references to variables in external C code. To actually create Scheme variables visible from C, use " (tt "define-external") " (see the Manual section on " (link "http://wiki.call-cc.org/man/4/Callbacks" "Callbacks") "). For example, the following code:") (highlight scheme "(import foreign)\n(define-foreign-variable x double \"var_x\")\n(print x)") (p "will not work, because a reference to " (tt "var_x") " will be inserted in the C code, but no declaration will be included (this can be easily verified by translating the program into C with " (tt "csc -t program.scm") "). Changing the second line to " (tt "(define-external x double 0.5)") " will work (and the value 0.5 will be printed)."))) (section 3 "foreign-lambda" (def (sig (syntax "(foreign-lambda RETURNTYPE NAME ARGTYPE ...)" (id foreign-lambda))) (p "Represents a binding to an external routine. This form can be used in the position of an ordinary " (tt "lambda") " expression. " (tt "NAME") " specifies the name of the external procedure and should be a string or a symbol."))) (section 3 "foreign-lambda*" (def (sig (syntax "(foreign-lambda* RETURNTYPE ((ARGTYPE VARIABLE) ...) STRING ...)" (id foreign-lambda*))) (p "Similar to " (tt "foreign-lambda") ", but instead of generating code to call an external function, the body of the C procedure is directly given in " (tt "STRING ...") ":") (highlight scheme "(define my-strlen\n  (foreign-lambda* int ((c-string str))\n    \"int n = 0;\n     while(*(str++)) ++n;\n     C_return(n);\") )\n\n(my-strlen \"one two three\")             ==> 13") (p "For obscure technical reasons you should use the " (tt "C_return") " macro instead of the normal " (tt "return") " statement to return a result from the foreign lambda body as some cleanup code has to be run before execution commences in the calling code."))) (section 3 "foreign-safe-lambda" (def (sig (syntax "(foreign-safe-lambda RETURNTYPE NAME ARGTYPE ...)" (id foreign-safe-lambda))) (p "This is similar to " (tt "foreign-lambda") ", but also allows the called function to call Scheme functions and allocate Scheme data-objects. See " (int-link "Callbacks") "."))) (section 3 "foreign-safe-lambda*" (def (sig (syntax "(foreign-safe-lambda* RETURNTYPE ((ARGTYPE VARIABLE)...) STRING ...)" (id foreign-safe-lambda*))) (p "This is similar to " (tt "foreign-lambda*") ", but also allows the called function to call Scheme functions and allocate Scheme data-objects. See " (int-link "Callbacks") "."))) (section 3 "foreign-primitive" (def (sig (syntax "(foreign-primitive [RETURNTYPE] ((ARGTYPE VARIABLE) ...) STRING ...)" (id foreign-primitive))) (p "This is also similar to " (tt "foreign-lambda*") " but the code will be executed in a " (i "primitive") " CPS context, which means it will not actually return, but call its continuation on exit. This means that code inside this form may allocate Scheme data on the C stack (the " (i "nursery") ") with " (tt "C_alloc") " (see below). If the " (tt "RETURNTYPE") " is omitted it defaults to " (tt "void") ". You can return multiple values inside the body of the " (tt "foreign-primitive") " form by calling this C function:") (highlight scheme "C_values(N + 2, C_SCHEME_UNDEFINED, C_k, X1, ...)") (p "where " (tt "N") " is the number of values to be returned, and " (tt "X1, ...") " are the results, which should be Scheme data objects. When returning multiple values, the return-type should be omitted.")))) (section 2 "Returning large objects or chunks of memory to Scheme" (p "When you call a C function which needs to return quantities of data, several issues arise:") (ul (li "the size of the nursery is limited, so C_alloc can cause stack overflow") (li "if you malloc in C, and intend to leave it there, and directly access parts of that data from Scheme, you will need C accessor functions to pinpoint the parts you need and return them as Scheme objects; you will also need a finalizer if you intend for this data to be garbage-collected") (li "building up lists or other complex Scheme structures from individual pairs, or putting non-immediate objects into vectors, is cumbersome in C")) (p "So some would advise you to just return a pointer to Scheme, use memcpy or any other function(s) which you need to get the data into Chicken-managed memory and into the desired kind of data structure, then free the C data.  For this example, we are trying to return an array of doubles into an f64vector; we can accomplish that by adding a specialized copy function to the C library being integrated:") (highlight C "void CopyResults(double* vector) {\n    memcpy(vector, bezierBuffer, totalOutputPoints * sizeof(double));\n}\n\n// The original C function which takes an array of doubles, \n// does some sort of transmogrification,\n// retains a new malloc'd array of the results\n// and returns the count\nint GenerateResults(double* vector, int count) {\n    ... \n}") (p "and the \"egg\" which calls the C functions can be implemented like this:") (highlight scheme "(module memcpy-demo (input->output)\n    (import chicken scheme foreign)\n    (use srfi-4)\n\n    (define CopyResults (foreign-lambda void \"CopyResults\" f64vector))\n\n    (define GenerateResults (foreign-lambda integer \"GenerateResults\" f64vector integer))\n\n    (define (input->output input)\n        (let* ([size (GenerateResults input (f64vector-length input))] \n               [vect (make-f64vector size)])\n            (printf \"returned size ~a~%\" size)\n            (CopyResults vect)\n            vect)))\n") (p "The foreign-lambda takes care of the details in this case so that an f64vector allocated in the nursery can be treated as a plain old array of doubles in C (assuming your C compiler uses 64-bit values for double).") (p "Various eggs provide other examples, and some of them do it more efficiently too, but this method is relatively clean and compact.") (hr) (p "Previous: " (int-link "Interface to external functions and variables")) (p "Next: " (int-link "Foreign type specifiers"))))