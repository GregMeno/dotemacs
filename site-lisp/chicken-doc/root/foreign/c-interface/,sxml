((tags "manual") (toc) (section 2 "C interface" (p "The following functions and macros are available for C code that invokes Scheme or foreign procedures that are called by Scheme:") (section 3 "Temporary stack" (section 4 "C_save" (pre "[C macro] void C_save (C_word x) :") (p "Saves the Scheme data object " (tt "x") " on the temporary stack.")) (section 4 "C_restore" (pre "[C macro] C_word C_restore") (p "Pops and returns the topmost value from the temporary stack."))) (section 3 "Type/value predicates" (p "When writing C code that accepts Scheme objects you often need to do checking what type of object is passed.  These can help you determine the type of an object.") (section 4 "C predicates" (p "These return regular C integer values (ie, zero is false, nonzero true).") (section 5 "C_truep" (pre "[C macro] int C_truep(C_word x)") (p "Is " (tt "x") " a truthy value, i.e. anything except " (tt "C_SCHEME_FALSE") "?")) (section 5 "C_immediatep" (pre "[C macro] int C_immediatep(C_word x)") (p "Is " (tt "x") " an immediate object? (see " (int-link "#constructors-for-immediate-scheme-objects" "below") " for a definition)")) (section 5 "C_fitsinfixnump" (pre "[C macro] int C_fitsinfixnump(int number)") (p "Will " (tt "number") " fit in a fixnum?  It will fit when there is room for one additional type bit to tag it as a fixnum (assuming one bit is already used for the sign). In practice this means that the number's top two bits must be identical.")) (section 5 "C_ufitsinfixnump" (pre "[C macro] int C_ufitsinfixnump(unsigned int number)") (p "Like " (tt "C_fitsinfixnump") " but for unsigned integers.  This checks the top " (i "two") " bits are zero, since fixnums " (b "always") " carry a sign."))) (section 4 "Scheme predicates" (p "These return Scheme booleans (ie, C_SCHEME_TRUE or C_SCHEME_FALSE). This means they can be used directly from Scheme using " (tt "##core#inline") ".") (section 5 "C_zero_length_p" (pre "[C macro] C_word C_zero_length_p(C_word x)") (p "Is " (tt "x") " a Scheme object of zero length?  Only accepts non-immediate objects.")) (section 5 "C_unboundvaluep" (pre "[C macro] C_word C_unboundvaluep(C_word x)") (p "Is " (tt "x") " the special unbound variable placeholder " (tt "C_SCHEME_UNBOUND") "?")) (section 5 "C_boundp" (pre "[C macro] C_word C_boundp(C_word x)") (p "Is " (tt "x") " a bound value?  Only accepts non-immediate objects.")) (section 5 "C_blockp" (pre "[C macro] C_word C_blockp(C_word x)") (p "Is " (tt "x") " a \"block\" value?") (p "A \"block\" value is a value that contains a memory block, i.e. is not an immediate value.")) (section 5 "C_immp" (pre "[C macro] C_word C_immp(C_word x)") (p "Is " (tt "x") " an immediate value?")) (section 5 "C_forwardedp" (pre "[C macro] C_word C_forwardedp(C_word x)") (p "Is " (tt "x") " a GC-forwarded object?")) (section 5 "C_flonump" (pre "[C macro] C_word C_flonump(C_word x)") (p "Is " (tt "x") " a Scheme flonum object?  Accepts only non-immediate objects.")) (section 5 "C_stringp" (pre "[C macro] C_word C_stringp(C_word x)") (p "Is " (tt "x") " a Scheme string object?  Accepts only non-immediate objects.")) (section 5 "C_symbolp" (pre "[C macro] C_word C_symbolp(C_word x)") (p "Is " (tt "x") " a symbol?  Accepts only non-immediate objects.")) (section 5 "C_pairp" (pre "[C macro] C_word C_pairp(C_word x)") (p "Is " (tt "x") " a pair?  Accepts only non-immediate objects.")) (section 5 "C_closurep" (pre "[C macro] C_word C_closurep(C_word x)") (p "Is " (tt "x") " a closure?  Accepts only non-immediate objects.")) (section 5 "C_vectorp" (pre "[C macro] C_word C_vectorp(C_word x)") (p "Is " (tt "x") " any kind of vector?  Accepts only non-immediate objects.") (p "This returns true for both regular heterogenous R5RS vectors and bytevectors (\"blobs\").  However, it does " (i "not") " return true for SRFI-4 vectors, as those are actually bytevectors wrapped in a structure with a type tag.")) (section 5 "C_bytevectorp" (pre "[C macro] C_word C_bytevectorp(C_word x)") (p "Is " (tt "x") " a bytevector (\"blob\")? Accepts only non-immediate objects.")) (section 5 "C_portp" (pre "[C macro] C_word C_portp(C_word x)") (p "Is " (tt "x") " a port object?  Accepts only non-immediate objects.")) (section 5 "C_structurep" (pre "[C macro] C_word C_structure(C_word x)") (p "Is " (tt "x") " a structure (record) object?  Accepts only non-immediate objects.")) (section 5 "C_locativep" (pre "[C macro] C_word C_locativep(C_word x)") (p "Is " (tt "x") " a locative object?  Accepts only non-immediate objects.")) (section 5 "C_charp" (pre "[C macro] C_word C_charp(C_word x)") (p "Is " (tt "x") " a character object?")) (section 5 "C_booleanp" (pre "[C macro] C_word C_booleanp(C_word x)") (p "Is " (tt "x") " a boolean object?")) (section 5 "C_eofp" (pre "[C macro] C_word C_eofp(C_word x)") (p "Is " (tt "x") " the " (tt "#!eof") " object?")) (section 5 "C_undefinedp" (pre "[C macro] C_word C_undefinedp(C_word x)") (p "Is " (tt "x") " the undefined value?")) (section 5 "C_fixnump" (pre "[C macro] C_word C_fixnump(C_word x)") (p "Is " (tt "x") " a fixnum object?")) (section 5 "C_nfixnump" (pre "[C macro] C_word C_nfixnump(C_word x)") (p "Is " (tt "x") " " (i "not") " a fixnum object?")) (section 5 "C_i_numberp" (pre "[C function] C_word C_i_numberp(C_word x)") (p "Is " (tt "x") " a number object (fixnum or flonum)?")) (section 5 "C_pointerp" (pre "[C macro] C_word C_pointerp(C_word x)") (p "Is " (tt "x") " a C pointer object?  Only accepts non-immediate objects.")) (section 5 "C_taggedpointerp" (pre "[C macro] C_word C_taggedpointerp(C_word x)") (p "Is " (tt "x") " a tagged pointer object?  Only accepts non-immediate objects.")) (section 5 "C_swigpointerp" (pre "[C macro] C_word C_swigpointerp(C_word x)") (p "Is " (tt "x") " a SWIG pointer object?  Only accepts non-immediate objects.")) (section 5 "C_anypointerp" (pre "[C macro] C_word C_anypointerp(C_word x)") (p "Is " (tt "x") " any type of pointer object?  Only accepts non-immediate objects.")) (section 5 "C_lambdainfop" (pre "[C macro] C_word C_lambdainfop(C_word x)") (p "Is " (tt "x") " a lambda-info object?  Only accepts non-immediate objects.")) (section 5 "C_byteblockp" (pre "[C macro] C_word C_byteblockp(C_word x)") (p "Is " (tt "x") " a \"byteblock\" object?  Only accepts non-immediate objects.") (p "Strings, flonums, bytevectors and lambda-info objects are considered \"byteblock\" objects, as they are not containers for Scheme objects but simply point to contiguous memory ranges of bytes.")) (section 5 "C_specialp" (pre "[C macro] C_word C_specialp(C_word x)") (p "Is " (tt "x") " a \"special\" object?  Only accepts non-immediate objects.") (p "Closures, ports, pointers and locatives are considered \"special\" objects, as they are not containers for Scheme objects (and they are not byte blocks either), so they have to be treated specially by the GC.")) (section 5 "C_nullp" (pre "[C macro] C_word C_nullp(C_word x)") (p "Is " (tt "x") " the empty list, i.e. is it " (tt "C_SCHEME_END_OF_LIST") "?")) (section 5 "C_anyp" (pre "[C macro] C_word C_anyp(C_word x)") (p "Always returns " (tt "C_SCHEME_TRUE") ".")))) (section 3 "Constructors" (section 4 "Constructors for immediate Scheme objects" (p "\"immediate\" Scheme objects are objects that are represented directly by a " (tt "C_word") ".  There's no additional memory used by them.") (section 5 "C_fix" (pre "[C macro] C_word C_fix (int integer)")) (section 5 "C_make_character" (pre "[C macro] C_word C_make_character (int char_code)")) (section 5 "C_mk_bool" (pre "[C macro] C_word C_mk_bool(int truth_value)")) (section 5 "C_mk_nbool" (pre "[C macro] C_word C_mk_nbool(int truth_value_to_negate)")) (section 5 "C_SCHEME_END_OF_LIST" (pre "[C macro] C_SCHEME_END_OF_LIST")) (section 5 "C_SCHEME_END_OF_FILE" (pre "[C macro] C_SCHEME_END_OF_FILE")) (section 5 "C_SCHEME_FALSE" (pre "[C macro] C_SCHEME_FALSE")) (section 5 "C_SCHEME_TRUE" (pre "[C macro] C_SCHEME_TRUE"))) (section 4 "Constructors for non-immediate Scheme objects" (p "Non-immediate Scheme objects are still represented and passed around by a single " (tt "C_word") ", but this is basically just a pointer to the start of the object (which should never be treated as such, use the accessor macros instead).") (section 5 "C_string" (pre "[C function] C_word C_string (C_word **ptr, int length, char *string)")) (section 5 "C_string2" (pre "[C function] C_word C_string2 (C_word **ptr, char *zero_terminated_string)")) (section 5 "C_intern2" (pre "[C function] C_word C_intern2 (C_word **ptr, char *zero_terminated_string)")) (section 5 "C_intern3" (pre "[C function] C_word C_intern3 (C_word **ptr, char *zero_terminated_string, C_word initial_value)")) (section 5 "C_pair" (pre "[C function] C_word C_pair (C_word **ptr, C_word car, C_word cdr)")) (section 5 "C_flonum" (pre "[C function] C_word C_flonum (C_word **ptr, double number)")) (section 5 "C_int_to_num" (pre "[C function] C_word C_int_to_num (C_word **ptr, int integer)")) (section 5 "C_mpointer" (pre "[C function] C_word C_mpointer (C_word **ptr, void *pointer)")) (section 5 "C_vector" (pre "[C function] C_word C_vector (C_word **ptr, int length, ...)")) (section 5 "C_list" (pre "[C function] C_word C_list (C_word **ptr, int length, ...)")) (section 5 "C_closure" (pre "[C function] C_word C_closure (C_word **ptr, int length, C_word procedure, ...)") (p "These functions allocate memory from " (tt "ptr") " and initialize a fresh data object. The new data object is returned. " (tt "ptr") " should be the " (b "address") " of an allocation pointer created with " (tt "C_alloc") ".") (p "To find out how big the memory block should be, use the " (tt "C_SIZEOF_*") " macros described below.") (p "Here's an example how to create a closure that accepts a vector, stores the Scheme numbers 1, 2 and 3 and a given string in it and returns that vector to its continuation:") (highlight scheme "#>\n\n#include <assert.h>\n\nvoid fill_vector(C_word c, C_word closure, C_word vec)\n{\n  C_word kontinuation = C_block_item(closure, 1);\n\n  C_block_item(vec, 0) = C_fix(1);\n  C_block_item(vec, 1) = C_fix(2);\n  C_block_item(vec, 2) = C_fix(3);\n  C_block_item(vec, 3) = C_block_item(closure, 2);\n\n  C_kontinue(kontinuation, vec);\n}\n\nvoid one_two_three(C_word c, C_word self, C_word k, C_word str)\n{\n  /*\n   * Allocate room on the stack to hold the closure:  1 word for\n   * the type tag, 1 word for the procedure and 2 words for the\n   * values \"closed over\"; this procedure's continuation \"k\" and\n   * the argument \"str\".  We could also use C_alloc(4).\n   */\n  C_word closure[4], *cp = closure;\n\n  /* Create the closure.  It holds 3 values, not counting the tag */\n  C_word closure_object = C_closure(&cp, 3, (C_word)fill_vector, k, str);\n\n  /*\n   * After this, cp points just beyond the last word of the allocated\n   * data and closure_object is an opaque representation of the newly\n   * created closure as a whole, i.e. the following relations hold:\n   */\n  assert(  (closure + 4) == cp  );\n  assert(  C_block_header(closure_object) == (*closure)  );\n  assert(  C_data_pointer(closure_object) == (closure + 1)  );\n  assert(  C_block_item(closure_object, 0) == (*(closure + 1))  );\n\n  /* Make a vector of 4 objects and use closure_object as continuation */\n  C_allocate_vector(6, (C_word)NULL, closure_object, C_fix(4),\n                    C_SCHEME_FALSE,  /* not a byte vector */\n                    C_SCHEME_FALSE,  /* initialization value. Don't care */\n                    C_SCHEME_FALSE); /* don't align at 8 bytes */\n  /* .. C_allocate_vector does not return ... */\n}\n<#\n\n\n(define one-two-three\n   (foreign-primitive ((scheme-object str)) \"one_two_three(C_c, C_self, C_k, str);\"))\n\n(print (one-two-three \"hi\"))") (p "This is equivalent to the following in Scheme:") (highlight scheme "(define (one-two-three str)\n  (let ((fill-vector (lambda (vec)\n                       (vector-set! vec 0 1)\n                       (vector-set! vec 1 2)\n                       (vector-set! vec 2 3)\n                       (vector-set! vec 3 str)\n                       vec)))\n    (fill-vector (make-vector 4 #f))))\n\n(print (one-two-three \"hi\"))"))) (section 4 "Memory allocation" (p "These can be used to allocate memory for non-immediate objects.") (section 5 "C_alloc" (pre "[C macro] C_word* C_alloc (int words)") (p "Allocates memory from the C stack (" (tt "C_alloc") ") and returns a pointer to it. " (tt "words") " should be the number of words needed for all data objects that are to be created in this function.  Note that stack-allocated data objects have to be passed to Scheme callback functions, or they will not be seen by the garbage collector. This is really only usable for callback procedure invocations, make sure not to use it in normal code, because the allocated memory will be re-used after the foreign procedure returns. When invoking Scheme callback procedures a minor garbage collection is performed, so data allocated with " (tt "C_alloc") " will already have moved to a safe place.") (p "Note that " (tt "C_alloc") " is really just a wrapper around " (tt "alloca") ", and can also be simulated by declaring a stack-allocated array of " (tt "C_word") "s:")) (section 5 "C_SIZEOF_LIST" (pre "[C macro] int C_SIZEOF_LIST (int length)")) (section 5 "C_SIZEOF_STRING" (pre "[C macro] int C_SIZEOF_STRING (int length)")) (section 5 "C_SIZEOF_VECTOR" (pre "[C macro] int C_SIZEOF_VECTOR (int length)")) (section 5 "C_SIZEOF_INTERNED_SYMBOL" (pre "[C macro] int C_SIZEOF_INTERNED_SYMBOL (int length)")) (section 5 "C_SIZEOF_PAIR" (pre "[C macro] int C_SIZEOF_PAIR")) (section 5 "C_SIZEOF_FLONUM" (pre "[C macro] int C_SIZEOF_FLONUM")) (section 5 "C_SIZEOF_POINTER" (pre "[C macro] int C_SIZEOF_POINTER")) (section 5 "C_SIZEOF_LOCATIVE" (pre "[C macro] int C_SIZEOF_LOCATIVE")) (section 5 "C_SIZEOF_TAGGED_POINTER" (pre "[C macro] int C_SIZEOF_TAGGED_POINTER") (p "These are macros that return the size in words needed for a data object of a given type.")))) (section 3 "Accessors" (section 4 "C_character_code" (pre "[C macro] int C_character_code (C_word character)")) (section 4 "C_unfix" (pre "[C macro] int C_unfix (C_word fixnum)")) (section 4 "C_flonum_magnitude" (pre "[C macro] double C_flonum_magnitude (C_word flonum)")) (section 4 "C_c_string" (pre "[C function] char* C_c_string (C_word string)")) (section 4 "C_num_to_int" (pre "[C function] int C_num_to_int (C_word fixnum_or_flonum)")) (section 4 "C_pointer_address" (pre "[C function] void* C_pointer_address (C_word pointer)") (p "These macros and functions can be used to convert Scheme data objects back to C data. Note that " (tt "C_c_string()") " returns a pointer to the character buffer of the actual Scheme object and is not zero-terminated.")) (section 4 "C_header_size" (pre "[C macro] int C_header_size (C_word x)")) (section 4 "C_header_bits" (pre "[C macro] int C_header_bits (C_word x)") (p "Return the number of elements and the type-bits of the non-immediate Scheme data object " (tt "x") ".")) (section 4 "C_block_item" (pre "[C macro] C_word C_block_item (C_word x, int index)") (p "This macro can be used to access slots of the non-immediate Scheme data object " (tt "x") ".  " (tt "index") " specifies the index of the slot to be fetched, starting at 0. Pairs have 2 slots, one for the " (b "car") " and one for the " (b "cdr") ". Vectors have one slot for each element.")) (section 4 "C_u_i_car" (pre "[C macro] C_word C_u_i_car (C_word x)")) (section 4 "C_u_i_cdr" (pre "[C macro] C_word C_u_i_cdr (C_word x)") (p "Aliases for " (tt "C_block_item(x, 0)") " and " (tt "C_block_item(x, 1)") ", respectively.")) (section 4 "C_port_file" (pre "[C macro] C_word C_port_file (C_word x)") (p "Alias for " (tt "(FILE *)C_block_item(x, 0)") ".  To be used with port objects representing files (but will not work on sockets, for example).")) (section 4 "C_data_pointer" (pre "[C macro] void* C_data_pointer (C_word x)") (p "Returns a pointer to the data-section of a non-immediate Scheme object."))) (section 3 "C_make_header" (pre "[C macro] C_word C_make_header (C_word bits, C_word size)") (p "A macro to build a Scheme object header from its bits and size parts.")) (section 3 "C_mutate" (pre "[C function] C_word C_mutate (C_word *slot, C_word val)") (p "Assign the Scheme value " (tt "val") " to the location specified by " (tt "slot") ".  If the value points to data inside the nursery (the first heap-generation), then the garbage collector will remember to handle the data appropriately. Assigning nursery-pointers directly will otherwise result in lost data. Note that no copying takes place at the moment when " (tt "C_mutate") " is called, but later - at the next (minor) garbage collection.")) (section 3 "C_symbol_value" (pre "[C macro] C_word C_symbol_value (C_word symbol)") (p "Returns the global value of the variable with the name " (tt "symbol") ". If the variable is unbound " (tt "C_SCHEME_UNBOUND") " is returned. You can set a variable's value with " (tt "C_mutate(&C_symbol_value(SYMBOL), VALUE)") ".")) (section 3 "GC interface" (section 4 "C_gc_protect" (pre "[C function] void C_gc_protect (C_word *ptrs[], int n)") (p "Registers " (tt "n") " variables at address " (tt "ptrs") " to be garbage collection roots. The locations should not contain pointers to data allocated in the nursery, only immediate values or pointers to heap-data are valid. Any assignment of potential nursery data into a root-array should be done via " (tt "C_mutate()") ". The variables have to be initialized to sensible values before the next garbage collection starts (when in doubt, set all locations in " (tt "ptrs") " to " (tt "C_SCHEME_UNDEFINED") ") " (tt "C_gc_protect") " may not called before the runtime system has been initialized (either by " (tt "CHICKEN_initialize") ", " (tt "CHICKEN_run") " or " (tt "CHICKEN_invoke") ".") (p "For a slightly simpler interface to creating and using GC roots see " (tt "CHICKEN_new_gc_root") ".")) (section 4 "C_gc_unprotect" (pre "[C function] void C_gc_unprotect (int n)") (p "Removes the last " (tt "n") " registered variables from the set of root variables.")) (section 4 "C_pre_gc_hook" (pre "[C Variable] void (*C_pre_gc_hook)(int mode)") (p "If not " (tt "NULL") ", the function pointed to by this variable will be called before each garbage collection with a flag indicating what kind of collection was performed (either " (tt "0") " for a minor or major collection or " (tt "2") " for a resizing collection). A \"resizing\" collection means a secondary collection that moves all live data into a enlarged (or shrinked) heap-space. Minor collections happen very frequently, so the hook function should not consume too much time. The hook function may not invoke Scheme callbacks.") (p "Note that resizing collections may be nested in normal major collections.")) (section 4 "C_post_gc_hook" (pre "[C Variable] void (*C_post_gc_hook)(int mode, long ms)") (p "If not " (tt "NULL") ", the function pointed to by this variable will be called after each garbage collection with a flag indicating what kind of collection was performed (either " (tt "0") " for a minor collection, " (tt "1") " for a major collection or " (tt "2") " for a resizing collection). Minor collections happen very frequently, so the hook function should not consume too much time. The hook function may not invoke Scheme callbacks. The " (tt "ms") " argument records the number of milliseconds required for the garbage collection, if the collection was a major one. For minor collections the value of the " (tt "ms") " argument is undefined."))) (section 3 "Type-specific macros and functions" (p "The following are macros and functions to ask information or perform operations on objects once their types are already known.  If you call it on any object of another type, it is not defined what will happen and likely your program will crash, especially if you pass immediates to procedures expecting non-immediates.") (section 4 "Vectors" (section 5 "C_vemptyp" (pre "[C macro] C_word C_vemptyp(C_word v)") (p "Is the (byte- or heterogenous) vector " (tt "v") " empty?")) (section 5 "C_notvemptyp" (pre "[C macro] C_word C_notvemptyp(C_word v)") (p "Is the (byte- or heterogenous) vector " (tt "v") " nonempty?"))) (section 4 "Numbers" (p "These procedures accept any type of number, so you can pass in either a fixnum or a flonum.  You shouldn't pass in another type though, since that could crash your program.") (section 5 "C_u_i_exactp" (pre "[C macro] C_word C_u_i_exactp(C_word x)") (p "Is " (tt "x") " an exact number (i.e., a fixnum)?")) (section 5 "C_u_i_inexactp" (pre "[C macro] C_word C_u_i_inexactp(C_word x)") (p "Is " (tt "x") " an inexact number (i.e., not a fixnum)?")) (section 5 "C_i_finitep" (pre "[C function] C_word C_i_finitep(C_word x)") (p "Is " (tt "x") " a finite number?  This returns false only when " (tt "x") " is a flonum representing " (tt "-inf") " or " (tt "+inf") "."))) (section 4 "Fixnums" (p "Note: Fixnums are immediates, so there is no " (tt "C_fixnum_equalp") " macro.  You can just compare them without hassle (or use " (int-link "#c-eqp" "C_eqp") " if you prefer).") (section 5 "C_i_fixnumevenp" (pre "[C macro] C_word C_i_fixnumevenp(C_word x)") (p "Is " (tt "x") " an even fixnum?")) (section 5 "C_i_fixnumoddp" (pre "[C macro] C_word C_i_fixnumoddp(C_word x)") (p "Is " (tt "x") " an odd fixnum?")) (section 5 "C_fixnum_times" (pre "[C macro] C_word C_fixnum_times(C_word n1, C_word n2)") (p "Multiply fixnum n1 by fixnum n2.")) (section 5 "C_fixnum_plus" (pre "[C macro] C_word C_fixnum_plus(C_word n1, C_word n2)") (p "Add fixnum " (tt "n1") " to fixnum " (tt "n2") ".")) (section 5 "C_u_fixnum_plus" (pre "[C macro] C_word C_u_fixnum_plus(C_word n1, C_word n2)") (p "Like " (tt "C_fixnum_plus") ", but unsafe (assumes no overflow/underflow).")) (section 5 "C_fixnum_difference" (pre "[C macro] C_word C_fixnum_difference(C_word n1, C_word n2)") (p "Calculate " (tt "n1") " - " (tt "n2") ".")) (section 5 "C_u_fixnum_difference" (pre "[C macro] C_word C_u_fixnum_difference(C_word n1, C_word n2)") (p "Like " (tt "C_fixnum_difference") ", but unsafe (assumes no overflow/underflow).")) (section 5 "C_fixnum_divide" (pre "[C macro] C_word C_fixnum_divide(C_word n1, C_word n2)\n[C macro] C_word C_u_fixnum_divide(C_word n1, C_word n2)") (p "Divide " (tt "n1") " by " (tt "n2") ", returning the quotient (i.e., integer division). " (tt "C_fixnum_divide") " signals an error if " (tt "n2") " is zero.")) (section 5 "C_fixnum_modulo") (section 5 "C_u_fixnum_modulo" (pre "[C macro] C_word C_fixnum_modulo(C_word n1, C_word n2)\n[C macro] C_word C_u_fixnum_modulo(C_word n1, C_word n2)") (p "Calculate " (tt "n1") " modulo " (tt "n2") ". " (tt "C_fixnum_modulo") " signals an error if " (tt "n2") " is zero.")) (section 5 "C_fixnum_and" (pre "[C macro] C_word C_fixnum_and(C_word n1, C_word n2)") (p "Calculate the bitwise " (tt "AND") " of the integral values of " (tt "n1") " and " (tt "n2") ".")) (section 5 "C_u_fixnum_and" (pre "[C macro] C_word C_u_fixnum_and(C_word n1, C_word n2)") (p "Like " (tt "C_fixnum_and") ", but unsafe.")) (section 5 "C_fixnum_or" (pre "[C macro] C_word C_fixnum_or(C_word n1, C_word n2)") (p "Calculate the bitwise " (tt "OR") " of the integral values of " (tt "n1") " and " (tt "n2") ".")) (section 5 "C_u_fixnum_or" (pre "[C macro] C_word C_u_fixnum_or(C_word n1, C_word n2)") (p "Like " (tt "C_fixnum_or") ", but unsafe.")) (section 5 "C_fixnum_xor" (pre "[C macro] C_word C_fixnum_xor(C_word n1, C_word n2)") (p "Calculate the bitwise " (tt "XOR") " of the integral values of " (tt "n1") " and " (tt "n2") ".")) (section 5 "C_fixnum_not" (pre "[C macro] C_word C_fixnum_not(C_word n)") (p "Calculate the bitwise " (tt "NOT") " (inversion of bits) of the integral value of " (tt "n") ".")) (section 5 "C_fixnum_shift_left" (pre "[C macro] C_word C_fixnum_shift_left(C_word n1, C_word n2)") (p "Shift the integral value of " (tt "n1") " left by " (tt "n2") " positions.")) (section 5 "C_fixnum_shift_right" (pre "[C macro] C_word C_fixnum_shift_right(C_word n1, C_word n2)") (p "Shift the integral value of " (tt "n1") " right by " (tt "n2"))) (section 5 "C_fixnum_negate" (pre "[C macro] C_word C_fixnum_negate(C_word n)") (p "Negate " (tt "n") ", i.e. return " (tt "-n") ".")) (section 5 "C_fixnum_greaterp" (pre "[C macro] C_word C_fixnum_greaterp(C_word n1, C_word n2)") (p "Returns " (tt "C_SCHEME_TRUE") " when " (tt "n1") " is greater than " (tt "n2") ", " (tt "C_SCHEME_FALSE") " if not.")) (section 5 "C_fixnum_greater_or_equal_p" (pre "[C macro] C_word C_fixnum_greater_or_equalp(C_word n1, C_word n2)") (p "Returns " (tt "C_SCHEME_TRUE") " when " (tt "n1") " is greater than or equal to " (tt "n2") ", " (tt "C_SCHEME_FALSE") " if not.")) (section 5 "C_fixnum_lessp" (pre "[C macro] C_word C_fixnum_lessp(C_word n1, C_word n2)") (p "Returns " (tt "C_SCHEME_TRUE") " when " (tt "n1") " is less than " (tt "n2") ", " (tt "C_SCHEME_FALSE") " if not.")) (section 5 "C_fixnum_less_or_equal_p" (pre "[C macro] C_word C_fixnum_less_or_equalp(C_word n1, C_word n2)") (p "Returns " (tt "C_SCHEME_TRUE") " when " (tt "n1") " is less than or equal to " (tt "n2") ", " (tt "C_SCHEME_FALSE") " if not.")) (section 5 "C_fixnum_increase" (pre "[C macro] C_word C_fixnum_increase(C_word n)") (p "Adds 1 to " (tt "n"))) (section 5 "C_u_fixnum_increase" (pre "[C macro] C_word C_u_fixnum_increase(C_word n)") (p "As " (tt "C_fixnum_increase") ", but unsafe (assumes the result will not overflow).")) (section 5 "C_fixnum_decrease" (pre "[C macro] C_word C_fixnum_decrease(C_word n)") (p "Subtracts 1 from " (tt "n"))) (section 5 "C_u_fixnum_decrease" (pre "[C macro] C_word C_u_fixnum_decrease(C_word n)") (p "As " (tt "C_fixnum_increase") ", but unsafe (assumes the result will not underflow).")) (section 5 "C_fixnum_abs" (pre "[C macro] C_word C_fixnum_abs(C_word n)") (p "Returns the absolute value of " (tt "n") ".")) (section 5 "C_i_fixnum_min" (pre "[C function] C_word C_fixnum_min(C_word n1, C_word n2)") (p "Returns the smallest of the two fixnums " (tt "n1") " and " (tt "n2") ".")) (section 5 "C_i_fixnum_max" (pre "[C function] C_word C_fixnum_max(C_word n1, C_word n2)") (p "Returns the largest of the two fixnums " (tt "n1") " and " (tt "n2") "."))) (section 4 "Flonums" (section 5 "C_flonum_equalp" (pre "[C macro] C_word C_flonum_equalp(C_word n1, C_word n2)") (p "Returns " (tt "C_SCHEME_TRUE") " when " (tt "n1") " and " (tt "n2") " are equal flonums, " (tt "C_SCHEME_FALSE") " otherwise.")) (section 5 "C_flonum_greaterp" (pre "[C macro] C_word C_flonum_greaterp(C_word n1, C_word n2)") (p "Returns " (tt "C_SCHEME_TRUE") " when " (tt "n1") " is greater than " (tt "n2") ", " (tt "C_SCHEME_FALSE") " if not.")) (section 5 "C_flonum_greater_or_equal_p" (pre "[C macro] C_word C_flonum_greater_or_equal_p(C_word n1, C_word n2)") (p "Returns " (tt "C_SCHEME_TRUE") " when " (tt "n1") " is greater than or equal to " (tt "n2") ", " (tt "C_SCHEME_FALSE") " if not.")) (section 5 "C_flonum_lessp" (pre "[C macro] C_word C_flonum_lessp(C_word n1, C_word n2)") (p "Returns " (tt "C_SCHEME_TRUE") " when " (tt "n1") " is less than " (tt "n2") ", " (tt "C_SCHEME_FALSE") " if not.")) (section 5 "C_flonum_less_or_equal_p" (pre "[C macro] C_word C_flonum_less_or_equal_p(C_word n1, C_word n2)") (p "Returns " (tt "C_SCHEME_TRUE") " when " (tt "n1") " is less than or equal to " (tt "n2") ", " (tt "C_SCHEME_FALSE") " if not.")) (section 5 "C_a_i_flonum_plus" (pre "[C macro] C_word C_a_i_flonum_plus(C_word **ptr, int c, C_word n1, C_word n2)") (p "Adds the flonum " (tt "n1") " to the flonum " (tt "n2") ", using the storage at " (tt "ptr") ".  " (tt "c") " should always be 2.") (p "Example:") (highlight scheme "#include <chicken.h>\n#include <stdio.h>\n\nint main(void)\n{\n  C_word *mema, *memb, *memresult;\n  C_word a, b, result;\n\n  mema = C_alloc(C_SIZEOF_FLONUM);\n  memb = C_alloc(C_SIZEOF_FLONUM);\n  memresult = C_alloc(C_SIZEOF_FLONUM);\n  a = C_flonum(&mema, 1.2);\n  b = C_flonum(&memb, 4.7);\n  result = C_a_i_flonum_plus(&memresult, 2, a, b);\n  printf(\"%lf\\n\", C_flonum_magnitude(result));\n  return 0;\n}") (p "This will print " (tt "5.9"))) (section 5 "C_a_i_flonum_difference" (pre "[C macro] C_word C_a_i_flonum_difference(C_word **ptr, int c, C_word n1, C_word n2)") (p "Subtracts the flonum " (tt "n2") " from the flonum " (tt "n1") ", using the storage at " (tt "ptr") ".  " (tt "c") " should always be 2.")) (section 5 "C_a_i_flonum_times" (pre "[C macro] C_word C_a_i_flonum_times(C_word **ptr, int c, C_word n1, C_word n2)") (p "Multiplies the flonum " (tt "n1") " by the flonum " (tt "n2") ", using the storage at " (tt "ptr") ".  " (tt "c") " should always be 2.")) (section 5 "C_a_i_flonum_quotient" (pre "[C macro] C_word C_a_i_flonum_quotient(C_word **ptr, int c, C_word n1, C_word n2)") (p "Calculates the quotient of the flonum " (tt "n1") " divided by the flonum " (tt "n2") ", using the storage at " (tt "ptr") ".  " (tt "c") " should always be 2.")) (section 5 "C_a_i_flonum_negate" (pre "[C macro] C_word C_a_i_flonum_negate(C_word **ptr, int c, C_word n)") (p "Negates the flonum " (tt "n") ", using the storage at " (tt "ptr") ". " (tt "c") " should always be 1.")) (section 5 "C_a_i_flonum_truncate" (pre "[C macro] C_word C_a_i_flonum_truncate(C_word **ptr, int c, C_word n)") (p "Truncate the flonum " (tt "n") ", using the storage at " (tt "ptr") ". " (tt "c") " should always be 1.")) (section 5 "C_a_i_flonum_ceiling" (pre "[C macro] C_word C_a_i_flonum_ceiling(C_word **ptr, int c, C_word n)") (p "Round the flonum " (tt "n") ", rounding upwards, using the storage at " (tt "ptr") ". " (tt "c") " should always be 1.")) (section 5 "C_a_i_flonum_floor" (pre "[C macro] C_word C_a_i_flonum_floor(C_word **ptr, int c, C_word n)") (p "Round the flonum " (tt "n") ", rounding downwards, using the storage at " (tt "ptr") ". " (tt "c") " should always be 1.")) (section 5 "C_a_i_flonum_round" (pre "[C macro] C_word C_a_i_flonum_round(C_word **ptr, int c, C_word n)") (p "Round the flonum " (tt "n") ", rounding towards the nearest integer, using the storage at " (tt "ptr") ". " (tt "c") " should always be 1.") (p "This macro returns the value like returned by C's " (tt "round()") " function.  That means it rounds to the larger value (away from 0) when rounding numbers halfway between two integers.")) (section 5 "C_a_i_flonum_round_proper" (pre "[C macro] C_word C_a_i_flonum_round_proper(C_word **ptr, int c, C_word n)") (p "Round the flonum " (tt "n") ", rounding towards the nearest integer, using the storage at " (tt "ptr") ". " (tt "c") " should always be 1.") (p "This macro returns the value like returned by Scheme's " (tt "round") " procedure.  That means it rounds to even numbers when rounding numbers halfway between two integers.")) (section 5 "C_a_i_flonum_sin" (pre "[C macro] C_word C_a_i_flonum_sin(C_word **ptr, int c, C_word n)") (p "Calculates the sine of " (tt "n") " (in radians).")) (section 5 "C_a_i_flonum_cos" (pre "[C macro] C_word C_a_i_flonum_cos(C_word **ptr, int c, C_word n)") (p "Calculates the cosine of " (tt "n") " (in radians).")) (section 5 "C_a_i_flonum_tan" (pre "[C macro] C_word C_a_i_flonum_tan(C_word **ptr, int c, C_word n)") (p "Calculates the tangent of " (tt "n") " (in radians).")) (section 5 "C_a_i_flonum_asin" (pre "[C macro] C_word C_a_i_flonum_asin(C_word **ptr, int c, C_word n)") (p "Calculates the arc sine of " (tt "n") " (in radians, in the range -pi/2 through +pi/2).")) (section 5 "C_a_i_flonum_acos" (pre "[C macro] C_word C_a_i_flonum_acos(C_word **ptr, int c, C_word n)") (p "Calculates the arc cosine of " (tt "n") " (in radians, in the range 0 through pi).")) (section 5 "C_a_i_flonum_atan" (pre "[C macro] C_word C_a_i_flonum_atan(C_word **ptr, int c, C_word n)") (p "Calculates the arc tangent of " (tt "n") " (in radians, in the range -pi/2 through +pi/2).") (p "Like C's " (tt "atan()") " or Scheme's unary " (tt "atan") ".")) (section 5 "C_a_i_flonum_atan2" (pre "[C macro] C_word C_a_i_flonum_atan2(C_word **ptr, int c, C_word n1, C_word n2)") (p "Calculates the arc tangent of " (tt "n1/n2") " (in radians), using the sign of both to determine the quadrant of the result.") (p "Like C's " (tt "atan2()") " or Scheme's binary " (tt "atan") ".")) (section 5 "C_a_i_flonum_log" (pre "[C macro] C_word C_a_i_flonum_log(C_word **ptr, int c, C_word n)") (p "Calculate the natural (base " (tt "e") ") logarithm of " (tt "n") ".")) (section 5 "C_a_i_flonum_exp" (pre "[C macro] C_word C_a_i_flonum_exp(C_word **ptr, int c, C_word n)") (p "Calculates the base " (tt "e") " exponent of " (tt "n") " (i.e., the inverse operation of " (tt "C_a_i_flonum_log") ").")) (section 5 "C_a_i_flonum_expt" (pre "[C macro] C_word C_a_i_flonum_expt(C_word **ptr, int c, C_word n1, C_word n2)") (p "Calculates " (tt "n1") " raised to the power " (tt "n2") ".")) (section 5 "C_a_i_flonum_sqrt" (pre "[C macro] C_word C_a_i_flonum_sqrt(C_word **ptr, int c, C_word n)") (p "Calculates the square root of " (tt "n") ".")) (section 5 "C_a_i_flonum_abs" (pre "[C macro] C_word C_a_i_flonum_abs(C_word **ptr, int c, C_word n)") (p "Calculates the absolute value of " (tt "n") "."))) (section 4 "Pointers" (section 5 "C_null_pointerp" (pre "[C macro] C_word C_null_pointerp(C_word x)") (p "Is " (tt "x") " a NULL pointer?")) (section 5 "C_a_i_address_to_pointer" (pre "[C macro] C_word C_a_i_address_to_pointer(C_word **ptr, int c, C_word addr)") (p "Convert " (tt "addr") " to a pointer object using the storage at " (tt "ptr") ". " (tt "addr") " is can be either a flonum or a fixnum representing a memory address.")) (section 5 "C_a_i_pointer_to_address" (pre "[C macro] C_word C_a_i_pointer_to_address(C_word **ptr, int c, C_word pptr)") (p "Convert back the pointer " (tt "pptr") " to an address number, possibly using the storage at " (tt "ptr") ".  The number returned can be either a fixnum or a flonum, so you will have to pass a memory storage that can hold a flonum at " (tt "ptr") ".  Whether it is actually used depends on the size of the address."))) (section 4 "Ports" (section 5 "C_tty_portp" (pre "[C macro] C_word C_tty_portp(C_word x)") (p "Is " (tt "x") " a TTY port object?"))) (section 4 "Structures" (section 5 "C_i_structurep" (pre "[C macro] C_word C_i_structurep(C_word x, C_word s)") (p "Is " (tt "x") " a structure (record) object with type tag " (tt "s") "?  This is completely safe to use, because it checks whether x is an immediate or not."))) (section 4 "Characters" (p "These understand only ASCII characters.") (section 5 "C_u_i_char_alphabeticp" (pre "[C macro] C_word C_u_i_char_alphabeticp(C_word c)") (p "Is " (tt "c") " an alphabetic character?")) (section 5 "C_u_i_char_numericp" (pre "[C macro] C_word C_u_i_char_numericp(C_word c)") (p "Is " (tt "c") " a numeric character?")) (section 5 "C_u_i_char_whitespacep" (pre "[C macro] C_word C_u_i_char_whitespacep(C_word c)") (p "Is " (tt "c") " a whitespace character?")) (section 5 "C_u_i_char_upper_casep" (pre "[C macro] C_word C_u_i_char_upper_casep(C_word c)") (p "Is " (tt "c") " an uppercase character?")) (section 5 "C_u_i_char_lower_casep" (pre "[C macro] C_word C_u_i_char_lower_casep(C_word c)") (p "Is " (tt "c") " a lowercase character?")))) (section 3 "Other Scheme procedures from C" (p "There are a number of Scheme procedures that have a direct C implementation, so you can call them from C too.") (section 4 "C_eqp" (pre "[C macro] C_word C_eqp(C_word a, C_word b)") (p "The C version of " (tt "(eq? a b)") ".")) (section 4 "C_equalp" (pre "[C macro] C_word C_equalp(C_word a, C_word b)") (p "The C version of " (tt "(equal? a b)") ".")) (section 4 "C_i_pairp" (pre "[C function] C_word C_i_pair_p(C_word x)") (p "The C version of " (tt "(pair? x)") ".")) (section 4 "C_i_not_pair_p" (pre "[C macro] C_word C_i_not_pair_p(C_word x)") (p "The C version of " (tt "(not (pair? x))") "."))) (section 3 "An example for simple calls to foreign code involving callbacks" (pre "% cat foo.scm\n#>\nextern int callout(int, int, int);\n<#\n\n(define callout (foreign-safe-lambda int \"callout\" int int int))\n\n(define-external (callin (scheme-object xyz)) int\n  (print \"This is 'callin': \" xyz)\n  123)\n\n(print (callout 1 2 3))") (pre "% cat bar.c\n#include <stdio.h>\n#include \"chicken.h\"\n\nextern int callout(int, int, int);\nextern int callin(C_word x);\n\nint callout(int x, int y, int z)\n{\n  C_word *ptr = C_alloc(C_SIZEOF_LIST(3));\n  C_word lst;\n\n  printf(\"This is 'callout': %d, %d, %d\\n\", x, y, z);\n  lst = C_list(&ptr, 3, C_fix(x), C_fix(y), C_fix(z));\n  return callin(lst);  /* Note: `callin' will have GC'd the data in `ptr' */\n}") (pre "% csc foo.scm bar.c -o foo\n% foo\nThis is 'callout': 1, 2, 3\nThis is 'callin': (1 2 3)\n123")) (section 3 "Notes:" (ul (li "Scheme procedures can call C functions, and C functions can call Scheme procedures, but for every pending C stack frame, the available size of the first heap generation (the " (i "nursery") ") will be decreased, because the C stack is identical to the nursery. On systems with a small nursery this might result in thrashing, since the C code between the invocation of C from Scheme and the actual calling back to Scheme might build up several stack-frames or allocates large amounts of stack data. To prevent this it is advisable to increase the default nursery size, either when compiling the file (using the " (tt "-nursery") " option) or when running the executable (using the " (tt "-:s") " runtime option).") (li "Calls to Scheme/C may be nested arbitrarily, and Scheme continuations can be invoked as usual, but keep in mind that C stack frames will not be recovered, when a Scheme procedure call from C does not return normally.") (li "When multiple threads are running concurrently, and control switches from one thread to another, then the continuation of the current thread is captured and saved. Any pending C stack frame still active from a callback will remain on the stack until the threads is re-activated again. This means that in a multithreading situation, when C callbacks are involved, the available nursery space can be smaller than expected. So doing many nested Scheme->C->Scheme calls can reduce the available memory up to the point of thrashing. It is advisable to have only a single thread with pending C stack-frames at any given time.") (li "Pointers to Scheme data objects should not be stored in local or global variables while calling back to Scheme.  Any Scheme object not passed back to Scheme will be reclaimed or moved by the garbage collector.") (li "Calls from C to Scheme are never tail-recursive.") (li "Continuations captured via " (tt "call-with-current-continuation") " and passed to C code can be invoked like any other Scheme procedure.")) (hr) (p "Previous: " (int-link "Other support procedures")) (p "Next: " (int-link "Extensions")))))