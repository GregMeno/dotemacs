(index ("define-location" 0) ("let-location" 261) ("location" 393) ("location" 393))
(def (sig (syntax "(define-location NAME TYPE [INIT])" (id define-location))) (p "Identical to " (tt "(define-external NAME TYPE [INIT])") ", but the variable is not accessible from outside of the current compilation unit (it is declared " (tt "static") ")."))
(def (sig (syntax "(let-location ((NAME TYPE [INIT]) ...) BODY ...)" (id let-location))) (p "Defines a lexically bound location."))
(def (sig (syntax "(location NAME)" (id location)) (syntax "(location X)" (id location))) (p "This form returns a pointer object that contains the address of the variable " (tt "NAME") ". If the argument to " (tt "location") " is not a location defined by " (tt "define-location") ", " (tt "define-external") " or " (tt "let-location") ", then") (pre "(location X)") (p "is essentially equivalent to") (pre "(make-locative X)") (p "(See the " (int-link "Unit lolevel#locatives" "manual section on locatives") " for more information about locatives)") (p "Note that " (tt "(location X)") " may be abbreviated as " (tt "#$X") ".") (highlight scheme "(define-external foo int)\n((foreign-lambda* void (((c-pointer int) ip)) \"*ip = 123;\") \n  (location foo))\nfoo                                                                    ==> 123") (p "This facility is especially useful in situations, where a C function returns more than one result value:") (highlight scheme "#>\n#include <math.h>\n<#\n\n(define modf\n  (foreign-lambda double \"modf\" double (c-pointer double)) )\n\n(let-location ([i double])\n  (let ([f (modf 1.99 (location i))])\n    (print \"i=\" i \", f=\" f) ) )") (p "See " (link "http://wiki.call-cc.org/location-and-c-string-star" "location and c-string*") " for a tip on returning a " (tt "c-string*") " type.") (p (tt "location") " returns a value of type " (tt "c-pointer") ", when given the name of a callback-procedure defined with " (tt "define-external") "."))
