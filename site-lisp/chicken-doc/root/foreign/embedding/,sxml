((tags "manual") (toc) (section 2 "Embedding" (p "Compiled Scheme files can be linked with C code, provided the Scheme code was compiled in " (i "embedded") " mode by passing " (tt "-DC_EMBEDDED") " to the C compiler (this will disable generation of a " (tt "main()") " function). " (tt "csc") " will do this, when given the " (tt "-embedded") " option. Alternatively pass " (tt "-embedded") " to " (tt "csc") ".") (p "The following C API is available:") (section 3 "CHICKEN_parse_command_line" (pre "[C function] void CHICKEN_parse_command_line (int argc, char *argv[], int *heap, int *stack int *symbols)") (p "Parse the programs command-line contained in " (tt "argc") " and " (tt "argv") " and return the heap-, stack- and symbol table limits given by runtime options of the form " (tt "-:...") ", or choose default limits. The library procedure " (tt "argv") " can access the command-line only if this function has been called by the containing application.")) (section 3 "CHICKEN_initialize" (pre "[C function] int CHICKEN_initialize (int heap, int stack, int symbols, void *toplevel) ") (p "Initializes the Scheme execution context and memory. " (tt "heap") " holds the number of bytes that are to be allocated for the secondary heap. " (tt "stack") " holds the number of bytes for the primary heap. " (tt "symbols") " contains the size of the symbol table. Passing " (tt "0") " to one or more of these parameters will select a default size. " (tt "toplevel") " should be a pointer to the toplevel entry point procedure. You should pass " (tt "C_toplevel") " here. In any subsequent call to " (tt "CHICKEN_run") " you can simply pass " (tt "NULL") ". Calling this function more than once has no effect. If enough memory is available and initialization was successful, then " (tt "1") " is returned, otherwise this function returns " (tt "0") ".")) (section 3 "CHICKEN_run" (pre "[C function] C_word CHICKEN_run (void *toplevel)") (p "Starts the Scheme program. Call this function once to execute all toplevel expressions in your compiled Scheme program. If the runtime system was not initialized before, then " (tt "CHICKEN_initialize") " is called with default sizes. " (tt "toplevel") " is the toplevel entry-point procedure, you usually pass " (tt "C_toplevel") " here. The result value is the continuation that can be used to re-invoke the Scheme code from the point after it called " (tt "return-to-host") " (see below).") (p "If you just need a Scheme interpreter, you can also pass " (tt "CHICKEN_default_toplevel") " as the toplevel procedure, which just uses the default library units.") (p "Once " (tt "CHICKEN_run") " has been called, Scheme code is executing until all toplevel expressions have been evaluated or until " (tt "return-to-host") " is called inside the Scheme program.")) (section 3 "return-to-host" (def (sig (procedure "(return-to-host)" (id return-to-host))) (p "Exits the Scheme code and returns to the invoking context that called " (tt "CHICKEN_run") " or " (tt "CHICKEN_continue") ".") (p "After " (tt "return-to-host") " has been executed and once " (tt "CHICKEN_run") " returns, you can invoke callbacks which have been defined with " (tt "define-external") ". The " (tt "eval") " library unit also provides " (i "boilerplate") " callbacks, that simplify invoking Scheme code embedded in a C or C++ application a lot."))) (section 3 "CHICKEN_eval" (pre "[C macro] int CHICKEN_eval (C_word exp, C_word *result)") (p "Evaluates the Scheme object passed in " (tt "exp") ", writing the result value to " (tt "result") ". The return value is 1 if the operation succeeded, or 0 if an error occurred. Call " (tt "CHICKEN_get_error_message") " to obtain a description of the error.")) (section 3 "CHICKEN_eval_string" (pre "[C macro] int CHICKEN_eval_string (char *str, C_word *result)") (p "Evaluates the Scheme expression passed in the string " (tt "str") ", writing the result value to " (tt "result") ".")) (section 3 "CHICKEN_eval_to_string" (pre "[C macro] int CHICKEN_eval_to_string (C_word exp, char *result, int size)") (p "Evaluates the Scheme expression passed in " (tt "exp") ", writing a textual representation of the result into " (tt "result") ". " (tt "size") " should specify the maximal size of the result string.")) (section 3 "CHICKEN_eval_string_to_string" (pre "[C macro] int CHICKEN_eval_string_to_string (char *str, char *result, int size)") (p "Evaluates the Scheme expression passed in the string " (tt "str") ", writing a textual representation of the result into " (tt "result") ". " (tt "size") " should specify the maximal size of the result string.")) (section 3 "CHICKEN_apply" (pre "[C macro] int CHICKEN_apply (C_word func, C_word args, C_word *result)") (p "Applies the procedure passed in " (tt "func") " to the list of arguments " (tt "args") ", writing the result value to " (tt "result") ".")) (section 3 "CHICKEN_apply_to_string" (pre "[C macro] int CHICKEN_apply_to_string (C_word func, C_word args, char *result, int size)") (p "Applies the procedure passed in " (tt "func") " to the list of arguments " (tt "args") ", writing a textual representation of the result into " (tt "result") ".")) (section 3 "CHICKEN_read" (pre "[C macro] int CHICKEN_read (char *str, C_word *result)") (p "Reads a Scheme object from the string " (tt "str") ", writing the result value to " (tt "result") ".")) (section 3 "CHICKEN_load" (pre "[C macro] int CHICKEN_load (char *filename)") (p "Loads the Scheme file " (tt "filename") " (either in source form or compiled).")) (section 3 "CHICKEN_get_error_message" (pre "[C macro] void CHICKEN_get_error_message (char *result, int size)") (p "Returns a textual description of the most recent error that occurred in executing embedded Scheme code.")) (section 3 "CHICKEN_yield" (pre "[C macro] int CHICKEN_yield (int *status)") (p "If threads have been spawned during earlier invocations of embedded Scheme code, then this function will run the next scheduled thread for one complete time-slice. This is useful, for example, inside an " (i "idle") " handler in a GUI application with background Scheme threads. Note that the " (tt "srfi-18") " library unit has to be linked in for this.") (p "An example:") (pre "% cat x.scm\n;;; x.scm\n\n(define (bar x) (gc) (* x x))\n\n(define-external (baz (int i)) double\n  (sqrt i))\n(return-to-host)\n") (pre "% cat y.c\n/* y.c */\n\n#include <chicken.h>\n#include <assert.h>\n\nextern double baz(int);\n\nint main() {\n  char buffer[ 256 ];\n  int status;\n  C_word val = C_SCHEME_UNDEFINED;\n  C_word *data[ 1 ];\n\n  data[ 0 ] = &val;\n\n  CHICKEN_run(C_toplevel);\n\n  status = CHICKEN_read(\"(bar 99)\", &val);\n  assert(status);\n\n  C_gc_protect(data, 1);\n\n  printf(\"data: %08x\\n\", val);\n\n  status = CHICKEN_eval_string_to_string(\"(bar)\", buffer, 255);\n  assert(!status);\n\n  CHICKEN_get_error_message(buffer, 255);\n  printf(\"ouch: %s\\n\", buffer);\n\n  status = CHICKEN_eval_string_to_string(\"(bar 23)\", buffer, 255);\n  assert(status);\n\n  printf(\"-> %s\\n\", buffer);\n  printf(\"data: %08x\\n\", val);\n\n  status = CHICKEN_eval_to_string(val, buffer, 255);\n  assert(status);\n  printf(\"-> %s\\n\", buffer);\n\n  printf(\"->` %g\\n\", baz(22));\n\n  return 0;\n}\n\n% csc x.scm y.c -embedded") (p "It is also possible to re-enter the computation following the call to " (tt "return-to-host") " by calling " (tt "CHICKEN_continue") ":")) (section 3 "CHICKEN_continue" (pre "[C function] C_word CHICKEN_continue (C_word k)") (p "Re-enters Scheme execution. " (tt "k") " is the continuation received from the previous invocation of " (tt "CHICKEN_run") " or " (tt "CHICKEN_continue") ". When " (tt "return-to-host") " is called again, this function returns another continuation that can be used to restart again.") (p "If you invoke callbacks prior to calling " (tt "CHICKEN_continue") ", make sure that the continuation is not reclaimed by garbage collection. This can be avoided by using " (tt "C_gc_protect") " or gc-roots.") (p "Another example:") (pre "% cat x.scm\n(require-extension srfi-18)\n\n(define m (make-mutex))\n\n(define (t)\n  (mutex-lock! m)\n  (thread-sleep! 1)\n  (print (thread-name (current-thread)))\n  (mutex-unlock! m)\n  (t) )\n\n(thread-start! (make-thread t 'PING!))\n(thread-start! (make-thread t 'PONG!))\n\n(let loop ()\n  (return-to-host)\n  (thread-yield!)\n  (loop) )\n\n% cat y.c\n#include <chicken.h>\n\nint main()\n{\n  C_word k = CHICKEN_run(C_toplevel);\n\n  for(;;)\n    k = CHICKEN_continue(k);\n\n  return 0;\n}\n\n% csc x.scm y.c -embedded") (p "It is advisable not to mix repeated uses of " (tt "CHICKEN_continue") "/" (tt "return-to-host") " (as in the example above) with callbacks. Once " (tt "return-to-host") " is invoked, the runtime system and any Scheme code executed prior to the invocation is initialized and can be conveniently used via callbacks.") (p "A simpler interface For handling GC-safe references to Scheme data are the so called " (i "gc-roots") ":")) (section 3 "CHICKEN_new_gc_root" (pre "[C function] void* CHICKEN_new_gc_root ()") (p "Returns a pointer to a " (i "GC root") ", which is an object that holds a reference to a Scheme value that will always be valid, even after a garbage collection. The content of the gc root is initialized to an unspecified value.")) (section 3 "CHICKEN_new_finalizable_gc_root" (pre "[C function] void* CHICKEN_new_finalizable_gc_root ()") (p "Similar to " (tt "CHICKEN_new_gc_root") ", but allows the stored value to be finalized: if this gc root holds reference to an otherwise unreferenced data object that has a finalizer, the finalizer is still invoked.")) (section 3 "CHICKEN_delete_gc_root" (pre "[C function] void CHICKEN_delete_gc_root (void *root)") (p "Deletes the gc root.")) (section 3 "CHICKEN_gc_root_ref" (pre "[C macro] C_word CHICKEN_gc_root_ref (void *root)") (p "Returns the value stored in the gc root.")) (section 3 "CHICKEN_gc_root_set" (pre "[C macro] void CHICKEN_gc_root_set (void *root, C_word value)") (p "Sets the content of the GC root to a new value.") (p "Sometimes it is handy to access global variables from C code:")) (section 3 "CHICKEN_global_lookup" (pre "[C function] void* CHICKEN_global_lookup (char *name)") (p "Returns a GC root that holds the global variable with the name " (tt "name") ". If no such variable exists, " (tt "NULL") " is returned.")) (section 3 "CHICKEN_global_ref" (pre "[C function] C_word CHICKEN_global_ref (void *global)") (p "Returns the value of the global variable referenced by the GC root " (tt "global") ".")) (section 3 "CHICKEN_global_set" (pre "[C function] void CHICKEN_global_set (void *global, C_word value)") (p "Sets the value of the global variable referenced by the GC root " (tt "global") " to " (tt "value") ".") (hr) (p "Previous: " (int-link "Foreign type specifiers")) (p "Next: " (int-link "Callbacks")))))