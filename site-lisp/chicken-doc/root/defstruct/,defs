(index ("defstruct" 0))
(def (sig (syntax "(defstruct NAME SLOT ...)" (id defstruct))) (p "Defines a record type with the name " (tt "NAME") ". " (tt "SLOT") " may be a symbol or a list of the form " (tt "(NAME INIT)") " where " (tt "INIT") " is the default value of the slot (the " (tt "INIT") " expression will only be evaluated when no value is given in the constructor procedure).  The " (tt "defstruct") " macro expands into predicate and accessor functions (just like the native " (tt "define-record") "):") (highlight scheme "(require-extension defstruct)\n\n(defstruct point x y)\n\n;; Creates code equivalent to the following:\n(begin\n  (define (point? x) ...)          ; is x a point?\n  (define (point-x p) ...)         ; return x slot of point p\n  (define (point-x-set! p n) ...)  ; change x slot of point p to n\n  ...)") (p "Additionally, a constructor procedure " (tt "make-STRUCTNAME") " is defined, which accepts initialization values for all slots specified as keyword arguments:") (highlight scheme "(make-point x: 99 y: 42)\n => ; a point with x = 99 and y = 42") (p "On Chicken 4 and higher, there are also two procedures " (tt "update-STRUCTNAME") " and " (tt "set-STRUCTNAME!") " defined for functionally and destructively updating selected values in an existing record:") (highlight scheme "(define p2 (update-point p1 x: 100))\np2\n => ; a point with x = 100 and y = 42\n\n(= p1-x 99)\n => #t\n\n(set-point! p1 x: 100)\n(= p1-x 100)\n => #t") (p "Additionally, there are two conversion procedures for converting to and from alists, " (tt "STRUCTNAME->alist") " and " (tt "alist->STRUCTNAME") ":") (highlight scheme "(define p3 (alist->point '((x . 1) (y . 2))))\np3\n => ; a point with x = 1 and y = 2\n\n(define p4 (make-point x: 123 y: 456))\n(point->alist p4)\n => ((x . 123) (y . 456))"))
