((tags "eggs") (toc) (section 2 "miniML" (section 3 "Description" (p "The libraries in the " (tt "miniML") " egg provide a parser, type checker, and interpreter for the mini-ML language described by Xavier Leroy in the paper " (link "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.4138" "A Modular Module System") ".") (p "The procedures in " (tt "miniML") " and " (tt "miniMLeval") " are intended to be used with the API for type checking and evaluation defined in the " (int-link "static-modules") " library.")) (section 3 ((tt "miniML") " library") (section 4 "Predicates" (def (sig (procedure "constant?:: OBJECT -> BOOL" (id constant?))) (p "A predicate for constants recognized by the interpreter.  " (tt "OBJECT") " must be of the form " (tt "(TYPE VALUE)") ", where value is a Scheme value and type is of the following symbols:") (ul (li (tt "nat") " (natural numbers)") (li (tt "real") " (real numbers)") (li (tt "bool") " (booleans)") (li (tt "label") " (symbols)"))) (def (sig (procedure "term?" (id term?))) (p "A predicate for a mini-ML term. See the next section for a list of term constructors."))) (section 4 "Term constructors" (pre " ") (dl (dt (tt "Const constant")) (dd "constant") (dt (tt "Longid path")) (dd "identifier; see " (int-link "static-modules") " for a definition of the path type") (dt (tt "Function identifier term")) (dd "function; see " (int-link "static-modules") " for a definition of the identifier type") (dt (tt "Apply term term")) (dd "function application") (dt (tt "Let0 identifier value term")) (dd "Let-binding"))) (section 4 "Type constructors" (dl (dt (tt "Tvar tyvar") "   ") (dt (tt "Tcon path type ...") "  "))) (section 4 "Module system definitions" (p "Definitions for the " (int-link "static-modules") " API:") (ul (li (tt "core-syntax")) (li (tt "core-typing")) (li (tt "core-scoping")))) (section 4 "Language environment initialization" (def (sig (procedure "core-initialize:: enter-type enter-val -> VOID" (id core-initialize))) (p "Given procedures to add entries to a type environment, creates the constants of the mini-ML language.") (p "The following types and constants are currently included:") (dl (dt "Type " (tt "'a -> 'b") "  ") (dt "Type " (tt "'a * 'b")) (dt "Type " (tt "'a list")) (dt "Type " (tt "real")) (dt "Type " (tt "bool") " ") (dt "Type " (tt "label")) (dt "Type " (tt "bot")) (dt "Type " (tt "nat")) (dt "Constant " (tt "false : bool") " ") (dt "Constant " (tt "true  : bool")) (dt "Constant " (tt "empty : bot")) (dt "Constants " (tt "add sub mul div : nat -> nat -> nat ")) (dt "Constants " (tt "== <> < <= > >= : nat -> nat -> bool")) (dt "Constant " (tt "pair : 'a -> 'b -> 'a * 'b")) (dt "Constant " (tt "fst : 'a * 'b -> 'a")) (dt "Constant " (tt "snd : 'a * 'b -> 'b")) (dt "Constant " (tt "null : 'a list")) (dt "Constant " (tt "cons : 'a -> a' list -> 'a list")) (dt "Constant " (tt "head : a' list -> 'a")) (dt "Constant " (tt "tail : a' list -> 'a list")) (dt "Constant " (tt "cond : bool -> 'a -> 'a -> 'a")))))) (section 3 ((tt "miniMLsyntax") " library") (p "The " (tt "miniMLsyntax") " library contains mini-ML module syntax constructors defined with " (int-link "static-modules") ":") (dl (dt (tt "modtype? Signature Functorty")) (dt (tt "modspec? Value_sig Type_sig Module_sig")) (dt (tt "modterm? Modid Structure Functor Mapply Constraint")) (dt (tt "moddef? Value_def Type_def Module_def")))) (section 3 ((tt "miniMLparse") " library") (def (sig (procedure "parse:: PORT-OR-STRING -> MODDEF LIST " (id parse))) (p "Given a port or a string, the " (tt "parse") " procedure parses the given text, and returns a list of mini-ML module definitions."))) (section 3 ((tt "miniMLeval") " library") (p "The " (tt "miniMLeval") " library provides support for mini-ML evaluation.") (section 4 "Predicates" (def (sig (procedure "value?:: OBJECT -> BOOL" (id value?))) (p "Returns " (tt "#t") " if the given object is a mini-ML value, " (tt "#f") " otherwise. The following values are supported:"))) (section 4 "Value constructors" (dl (dt (tt "Const_v constant")) (dd "constants") (dt (tt "Closure_v term env")) (dd "closures") (dt (tt "Prim_v procedure")) (dd "invocations of primitive procedures") (dt (tt "Tuple_v slots")) (dd "tuples (represented as Scheme lists)"))) (section 4 "Evaluation" (def (sig (procedure "core-eval-cbv:: TERM * VALUE-ENV -> VALUE" (id core-eval-cbv))) (p "Given a mini-ML term and value environment, evaluates the term using a call-by-value strategy and returns the resulting value.")) (def (sig (procedure "eval-cbv-initialize:: ENTER-VAL -> VALUE-ENV" (id eval-cbv-initialize))) (p "Initializes a given evaluation environment with the primitives of the mini-ML language.")) (def (sig (procedure "mod-eval-cbv:: MODTERM -> VALUE-ENV" (id mod-eval-cbv))) (p "A module definition evaluator based on " (tt "core-eval-cbv") " and " (int-link "static-modules") ".")))) (section 3 "Example interpreter" (pre "(require-extension datatype static-modules miniML miniMLsyntax miniMLparse miniMLeval)\n(import (only data-structures compose)\n \t (only srfi-1 fold filter member delete-duplicates) \n (only extras pp fprintf))\n\n\n(define-values (env-binding? env-empty env-add-signature env-add-module env-add-type env-add-spec env-add-value\n\t        env-find-value env-find-type env-find-module env-find)\n  (make-mod-env core-syntax))\n\n(define-values (scope-typedecl scope-modtype scope-signature scope-modterm scope-moddef)\n  (make-mod-scoping core-syntax core-scoping))\n\n(define-values (check-modtype check-signature type-modterm type-moddef type-definition)\n  (make-mod-typing core-syntax core-typing))\n\n(define init-scope      (make-parameter st-empty))\n(define init-type-env   (make-parameter env-empty))\n(define init-eval-env   (make-parameter env-empty))\n\n(define (enter-typedecl id decl)\n  (init-scope (st-enter-type id (init-scope)))\n  (init-type-env   (env-add-type id decl (init-type-env))))\n\n(define (enter-valtype name ty)\n  (let ((id (ident-create name)))\n    (init-scope (st-enter-value id (init-scope)))\n    (init-type-env   (env-add-value id ty (init-type-env)))))\n\n(define (enter-val name val)\n  (let ((id (or (and (ident? name) name) (ident-create name))))\n    (init-eval-env (ident-add id val (init-eval-env)))))\n\n(core-initialize enter-typedecl enter-valtype)\n(eval-cbv-initialize enter-val)\n\n(define (enter-module id mty)\n  (init-scope (st-enter-module id (init-scope)))\n  (init-type-env (env-add-module id mty (init-type-env))))\n\n(define (interpreter operand)\n  (let ((defs (parse 'miniML (open-input-file operand))))\n    (let* ((scoped-defs      (scope-moddef (init-scope) defs))\n\t    (mty              (type-moddef (init-type-env) '() scoped-defs))\n    (type-env         (map (lambda (x) (cases modspec x\n\t\t\t\t\t      (Value_sig (id vty) (cons id x))\n \t\t\t\t\t      (Type_sig (id decl) (cons id x))\n\t\t\t\t\t      (Module_sig (id mty) (cons id x))\n\t\t\t\t\t      )) mty))\n    (eval-env         (mod-eval-cbv (init-eval-env) scoped-defs))\n    (unified-env      (list scoped-defs \n\t \t\t\t   (filter (lambda (x) (not (assoc (car x) (init-type-env)))) type-env) \n\t\t\t\t   (filter (lambda (x) (not (assoc (car x) (init-eval-env)))) eval-env) ))\n\n\t   )\n      (pp unified-env)\n      )))\n\n(for-each interpreter (command-line-arguments))\n")) (section 3 "Version History" (ul (li "1.0 Initial Release"))) (section 3 "License" (p (tt "miniML") " is based on the code and paper by Xavier Leroy (2000): A modular module system. Journal of Functional Programming, 10, pp 269-303") (pre "Copyright 2010 Ivan Raikov and the Okinawa Institute of\nScience and Technology.\n\nThis program is free software: you can redistribute it and/or\nmodify it under the terms of the GNU General Public License as\npublished by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nA full copy of the GPL license can be found at\n<http://www.gnu.org/licenses/>."))))