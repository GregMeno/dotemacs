(index ("make-fancy-rules" 0) ("make-smart-quote-rules" 626) ("default-exceptions" 1310) ("default-ligature-map" 1535) ("default-punctuation-map" 2009) ("default-arrow-map" 2357) ("default-map" 2614) ("all-quotes" 2855) ("fancify" 3735) ("smarten-quotes" 3961))
(def (sig (procedure "(make-fancy-rules [exceptions] [character-map])" (id make-fancy-rules))) (p "Create a ruleset that performs ASCII->Unicode mappings for all entries in the " (tt "character-map") " argument.  " (tt "character-map") " defaults to " (tt "default-map") " (see below).") (p "Please note that the order matters because the replacement algorithm employes a nongreedy search.  Place prefixes of other matches after them and there is no problem.  The symbols in " (tt "exceptions") " are the tags to leave alone (ie, nothing below these is fancified) and defaults to " (tt "default-exceptions") " (see below)."))
(def (sig (procedure "(make-smart-quote-rules [exceptions] [quotes])" (id make-smart-quote-rules))) (p "Create a ruleset that educates quotes.  " (tt "quotes") " defines the strategy of how to translate quotes to smart quotes.  See the documentation for " (tt "all-quotes") " for more info on the structure of this argument.  Please note that here, the order doesn't matter because the replacement algorithm uses simple regexes.  The symbols in " (tt "exceptions") " are the tags to leave alone. (ie, under these nothing has its quotes changes)") (p (tt "exceptions") " defaults to " (tt "default-exceptions") " and " (tt "quotes") " defaults to " (tt "all-quotes") " (see below)."))
(def (sig (constant "default-exceptions" (id default-exceptions))) (p "This constant is a list of all the tags (symbols) that are ignored by default.") (pre "") (p "These are: " (tt "(head script pre code kbd samp @)") "."))
(def (sig (constant "default-ligature-map" (id default-ligature-map))) (p "An alist of default ASCII sequences that are translated to ligatures by " (tt "make-fancy-rules") ".") (p "Contains mappings for 'ffi', 'ffl', 'ff', 'fi', 'fl' and 'ft'.  The mapping for 'st' is intentionally left out because this ligature is too elaborate to use in body copy.  You could easily define a ruleset for eg headings that does include the 'st' ligature (it's Unicode character fb06)."))
(def (sig (constant "default-punctuation-map" (id default-punctuation-map))) (p "An alist of default ASCII punctuation sequences to translate to 'fancy' Unicode versions.  Contains mappings for '" "..." "' => '" "…" "', '" ".." "' => '" "‥" "', '" ". . ." "' => '" "…" "', '" "---" "' => '" "&mdash;" "' and '" "--" "' => '" "&ndash;" "'."))
(def (sig (constant "default-arrow-map" (id default-arrow-map))) (p "An alist of default ASCII sequences to translate to 'fancy' Unicode versions.  This contains several types of arrows.  Useful mostly for mathematical texts and 'evaluates to' examples."))
(def (sig (constant "default-map" (id default-map))) (p "The default map to use for fancifying text.  This is simply a concatenation of " (tt "default-ligature-map") ", " (tt "default-punctuation-map") " and " (tt "default-arrow-map") "."))
(def (sig (constant "all-quotes" (id all-quotes))) (p "The quote characters in here to be translated by " (tt "make-smart-quotes") ".  Remove any you don't want to have handled.") (pre "") (p "The structure of an entry in this list is:") (pre " (pre match post how counts?)") (p (tt "pre") " is the part of the string that's before the quote to match, " (tt "post") " is the string that is after the match.  These are all irregex literals.") (p (tt "how") " is one of the following symbols: " (tt "single") ", " (tt "double") ", " (tt "single-open") ", " (tt "double-open") ", " (tt "single-close") " or " (tt "double-close") ".") (p (tt "counts?") " is a boolean describing whether the quote should influence the nesting of subsequent quotes or not.  (ie, \"isn't\" => #f, since the ' is not a quote which matches a preceding quote or which is matched by a subsequent quote)."))
(def (sig (procedure "(fancify string character-map)" (id fancify))) (p "Perform simple substitution of all ASCII character strings in the " (tt "character-map") " alist to their Unicode character within " (tt "string") "."))
(def (sig (procedure "(smarten-quotes sxml quotes exceptions)" (id smarten-quotes))) (p "Smarten the " (tt "sxml") ".  Translates only the strings in the " (tt "quotes") " argument, and skips all tag names in the " (tt "exceptions") " list"))
