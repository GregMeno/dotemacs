((section 2 "spiffy-request-vars " (section 3 "Introduction" (p (tt "spiffy-request-vars") " provides easy access to variables from HTTP requests.")) (section 3 "Author" (p (link "http://wiki.call-cc.org/users/mario-domenech-goulart" "Mario Domenech Goulart")) (p "Thanks to Moritz Heidkamp for the implementation of the content body reader and for several terminology suggestions (including the egg name).  Also thanks to " (link "http://wiki.call-cc.org/users/peter-bex" "Peter Bex") " for the helpful discussions and lots of implementation suggestions.")) (section 3 "Procedures parameters and macros" (def (sig (procedure "(request-vars #!key (source 'both) max-content-length)" (id request-vars))) (p (tt "request-vars") " returns a procedure which can be used to access variables from the HTTP request.  The returned procedure takes the name of the variable (either a symbol or a string) as argument. You can (optionally) also pass a converter procedure to be used as a type converter for the variable value (see Converter procedures) or a default value.") (p (tt "request-vars") " accepts some keyword arguments:") (dl (dt (tt "source")) (dd (tt "'query-string") " tells " (tt "request-vars") " to parse the query string only (for GET variables). " (tt "'request-body") " tells " (tt "request-vars") " to parse the request body only (e.g., for POST variables). " (tt "'both") " tells " (tt "request-vars") " to parse both the request body and the query string. The default value for " (tt "source") " is " (tt "'both") ". Notice that when " (tt "'both") " is used, variables from the request body have precedence over the ones from the query string.") (dt (tt "max-content-length")) (dd "the maximum content length (in characters) to be read from the request body.  Default is " (tt "#f") " (no limit)."))) (section 4 "Converter procedures" (p "The following procedures are intended to be used by the procedure returned by " (tt "request-vars") ".  The " (tt "variables/values") " parameter is an alist mapping variable names to their corresponding values, resulting from parsing the request.") (def (sig (procedure "(as-number variable variables/values)" (id as-number))) (p "If the given variable is set, convert its value to a number using " (tt "string->number") ".")) (def (sig (procedure "(as-boolean variable variables/values)" (id as-boolean))) (p "If the variable is set and its value is one of the values yield by the " (tt "true-boolean-values") " parameter, return " (tt "#t") ", otherwise return " (tt "#f") ". It also returns " (tt "#t") " if the variable is passed in the request but is not bound to any value.")) (def (sig (procedure "(as-list variable variables/values)" (id as-list))) (p "If the variable is set once, returns a list with a single element (the value for the given variable).  If the variable is set multiple times, return a list with the multiple values for the variable.  If the variable is not set, return " (tt "#f") ".")) (def (sig (procedure "(as-alist variable variables/values)" (id as-alist))) (p "Returns an alist represented by the request variables/values for the given variable.  The request representation for alists is " (tt "variable.key=value") ".  Example: " (tt "foo.a=1") " would result in " (tt "'((a . \"1\"))") " for the " (tt "foo") " variable.") (p "Example:") (highlight scheme ";; considering a http://server:port/path?foo.a=0&foo.b=1 request\n\n(let (($ (request-vars)))\n  ($ 'foo as-alist))   ;; => ((a . \"0\") (b . \"1\"))") (p (tt "as-alist") " returns " (tt "#f") " when the wanted variable is not sent in the request or it is sent not in the " (i "dot") " notation (e.g., " (tt "foo=0") ").")) (def (sig (procedure "(as-hash-table variable variables/values)" (id as-hash-table))) (p "The same as " (tt "as-alist") ", but returns a hash-table object instead of an alist.")) (def (sig (procedure "(as-vector variable variables/values)" (id as-vector))) (p "Returns a vectir represented by the request variables/values for the given variable.  The request representation for vectors is " (tt "variable.numeric-index=value") ".  Example: " (tt "foo.0=1") " would result in " (tt "#(\"1\")") " for the " (tt "foo") " variable.") (p "Example:") (highlight scheme ";; considering a http://server:port/path?foo.0=a&foo.1=b\n\n(let (($ (request-vars)))\n  ($ 'foo as-vector))   ;; => #(\"a\" \"b\")") (p (tt "as-vector") " returns " (tt "#f") " when the wanted variable is not sent in the request or it is sent not in the " (i "dot") " notation (e.g., " (tt "foo=0") ").") (p "If the vector represented by the request is sparse, the missing items are unspecified values.")) (def (sig (parameter "(true-boolean-values)" (id true-boolean-values))) (p "A list of values (strings) to be considered as " (tt "#t") " for request variables when " (tt "as-boolean") " is used as converter.") (p "The default value is " (tt "'(\"y\" \"yes\" \"1\" \"on\" \"true\")") ".  The values are compared using " (tt "string-ci=?") "."))) (section 4 "Example" (highlight scheme "  (let (($ (request-vars)))\n    ($ 'var1)\n    ($ 'var2 \"\") ;; if var12 is not set, return \"\"\n    ($ 'var3 as-number)) ;; if var3 is not set, return #f; if it is\n                         ;; set, convert its value to a number") (def (sig (syntax "(with-request-vars [getter] (var1 var2 ... varN) expr1 expr2 ... exprN)" (id with-request-vars))) (p "Bind the given identifiers to the corresponding query string and request body variable values and evaluate the expressions.  The optional " (tt "getter") " argument (the return value of " (tt "request-vars") ") may be used in situations when you already have the getter and don't want to reparse the query string and request body.  With " (tt "with-request-vars*") ", the given getter will be used and no reparsing will be performed.  When the syntax is ambiguous (e.g., " (tt "(with-request-vars (request-vars) (var1 var2) (body))") ", " (tt "with-request-vars*") " can be used)."))) (section 4 "Examples" (highlight scheme "(with-request-vars (a b c)\n   (conc \"a = \" a\n         \"b = \" b\n         \"c = \" c))") (highlight scheme "(let (($ (request-vars)))\n  (with-request-vars $ (a b c)\n     (conc \"a = \" a\n           \"b = \" b\n           \"c = \" c)))") (p "A converter procedure can also be used to specify the type of the variable values:") (highlight scheme "(let (($ (request-vars)))\n  (with-request-vars $ (a (b as-list) (c as-number))\n     (conc \"a = \" a\n           \"b = \" b\n           \"c = \" c)))") (def (sig (syntax "(with-request-vars* getter (var1 var2 ... varN) expr1 expr2 ... exprN)" (id with-request-vars*))) (p "The same as " (tt "with-request-vars") ", but the getter is mandatory.")))) (section 3 "More examples" (p "Considering") (highlight scheme "(define $ (request-vars))") (p "here are some expected results for the given requests:") (highlight scheme ";; http://host:port/\n\n($ 'foo)             => #f\n($ 'foo 'bar)        => bar\n($ 'foo as-list)     => #f\n($ 'foo as-boolean)  => #f\n($ 'foo as-number)   => #f\n\n\n;; http://host:port/?foo=bar\n\n($ 'foo)             => \"bar\"\n($ 'foo 'bar)        => \"bar\"\n($ 'foo as-list)     => (\"bar\")\n($ 'foo as-boolean)  => #f\n($ 'foo as-number)   => #f\n\n\n;; http://host:port/?foo=bar&foo=baz\n\n($ 'foo)             => \"bar\"\n($ 'foo 'bar)        => \"bar\"\n($ 'foo as-list)     => (\"bar\" \"baz\")\n($ 'foo as-boolean)  => #f\n($ 'foo as-number)   => #f\n\n\n;; http://host:port/?foo=0\n\n($ 'foo)             => \"0\"\n($ 'foo 'bar)        => \"0\"\n($ 'foo as-list)     => (\"0\")\n($ 'foo as-boolean)  => #f\n($ 'foo as-number)   => 0\n\n\n;; http://host:port/?foo=yes\n\n($ 'foo)             => \"yes\"\n($ 'foo 'bar)        => \"yes\"\n($ 'foo as-list)     => (\"yes\")\n($ 'foo as-boolean)  => #t\n($ 'foo as-number)   => #f\n\n\n;; http://host:port/\n\n(with-request-vars (foo (bar as-list) (baz 5))\n  (list foo bar baz) => (#f #f 5)\n\n\n;; http://host:port/?foo=10\n\n(with-request-vars (foo (bar as-list) (baz 5))\n  (list foo bar baz) => (\"10\" #f 5)\n\n\n;; http://host:port/?foo=10&bar=1\n\n(with-request-vars (foo (bar as-list) (baz 5))\n  (list foo bar baz) => (\"10\" (\"1\") 5)\n\n\n;; http://host:port/?foo=10&bar=1&bar=2\n\n(with-request-vars (foo (bar as-list) (baz 5))\n  (list foo bar baz) => (\"10\" (\"1\" \"2\") 5)\n\n\n;; http://host:port/?foo=10&bar=1&bar=2&baz=-8\n\n(with-request-vars (foo (bar as-list) (baz 5))\n  (list foo bar baz) => (\"10\" (\"1\" \"2\") \"-8\")\n\n\n;; http://host:port\n\n(with-request-vars ((foo as-alist) (bar as-number) (baz as-vector) (bool as-boolean))\n  (list foo bar baz bool)) => (#f #f #f #f)\n\n\n;; http://host:port/?foo.A=0&foo.B=1&bar=0&baz.0=a&baz.1=b&bool=yes\n\n(with-request-vars ((foo as-alist) (bar as-number) (baz as-vector) (bool as-boolean))\n  (list foo bar baz bool)) => (((A . \"0\") (B . \"1\")) 0 #(\"a\" \"b\") #t)\n\n\n;; http://host:port/?foo=0&bar=a&baz=0&bool=3\n\n(with-request-vars ((foo as-alist) (bar as-number) (baz as-vector) (bool as-boolean))\n  (list foo bar baz bool)) => (#f #f #f #f)\n\n")) (section 3 "Tips and tricks" (p "If you want to specify both converters and default values, you can use the following trick:") (highlight scheme "\n;; Define a procedure to return the default value if the\n;; variable is not set.\n(define ((as-number/default default) var vars/vals)\n  (or (as-number var vars/vals) default))\n\n\n;; http://host:port/\n\n(with-request-vars (foo (bar as-list) (baz (as-number/default 3)))\n  (->string (list foo bar baz))) => (#f #f 3)\n\n\n;; http://host:port/?baz=9\n\n(with-request-vars (foo (bar as-list) (baz (as-number/default 3)))\n  (->string (list foo bar baz))) => (#f #f 9)")) (section 3 "License" (p "BSD")) (section 3 "Requirements" (ul (li (int-link "spiffy")) (li (int-link "intarweb")) (li (int-link "uri-common")))) (section 3 "Version history" (dl (dt "0.12") (dd "Bug fixes: " (tt "request-vars") " returns " (tt "#f") " when the content-type is not " (tt "application/x-www-form-urlencoded") " (thanks to Peter Bex for reporting this problem). " (tt "req-vars/vals") " always return a list.") (dt "0.11") (dd "Applied patch by " (int-link "/users/moritz-heidkamp" "Moritz Heidkamp") " which enhances " (tt "as-boolean") " in two ways: It adds " (tt "\"true\"") " to the default list of " (tt "true-boolean-values") " and it considers the mere presence of the parameter as " (tt "#t") ", i.e. a query string like " (tt "\"?foo\"") " would bind " (tt "foo") " to " (tt "#t") " when it is cast " (tt "as-boolean") ".") (dt "0.10") (dd "bug fix for some corner cases") (dt "0.9") (dd "added " (tt "as-vector") ", " (tt "as-alist") " and " (tt "as-hash-table") " as converters.") (dt "0.8") (dd "bug fix/improvement: don't bother reading the request body when the content-length is zero (fixes some awful/jquery ajax issues)") (dt "0.7") (dd "bug fix.  Interpret request body before query string.") (dt "0.6")) (ul (li "support for specifying types to variables") (li "support for receiving lists from the URI") (li (b "Warning") ": compatibility with previous versions has been broken: now the procedure returned by " (tt "request-vars") " accepts only " (b "two") " arguments, not " (b "three") ".  So, if you are using converter procedures as argument to the procedure returned by " (tt "request-vars") ", beware that your code will break.")) (dl (dt "0.5") (dd (tt "with-request-vars") " accepts a getter as argument when the syntax is not ambiguous.") (dt "0.4") (dd (tt "with-request-vars*") " resurrected.  For the cases when the syntax of " (tt "with-request-vars") " is ambiguous.  Thanks to Moritz Heidkamp for catching this bug.") (dt "0.3") (dd "Removed " (tt "with-request-vars*") ".  " (tt "with-request-vars") " accepts an optional getter argument") (dt "0.2") (dd "Added " (tt "with-request-vars") " and " (tt "with-request-vars*")) (dt "0.1") (dd "Initial release")))))