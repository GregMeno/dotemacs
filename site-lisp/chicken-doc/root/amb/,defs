(index ("amb" 0) ("amb/random" 472) ("amb-find" 688) ("amb-collect" 1215) ("amb-assert" 1448) ("amb-failure-continuation" 1569) ("amb-failure-continuation" 1569) ("amb-thunks" 3016) ("amb-find-thunk" 3271) ("amb-collect-thunk" 3492) ("choose" 3714) ("one-of" 3828) ("all-of" 3920) ("required" 4018) ("distinct?" 4111))
(def (sig (syntax "(amb EXPRESSION...) => TOP" (id amb))) (p "If the " (tt "EXPRESSION") " has any parameters, the first one of them is evaluated and the result is returned. If a subsequent occurrence of " (tt "amb") " fails, though, backtracking may cause the second of the given " (tt "EXPRESSION...") " to be selected for evaluation, then the third and so forth until the whole program does not fail if at all possible.") (p "The form " (tt "(amb)") " always fails."))
(def (sig (syntax "(amb/random EXPRESSION...) => TOP" (id amb/random))) (p "Works like " (tt "amb") " but the parameters are not selected in sequence but randomly. None of them is selected more than once, though."))
(def (sig (syntax "(amb-find EXPRESSION [FAILURE-VALUE]) => *" (id amb-find))) (p "Evaluates " (tt "EXPRESSION") " returning its value if successful (possibly after backtracking).") (p "If " (tt "EXPRESSION") " cannot be evaluated successfully and the expression tree is exhausted, " (tt "FAILURE-VALUE") " is evaluated and the result is returned instead.") (p "If no " (tt "FAILURE-VALUE") " is specified, an exception occurs. See the " (tt "amb-failure-continuation") " parameter below for a description of the exception."))
(def (sig (syntax "(amb-collect EXPRESSION) => list" (id amb-collect))) (p "Evaluates " (tt "EXPRESSION") " and performs backtracking repeatedly until all possible values for it have been accumulated in a list, which is returned."))
(def (sig (syntax "(amb-assert OK?)" (id amb-assert))) (p "Evaluates " (tt "OK?") " and fails if it is " (tt "#f") "."))
(def (sig (procedure "(amb-failure-continuation) => STATUS-VARIABLE" (id amb-failure-continuation)) (procedure "(amb-failure-continuation STATUS-VARIABLE)" (id amb-failure-continuation))) (p "Seen in a global context, the " (tt "amb") " operator transforms the whole program that contains it into a depth first search for return values from " (tt "amb") " forms that will not cause failure.") (p "This is realized using a backtracking system that invokes previously stored continuations whenever an " (tt "amb") " expression fails. The " (tt "amb-failure-continuation") " parameter is the status variable for this system.") (p "At the start of the program, or when no further backtracking options are available, this is set to a procedure of no arguments that raises an exception condition " (tt "(exn amb)") " (except when a " (tt "amb-collect") " statement is being processed, where the parameter will point to a procedure signalling " (tt "amb-collect") " that there are no more backtracking options available).") (p "In all other cases this parameter is set to a procedure of no arguments that causes backtracking to the next possible alternative in the " (i "tree") ".") (p "If you want to restrict the scope of backtracking to something smaller than the whole past program, use " (tt "amb-find") " or " (tt "amb-collect") " which restore this parameter to its original value when they are done evaluating the expressions they were given."))
(def (sig (procedure "(amb-thunks THUNKS) => TOP" (id amb-thunks))) (p "The backend of " (tt "amb") ".") (p (tt "amb") " wraps all its parameters into thunks and passes a list of them into this procedure, " (tt "amb/random") " shuffles the list first."))
(def (sig (procedure "(amb-find-thunk THUNK [FAILURE]) => TOP" (id amb-find-thunk))) (p "The backend of " (tt "amb-find") ".") (p (tt "amb-find") " wraps its parameters into thunks and passes them into this procedure."))
(def (sig (procedure "(amb-collect-thunk THUNK) => list" (id amb-collect-thunk))) (p "The backend of " (tt "amb-collect") ".") (p (tt "amb-collect") " wraps its parameter into a thunk and passes it into this procedure."))
(def (sig (syntax "(choose LIST) => TOP" (id choose))) (p (tt "amb/random") " but with a single list argument."))
(def (sig (syntax "(one-of EXPRESSION) => *" (id one-of))) (p (tt "amb-find") " synonym."))
(def (sig (syntax "(all-of EXPRESSION) => list" (id all-of))) (p (tt "amb-collect") " synonym."))
(def (sig (syntax "(required EXPRESSION)" (id required))) (p (tt "amb-assert") " synonym."))
(def (sig (procedure "(distinct? LIST [=? equal?]) => boolean" (id distinct?))) (p "Is " (tt "LIST") " a list of distinct elements, as determined by " (tt "=?") "?"))
