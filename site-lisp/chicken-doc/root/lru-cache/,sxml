((section 2 "lru-cache" (p (b "lru-cache") " implements an LRU cache of N elements.  It uses a hash table for fast lookup and a doubly-linked list to maintain LRU ordering.  As the hash table associates keys with list nodes, items may be reordered without traversing the list.") (toc) (section 3 "Interface" (section 4 "make-lru-cache" (def (sig (procedure "(make-lru-cache capacity equal? [deleter])" (id make-lru-cache))) (p "Create an LRU cache capable of holding " (tt "capacity") " items.  " (tt "equal?") " is the item equality procedure and is passed directly to the hash table, as in " (tt "(make-hash-table equal?)") ".  " (tt "deleter") " is an optional procedure of two arguments " (tt "(key value)") " which will be invoked whenever an item is deleted, flushed or simply falls off the cache.") (p "If " (tt "capacity") " is zero, the cache is disabled.  Attempts to read items will return " (tt "#f") ", and writing them will silently fail."))) (section 4 "lru-cache-ref" (def (sig (procedure "(lru-cache-ref cache key)" (id lru-cache-ref))) (p "Looks up the item matching " (tt "key") " and returns the associated value, or " (tt "#f") " if no such item exists.") (p "If the item is not the most-recently used, it is marked as MRU (in other words, moved to the head of the list).") (p "If the item is the most-recently used, the LRU list structure is not modified, and consequently the item is returned a bit faster."))) (section 4 "lru-cache-set!" (def (sig (procedure "(lru-cache-set! cache key val)" (id lru-cache-set!))) (p "Add an item into the cache which associates " (tt "key") " with " (tt "val") ", or if an item matching " (tt "key") " already exists, updates the item to the new " (tt "val") ".  If the key did not exist, the item is marked as the most-recently used.  If the key did exist, the LRU ordering behavior is undefined; currently -- and don't take this for granted -- the LRU order is not updated.") (p "If adding this item causes the cache to exceed its capacity, the least-recently used item is deleted, and consequently the deleter (if provided) is invoked.  If the deleter throws an exception, the item remains in the cache, and the new item is not added."))) (section 4 "lru-cache-delete!" (def (sig (procedure "(lru-cache-delete! cache key)" (id lru-cache-delete!))) (p "Deletes the item matching " (tt "key") " from " (tt "cache") ".  If no corresponding item exists, the procedure silently fails.  The deleter, if provided, will be invoked for this item.") (p "Note: if the deleter throws an exception, the item is " (i "not") " deleted from the cache."))) (section 4 "lru-cache-flush!" (def (sig (procedure "(lru-cache-flush! cache)" (id lru-cache-flush!))) (p "Delete all items in " (tt "cache") ". The deleter procedure (if provided to " (tt "make-lru-cache") ") is invoked for each item as the item list is traversed from head to tail.  If an error occurs in the deleter, the offending item will be left at the head of the cache."))) (section 4 "lru-cache-walk" (def (sig (procedure "(lru-cache-walk cache proc)" (id lru-cache-walk))) (p "Call " (tt "(proc key value)") " for each item in the cache, returning an unspecified value.  Items are traversed from MRU to LRU."))) (section 4 "lru-cache-fold" (def (sig (procedure "(lru-cache-fold cache kons knil)" (id lru-cache-fold))) (p "Iterate over the items in the cache in order from MRU to LRU.  " (tt "kons") " is called with three arguments: " (tt "k") ", the item's key; " (tt "v") ", the item's value; and " (tt "s") ", the current state.  The initial state is set to " (tt "knil") ", and the return value from the call to " (tt "kons") " is passed as the next state value to " (tt "kons") ".") (p "For example, to build a list of " (tt "(key . value)") " pairs in " (tt "cache") " from LRU to MRU, execute:") (pre "(lru-cache-fold cache (lambda (k v s) (cons (cons k v) s)) '())"))) (section 4 "lru-cache-size" (def (sig (procedure "(lru-cache-size cache)" (id lru-cache-size))) (p "Returns the number of items currently in the cache."))) (section 4 "lru-cache-capacity" (def (sig (procedure "(lru-cache-capacity cache)" (id lru-cache-capacity))) (p "Returns the capacity of the cache in items.")))) (section 3 "Example" (pre "(use lru-cache)\n(define C (make-lru-cache 4 string=?\n                          (lambda (k v) (printf \"deleting (~S ~S)\\n\" k v))))\n(lru-cache-set! C \"a\" 1) ; a\n(lru-cache-set! C \"b\" 2) ; b a\n(lru-cache-set! C \"c\" 3) ; c b a\n(lru-cache-set! C \"d\" 4) ; d c b a\n(lru-cache-walk C print)\n;; d4\n;; c3\n;; b2\n;; a1\n(lru-cache-set! C \"e\" 5) ; e d c b\n;; deleting (a 1)\n(lru-cache-ref C \"b\")    ; 2, b e d c\n(lru-cache-ref C \"d\")    ; 4, d b e c\n(lru-cache-walk C print)\n;; d4\n;; b2\n;; e5\n;; c3\n(lru-cache-delete! C \"e\") ; d b c\n;; deleting (\"e\" 5)\n(lru-cache-set! C \"a\" 6) ; a d b c\n(lru-cache-flush! C)\n;; deleting (\"a\" 6)\n;; deleting (\"d\" 4)\n;; deleting (\"b\" 2)\n;; deleting (\"c\" 3)\n(lru-cache-walk C print)")) (section 3 "Author" (p (link "http://3e8.org/zb" "Jim Ursetto"))) (section 3 "Version history" (ul (li "0.5 (2009-03-23): Initial release "))) (section 3 "License" (pre "Copyright (c) 2009 Jim Ursetto.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n Redistributions of source code must retain the above copyright notice,\n  this list of conditions and the following disclaimer.\n Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n Neither the name of the author nor the names of its contributors \n  may be used to endorse or promote products derived from this software \n  without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\nEXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."))))