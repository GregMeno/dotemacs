(index ("make-lru-cache" 0) ("lru-cache-ref" 620) ("lru-cache-set!" 1069) ("lru-cache-delete!" 1806) ("lru-cache-flush!" 2175) ("lru-cache-walk" 2525) ("lru-cache-fold" 2736) ("lru-cache-size" 3372) ("lru-cache-capacity" 3499))
(def (sig (procedure "(make-lru-cache capacity equal? [deleter])" (id make-lru-cache))) (p "Create an LRU cache capable of holding " (tt "capacity") " items.  " (tt "equal?") " is the item equality procedure and is passed directly to the hash table, as in " (tt "(make-hash-table equal?)") ".  " (tt "deleter") " is an optional procedure of two arguments " (tt "(key value)") " which will be invoked whenever an item is deleted, flushed or simply falls off the cache.") (p "If " (tt "capacity") " is zero, the cache is disabled.  Attempts to read items will return " (tt "#f") ", and writing them will silently fail."))
(def (sig (procedure "(lru-cache-ref cache key)" (id lru-cache-ref))) (p "Looks up the item matching " (tt "key") " and returns the associated value, or " (tt "#f") " if no such item exists.") (p "If the item is not the most-recently used, it is marked as MRU (in other words, moved to the head of the list).") (p "If the item is the most-recently used, the LRU list structure is not modified, and consequently the item is returned a bit faster."))
(def (sig (procedure "(lru-cache-set! cache key val)" (id lru-cache-set!))) (p "Add an item into the cache which associates " (tt "key") " with " (tt "val") ", or if an item matching " (tt "key") " already exists, updates the item to the new " (tt "val") ".  If the key did not exist, the item is marked as the most-recently used.  If the key did exist, the LRU ordering behavior is undefined; currently -- and don't take this for granted -- the LRU order is not updated.") (p "If adding this item causes the cache to exceed its capacity, the least-recently used item is deleted, and consequently the deleter (if provided) is invoked.  If the deleter throws an exception, the item remains in the cache, and the new item is not added."))
(def (sig (procedure "(lru-cache-delete! cache key)" (id lru-cache-delete!))) (p "Deletes the item matching " (tt "key") " from " (tt "cache") ".  If no corresponding item exists, the procedure silently fails.  The deleter, if provided, will be invoked for this item.") (p "Note: if the deleter throws an exception, the item is " (i "not") " deleted from the cache."))
(def (sig (procedure "(lru-cache-flush! cache)" (id lru-cache-flush!))) (p "Delete all items in " (tt "cache") ". The deleter procedure (if provided to " (tt "make-lru-cache") ") is invoked for each item as the item list is traversed from head to tail.  If an error occurs in the deleter, the offending item will be left at the head of the cache."))
(def (sig (procedure "(lru-cache-walk cache proc)" (id lru-cache-walk))) (p "Call " (tt "(proc key value)") " for each item in the cache, returning an unspecified value.  Items are traversed from MRU to LRU."))
(def (sig (procedure "(lru-cache-fold cache kons knil)" (id lru-cache-fold))) (p "Iterate over the items in the cache in order from MRU to LRU.  " (tt "kons") " is called with three arguments: " (tt "k") ", the item's key; " (tt "v") ", the item's value; and " (tt "s") ", the current state.  The initial state is set to " (tt "knil") ", and the return value from the call to " (tt "kons") " is passed as the next state value to " (tt "kons") ".") (p "For example, to build a list of " (tt "(key . value)") " pairs in " (tt "cache") " from LRU to MRU, execute:") (pre "(lru-cache-fold cache (lambda (k v s) (cons (cons k v) s)) '())"))
(def (sig (procedure "(lru-cache-size cache)" (id lru-cache-size))) (p "Returns the number of items currently in the cache."))
(def (sig (procedure "(lru-cache-capacity cache)" (id lru-cache-capacity))) (p "Returns the capacity of the cache in items."))
