(index ("*sql-datastore*" 0) ("*sql-dataset*" 489) ("DATASTORE" 808) ("DATASTORE" 2286) ("DATASTORE" 2839) ("DATASTORE" 3258) ("DATASTORE" 3796) ("DATASTORE" 4130) ("DATASTORE" 4516) ("DATASTORE" 4896) ("DATASTORE" 5312) ("DATASTORE" 5566) ("DATASET" 5838) ("DATASET" 6189) ("DATASET" 6309) ("DATASET" 6553) ("DATASET" 6842) ("DATASET" 7305) ("DATASET" 7627) ("DATASET" 7944) ("DATASET" 8043) ("DATASET" 8043) ("DATASET" 8816) ("DATASET" 8816) ("DATASET" 9118) ("DATASET" 9118) ("DATASET" 9544) ("DATASET" 9544) ("DATASET" 9910) ("DATASET" 9910) ("DATASET" 10276) ("DATASET" 10276) ("DATASET" 10642) ("DATASET" 10642) ("DATASET" 10923) ("DATASET" 11118) ("DATASET" 11315) ("char-set:sql-identifier" 11513) ("sql/parentheses" 11681))
(def (sig (constant "*sql-datastore*" (id *sql-datastore*))) (p "A generic container that can be queried using SQL. It is possible to use this object directly to obtain dummy datasets that are potentially useful to generate SQL statements easily. To connect to an actual database, use the " (tt "connect") " method.") (p "Database drivers will usually want to inherit from this object, override the methods to fetch data and register their child using " (tt "add-connection-prototype!")))
(def (sig (constant "*sql-dataset*" (id *sql-dataset*))) (p "A representation of a set of rows in an SQL database. Methods of datastores return children of this object for further manipulation.") (p "A dataset that is sufficiently restricted to contain only a single row can also be seen as a reference to that row."))
(def (sig (method "(DATASTORE 'connect URI) => DATASTORE" (id DATASTORE))) (p "Establish a connection to a real database.") (p "Depending on the scheme of the " (tt "URI") ", a registered prototype to clone is selected and the " (tt "URI") " is passed on to the clone call.  The new object is returned.") (p (tt "URI") " may be a string or a " (int-link "uri-generic") " record, but is always passed to the connection prototype's " (tt "clone") " method as a record.") (p "The drivers bundled with pandora will handle the URI schemes " (tt "sqlite3") " or " (tt "memory") " for access to SQLite3 databases (the latter always creates a database in memory) and " (tt "postgresql") " or " (tt "psql") " for access to PostgreSQL databases.") (p "The SQLite3 driver also supports a URI parameter " (tt "cache") " that determines the size of the prepared statement cache, which defaults to 64.") (p "Before using a backend, it must be loaded, but it doesn't have to be imported.") (highlight scheme ";; Example using SQLite3:\n(require-extension pandora)\n(require-library pandora-sqlite3)\n(define store (*sql-datastore* 'connect \"sqlite3:test.db?cache=16\"))\n\n;; Example using PostgreSQL:\n(require-extension pandora)\n(require-library pandora-postgresql)\n(define store (*sql-datastore* 'connect \"psql:\"))") (p "<method>(DATASTORE 'disconnect!) => VOID</enscript>") (p "Close the connection this datastore holds to a real database. The default implementation does nothing."))
(def (sig (method "(DATASTORE 'table NAME) => DATASET" (id DATASTORE))) (p "Create a dataset backed by the table called " (tt "NAME") " in the datastore. Tables may be named by symbols or strings.") (p "Actual database implementations should try to obtain meta information about the table and setup column accessors. See " (tt "add-column-slots!") " for information how to do that conveniently.") (highlight scheme ";; Example:\n(define-values (items tags item-tags)\n(values\n(store 'table 'items)\n(store 'table 'tags)\n(store 'table 'item-tags)))"))
(def (sig (method "(DATASTORE 'execute SQL [PARAMETERS]) => VOID" (id DATASTORE))) (p "Executes the given " (tt "SQL") " statement and discards all data possibly returned by it.") (p "The method is responsible to transform the SQL fragment list passed to it into a suitable form for processing by the database.") (p "The default implementation does nothing.") (p "You should never have to call this method directly."))
(def (sig (method "(DATASTORE 'fold PROC INIT SQL [PARAMETERS]) => VOID" (id DATASTORE))) (p "Fetches data returned by the given " (tt "SQL") " statement from from the database and applies " (tt "PROC") " to " (tt "INIT") " or its last return value and to all columns of each row.") (p "The method is responsible to transform the SQL fragment list passed to it into a suitable form for processing by the database.") (p "The default implementation just returns " (tt "INIT") ".") (p "You should never have to call this method directly."))
(def (sig (method "(DATASTORE 'with-transaction THUNK) => OBJECT" (id DATASTORE))) (p "Executes " (tt "THUNK") " within a transaction of the datastore. The transaction is rolled back if the " (tt "THUNK") " returns " (tt "#f") " or raises an error, otherwise the transaction is committed.") (p "Returns the result of the callback."))
(def (sig (method "(DATASTORE 'escape-sql-identifier ID) => STRING" (id DATASTORE))) (p "Escapes an SQL identifier in a driver specific way, if necessary.") (p "The default implementation just returns the " (tt "ID") " unchanged or raises an error if it contains characters not valid in a standard SQL identifier.") (p "Usually it should be unnecessary to call this method directly."))
(def (sig (method "(DATASTORE 'name->table-clause NAME) => STRING" (id DATASTORE))) (p "Turns a name into an SQL table clause, using driver specific escaping.") (p "The default implementation converts hyphenated identifiers into camel case and delegates to " (tt "escape-sql-identifier") " for the escaping.") (p "Usually it should be unnecessary to call this method directly."))
(def (sig (method "(DATASTORE 'name->column-clause NAME) => STRING" (id DATASTORE))) (p "Turns a name into an SQL column clause, using driver specific escaping.") (p "The default implementation converts hyphenated identifiers into lower case, underscore separated identifiers and delegates to " (tt "escape-sql-identifier") " for the escaping.") (p "Usually it should be unnecessary to call this method directly."))
(def (sig (method "(DATASTORE 'add-connection-prototype! URI-SCHEME OBJECT) => VOID" (id DATASTORE))) (p "Add a prototype for connections to databases using the given " (tt "URI-SCHEME") ".") (p "Only database drivers should have to call this method."))
(def (sig (method "(DATASTORE 'delete-connection-prototype! URI-SCHEME) => VOID" (id DATASTORE))) (p "Remove the prototype for connections to databases using the given " (tt "URI-SCHEME") ".") (p "This method just exists for completeness and is probably rarely useful."))
(def (sig (method "(DATASET 'filter {KEY: VALUE | KEY: VALUES | SQL PARAMETERS}*) => DATASET" (id DATASET))) (p "Obtain a dataset that is filtered selecting records with fields set to specific values or with arbitrary boolean SQL expressions.") (highlight scheme ";; Example:\n(define containers (items 'filter name: '(\"bag\" \"box\" \"trunk\")))"))
(def (sig (method "(DATASET 'count) => CARDINAL-INTEGER" (id DATASET))) (p "Count the number of rows in the dataset."))
(def (sig (method "(DATASET 'first [THUNK]) => DATASET" (id DATASET))) (p "Returns a dataset containing only the first row of this one or the result of " (tt "THUNK") " if this dataset is empty. The default thunk raises an access exception."))
(def (sig (method "(DATASET 'all [limit: LIMIT] [offset: OFFSET]) => LIST" (id DATASET))) (p "Returns a list of datasets each containing one row from this dataset.") (p "The range of returned rows may optionally be restricted using the " (tt "LIMIT") " and " (tt "OFFSET") " arguments."))
(def (sig (method "(DATASET 'fold  PROC INIT [limit: LIMIT] [offset: OFFSET]) => OBJECT" (id DATASET))) (p "Applies " (tt "PROC") " to successive rows from this dataset and either " (tt "INIT") " or its last return value. Returns either " (tt "INIT") " (if the dataset is empty) or the result of the last application of " (tt "PROC") ".") (p "The range of processed rows may optionally be restricted using the " (tt "LIMIT") " and " (tt "OFFSET") " arguments."))
(def (sig (method "(DATASET 'map PROC [limit: LIMIT] [offset: OFFSET]) => LIST" (id DATASET))) (p "Applies " (tt "PROC") " to successive rows from this dataset and collects the results in a list.") (p "The range of processed rows may optionally be restricted using the " (tt "LIMIT") " and " (tt "OFFSET") " arguments."))
(def (sig (method "(DATASET 'for-each PROC [limit: LIMIT] [offset: OFFSET]) => VOID" (id DATASET))) (p "Applies " (tt "PROC") " to successive rows from this dataset and discards the results.") (p "The range of processed rows may optionally be restricted using the " (tt "LIMIT") " and " (tt "OFFSET") " arguments."))
(def (sig (method "(DATASET 'delete!)" (id DATASET))) (p "Deletes the contents of this dataset."))
(def (sig (method "(DATASET 'add-link-slots! GETTER SETTER ((KEY REFERENCE)*) DATASET)" (id DATASET)) (method "(DATASET 'add-link-slots! GETTER SETTER ((KEY REFERENCE)*) AUXILIARY ((KEY REFERENCE)*) DATASET)" (id DATASET))) (p "Adds getter and/or setter methods to this dataset for a link to a different dataset.") (p "The first form of this method can be used to model one-to-many and many-to-one relations. The second form using an auxiliary translation dataset can be used to model many to many relations.") (highlight scheme ";; Example:\n(items 'add-link-slots! 'tags 'set-tags! '((id item)) item-tags '((tag id)) tags)\n((items 'filter name: \"bag\") 'set-tags! (tags 'filter name: '(\"large\" \"brown\")))\n(print ((containers 'tags) 'select 'name distinct: #t))"))
(def (sig (method "(DATASET 'datastore) => DATASTORE" (id DATASET)) (method "(DATASET 'set-datastore! DATASTORE)" (id DATASET))) (p "The datastore associated with the dataset.") (p "This slot will be set up by methods of the datastore that return datasets. Modifying it directly is not recommended."))
(def (sig (method "(DATASET 'row-prototype) => DATASET" (id DATASET)) (method "(DATASET 'set-row-prototype! DATASET) => VOID" (id DATASET))) (p "The prototype to use for row objects created when iterating over or fetching from the dataset using the " (tt "first") ", " (tt "all") ", " (tt "fold") " or " (tt "map") " methods.") (p "The " (tt "table") " method of a datastore sets this field to the table itself by default."))
(def (sig (method "(DATASET 'table-clauses) => LIST" (id DATASET)) (method "(DATASET 'set-table-clauses! LIST)" (id DATASET))) (p "The SQL clauses defining the sources of data for this dataset, potentially augmented by parameters.") (p "This slot will be set up by methods of datastores or datasets that return datasets. Modifying it directly is not recommended."))
(def (sig (method "(DATASET 'filter-clauses) => LIST" (id DATASET)) (method "(DATASET 'set-filter-clauses! LIST)" (id DATASET))) (p "The SQL clauses defining filter conditions for this dataset, potentially augmented by parameters.") (p "This slot will be set up by methods of datastores or datasets that return datasets. Modifying it directly is not recommended."))
(def (sig (method "(DATASET 'order-clauses) => LIST" (id DATASET)) (method "(DATASET 'set-order-clauses! LIST)" (id DATASET))) (p "The SQL clauses defining the ordering of rows in this dataset, potentially augmented by parameters.") (p "This slot will be set up by methods of datastores or datasets that return datasets. Modifying it directly is not recommended."))
(def (sig (method "(DATASET 'primary-key-clauses) => LIST" (id DATASET)) (method "(DATASET 'set-primary-key-clauses! LIST)" (id DATASET))) (p "The SQL clauses defining the primary key columns for this dataset.") (p "This slot will be set up by the database engine, if possible."))
(def (sig (method "(DATASET 'table-expression) => STRING, LIST" (id DATASET))) (p "Renders the table clauses of the dataset into an SQL fragment and a list of parameters binding placeholders."))
(def (sig (method "(DATASET 'filter-expression) => STRING, LIST" (id DATASET))) (p "Renders the filter clauses of the dataset into an SQL fragment and a list of parameters binding placeholders."))
(def (sig (method "(DATASET 'order-expression) => STRING, LIST" (id DATASET))) (p "Renders the ordering clauses of the dataset into an SQL fragment and a list of parameters binding placeholders."))
(def (sig (constant "char-set:sql-identifier" (id char-set:sql-identifier))) (p "A SRFI-14 character set containing what's valid inside an unescaped SQL identifier."))
(def (sig (procedure "(sql/parentheses SQL) => SQL" (id sql/parentheses))) (p "Adds parentheses around an SQL statement unless they are already present."))
