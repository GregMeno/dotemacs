((tags "eggs") (p "This is the " (b "sxml-transforms") " extension library for Chicken Scheme.") (toc) (section 2 "Description" (p "The " (link "http://cvs.sourceforge.net/viewcvs.py/ssax/SSAX" "SXML transformations") " (to XML, SXML, and HTML) from the " (link "http://ssax.sf.net" "SSAX project"))) (section 2 "Documentation" (p "This egg provides the SXML transforms available in the SSAX/SXML Sourceforge project.  It incorporates one main module, and an auxiliary one:") (section 3 "sxml-transforms" (section 4 "SRV:send-reply" (def (sig (procedure "(SRV:send-reply . fragments)" (id SRV:send-reply))) (p "Output the FRAGMENTS to the current output port.") (p "The fragments are a list of strings, characters, numbers, thunks, " (tt "#f") ", " (tt "#t") " -- and other fragments.  The function traverses the tree depth-first, writes out strings and characters, executes thunks, and ignores " (tt "#f") " and " (tt "'()") ".  The function returns " (tt "#t") " if anything was written at all; otherwise the result is " (tt "#f") ".  If " (tt "#t") " occurs among the fragments, it is not written out but causes the result of " (tt "SRV:send-reply") " to be " (tt "#t") "."))) (section 4 "pre-post-order" (def (sig (procedure "(pre-post-order tree bindings)" (id pre-post-order))) (p "(See also " (tt "pre-post-order*") ", which is preferred on Chicken.)") (p "Traversal of an SXML tree or a grove: a <Node> or a <Nodelist>") (p "A <Node> and a <Nodelist> are mutually-recursive datatypes that underlie the SXML tree:") (pre "    <Node> ::= (name . <Nodelist>) | \"text string\"") (p "An (ordered) set of nodes is just a list of the constituent nodes:") (pre "    <Nodelist> ::= (<Node> ...)") (p "Nodelists, and Nodes other than text strings are both lists. A <Nodelist> however is either an empty list, or a list whose head is not a symbol (an atom in general). A symbol at the head of a node is either an XML name (in which case it's a tag of an XML element), or an administrative name such as '@'. See SXPath.scm and SSAX.scm for more information on SXML.") (p "Pre-Post-order traversal of a tree and creation of a new tree:") (pre "pre-post-order:: <tree> x <bindings> -> <new-tree>\n\nwhere\n   <bindings> ::= (<binding> ...)\n   <binding> ::= (<trigger-symbol> *preorder* . <handler>) |\n                 (<trigger-symbol> *macro* . <handler>) |\n                 (<trigger-symbol> <new-bindings> . <handler>) |\n                 (<trigger-symbol> . <handler>)\n   <trigger-symbol> ::= XMLname | *text* | *default*\n   <handler> :: <trigger-symbol> x [<tree>] -> <new-tree>") (p "The pre-post-order function visits the nodes and nodelists pre-post-order (depth-first).  For each <Node> of the form (name <Node> ...) it looks up an association with the given 'name' among its <bindings>. If failed, pre-post-order tries to locate a " (tt "*default*") " binding. It's an error if the latter attempt fails as well.  Having found a binding, the pre-post-order function first checks to see if the binding is of the form") (pre "(<trigger-symbol> *preorder* . <handler>)") (p "If it is, the handler is 'applied' to the current node. Otherwise, the pre-post-order function first calls itself recursively for each child of the current node, with <new-bindings> prepended to the <bindings> in effect. The result of these calls is passed to the <handler> (along with the head of the current <Node>). To be more precise, the handler is _applied_ to the head of the current node and its processed children. The result of the handler, which should also be a <tree>, replaces the current <Node>. If the current <Node> is a text string or other atom, a special binding with a symbol " (tt "*text*") " is looked up.") (p "A binding can also be of a form") (pre "(<trigger-symbol> *macro* . <handler>)") (p "This is equivalent to *preorder* described above. However, the result is re-processed again, with the current stylesheet."))) (section 4 "pre-post-order-splice" (def (sig (procedure "(pre-post-order-splice tree bindings)" (id pre-post-order-splice))) (p "This module's version of " (tt "pre-post-order") " is a variant which always outputs strictly-conformant SXML. It unnests lists that do not have a tag as their " (tt "car") " until they do."))) (section 4 "post-order" (def (sig (procedure "(post-order tree bindings)" (id post-order))) (p "Deprecated. This was a version of pre-post-order that did not accept " (tt "*macro*") " or " (tt "*preorder*") " directives."))) (section 4 "foldts" (def (sig (procedure "(foldts fdown fup fhere seed tree)" (id foldts))) (p "Tree fold operator.") (pre "   tree = atom | (node-name tree ...)") (pre "   foldts fdown fup fhere seed (Leaf str) = fhere seed str\n   foldts fdown fup fhere seed (Nd kids) =\n         fup seed $ foldl (foldts fdown fup fhere) (fdown seed) kids") (pre "   procedure fhere: seed -> atom -> seed\n   procedure fdown: seed -> node -> seed\n   procedure fup: parent-seed -> last-kid-seed -> node -> seed") (p "foldts returns the final seed"))) (section 4 "replace-range" (def (sig (procedure "(replace-range beg-pred end-pred forest)" (id replace-range))) (pre "   procedure: replace-range:: BEG-PRED x END-PRED x FOREST -> FOREST") (p "Traverse a forest depth-first and cut/replace ranges of nodes.") (p "The nodes that define a range don't have to have the same immediate parent, don't have to be on the same level, and the end node of a range doesn't even have to exist. A replace-range procedure removes nodes from the beginning node of the range up to (but not including) the end node of the range.  In addition, the beginning node of the range can be replaced by a node or a list of nodes. The range of nodes is cut while depth-first traversing the forest. If all branches of the node are cut a node is cut as well.  The procedure can cut several non-overlapping ranges from a forest.") (pre "   replace-range:: BEG-PRED x END-PRED x FOREST -> FOREST") (p "where") (pre "   type FOREST = (NODE ...)\n   type NODE = Atom | (Name . FOREST) | FOREST") (p "The range of nodes is specified by two predicates, beg-pred and end-pred.") (pre "   beg-pred:: NODE -> #f | FOREST\n   end-pred:: NODE -> #f | FOREST") (p "The beg-pred predicate decides on the beginning of the range. The node for which the predicate yields non-#f marks the beginning of the range The non-#f value of the predicate replaces the node. The value can be a list of nodes. The replace-range procedure then traverses the tree and skips all the nodes, until the end-pred yields non-#f. The value of the end-pred replaces the end-range node. The new end node and its brothers will be re-scanned. The predicates are evaluated pre-order. We do not descend into a node that is marked as the beginning of the range."))) (section 4 "SXML->HTML" (def (sig (procedure "(SXML->HTML tree)" (id SXML->HTML))) (p "This procedure is the most generic transformation of SXML into the corresponding HTML document. The SXML tree is traversed post-oder (depth-first) and transformed into another tree, which, written in a depth-first fashion, results in an HTML document.") (p "It's basically like pre-post-order with the universal-conversion-rules hardcoded. It also knows about a rule " (tt "html:begin") ", which translates the HTML code to oldskool uppercase HTML 3 code preceded by a Content-Type header."))) (section 4 "entag" (def (sig (procedure "(entag tag elems)" (id entag))) (p "Create the HTML markup fragments for tags. TAG is the name of the tag (a symbol) and ELEMS is the tree of elements that form the contents of this tag (" (i "not") " recusively processed). This is used in the node handlers for the (pre-)post-order function, to prepare it for output by " (tt "SRV:send-reply") ". This is an alias for " (tt "entag-xhtml") " (see below, in the section about Chicken-specific modifications)"))) (section 4 "enattr" (def (sig (procedure "(enattr attr-key value)" (id enattr))) (p "Create the HTML markup fragments for attributes. The ATTR-KEY is the name of the attribute (a symbol) and VALUE is the value it should have. This is used in the node handlers for the (pre-)post-order function, to prepare it for output by " (tt "SRV:send-reply") "."))) (section 4 "string->goodHTML" (def (sig (procedure "(string->goodHTML html)" (id string->goodHTML))) (p "Given a string, check to make sure it does not contain characters such as '<' or '&' that require encoding. Return either the original string, or a list of string fragments with special characters replaced by appropriate character entities."))) (section 4 "universal-conversion-rules" (def (sig (constant "universal-conversion-rules" (id universal-conversion-rules))) (p "Bindings for the pre-post-order function, which traverses the SXML tree and converts it to a tree of fragments. It contains rules to call " (tt "string->goodHTML") ", " (tt "enattr") " and " (tt "entag") " on all text, attributes and tags. In normal situations you always append these rules to your own rules, or add a final pre-post-order processing step with just these bindings."))) (section 4 "universal-protected-rules" (def (sig (constant "universal-protected-rules" (id universal-protected-rules))) (p "A variation of universal-conversion-rules which keeps " (tt "'<'") ", " (tt "'>'") ", " (tt "'&'") " and similar characters intact (ie, it skips calling " (tt "string->goodHTML") "). The " (tt "universal-protected-rules") " are useful when the tree of fragments has to be traversed one more time.") (p "On Chicken, " (tt "universal-conversion-rules") " have been augmented a bit. The following rule has been added:") (pre "(& ENTITY-NAME ...)") (p "Quotes character references given by strings " (tt "ENTITY-NAME ...") ".") (highlight scheme "(& \"ndash\" \"quot\")\n => \"&ndash;&quot;\""))) (section 4 "alist-conv-rules" (def (sig (constant "alist-conv-rules" (id alist-conv-rules))) (p "These rules define the identity transformation. You will usually need to append these rules to all of the bindings you use with " (tt "pre-post-order") ", unless you explicitly define your own conversion rules for " (tt "*default*") " and " (tt "*text*") "."))) (section 4 "make-char-quotator" (def (sig (procedure "(make-char-quotator quot-rules)" (id make-char-quotator))) (p "Given QUOT-RULES, an assoc list of (char . string) pairs, return a quotation procedure. The returned quotation procedure takes a string and returns either a string or a list of strings. The quotation procedure check to see if its argument string contains any instance of a character that needs to be encoded (quoted). If the argument string is \"clean\", it is returned unchanged. Otherwise, the quotation procedure will return a list of string fragments. The input straing will be broken at the places where the special characters occur. The special character will be replaced by the corresponding encoding strings.") (p "For example, to make a procedure that quotes special HTML characters, do:") (highlight scheme "(make-char-quotator\n    '((#\\< . \"&lt;\") (#\\> . \"&gt;\") (#\\& . \"&amp;\") (#\\\" . \"&quot;\")))")))) (section 3 "Chicken-specific modifications" (section 4 "entag-xhtml" (def (sig (procedure "(entag-xhtml)" (id entag-xhtml))) (p (tt "entag-xhtml") " closes XHTML tags properly in an HTML compatible way.  " (tt "entag") " is now an alias for " (tt "entag-xhtml") ", so this behaviour is the default.") (p "Newlines before open tags in the rendered HTML output are omitted for inline elements, such as " (tt "tt") " and " (tt "strong") ".  This prevents the introduction of extraneous whitespace."))) (section 4 "entag-html" (def (sig (procedure "(entag-html)" (id entag-html))) (p (tt "entag-html") " is an alias for the original " (tt "entag") "."))) (section 4 "Starred versions" (p "Because pre-post-order necessarily uses " (tt "apply") " to call user handlers, it will fail on large SXML trees.  Chicken's " (tt "apply") " procedure is limited in how many arguments it can pass to a lambda, as described in " (int-link "/man/4/Deviations from the standard" "the manual") ".") (p "For this reason, the Chicken implementation of sxml-transforms provides alternative \"starred\" procedures not subject to this limit.") (p (tt "SXML->HTML") " uses the starred versions internally so it no longer suffers from this problem.  This has no impact on callers.") (def (sig (procedure "(pre-post-order* tree bindings)" (id pre-post-order*))) (p "Variant of " (tt "pre-post-order") " which calls its handlers with only two arguments, TAG (the trigger symbol) and BODY (the subtree body):") (pre "(handler (car tree) (cdr tree))") (p "In contrast, " (tt "pre-post-order") " calls its handlers with the trigger symbol and with one argument for each element of the body:") (pre "(apply handler (car tree) (cdr tree))") (p "On Chicken, " (tt "pre-post-order") " is inefficient and will even fail if the tree length is greater than the native apply parameter limit, which may be as low as 126 depending on your system.  We recommend using " (tt "pre-post-order*") " to avoid these issues.") (p "An example:") (pre " ;; Convert generic lists to ordered HTML lists\n (pre-post-order\n   `(list \"one\" \"two\" (strong \"three!\"))\n   `((list . ,(lambda (tag . body)\n                (cons 'ol (map (lambda (x) (list 'li x)) body))))\n     ,@alist-conv-rules))") (p "now becomes:") (pre " ;; Convert generic lists to ordered HTML lists, no limits!\n (pre-post-order*\n   `(list \"one\" \"two\" (strong \"three!\"))\n   `((list . ,(lambda (tag body)\n                (cons 'ol (map (lambda (x) (list 'li x)) body))))\n     ,@alist-conv-rules*))")) (def (sig (procedure "(pre-post-order-splice* tree bindings)" (id pre-post-order-splice*))) (p "Variant of " (tt "pre-post-order-splice") " which passes its handlers only two arguments: TAG and BODY.  See " (tt "pre-post-order*") ".")) (def (sig (constant "universal-conversion-rules*" (id universal-conversion-rules*))) (p "Variant of " (tt "universal-conversion-rules") " to be used with " (tt "pre-post-order*") ".")) (def (sig (constant "universal-protected-rules*" (id universal-protected-rules*))) (p "Variant of " (tt "universal-protected-rules") " to be used with " (tt "pre-post-order*") ".")) (def (sig (constant "alist-conv-rules*" (id alist-conv-rules*))) (p "Variant of " (tt "alist-conv-rules") " to be used with " (tt "pre-post-order*") "."))))) (section 2 "Examples" (p (link "http://okmij.org/ftp/Scheme/xml.html" "Oleg's site") " is the main resource.  Be sure to read his examples and the ones in the SSAX repository (also included in the egg).  The following papers were of great help:") (ul (li (link "http://okmij.org/ftp/papers/SXs-talk.pdf")) (li (link "http://okmij.org/ftp/papers/SXs.pdf")) (li (link "http://okmij.org/ftp/papers/SXSLT-talk.pdf"))) (p "There's also a more friendly " (link "http://sjamaan.ath.cx/docs/scheme/sxslt.pdf" "SXML tutorial") " available.") (p "The initial documentation on this wiki page came straight from the comments in the extremely well-documented source code. It's recommended you read the code if you want to learn more.")) (section 2 "About this egg" (section 3 "Author" (p (link "http://okmij.org/ftp/" "Oleg Kiselyov") ". Port by " (link "http://3e8.org/zb/" "Zbigniew"))) (section 3 "Version history" (dl (dt "1.4") (dd "Add starred versions (pre-post-order* etc)") (dt "1.3") (dd "Update to upstream latest version, remove splicing pre-post-order from extra file and rename it to pre-post-order-splice") (dt "1.2") (dd "Port to hygienic chicken") (dt "1.1") (dd "Improve inline element whitespace handling; add '&' rule.") (dt "1.0") (dd "Initial release"))) (section 3 "License" (p "The sxml-transforms code is in the public domain."))))