(index ("seq" 0) ("bar" 142) ("star" 351) ("star*" 544) ("redo" 646) ("tok" 891) ("Input->Token" 2132) ("Token->CharLex" 2514) ("char" 2784) ("set" 2877) ("range" 2988) ("lit" 3135) ("try" 3239) ("lst" 3440) ("pass" 3589) ("pos" 3699) ("opt" 3810) ("bind" 3921) ("rebind" 4238) ("drop" 4640) ("longest" 4828) ("lex" 5106))
(def (sig (procedure "(seq MATCHER1 MATCHER2) => MATCHER" (id seq))) (p (tt "seq") " builds a matcher that matches a sequence of patterns."))
(def (sig (procedure "(bar MATCHER1 MATCHER2) => MATCHER" (id bar))) (p (tt "bar") " matches either of two patterns. It's analogous to patterns separated by " (tt "|") " in traditional regular expressions."))
(def (sig (procedure "(star MATCHER) => MATCHER" (id star))) (p (tt "star") " is an implementation of the Kleene closure. It is analogous to " (tt "*") " in traditional regular expressions."))
(def (sig (procedure "(star* MATCHER) => MATCHER" (id star*))) (p "Greedy Kleene closure matching."))
(def (sig (procedure "(redo P Q R) => MATCHER" (id redo))) (p "If matcher " (tt "P") " fails (returns an empty list), then invoke matcher " (tt "Q") " on the original input stream, otherwise invoke " (tt "R") " on the result of " (tt "P") "."))
(def (sig (procedure "(tok <Input>) => (LAMBDA TOKEN PROC) => MATCHER" (id tok))) (p "Procedure " (tt "tok") " builds pattern matchers based on character comparison operations. It is intended for matching input sequences of arbitrary kinds, e.g. character lists, strings, or other kinds of sequences. To achieve abstraction over the input sequence kind, " (tt "tok") " is parameterised on a type class named " (tt "<Input>") ". Please see libraries " (int-link "typeclass") " and " (int-link "input-classes") " for information on the type class interface.") (p "As an example, the code below creates an input class for character lists and defines a version of " (tt "tok") " specialized for character lists.") (highlight scheme "(require-extension typeclass input-classes)\n\n(define char-list-<Input>\n  (make-<Input> null? car cdr))\n\n(define char-list-tok (tok <char-list-<Input>))") (p "Once applied to an input class, " (tt "tok") " builds a pattern matcher that, for each stream given, applies a procedure to the given token " (tt "TOKEN") " and an input character. If the procedure returns a true value, that value is prepended to the list of consumed elements, and the input character is removed from the list of input elements."))
(def (sig (procedure "(Input->Token INPUT-CLASS => TOKEN-CLASS)" (id Input->Token))) (p "This procedure takes an instance of the " (tt "<Input>") " typeclass, created by the " (tt "make-<Instance>") " constructor shown above, and returns an instance of the " (tt "<Token>") " typeclass, which in turn contains an instance of " (tt "tok") " specialized for the given input class."))
(def (sig (procedure "(Token->CharLex TOKEN-CLASS => CHARLEX-CLASS)" (id Token->CharLex))) (p "This procedure takes an instance of the " (tt "<Token>") " typeclass, and returns an instance of the " (tt "CharLex") " typeclass, which contains the following procedures:"))
(def (sig (procedure "(char CHAR) => MATCHER" (id char))) (p "Matches a single character."))
(def (sig (procedure "(set CHAR-SET) => MATCHER" (id set))) (p "Matches any of a SRFI-14 set of characters."))
(def (sig (procedure "(range CHAR CHAR) => MATCHER" (id range))) (p "Matches a range of characters. Analogous to character class " (tt "[]") "."))
(def (sig (procedure "(lit STRING) => MATCHER" (id lit))) (p "Matches a literal string " (tt "s") "."))
(def (sig (procedure "(try PROC) => PROC" (id try))) (p "Converts a binary predicate procedure to a binary procedure that returns its right argument when the predicate is true, and false otherwise."))
(def (sig (procedure "(lst MATCHER-LIST) => MATCHER" (id lst))) (p "Constructs a matcher for the sequence of matchers in " (tt "MATCHER-LIST") "."))
(def (sig (procedure "(pass) => MATCHER" (id pass))) (p "This matcher returns without consuming any input."))
(def (sig (procedure "(pos MATCHER) => MATCHER" (id pos))) (p "Positive closure. Analogous to " (tt "+") "."))
(def (sig (procedure "(opt MATCHER) => MATCHER" (id opt))) (p "Optional pattern. Analogous to " (tt "?") "."))
(def (sig (procedure "(bind F P) => MATCHER" (id bind))) (p "Given a rule " (tt "P") " and function " (tt "F") ", returns a matcher that first applies " (tt "P") " to the input stream, then applies " (tt "F") " to the returned list of consumed tokens, and returns the result and the remainder of the input stream."))
(def (sig (procedure "(rebind F G P) => MATCHER" (id rebind))) (p "Given a rule " (tt "P") " and procedures " (tt "F") " and " (tt "G") ", returns a matcher that first applies " (tt "F") " to the input stream, then applies " (tt "P") " to the resulting stream, then applies " (tt "G") " to the resulting list of consumed elements and returns the result along with the remainder of the input stream."))
(def (sig (procedure "(drop P) => MATCHER" (id drop))) (p "Given a rule " (tt "P") ", returns a matcher that always returns an empty list of consumed tokens when " (tt "P") " succeeds."))
(def (sig (procedure "(longest STREAM-LIST) => STREAM" (id longest))) (p "Takes the resulting streams produced by the application of a pattern on a stream (or streams) and selects the longest match if one exists. If " (tt "STREAM-LIST") " is empty, it returns " (tt "#F") "."))
(def (sig (procedure "(lex MATCHER ERROR STRING) => CHAR-LIST" (id lex))) (p (tt "lex") " takes a pattern and a string, turns the string into a list of streams (containing one stream), applies the pattern, and returns the longest match. Argument " (tt "ERROR") " is a single-argument procedure called when the pattern does not match anything."))
