((tags "eggs") (toc) (section 2 "lexgen" (section 3 "Description" (p (tt "lexgen") " is a lexer generator comprised in its core of only five small procedures that can be combined to form pattern matchers.") (p "A pattern matcher procedure takes a list of streams, and returns a new list of streams advanced by every combination allowed by the pattern.") (pre "A stream is defined as a list that contains a list of characters") (p "consumed by the pattern matcher, and a list of characters not yet consumed. E.g., the list") (pre " ((#\\a) (#\\b #\\c #\\d #\\e))") (p "represents a stream that contains the consumed character a, and the unconsumed characters b c d e.") (p "Note that the number of streams returned by a pattern matcher may not match the number of streams passed in. If the pattern doesn't match at all, the empty list is returned.")) (section 3 "Library Procedures" (p "Every combinator procedure in this library returns a procedure that takes in a continuation procedure and a list of streams as arguments.") (section 4 "Basic procedures" (def (sig (procedure "(seq MATCHER1 MATCHER2) => MATCHER" (id seq))) (p (tt "seq") " builds a matcher that matches a sequence of patterns.")) (def (sig (procedure "(bar MATCHER1 MATCHER2) => MATCHER" (id bar))) (p (tt "bar") " matches either of two patterns. It's analogous to patterns separated by " (tt "|") " in traditional regular expressions.")) (def (sig (procedure "(star MATCHER) => MATCHER" (id star))) (p (tt "star") " is an implementation of the Kleene closure. It is analogous to " (tt "*") " in traditional regular expressions.")) (def (sig (procedure "(star* MATCHER) => MATCHER" (id star*))) (p "Greedy Kleene closure matching.")) (def (sig (procedure "(redo P Q R) => MATCHER" (id redo))) (p "If matcher " (tt "P") " fails (returns an empty list), then invoke matcher " (tt "Q") " on the original input stream, otherwise invoke " (tt "R") " on the result of " (tt "P") "."))) (section 4 "Token procedure" (def (sig (procedure "(tok <Input>) => (LAMBDA TOKEN PROC) => MATCHER" (id tok))) (p "Procedure " (tt "tok") " builds pattern matchers based on character comparison operations. It is intended for matching input sequences of arbitrary kinds, e.g. character lists, strings, or other kinds of sequences. To achieve abstraction over the input sequence kind, " (tt "tok") " is parameterised on a type class named " (tt "<Input>") ". Please see libraries " (int-link "typeclass") " and " (int-link "input-classes") " for information on the type class interface.") (p "As an example, the code below creates an input class for character lists and defines a version of " (tt "tok") " specialized for character lists.") (highlight scheme "(require-extension typeclass input-classes)\n\n(define char-list-<Input>\n  (make-<Input> null? car cdr))\n\n(define char-list-tok (tok <char-list-<Input>))") (p "Once applied to an input class, " (tt "tok") " builds a pattern matcher that, for each stream given, applies a procedure to the given token " (tt "TOKEN") " and an input character. If the procedure returns a true value, that value is prepended to the list of consumed elements, and the input character is removed from the list of input elements."))) (section 4 ((tt "<CharLex>") " type class and related procedures") (p "This library provides several procedures for character matching based on the " (tt "tok") " procedure. These procedures are enumerated as the fields of another typeclas, " (tt "<CharLex>") ", which inherits from the " (tt "<Token>") " typeclass:") (highlight scheme " (define-class <CharLex> (<Token> T)  char set range lit)") (p "The " (tt "<Token>") " typeclass inherits from the " (tt "<Input>") " typeclass and contains only the " (tt "tok") " field:") (highlight scheme " (define-class <Token> (<Input> input)  tok)") (p "This library provides convenience functions to create instances of " (tt "CharLex") " based on different input typeclasses:") (def (sig (procedure "(Input->Token INPUT-CLASS => TOKEN-CLASS)" (id Input->Token))) (p "This procedure takes an instance of the " (tt "<Input>") " typeclass, created by the " (tt "make-<Instance>") " constructor shown above, and returns an instance of the " (tt "<Token>") " typeclass, which in turn contains an instance of " (tt "tok") " specialized for the given input class.")) (def (sig (procedure "(Token->CharLex TOKEN-CLASS => CHARLEX-CLASS)" (id Token->CharLex))) (p "This procedure takes an instance of the " (tt "<Token>") " typeclass, and returns an instance of the " (tt "CharLex") " typeclass, which contains the following procedures:")) (def (sig (procedure "(char CHAR) => MATCHER" (id char))) (p "Matches a single character.")) (def (sig (procedure "(set CHAR-SET) => MATCHER" (id set))) (p "Matches any of a SRFI-14 set of characters.")) (def (sig (procedure "(range CHAR CHAR) => MATCHER" (id range))) (p "Matches a range of characters. Analogous to character class " (tt "[]") ".")) (def (sig (procedure "(lit STRING) => MATCHER" (id lit))) (p "Matches a literal string " (tt "s") "."))) (section 4 "Convenience procedures" (p "These procedures are built from the basic procedures and are provided for convenience.") (def (sig (procedure "(try PROC) => PROC" (id try))) (p "Converts a binary predicate procedure to a binary procedure that returns its right argument when the predicate is true, and false otherwise.")) (def (sig (procedure "(lst MATCHER-LIST) => MATCHER" (id lst))) (p "Constructs a matcher for the sequence of matchers in " (tt "MATCHER-LIST") ".")) (def (sig (procedure "(pass) => MATCHER" (id pass))) (p "This matcher returns without consuming any input.")) (def (sig (procedure "(pos MATCHER) => MATCHER" (id pos))) (p "Positive closure. Analogous to " (tt "+") ".")) (def (sig (procedure "(opt MATCHER) => MATCHER" (id opt))) (p "Optional pattern. Analogous to " (tt "?") ".")) (def (sig (procedure "(bind F P) => MATCHER" (id bind))) (p "Given a rule " (tt "P") " and function " (tt "F") ", returns a matcher that first applies " (tt "P") " to the input stream, then applies " (tt "F") " to the returned list of consumed tokens, and returns the result and the remainder of the input stream.")) (def (sig (procedure "(rebind F G P) => MATCHER" (id rebind))) (p "Given a rule " (tt "P") " and procedures " (tt "F") " and " (tt "G") ", returns a matcher that first applies " (tt "F") " to the input stream, then applies " (tt "P") " to the resulting stream, then applies " (tt "G") " to the resulting list of consumed elements and returns the result along with the remainder of the input stream.")) (def (sig (procedure "(drop P) => MATCHER" (id drop))) (p "Given a rule " (tt "P") ", returns a matcher that always returns an empty list of consumed tokens when " (tt "P") " succeeds."))) (section 4 "Lexer procedures" (def (sig (procedure "(longest STREAM-LIST) => STREAM" (id longest))) (p "Takes the resulting streams produced by the application of a pattern on a stream (or streams) and selects the longest match if one exists. If " (tt "STREAM-LIST") " is empty, it returns " (tt "#F") ".")) (def (sig (procedure "(lex MATCHER ERROR STRING) => CHAR-LIST" (id lex))) (p (tt "lex") " takes a pattern and a string, turns the string into a list of streams (containing one stream), applies the pattern, and returns the longest match. Argument " (tt "ERROR") " is a single-argument procedure called when the pattern does not match anything.")))) (section 3 "Examples" (section 4 "Creating a lexer specialized for lists of characters" (highlight scheme "(require-extension typeclass input-classes lexgen srfi-1 srfi-14 test)\n\n;; The following definitions create matchers {{char}} {{range}}\n;; {{set}} {{lit}} specialized for lists of characters.\n\n(define char-list-<Input>\n  (make-<Input> null? car cdr))\n\n(define char-list-<Token>\n  (Input->Token char-list-<Input>))\n\n(define char-list-<CharLex>\n  (Token->CharLex char-list-<Token>))\n\n(import-instance (<Token> char-list-<Token> char-list/)\n\t\t (<CharLex> char-list-<CharLex> char-list/))")) (section 4 "A pattern to match floating point numbers" (highlight scheme "\n;;  A pattern to match floating point numbers. \n;;  \"-\"?(([0-9]+(\\\\.[0-9]+)?)|(\\\\.[0-9]+))([eE][+-]?[0-9]+)? \n\n(define numpat\n  (let* ((digit        (char-list/range #\\0 #\\9))\n\t (digits       (pos digit))\n\t (fraction     (seq (char-list/char #\\.) digits))\n\t (significand  (bar (seq digits (opt fraction)) fraction))\n\t (exp          (seq (char-list/set \"eE\") (seq (opt (char-list/set \"+-\")) digits)))\n\t (sign         (opt (char-list/char #\\-))))\n    (seq sign (seq significand (opt exp)))))\n \n (define (err s)\n  (print \"lexical error on stream: \" s)\n  (list))\n\n (lex numpat err \"-123.45e-6\")")) (section 4 "Tokens with position information" (highlight scheme "       \n(define-record-type postok\n  (make-postok pos token)\n  postok?\n  (pos        postok-pos )\n  (token      postok-token )\n  )\n\n(define pos? pair?)\n(define pos-row car)\n(define pos-col cdr)\n(define make-pos cons)\n\n(define-record-printer (postok x out)\n  (fprintf out \"#<token ~A: ~A>\" \n\t   (postok-pos x)\n\t   (postok-token x)))\n\t  \n(define (getpos p)\n  (let ((f (lambda (in) (and (pair? in) (postok-pos (car in)))))\n\t(g (lambda (i s) (list (make-postok i (car s))))))\n    (rebind f g p)))\n\n(define pos-<Input>\n  (let ((pos-tail\n\t (lambda (strm)\n\t   (cond ((or (null? strm) (null? (cdr strm)))  '())\n\t\t (else\n\t\t  (let* ((curtok  (car strm))\n\t\t\t (pos0    (postok-pos curtok))\n\t\t\t (pos1    (let ((row0 (pos-row pos0))\n\t\t\t\t\t(col0 (pos-col pos0)))\n\t\t\t\t    (case (cadr strm)\n\t\t\t\t      ((#\\newline)  (make-pos (+ 1 row0) 1))\n\t\t\t\t      ((#\\return)   (make-pos row0 1))\n\t\t\t\t      (else         (make-pos row0 (+ 1 col0))))))\n\t\t\t (res (cons (make-postok pos1 (cadr strm)) (cddr strm))))\n\t\t    res)))))\n\t(pos-null? null?)\n\t(pos-head  (compose postok-token car)))\n    (make-<Input> pos-null? pos-head pos-tail)))\n\n(define pos-<Token>\n  (Input->Token pos-<Input>))\n\n(define pos-<CharLex>\n  (Token->CharLex pos-<Token>))\n\n(import-instance (<Token> pos-<Token> pos/)\n\t\t (<CharLex> pos-<CharLex> pos/))\n\n(define (make-pos-stream strm)\n  (let ((begpos (make-pos 1 1)))\n    (list `(() ,(cons (make-postok begpos (car strm)) (cdr strm))))))\n  \n(define pos-numpat-stream\n  (make-pos-stream (string->list \"-123.45e-6\")))\n\n(define pbnumpat \n  (let* ((digit        (pos/range #\\0 #\\9))\n\t (digits       (star digit))\n\t (fraction     (seq (pos/char #\\.) digits))\n\t (significand  (bar (seq digits (opt fraction)) fraction))\n\t (exp          (seq (pos/set \"eE\") (seq (opt (pos/set \"+-\")) digits)))\n\t (sign         (opt (pos/char #\\-)) )\n\t (pat          (seq (getpos (bind make-sign sign))\n\t\t\t    (seq (getpos (bind make-significand (longest significand)))\n\t\t\t\t (getpos (bind make-exp (longest (opt exp))))))))\n    pat))\n\n(define (pos-num-parser s)  (car (lex pbnumpat err s)))\n"))) (section 3 "Requires" (ul (li (int-link "typeclass")) (li (int-link "input-classes")))) (section 3 "Version History" (ul (li "4.0 Implemented typeclass interface for abstracting over input sequences") (li "3.8 Added procedure " (tt "star*") " (greedy Kleene closure matching)") (li "3.6 Added procedure redo [thanks to Christian Kellermann]") (li "3.5 Bug fixes in bind [reported by Peter Bex]") (li "3.3 Bug fixes in stream comparison") (li "3.2 Improved input stream comparison procedures") (li "3.1 Added rebind combinator and stream-unfold procedure ") (li "3.0 Added an extension mechanism for input streams of different types (to be elaborated and documented in subsequent versions).") (li "2.6 Added bind and drop combinators") (li "2.5 The seq combinator checks whether the first parser in the sequence has failed") (li "2.4 Added (require-library srfi-1); using lset<= instead of equal? in star") (li "2.3 Bug fix in procedure range; added procedure cps-table") (li "2.2 Bug fix in procedure star") (li "2.1 Added procedure lst") (li "2.0 Core procedures rewritten in continuation-passing style") (li "1.5 Using (require-extension srfi-1)") (li "1.4 Ported to Chicken 4") (li "1.2 Added procedures try and tok (supersedes pred)") (li "1.0 Initial release"))) (section 3 "License" (p "Based on the " (link "http://www.standarddeviance.com/projects/combinators/combinators.html" "SML lexer generator by Thant Tessman") ".") (pre " Copyright 2009-2010 Ivan Raikov and the Okinawa Institute of Science and\n Technology.\n\n\n This program is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n This program is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n General Public License for more details.\n\n A full copy of the GPL license can be found at\n <http://www.gnu.org/licenses/>.\n"))))