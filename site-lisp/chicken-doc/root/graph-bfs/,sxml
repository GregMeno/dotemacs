((tags "egg") (section 2 "graph-bfs" (p "Breadth-first search in a graph.") (toc)) (section 2 "Usage" (p "(require-extension graph-bfs)")) (section 2 "Documentation" (p "The graph-bfs library is an implementation of breadth-first search on a graph object that follows the API of e.g. the " (int-link "digraph" "digraph egg") ".") (section 3 "Breadth-first-search procedures" (def (sig (procedure "graph-bfs-foreach:: G FNODE FEDGE ROOTS -> UNDEFINED" (id graph-bfs-foreach))) (p "Breadth-first search iterator; given a list of initial nodes, " (tt "ROOTS") ", the successors of each initial node are visited in breadth-first search order, and procedures " (tt "FNODE") " and " (tt "FEDGE") " are applied to each node or edge, respectively, as the graph is traversed. " (tt "FNODE") " is of the form " (tt "LAMBDA N -> _") " where " (tt "N") " is node number; and " (tt "FEDGE") " is of the form " (tt "LAMBDA EDGE") " where " (tt "EDGE") " is a list of the form " (tt "(I J INFO)") "; " (tt "I") " and " (tt "J") " are the nodes defining the edge, and " (tt "INFO") " is edge metadata.")) (def (sig (procedure "graph-bfs-fold:: G FNODE FEDGE ROOTS NODE-INIT EDGE-INIT -> NODE-STATE EDGE-STATE" (id graph-bfs-fold))) (p "Breadth-first search iterator with state; given a list of initial nodes, " (tt "ROOTS") ", and initial node state and edge state, " (tt "NODE-INIT") " and " (tt "EDGE-INIT") " the successors of each initial node are visited in breadth-first search order, and procedures " (tt "FNODE") " and " (tt "FEDGE") " are applied to each node and the node state, or edge and the edge state, respectively, as the graph is traversed. " (tt "FNODE") " is of the form " (tt "LAMBDA N NODE-STATE -> NODE-STATE") " where " (tt "N") " is node number, and NODE-STATE can be of arbitrary type and must of the same type as " (tt "NODE-INIT") ". " (tt "FEDGE") " is of the form " (tt "LAMBDA EDGE EDGE-STATE") " where " (tt "EDGE") " is a list of the form " (tt "(I J INFO)") "; " (tt "I") " and " (tt "J") " are the nodes defining the edge, and " (tt "INFO") " is edge metadata; " (tt "EDGE-STATE") " must be of the same type as " (tt "EDGE-INIT"))) (def (sig (procedure "graph-bfs-dist:: G ROOTS -> S32VECTOR * MAX-DIST" (id graph-bfs-dist))) (p "Breadth-first search distance; this procedure computes BFS maximum distance from a root node for all successors of the given initial nodes, and the maximum distance from root across all nodes traversed. The node distances are returned in  an SRFI-4 vector of type " (tt "S32VECTOR") " and " (tt "MAX-DIST") " is the maximum distance computed.")))) (section 2 "Examples" (pre ";; example adapted from graph example in the Boost library documentation\n(use srfi-1 digraph graph-bfs)\n\n(define g (make-digraph 'depgraph \"dependency graph\"))\n\n(define used-by\n   (list \n     (cons 'dax_h 'foo_cpp) (cons 'dax_h 'bar_cpp) (cons 'dax_h 'yow_h)\n     (cons 'yow_h 'bar_cpp) (cons 'yow_h 'zag_cpp) (cons 'boz_h 'bar_cpp)\n     (cons 'boz_h 'zig_cpp) (cons 'boz_h 'zag_cpp) (cons 'zow_h 'foo_cpp)\n     (cons 'foo_cpp 'foo_o) (cons 'foo_o 'libfoobar_a) \n     (cons 'bar_cpp 'bar_o) (cons 'bar_o 'libfoobar_a) \n     (cons 'libfoobar_a 'libzigzag_a) (cons 'zig_cpp 'zig_o) \n     (cons 'zig_o 'libzigzag_a) (cons 'zag_cpp 'zag_o) \n     (cons 'zag_o 'libzigzag_a) (cons 'libzigzag_a 'killerapp)))\n\n\n(define node-list (delete-duplicates \n\t\t   (concatenate (list (map car used-by) (map cdr used-by)))))\n\n(define node-ids (list-tabulate (length node-list) values))\n \n(for-each (lambda (i n) ((g 'add-node!) i n)) node-ids node-list)\n(define node-map (zip node-list node-ids))\n\n(for-each (lambda (e) \n\t    (match e ((ni . nj) (let ((i (car (alist-ref ni node-map)))\n\t\t\t\t      (j (car (alist-ref nj node-map))))\n\t\t\t\t  ((g 'add-edge!) (list i j (format \"~A->~A\" ni nj)))))\n\t\t   (else (error \"invalid edge \" e))))\n\t  used-by)\n\n(define roots (map car ((g 'roots))))\n\n(graph-bfs-foreach g \n\t   (lambda (n) (print (format \"node ~A; \" n)))\n\t   (lambda (e) (print (format \"edge ~A; \" e)))\n\t   roots)\n\n(graph-bfs-fold g \n\t       (lambda (n ax) (cons (list 'node n) ax)) \n\t       (lambda (e ax) (cons (list 'edge e) ax)) \n\t       roots (list) (list))")) (section 2 "About this egg" (section 3 "Author" (p (int-link "/users/ivan-raikov" "Ivan Raikov"))) (section 3 "Version history" (dl (dt "1.12") (dd "Documentation converted to wiki format") (dt "1.11") (dd "Added digraph and test as test-dependencies") (dt "1.9") (dd "Ported to Chicken 4") (dt "1.8") (dd "Now using matchable extension") (dt "1.7") (dd "Unit tests updated to use testbase") (dt "1.6") (dd "Build script updated for better cross-platform compatibility") (dt "1.5") (dd "eggdoc documentation fix") (dt "1.4") (dd "License upgrade to GPL v3") (dt "1.3") (dd "Minor updates to the setup script") (dt "1.2") (dd "Added support for chicken-setup -test") (dt "1.1") (dd "Clarification in the section on graph-bfs-dist") (dt "1.0") (dd "Initial release"))) (section 3 "License" (pre "Copyright 2007-2010 Ivan Raikov and the Okinawa Institute of Science and Technology\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or (at\nyour option) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nA full copy of the GPL license can be found at\n<http://www.gnu.org/licenses/>."))))