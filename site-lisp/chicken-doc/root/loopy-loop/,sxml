((tags "egg") (section 2 "Loopy-loop" (p "LOOP is a generalized iteration form supporting extensible iterator macros, keyword updates, and full recursion.  The idea is to create a loop as simple and close to natural Scheme as possible, while still being extensible.") (toc) (section 3 "Introduction" (p "In its most basic usage, LOOP can be used as a drop-in replacement for named let (assuming the let name isn't passed as a first class value). So, for example, the following definitions") (highlight scheme "  (define (fold kons knil ls)\n    (let lp ((ls ls) (knil knil))\n      (if (pair? ls)\n        (lp (cdr ls) (kons (car ls) knil))\n        knil)))") (p "and") (highlight scheme "  (define (fold kons knil ls)\n    (loop lp ((ls ls) (knil knil))\n      (if (pair? ls)\n        (lp (cdr ls) (kons (car ls) knil))\n        knil)))") (p "are equivalent.  We further allow automatic stepping of variables, as in the DO macro:") (highlight scheme "  (define (fold kons knil ls)\n    (loop lp ((ls ls (cdr ls)) (knil knil (kons (car ls) knil)))\n      (if (pair? ls)\n        (lp)\n        knil)))") (p "The parameters have default steps, so we don't need to pass them explicitly anymore (though we can still do so if we wanted to override the defaults).") (p "In addition, we provide extensible iterators to automatically handle the logic of stepping, fetching, and checking termination on sequence types.  To use an iterator, specify one or more variable names followed by `<-' followed by the iterator and any parameters:") (pre " (x <- in-foo bar baz qux)") (p "To iterate over a list, use the IN-LIST macro:") (pre " (x <- in-list ls)") (p "This will bind X to the successive elements of LS in the body of the loop.") (p "Now, when iterating automatically, the loop will also terminate automatically if it encounters the end of its input.  In such a case you may want to specify a return value.  You can do this by putting") (pre " => <expr>") (p "right at the start of the loop body.  So our example now becomes:") (highlight scheme "  (define (fold kons knil ls)\n    (loop lp ((x <- in-list ls) (knil knil (kons x knil)))\n        => knil\n      (lp)))") (p "Note we can still call, or not call, the loop itself in the body according to whatever logic we want, and re-enter it possibly multiple times.  However, in this common case where the entire body is reduced to just calling the loop again, we can omit it by using an anonymous loop:") (highlight scheme "  (define (fold kons knil ls)\n    (loop ((x <- in-list ls) (knil knil (kons x knil)))\n       => knil))") (p "No flexibility is lost over named let, yet we've gained the convenience of iterators.  If you wanted to change the above to work on vectors, all you would need to do is change the iterator:") (pre " (x <- in-vector vec)") (p "and it works as expected.")) (section 3 "Bindings and scope" (p "Iterator macros may introduce variables in three different lexical scopes:") (dl (dt "Loop variables") (dd "Analogous to the variables in a named let, these are initialized once and updated on each iteration through the loop.  In the example above, KNIL is a loop variable (as are all named let and DO-style variables).") (dt "Body variables") (dd "Bound in the body, these are usually derived directly from loop variables.  They can't be overridden (see below) and are not available in the final expression.  In the example above, X is a body variable.") (dt "Final variables") (dd "Bound once in the return expression, these are sometimes used for some final computation such as reversing a consed up list.")) (p "Within each of these three lexical scopes, all variables are updated in parallel, and none are ever mutated (unless the programmer does so manually).  This referential transparency is important to achieve full non-tail recursion and re-entrancy.") (p "In many cases the loop variables will be implicit and unnamed.  For instance, IN-LIST uses a loop variable to cdr down the list of pairs, binding X to the successive cars.  However, in such cases the iterator usually lets you explicitly name the loop variable if you want access to it.") (p "Loop variables may be manually overridden on a recursive call.  You can either use the original positional arguments, or specify individual values by name with the <- syntax, punning the initial binding.  Thus in") (pre "  (loop lp ((x ls <- in-list ls)) ...)") (p "the recursive calls") (pre "  (lp)\n  (lp (cdr ls))\n  (lp ls <- (cdr ls))") (p "are all the same.  Note that we are binding the loop variable LS, not X which is considered to be always derived from the loop variable. Note also that there is no need to recurse on CDR - we could use CDDR, or a completely unrelated list, or '() to force an early termination.") (p "The following example flattens a tree into a list, using minimal conses and stack.  This serves as an example of naming implicit loop variables, binding loop variables, and non-tail recursion.") (highlight scheme "  (define (flatten ls)\n    (reverse\n     (loop lp ((x ls <- in-list ls) (res '()))\n         => res\n       (if (pair? x)\n           (lp res <- (lp ls <- x))\n           (lp res <- (cons x res))))))") (p "The scope of the final expression will include all the final variables, as well as all the last instances of all the loop variables, at least one of which will correspond to a true termination condition (you could manually check the others to see if the sequence lengths were uneven).  The body variables are not bound, however the loop itself, if named, is available so that you can restart the loop with all new initial values if you want.")) (section 3 "Iterators" (section 4 "in-list" (pre "syntax: (<element> [<pair>] <- in-list <list> [<cdr> [<null?>]])") (p "Iterates over the successive elements of a list.") (highlight scheme "  ;;; Simple loop\n  > (loop ((x <- in-list '(a b c))) (write x) (newline))\n  a\n  b\n  c\n\n  ;;; Reverse a list destructively.\n  (define (reverse! list)\n    (loop ((elt pair <- in-list list)\n           (tail '() pair))\n        => tail\n      (set-cdr! pair tail)))\n\n  ;;; Test for circularity\n  (define (cddr* ls) ; CL's cddr\n    (if (pair? (cdr ls)) (cddr ls) '()))\n\n  (define (circular-list? ls)\n    (and (pair? ls)\n         (loop race ((tortoise <- in-list ls)\n                     (hare <- in-list (cdr ls) cddr*))\n             => #f\n           (or (eq? hare tortoise) (race)))))")) (section 4 "in-lists" (pre "syntax: (<elements> [<pairs>] <- in-lists <lol> [<cdr> [<null?>]])") (p "Iterate over a list of lists.  <elements> is bound to the heads of each of the lists in <lol>.  The CDR and NULL? options can be specified as in IN-LIST.") (highlight scheme "  (define (any pred . lol)\n    (loop lp ((elts <- in-lists lol))\n        => #f\n      (or (apply pred elts) (lp))))")) (section 4 "in-string / in-string-reverse" (pre "syntax: (<element> [<index>] <- in-string <str> [<start> [<end> [<step>]]])\nsyntax: (<element> [<index>] <- in-string-reverse <str> [<start> [<end> [<step>]]])") (p "Iterate over the characters of a string.  Proceeds from <start>, inclusive, to <end>, exclusive.  By default <start> is 0 and <end> is the string length, thus iterating over every character.") (p "You can specify a step other than the default 1, for example 2 to iterate over every other character.") (p "The reverse version steps from one less than the end, continuing until you step below the start.  Thus with the same <start> and <end> and a <step> of 1 (or any divisor of the difference), the two forms will iterate over the same characters but in the reverse order.") (p "Note this works correctly with the utf8 egg, but is not optimal in such cases because the use of numeric indexes is slow.")) (section 4 "in-vector / in-vector-reverse" (pre "syntax: (<element> [<index>] <- in-vector <vec> [<start> [<end> [<step>]]])\nsyntax: (<element> [<index>] <- in-vector-reverse <vec> [<start> [<end> [<step>]]])") (p "Analogues of the string iterators, but for vectors.  Note also all of the SRFI-4 uniform vectors can iterated over as in-u8vector, etc.")) (section 4 "in-port / in-file" (pre "syntax: (<datum> <- in-port [<port> [<reader> [<eof?>]]])\nsyntax: (<datum> <- in-file <path> [<reader> [<eof?>]])") (p "Iterate over data read from a port, defaulting to (CURRENT-INPUT-PORT) for IN-PORT, and a port opened by (OPEN-INPUT-FILE <path>) for IN-FILE.  The reader defaults to READ-CHAR?, and the termination test defaults to EOF-OBJECT?.") (p "The stateful nature of ports means that these are not referentially transparent, and you can't save a loop iteration to go back to later. In particular, IN-FILE will close its port on the first termination, causing an error if you attempt to re-enter the same loop again.") (highlight scheme "  (define (read-mime-headers port)\n    (loop lp ((line <- in-port port read-line)\n              (res '() (cons line res)))\n        => (reverse res) ; eof case\n      (if (string-null? line)\n        (reverse res)\n        (lp))))\n\n  ;; alternate version with a custom termination test\n  (define (read-mime-headers port)\n    (loop lp ((line <- in-port port read-line\n                       (disjoin eof-object? string-null?))\n              (res <- collecting line))\n        => res))\n\n  (define (file->sexp-list path)\n    (loop ((x <- in-file path read) (ls <- collecting x)) => x))")) (section 4 "in-range / in-range-reverse" (pre "syntax: (<number> <- in-range [[<from>] <to> [<step>]])\nsyntax: (<number> <- in-range-reverse [[<from>] <to> [<step>]])") (p "Step through the real numbers beginning with <from> (default 0), until they would be greater than (less then in the -reverse case) or equal to <to> (thus <to> is never included).  <step> defaults to 1.") (p "Two arguments indicate <from> and <to>, so provide the default <from> of 0 if you're only interested in <to> and <step>.") (p "These macros are subject to change in the near future.")) (section 4 "in-random" (pre "syntax: (<number> <- in-random [<range> [<low>]])") (p "With no arguments, <number> is bound to a random inexact number uniformly distributed over 0.0 and 1.0, inclusive, on each iteration.") (p "With a single argument, <number> is bound to a random integer uniformly distributed over 0..<range>-1, inclusive.") (p "With two arguments, <number> is bound to a random integer uniformly distributed over <low>..<low>+<range>-1, inclusive.") (p "These are conceptually infinite sequences, and themselves never cause the loop to terminate.")) (section 4 "in-random-element" (pre "syntax: (<element> <- in-random-element <vector-or-list>)") (p "On each iteration, <element> is bound a random object uniformly chosen from the elements of the <vector-or-list> source.") (p "Elements may be repeated, so this is a conceptually infinite sequence.")) (section 4 "in-permutations" (pre "syntax: (<perm> <- in-permutations <list> [<n>])") (p "With one argument, <perm> is bound to the successive permutations of the elements of <list> in lexicographic order.  No assumptions about the elements are made - if <list> is a multi-set, duplicate permutations will arise.") (p "This is very fast and mutation free.  It uses only O(k) space, where k is the number of elements in <list>.  Beware that the number of permutations of n elements is n!, which grows extremely fast.") (highlight scheme "  > (loop ((p <- in-permutations '(a b c) 2)) (write p) (newline))\n  (a b)\n  (a c)\n  (b a)\n  (b c)\n  (c a)\n  (c b)")) (section 4 "in-combinations" (pre "syntax: (<comb> <- in-combinations <list> <n>)") (p "Similar to IN-PERMUTATIONS, but iterates over all combinations of <n> elements from <list> (i.e. order doesn't matter).") (highlight scheme "  > (loop ((c <- in-combinations '(a b c) 2)) (write c) (newline))\n  (a b)\n  (a c)\n  (b c)") (p "Using permutations and combinations can be a convenient way to build very extensive (albeit brute-force) test suites, among other things.")) (section 4 "in-cartesian-product" (pre "syntax: (<list> <- in-cartesian-product <list-of-lists>)") (p "Iterates over the full cartesian product (all joins) of <list-of-lists>, lexicographically (the rightmost list changes first).") (highlight scheme "  > (loop ((x <- in-cartesian-product '((a b) (c d e)))) (write x) (newline))\n  (a c)\n  (a d)\n  (a e)\n  (b c)\n  (b d)\n  (b e)")) (section 4 "in-hash-table" (pre "syntax: (<key> <value> <- in-hash-table <table>)") (p "Iterate over the <key> and <value> pairs of a hash-table <table>.  The current <key> being iterated over may be deleted from the table or have its value in the table changed safely.") (p "The result is unspecified if you add or remove other values to the table while it is being iterated over.  If you want to capture a safe snapshot of the table first, you can convert it to an alist and iterate over those values.") (highlight scheme "  (define (hash-table-purge! pred table)\n    (loop ((k v <- in-table table))\n      (if (pred k v)\n        (hash-table-delete! table k))))")) (section 4 "collecting" (pre "syntax: (<list> [<rev>] <- collecting <expr> [<cons> [<finalize> [<init>]]])") (p "The only of the standard iterators that introduces a final variable. <list> is bound only in the => final clause.  By default,") (ul (li "a <cons> of APPEND-REVERSE will append all the <expr>'s into a list.") (li "a <finalize> of REVERSE-LIST->VECTOR will collect a vector, and IDENTITY will collect a reversed list.")) (p "By specifying all of <cons>, <finalize> and <init> you could collect into any data structure.") (p "The optional <rev> is a loop variable representing the intermediate consed results.  You may override this manually to include or exclude values, or even reset the collected results mid-loop.") (p "This is really just syntactic sugar over an accumulated list to save you the trouble of reversing manually at the end."))) (section 3 "Implicit matching" (p "For any body variable (as described above, the ones derived from iterators, e.g. the elements in a list), instead of a simple name you can use any sexp, and it will be matched against the result as in Common-Lisp's destructuring-bind, except using the " (int-link "matchable") " syntax (described in " (link "http://wiki.call-cc.org/Pattern%20matching" "Pattern Matching") ".  So for example, to iterate nicely over the pairs in an alist, you just do") (highlight scheme "  (loop (((k . v) <- in-list alist))\n    (print \"key: \" k \" value: \" v))") (p "This costs nothing if you don't use it, and is fast even if you do.")) (section 3 "Extending" (p "Adding your own iterators is easy.  When a loop includes a binding such as") (highlight scheme "  (left ... <- in-iterator right ...)") (p "then the iterator itself is called as a macro in the following form:") (highlight scheme "  (in-iterator ((left ...) (right ...)) next . rest)") (p "where next and rest are the continuation.  The continuation expects to be passed the appropriate information to insert in the loop, in the following form:") (highlight scheme "  (next ((temp-var value) ...)     ; one-time bindings outside the loop\n        ((loop-var init step) ...) ; do-style description of loop variables\n        (done? ...)                ; termination tests\n        ((body-var value) ...)     ; body variables\n        ((final-var value) ...)    ; final result bindings in => clause\n        . rest)") (p "Note that any or all of the terms may be empty lists - the iterator doesn't have to do anything.") (p "As an example, consider the following simplified implementation of IN-LIST:") (highlight scheme "  (define-syntax in-list\n    (syntax-rules ()\n      ((in-list ((elt) (init-list)) next . rest)\n       ;; pass the info to next\n       (next ()                              ; no outer let bindings\n             ((ls init-list (cdr ls)))       ; loop variable, init, step\n             ((null? ls))                    ; termination tests\n             ((elt (car ls)))                ; body variables and values\n             ()                              ; no final result bindings\n             . rest))))") (p "This implementation of IN-LIST causes the code") (highlight scheme "  (loop ((x <- in-list '(1 2 3)))\n    (print x))") (p "to expand to") (highlight scheme "  (let ((ls '(1 2 3)))\n    (if (null? ls)\n      (if #f #f) ; unspecified value returned by default\n      (let ((x (car ls)))\n        (print x)\n        (lp (cdr ls)))))") (p "Note the outer let bindings are empty because we don't have anything to remember - the loop just proceeds by cdr'ing down the LS loop variable.  In an interator such as IN-VECTOR, where you repeatedly VECTOR-REF the same vector, you'd want to bind the vector once so that it's not evaluated multiple times.") (p "The final result bindings are also usually empty.  Currently it's only used by COLLECTING to reverse the list that has been accumulated so far.")) (section 3 "Further reading" (p "See the article with message-id " (link "http://groups.google.com/group/comp.lang.scheme/msg/60dcac5ea812398" "<1157562097.001179.11470@i42g2000cwa.googlegroups.com>") " posted on comp.lang.scheme in September of 2006 for the original version and a brief history of Lisp iteration constructs.")) (section 3 "Requirements" (p (int-link "matchable"))) (section 3 "License" (p "public domain")) (section 3 "History" (dl (dt "0.5") (dd "srfi-4 uniform vectors and in-cartesian-product") (dt "0.4") (dd "fixing bug in IN-FILE") (dt "0.3") (dd "minor changes and cleanup") (dt "0.2") (dd "implicit matching") (dt "0.1") (dd "initial release")))))