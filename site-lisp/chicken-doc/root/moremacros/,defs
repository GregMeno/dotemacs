(index ("type-case" 0) ("type-case*" 753) ("whennot" 1169) ("swap-set!" 1280) ("fluid-set!" 1463) ("stiff-set!" 1608) ("set!/op" 1751) ("assure" 2154) ("make-reference-let" 2351) ("NAME" 3079) ("hash-let" 3928) ("++" 5263) ("--" 5482) ("fx++" 5701) ("fx--" 5779) ("fp++" 5857) ("fp--" 5935) ("fl++" 6013) ("fl--" 6116) ("++!" 6219) ("--!" 6286) ("fx++!" 6353) ("fx--!" 6431) ("fp++!" 6509) ("fp--!" 6587) ("fl++!" 6665) ("fl--!" 6768))
(def (sig (syntax "(type-case EXPRESSION [(TYPE-CASE BODY ...) ...]))" (id type-case))) (p "Expands into a form that selects a " (tt "TYPE-CASE") " based on the type of the " (tt "EXPRESSION") ".") (p "A " (tt "TYPE-CASE") " is:") (dl (dt (tt "symbol")) (dd "the base name of a type predicate") (dt "(" (tt "symbol") " " (tt "symbol") "...)") (dd "a list of base names") (dt (tt "else")) (dd "an else clause")) (p "The actual name of the predicate is built from the base name and a " (tt "?") " suffix. So a base name " (tt "number") " has the predicate " (tt "number?") ".") (highlight scheme "(use moremacros)\n\n(type-case 23\n  ((symbol string char) 'symbolic)\n  (number               'numeric)\n  (else                 'otheric) )\n;=> numeric"))
(def (sig (syntax "(type-case* EXPRESSION [(TYPE-TEST BODY ...) ...]))" (id type-case*))) (p "Like " (tt "type-case") " but binds local variable " (tt "it") " to the value of " (tt "EXPRESSION") ".") (highlight scheme "(use moremacros)\n\n(type-case* 23\n  ((symbol string char) (list it 'symbolic) )\n  (number               (list it 'numeric) )\n  (else                 (list it 'otheric) ) )\n;=> (23 numeric)"))
(def (sig (syntax "(whennot TEST [BODY ...]))" (id whennot))) (p "Synonym for " (tt "miscmacros#unless") "."))
(def (sig (syntax "(swap-set! VAR1 VAR2))" (id swap-set!))) (p "Swap settings of " (tt "VAR1") " & " (tt "VAR2") ".") (p "Like " (tt "(exchange! VAR1 VAR2)") " but lower overhead."))
(def (sig (syntax "(fluid-set! VAR VAL ...))" (id fluid-set!))) (p "Set each variable " (tt "VAR") " to the value " (tt "VAL") " in parallel."))
(def (sig (syntax "(stiff-set! VAR VAL ...))" (id stiff-set!))) (p "Set each variable " (tt "VAR") " to the value " (tt "VAL") " in series."))
(def (sig (syntax "(set!/op VAR OP ARG...))" (id set!/op))) (p "Sets " (tt "VAR") " to the value of " (tt "(OP ARG...)") ", where an occurrence of <> in " (tt "ARG...") " is replaced with " (tt "VAR") ".") (p "When there is no occurrence of <> in " (tt "ARG...") " the template " (tt "(OP <> ARG...)") " is used.") (p "Similar to the C language family " (tt "<l-value> <bin-op-assign> <r-value>") "."))
(def (sig (syntax "(assure EXPRESSION [ERROR-ARGUMENT...]))" (id assure))) (p "When " (tt "EXPRESSION") " yields value " (tt "#f} invoke {{(error ERROR-ARGUMENT...)") ", otherwise return value."))
(def (sig (syntax "(make-reference-let NAME REFERENCE-FUNCTION)" (id make-reference-let))) (p (tt "NAME") " is a " (tt "symbol") ", the name of generated " (i "reference-let") " macro.") (p (tt "REFERENCE-FUNCTION") " is a " (tt "(procedure (* * *) *)") " with arguments:") (dl (dt (tt "TABLE")) (dd "some data-structure instance that reifies a set of key+value abstraction") (dt (tt "KEY")) (dd "identifier for a possible entry in the " (tt "TABLE")) (dt (tt "DEFAULT")) (dd "in case an entry for the " (tt "KEY") " does not exist")) (p "The " (tt "REFERENCE-FUNCTION") " is to return the value for " (tt "KEY") " in the " (tt "TABLE") ", otherwise the " (tt "DEFAULT") " value.") (p "The generated macro has the signature:"))
(def (sig (syntax "(NAME ((((VAR | (VAR) | (VAR KEY [DEFAULT]))...) TABLE)...) BODY...))" (id NAME))) (p "Decompose " (tt "TABLE") " entries into variable bindings. Should the " (tt "KEY") " not be a " (tt "symbol") ", or the desired variable name " (tt "VAR") ", as " (tt "'VAR") ", is not the key, the " (tt "(VAR KEY [DEFAULT])") " form can be used.") (p "The default for " (tt "DEFAULT") " is " (tt "#f") ".") (p "The " (tt "BODY...") " is evaluated with the specified bindings.") (p "See " (int-link "hash-let") " for an example of use.") (ul (li (i "Note") " that only one type of " (tt "TABLE") " is supported. As yet there is no syntax for generating a " (i "reference-let") " supporting multiple table types. While such a beast is possible just using nested " (i "reference-lets") " gets the same effect without the necessary overhead.")))
(def (sig (syntax "(hash-let ((((VAR | (VAR) | (VAR KEY [DEFAULT]))...) HASH-TABLE)...) BODY...))" (id hash-let))) (p "Decompose " (tt "HASH-TABLE") " entries into variable bindings. Should the " (tt "KEY") " not be a " (tt "symbol") ", or the desired variable name " (tt "VAR") " is not the key, the " (tt "(VAR KEY [DEFAULT])") " form can be used.") (p "The default value for a missing hash-table entry is " (tt "#f") " but can be specified with the " (tt "(VAR KEY DEFAULT)") " form.") (p "The " (tt "BODY...") " is evaluated with the specified bindings.") (highlight scheme "(use hash-let srfi-69)\n\n(define tbl (make-hash-table))\n\n(hash-table-set! tbl 'abc \"commercial network\")\n(hash-table-set! tbl \"abc\" \"commercial network\")\n(hash-table-set! tbl 'cbs \"commercial network\")\n(hash-table-set! tbl \"cbs\" \"commercial network\")\n\n(hash-let ((((abc) (cbs \"cbs\")) tbl )\n           (((pbs (string-append \"p\" \"bs\") #t) tbs) tbl ) )\n  (print 'abc \" is a \" abc) (print \"cbs\" \" is a \" cbs)\n  (print (string-append \"p\" \"bs\") \" is a \" pbs)\n  (print 'tbs \" is a \" tbs) )") (p "This prints the following:") (pre "abc is a commercial network\ncbs is a commercial network\npbs is a #f\ntbs is a ?") (p (tt "hash-let") " is actually " (tt "(generic-reference-let hash-let hash-table-ref/default)") "."))
(def (sig (syntax "(++ VAL)" (id ++))) (p "Read-only increment.") (p "When " (tt "VAL") " is a numeric literal the strongest operation available is used in the generated expression, based on the type of the literal."))
(def (sig (syntax "(-- VAL)" (id --))) (p "Read-only decrement.") (p "When " (tt "VAL") " is a numeric literal the strongest operation available is used in the generated expression, based on the type of the literal."))
(def (sig (syntax "(fx++ VAL)" (id fx++))) (p "Read-only fixnum increment."))
(def (sig (syntax "(fx-- VAL)" (id fx--))) (p "Read-only fixnum decrement."))
(def (sig (syntax "(fp++ VAL)" (id fp++))) (p "Read-only flonum increment."))
(def (sig (syntax "(fp-- VAL)" (id fp--))) (p "Read-only flonum decrement."))
(def (sig (syntax "(fl++ VAL)" (id fl++))) (p "Read-only flonum increment.") (p "R6RS nomenclature."))
(def (sig (syntax "(fl-- VAL)" (id fl--))) (p "Read-only flonum decrement.") (p "R6RS nomenclature."))
(def (sig (syntax "(++! VAR)" (id ++!))) (p "Mutable increment."))
(def (sig (syntax "(--! VAR)" (id --!))) (p "Mutable decrement."))
(def (sig (syntax "(fx++! VAR)" (id fx++!))) (p "Mutable fixnum increment."))
(def (sig (syntax "(fx--! VAR)" (id fx--!))) (p "Mutable fixnum decrement."))
(def (sig (syntax "(fp++! VAR)" (id fp++!))) (p "Mutable flonum increment."))
(def (sig (syntax "(fp--! VAR)" (id fp--!))) (p "Mutable flonum decrement."))
(def (sig (syntax "(fl++! VAR)" (id fl++!))) (p "Mutable flonum increment.") (p "R6RS nomenclature."))
(def (sig (syntax "(fl--! VAR)" (id fl--!))) (p "Mutable flonum decrement.") (p "R6RS nomenclature."))
