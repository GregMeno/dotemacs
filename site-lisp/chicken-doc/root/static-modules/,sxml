((tags "eggs") (toc) (section 2 "static-modules" (section 3 "Description" (p (tt "static-modules") " is a Scheme implementation of the module system described by Xavier Leroy in the paper " (link "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.4138" "A Modular Module System") ".")) (section 3 "Library Procedures" (section 4 "Identifiers" (def (sig (procedure "(ident? X) -> BOOL" (id ident?))) (p "Returns " (tt "#t") " if " (tt "X") " is an identifier, " (tt "#f") " otherwise.")) (def (sig (procedure "(ident-name IDENT) -> STRING" (id ident-name))) (p "Returns the string name associated with the given identifier.")) (def (sig (procedure "(ident-stamp IDENT) -> INT" (id ident-stamp))) (p "Returns the unique stamp of the given identifier.")) (def (sig (procedure "(ident-create NAME) -> IDENT" (id ident-create))) (p "Returns a fresh identifier associated with the given name.")) (def (sig (procedure "(ident-equal? IDENT IDENT) -> BOOL" (id ident-equal?))) (p "Returns " (tt "#t") " if the stamps of the given identifiers are equal, " (tt "#f") " otherwise.")) (def (sig (procedure "(ident-empty) -> IDENV" (id ident-empty))) (p "Returns an empty identifier environment.")) (def (sig (procedure "(ident-add IDENT DATA IDENV) -> IDENV" (id ident-add))) (p "Adds the given identifier and associated data to the given identifier environment.")) (def (sig (procedure "(ident-find IDENT IDENV) -> DATA" (id ident-find))) (p "Looks up the given identifier in the given identifier environment and returns the associated data, or " (tt "#f") " if not found."))) (section 4 "Access paths" (p "We refer to named types, values (variables), and modules either by identifier (if we are in the scope of their binding) or via the dot notation, e.g. " (tt "M.x") " to refer to component " (tt "x") " of module " (tt "M") ". Access paths represent both kinds of references.") (def (sig (procedure "(path? X) -> BOOL" (id path?))) (p "Returns " (tt "#t") " if " (tt "X") " is an access path, " (tt "#f") " otherwise.")) (def (sig (procedure "(Pident IDENT) -> PATH" (id Pident))) (p "Returns a path consisting of the given identifier.")) (def (sig (procedure "(Pdot PATH STRING) -> PATH" (id Pdot))) (p "Returns an access path for the given path and field.")) (def (sig (procedure "(path-equal? PATH PATH) -> BOOL" (id path-equal?))) (p "Returns " (tt "#t") " if the two given paths are equal, " (tt "#f") " otherwise."))) (section 4 "Substitutions" (def (sig (procedure "(subst-add IDENT PATH IDENV) -> IDENV" (id subst-add))) (p "Extends the substition environment with the given identifier and path.")) (def (sig (procedure "(subst-path PATH IDENV) -> PATH" (id subst-path))) (p "Applies the given substitutions to the given path.")) (def (sig (procedure "(subst-identity) -> IDENV" (id subst-identity))) (p "Returns an empty substitution environment."))) (section 4 "Abstract syntax for the base language" (def (sig (procedure "(make-core-syntax term? valtype? deftype? kind? make-valtype make-deftype subst-valtype subst-deftype subst-kind)" (id make-core-syntax))) (p "This procedure creates the structure describing base language syntax. The meaning of the fields is as follows:") (ul (li (tt "term?") ": predicate for value expressions") (li (tt "valtype?") ": predicate for type expressions") (li (tt "deftype?") ": predicate for type definitions") (li (tt "kind?") ": predicate for the kinds that a type definition can have") (li (tt "make-valtype") ": constructor for type expressions") (li (tt "make-deftype") ": constructor for type definitions") (li (tt "subst-valtype") ": substitution function for type expressions") (li (tt "subst-deftype") ": substitution function for type definitions") (li (tt "subst-kind") ": substitution function for kinds")))) (section 4 "Abstract syntax for the module language " (def (sig (procedure "(make-mod-syntax core)" (id make-mod-syntax))) (p "This procedure creates the structure describing module language syntax. " (tt "core") " is an object created by " (tt "make-core-syntax") ". This procedure returns multiple values with the following meaning:") (ul (li (tt "modtype?") " " (tt "Signature") " " (tt "Functorty") ": predicate and constructors for module type definitions") (li (tt "modspec?") " " (tt "Value_sig") " " (tt "Type_sig") " " (tt "Module_sig") ": predicate and constructors for module type expressions") (li (tt "modterm?") " " (tt "Modid") " " (tt "Structure") " " (tt "Functor") " " (tt "Mapply") " " (tt "Constraint") ": module term constructors") (li (tt "moddef?") "  " (tt "Value_def") " " (tt "Type_def") " " (tt "Module_def") ": predicate and constructor for module definitions") (li (tt "subst-modtype") " " (tt "subst-modspec") " " (tt "subst-typedecl") ": substitution procedures")))) (section 4 "Type-checking the base language " (def (sig (procedure "(make-core-typing type-term kind-deftype check-valtype check-kind valtype-match deftype-equiv kind-match deftype-of-path)" (id make-core-typing))) (p "This procedure creates the structure describing base language type checking. The meaning of the fields is as follows:") (ul (li (tt "type-term") ": the main typing function, which takes a type and an environment, and returns the principal type of the term in the given environment") (li (tt "kind-deftype") ": infers and returns the kind of the given definable type") (li (tt "check-valtype") " " (tt "check-kind") ": check the well-formedness of type and kind expressions in the base language") (li (tt "valtype-match") " " (tt "deftype-equiv") " " (tt "kind-match") ": checking values vs. signatures") (li (tt "deftype-of-path") ": transforms a type path and its kind into the corresponding definable type")))) (section 4 "Type-checking the module language " (def (sig (procedure "(make-mod-typing core-syntax core-typing)" (id make-mod-typing))) (p "This procedure creates the structure describing module language type checking. " (tt "core-syntax") " is an object created by " (tt "make-core-syntax") ", and " (tt "core-typing") " is an object created by " (tt "make-core-typing") ". This procedure returns multiple values with the following meaning:") (ul (li (tt "check-modtype") ": checks the well-formedness of a module type") (li (tt "check-signature") ": checks the well-formedness of a signature") (li (tt "type-modterm") ": infers and returns the type of a module term") (li (tt "type-moddef") ": infers and returns the type of a module definition (sequence of definitions)") (li (tt "type-definition") ": infers and returns the type of a definition (inside a module or at toplevel)")))) (section 4 "Scoping" (p "This library implements generic scoping pass for the module language. This pass is not described in the paper.") (p "Scoping is the act of associating identifiers with their binding location.  We assume that the parser generates fresh identifiers each time it encounters an occurrence of a lexical identifier in the program, and stores those fresh identifiers in the abstract syntax tree it constructs.  The scoping pass rewrites the abstract syntax tree to use identical identifiers at a binding site and at all its usage sites.") (def (sig (procedure "st-empty" (id st-empty))) (p "Empty scoping table.")) (def (sig (procedure "(st-enter-value ID SC) -> SC" (id st-enter-value))) (p "Enters a value identifier in the given scoping table.")) (def (sig (procedure "(st-enter-type ID SC) -> SC" (id st-enter-type))) (p "Enters a type identifier in the given scoping table.")) (def (sig (procedure "(st-enter-module ID SC) -> SC" (id st-enter-module))) (p "Enters a module identifier in the given scoping table.")) (def (sig (procedure "(st-value-path PATH SC) -> PATH" (id st-value-path)))) (def (sig (procedure "(st-type-path PATH SC) -> PATH" (id st-type-path)))) (def (sig (procedure "(st-module-path PATH SC) -> PATH" (id st-module-path)))) (def (sig (procedure "(st-scope-module PATH SC) -> PATH" (id st-scope-module))))) (section 4 "Evaluation" (def (sig (procedure "(make-mod-eval core-eval enter-val) -> LAMBDA (ENV MODDEF) " (id make-mod-eval))) (p "Support for module evaluation.")))) (section 3 "Version History" (ul (li "1.0 Initial Release"))) (section 3 "License" (p (tt "static-modules") " is based on the code and paper by Xavier Leroy (2000): A modular module system. Journal of Functional Programming, 10, pp 269-303") (pre "Copyright 2010 Ivan Raikov and the Okinawa Institute of\nScience and Technology.\n\nThis program is free software: you can redistribute it and/or\nmodify it under the terms of the GNU General Public License as\npublished by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nA full copy of the GPL license can be found at\n<http://www.gnu.org/licenses/>."))))