((tags "egg") (section 2 "dyn-vector" (p "Dynamic (dense) vectors based on SRFI-43.") (toc)) (section 2 "Usage" (p "(require-extension dyn-vector)")) (section 2 "Documentation" (p "The dyn-vector library is an implementation of a dynamically-growing vector, based on " (link "http://srfi.schemers.org/srfi-43/" "SRFI-43") ". An attempt to set the " (tt "i") "'th element of a dynvector of underlying size n causes the dynvector to grow to size " (tt "2n") ", " (tt "i+1") ", or " (tt "16") ", whichever is greatest. The semantics of this library follow SRFI-43 closely, with the exception of the following procedures:") (def (sig (procedure "dynvector-ref vect i" (id dynvector-ref))) (p "If the index " (tt "i") " is greater than the current size of the vector, this procedure returns the default value specified when the dynamic vector was created.")) (def (sig (procedure "dynvector-set! vect i e" (id dynvector-set!))) (p "If the index " (tt "i") " is greater than the current size of the vector, the vector size is increased to " (tt "max(2*N,i+1)") " and the new element is then inserted in the vector.")) (def (sig (procedure "dynvector-clear! vect n" (id dynvector-clear!))) (p "This procedure removes all elements from the dynamic vector, and sets the size of the vector to " (tt "n") ".")) (def (sig (procedure "dynvector-extend! vect n" (id dynvector-extend!))) (p "This procedure explicitly resizes the dynamic vector to the specified size.")) (def (sig (procedure "dynvector-tabulate f len [dflt]" (id dynvector-tabulate))) (p "If the optional argument " (tt "dflt") " is specified, it is used as default value, otherwise the first element in the vector is used as default value.")) (def (sig (procedure "list->dynvector lst [dflt] -> dynvector" (id list->dynvector))) (p "If the optional argument " (tt "dflt") " is specified, it is used as default value, otherwise the first element in the list is used as default value.")) (section 3 "Procedures" (def (sig (procedure "dynvector? x -> boolean" (id dynvector?))) (p "Returns " (tt "#t") " if " (tt "x") " is a dynamic vector, " (tt "#f") " otherwise.")) (def (sig (procedure "dynvector-tabulate f len [dflt]" (id dynvector-tabulate))) (p "Creates a new dynamic vector of length " (tt "len") " and iterates across each index, applying f at each iteration to the current index; if the optional argument " (tt "dflt") " is specified, it is used as default value, otherwise the first element in the vector is used as default value.")) (def (sig (procedure "list->dynvector lst [dflt] -> dynvector" (id list->dynvector))) (p "Creates a dynamic vector with the elements of the given list; if the optional argument " (tt "dflt") " is specified, it is used as default value, otherwise the first element in the vector is used as default value.")) (def (sig (procedure "make-dynvector n default -> dynvector" (id make-dynvector))) (p "Creates a dynamic vector of length " (tt "n") " and fills it with value " (tt "default") ".")) (def (sig (procedure "dynvector-clear! x n -> unspecified" (id dynvector-clear!))) (p "Removes all elements from the given dynamic vector, and sets the size of the vector to " (tt "n") ".")) (def (sig (procedure "dynvector-length x -> integer" (id dynvector-length))) (p "Returns the length of the given dynamic vector.")) (def (sig (procedure "dynvector-ref x i -> value" (id dynvector-ref))) (p "Returns the element at index " (tt "i") "of the given dynamic vector" (tt "x") ".")) (def (sig (procedure "dynvector-set! x i e -> unspecified" (id dynvector-set!))) (p "Updates the element at index " (tt "i") "of the given dynamic vector" (tt "x") "; if the index " (tt "i") " is greater than the current size of the vector, the vector size is increased to " (tt "max(2*N,i+1)") " and the new element is then inserted in the vector.")) (def (sig (procedure "dynvector-expand! x  n -> unspecified" (id dynvector-expand!))) (p "Expands the size of the dynamic vector to the given size " (tt "n") ".")) (def (sig (procedure "dynvector-for-each f x1 ... -> unspecified" (id dynvector-for-each))) (p "Dynamic vector iterator: applies " (tt "f") "to each index in the  range " (tt "[0, k)") ", where " (tt "k") " is the length of the smallest dynamic vector argument passed, and the respective list of parallel elements from " (tt "x1") " ...  at that index.")) (def (sig (procedure "dynvector-map f x1 ... -> dynvector" (id dynvector-map))) (p "Constructs a new dynamic vector of the shortest size of the given dynamic vector; each element at index " (tt "i") " of the new dynamic vector is mapped from the old vectors by " (tt "f i  (dynvector-ref  x1 i) ...") ".")) (def (sig (procedure "dynvector-copy x -> dynvector" (id dynvector-copy))) (p "Creates a copy of the given dynamic vector.")) (def (sig (procedure "dynvector-fold f initial x1 ... -> state" (id dynvector-fold))) (p "Left-to-right dynamic vector iterator with state. " (tt "f") " is iterated over each index in all of the vectors, stopping at the end of the shortest; " (tt "f") " is applied as  " (tt "(f i state  (dynvector-ref  x1 i) ...)") " where state is the current state value, which begins with " (tt "initial") " and becomes whatever " (tt "f") "returns at the respective iteration; " (tt "i") " is the current index.")) (def (sig (procedure "dynvector-fold-right f initial x1 ... -> state" (id dynvector-fold-right))) (p "Right-to-left dynamic vector iterator with state. " (tt "f") " is iterated over each index in all of the vectors, stopping at the end of the shortest; " (tt "f") " is applied as  " (tt "(f i state  (dynvector-ref  x1 i) ...)") " where state is the current state value, which begins with " (tt "initial") " and becomes whatever " (tt "f") "returns at the respective iteration; " (tt "i") " is the current index.")) (def (sig (procedure "dynvector-index pred? x1 ... -> integer or #f" (id dynvector-index))) (p "Finds and returns the index of the first elements in " (tt "x1 ...") " that satisfy " (tt "pred?") "; if no matching element is found by the end of the shortest vector, " (tt "#f") " is returned.")) (def (sig (procedure "dynvector-any pred? x1 ... -> value or #f" (id dynvector-any))) (p "Finds the first set of elements in " (tt "x1 ... ") "for which " (tt "pred?") " returns a true value. If such a parallel set of elements exists, this procedure returns the value that " (tt "pred?") "returned for that set of elements.")) (def (sig (procedure "dynvector-every pred? x1 ... -> value or #f" (id dynvector-every))) (p "If, for every index " (tt "i") " between 0 and the length of the shortest vector argument, the set of elements " (tt "(dynvector-ref x1 i) ...") " satisfies " (tt "pred?") ", this procedure returns the value that " (tt "pred?") "returned for the last set of elements.")) (def (sig (procedure "dynvector->list x1 -> list" (id dynvector->list))) (p "Returns a list containing all the elements in the given dynamic vector.")))) (section 2 "Examples" (pre "csi> (require-extension dyn-vector)\n\ncsi> (define dv (make-dynvector 1 0))\ncsi> (dynvector-ref dv 6)\n0\ncsi> (dynvector-set! dv 6 18)\ncsi> (dynvector-ref dv 6)\n18\ncsi> (define dv2 (list->dynvector '(1 2 3)))\ncsi> dv2\n#(dynvector 1 2 3)\ncsi> (dynvector-ref dv2 4)\n1\ncsi> (dynvector-clear! dv2 5)\ncsi> (dynvector-for-each (lambda (i x) (print i \" = \" x)) dv2)\n0 = 1\n1 = 1\n2 = 1\n3 = 1\n4 = 1\ncsi> (dynvector-map (lambda (i x) (+ x i)) dv2)\n#(dynvector 1 2 3 4 5)\ncsi> (dynvector-fold (lambda (i state v) (+ state v)) 0 dv2)\n5")) (section 2 "About this egg" (section 3 "Author" (p (int-link "/users/ivan-raikov" "Ivan Raikov"))) (section 3 "Version history" (dl (dt "1.11") (dd "Converted documentation to wiki format") (dt "1.9") (dd "Ported to Chicken 4") (dt "1.8") (dd "Build script updated for better cross-platform compatibility") (dt "1.7") (dd "eggdoc documentation fix") (dt "1.6") (dd "License upgrade to GPL v3") (dt "1.5") (dd "Minor updates to the setup script") (dt "1.4") (dd "Bug fix in the setup script") (dt "1.3") (dd "Added a clarification of how the vector grows [thanks to John Cowan]") (dt "1.2") (dd "Bug fix to handle zero-length initial base vector") (dt "1.1") (dd "Added optional dflt argument to list->dynvector and dynvector->tabulate") (dt "1.0") (dd "Initial release"))) (section 3 "License" (pre "Parts of this documentation are taken from SRFI-43.\nThe rest was created by Ivan Raikov.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or (at\nyour option) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nA full copy of the GPL license can be found at\n<http://www.gnu.org/licenses/>."))))