((tags "egg") (section 2 "mpi" (p "Message Passing Interface (MPI)") (toc)) (section 2 "Usage" (p "(require-extension mpi)")) (section 2 "Documentation" (p (link "http://www-unix.mcs.anl.gov/mpi/" "MPI") " is a popular library for distributed-memory parallel programming. It offers both point-to-point message passing and group communication operations (broadcast, scatter/gather, etc).") (p (link "http://www.open-mpi.org/" "Open MPI") " is an implementation of the MPI standard that combines technologies and resources from several other projects (FT-MPI, LA-MPI, LAM/MPI, and PACX-MPI) in order to build the best MPI library available.") (p "The Chicken MPI egg provides a Scheme interface to a large subset of the MPI 1.2 procedures for communication.  It is based on the " (link "http://pauillac.inria.fr/~xleroy/software.html#ocamlmpi" "Ocaml MPI") " library by Xavier Leroy. Below is a list of procedures that are included in this egg, along with brief descriptions. This egg has been tested with Open MPI version 1.2.4.") (section 3 "Initialization and time procedures" (def (sig (procedure "MPI:init:: [ARG1 ...] -> UNDEFINED" (id MPI:init))) (p "Initializes the MPI execution environment. This  routine must be called before any other MPI routine. MPI can be initialized at most once.")) (def (sig (procedure "MPI:spawn:: COMMAND * ARGUMENTS *  MAXPROCS * LOCATIONS * ROOT * COMM -> (COMM * S32VECTOR)" (id MPI:spawn))) (p "Spawns " (tt "MAXPROCS") " identical copies of the MPI program specified by " (tt "COMMAND") " and returns an intercommunicator and a vector of status values. " (tt "ARGUMENTS") " is a list of command-line arguments. " (tt "LOCATIONS") " is a list of string pairs " (tt "(HOST * WDIR)") " that tell MPI the host and working directory where to start processes.")) (def (sig (procedure "MPI:finalize" (id MPI:finalize))) (p "Terminates the MPI execution environment.")) (def (sig (procedure "MPI:wtime:: VOID -> SECONDS" (id MPI:wtime))) (p "Returns the number of seconds representing elapsed wall-clock time on the calling process."))) (section 3 "Handling of communicators" (def (sig (procedure "MPI:comm?:: OBJ -> BOOL" (id MPI:comm?))) (p "Returns true if " (tt "OBJ") " is an MPI communicator object, false otherwise.")) (def (sig (procedure "MPI:get-comm-world:: VOID -> COMM" (id MPI:get-comm-world))) (p "Returns the default communicator created by " (tt "MPI_Init") "; the group associated with this communicator contains all processes.")) (def (sig (procedure "MPI:comm-size:: COMM -> INTEGER" (id MPI:comm-size))) (p "Returns the size of the group associated with communicator " (tt "COMM") ".")) (def (sig (procedure "MPI:comm-rank:: COMM -> INTEGER" (id MPI:comm-rank))) (p "Returns the rank of the calling process in communicator " (tt "COMM") ".")) (def (sig (procedure "MPI:comm-equal?:: COMM1 * COMM2 -> BOOL" (id MPI:comm-equal?))) (p "Returns true if the two given communicators are for identical groups, false otherwise.")) (def (sig (procedure "MPI:comm-split:: COMM * COLOR * KEY -> BOOL" (id MPI:comm-split))) (p "Creates new communicators based on colors and keys.")) (def (sig (procedure "MPI:comm-create:: COMM * GROUP -> COMM" (id MPI:comm-create))) (p "Creates a new communicator  with communication group that spans all processes in " (tt "GROUP") " and a new context. See the procedures in subsection " (i "Handling of communication groups") " for information on how to create process group objects.")) (def (sig (procedure "MPI:make-cart:: COMM * DIMS * PERIODS * REORDER -> COMM" (id MPI:make-cart))) (p "Creates a new communicator with Cartesian topology information. Argument " (tt "DIMS") " is an SRFI-4 s32vector that contains the number of dimensions of the Cartesian grid. Argument " (tt "PERIODS") " is an SRFI-4 s32vector of the same length as " (tt "DIMS") " that indicates if the grid is periodic (1) or not (0) in each dimension. Argument " (tt "REORDER") " is a boolean value that indicates whether process ranking may be reordered.")) (def (sig (procedure "MPI:make-dims:: NNODES * NDIMS -> DIMS" (id MPI:make-dims))) (p "Creates a division of processes in a Cartesian grid. Argument " (tt "NNODES") " is the number of nodes in the grid. Argument " (tt "NDIMS") " is the number of Cartesian dimensions. The return values is an SRFI-4 s32vector.")) (def (sig (procedure "MPI:cart-coords:: COMM * RANK -> COORDS" (id MPI:cart-coords))) (p "Determines process coordinates in Cartesian topology, given a rank in the group. The return value is an SRFI-4 s32vector of length " (tt "NDIMS") " (the number of dimensions in the Cartesian topology)."))) (section 3 "Handling of communication groups" (def (sig (procedure "MPI:group?:: OBJ -> BOOL" (id MPI:group?))) (p "Returns true if " (tt "OBJ") " is an MPI group object, false otherwise.")) (def (sig (procedure "MPI:comm-group:: COMM -> GROUP" (id MPI:comm-group))) (p "Returns the group associated with the given communicator.")) (def (sig (procedure "MPI:group-size:: GROUP -> INTEGER" (id MPI:group-size))) (p "Returns the size of the group " (tt "GROUP") ".")) (def (sig (procedure "MPI:group-rank:: GROUP -> INTEGER" (id MPI:group-rank))) (p "Returns the rank of the calling process in the given group.")) (def (sig (procedure "MPI:group-translate-ranks:: GROUP1 * RANKS * GROUP2 -> RANKS2" (id MPI:group-translate-ranks))) (p "Translates the ranks of processes in one group to those in another group. The return value is an SRFI-4 s32vector.")) (def (sig (procedure "MPI:group-union:: GROUP1 * GROUP2 -> GROUP" (id MPI:group-union)))) (def (sig (procedure "MPI:group-difference:: GROUP1 * GROUP2 -> GROUP" (id MPI:group-difference)))) (def (sig (procedure "MPI:group-intersection:: GROUP1 * GROUP2 -> GROUP" (id MPI:group-intersection)))) (def (sig (procedure "MPI:group-incl:: GROUP * RANKS -> GROUP" (id MPI:group-incl))) (p "Produces a group by reordering an existing group and taking only members with the given ranks. Argument " (tt "RANKS") " is an SRFI-4 s32vector.")) (def (sig (procedure "MPI:group-excl:: GROUP * RANKS -> GROUP" (id MPI:group-excl))) (p "Produces a group by reordering an existing group and taking only members that do not have the given ranks. Argument " (tt "RANKS") " is an SRFI-4 s32vector."))) (section 3 "Point-to-point communication" (p "Most communication procedures in this library come in several flavors, for fixnums, integers, floating point numbers, bytevectors, and for each of the SRFI-4 homogeneous vector types.") (def (sig (procedure "MPI:send-TYPE:: DATA * DEST * TAG * COMM -> UNDEFINED" (id MPI:send-TYPE))) (p "Performs a standard-mode blocking send. Argument " (tt "DEST") " is the rank of the destination process. Argument " (tt "TAG") " is integer message tag. " (tt "TYPE") " is one of the following: " (tt "fixnum, int, flonum, bytevector, s8vector, u8vector, s16vector, u16vector, s32vector, u32vector, f32vector, f64vector"))) (def (sig (procedure "MPI:receive-TYPE:: SOURCE * TAG * COMM -> DATA" (id MPI:receive-TYPE)))) (def (sig (procedure "MPI:receive-TYPE:: LENGTH * SOURCE * TAG * COMM -> DATA" (id MPI:receive-TYPE))) (p "Performs a standard-mode blocking receive. Argument " (tt "DEST") " is the rank of the destination process. Argument " (tt "TAG") " is integer message tag. Argument " (tt "LENGTH") " is present only in the vector procedures. " (tt "TYPE") " is one of the following: " (tt "fixnum, int, flonum, bytevector, s8vector, u8vector, s16vector, u16vector, s32vector, u32vector, f32vector, f64vector"))) (def (sig (procedure "MPI:probe:: SOURCE * TAG * COMM -> (COUNT * SOURCE * TAG)" (id MPI:probe))) (p "Check for an incoming message. This is a blocking call that returns only after a matching message is found. Argument " (tt "SOURCE") " can be " (tt "MPI:any-source") ". Argument " (tt "TAG") " can be " (tt "MPI:any-tag") "."))) (section 3 "Group communication" (def (sig (procedure "MPI:barrier:: COMM -> UNDEFINED" (id MPI:barrier))) (p "Barrier synchronization.")) (def (sig (procedure "MPI:broadcast-TYPE:: DATA * ROOT * COMM -> UNDEFINED" (id MPI:broadcast-TYPE))) (p "Broadcasts a message from the process with rank root to all other processes of the group. " (tt "TYPE") " is one of the following: " (tt "fixnum, int, flonum, bytevector, s8vector, u8vector, s16vector, u16vector, s32vector, u32vector, f32vector, f64vector"))) (def (sig (procedure "MPI:scatter-TYPE:: DATA * SENDCOUNT * ROOT * COMM -> DATA" (id MPI:scatter-TYPE))) (p "Sends data from the root process to all processes in a group, and returns the data received by the calling process. all other processes of the group. Argument " (tt "SENDCOUNT") " is the number of elements sent to each process. Argument " (tt "DATA") " is only required at the root process. All other processes can invoke this procedure with (void) as " (tt "DATA") ". " (tt "TYPE") " is one of the following: " (tt "int, flonum, bytevector, s8vector, u8vector, s16vector, u16vector, s32vector, u32vector, f32vector, f64vector"))) (def (sig (procedure "MPI:scatterv-TYPE:: DATA * SENDCOUNT * ROOT * COMM -> DATA" (id MPI:scatterv-TYPE))) (p "Sends variable-length data from the root process to all processes in a group, and returns the data received by the calling process. all other processes of the group. Argument " (tt "SENDCOUNT") " is the number of elements sent to each process. Argument " (tt "DATA") " is only required at the root process, and is a list of values of type " (tt "TYPE") ", where each element of the list is sent to the process of corresponding rank. All other processes can invoke this procedure with (void) as " (tt "DATA") ". " (tt "TYPE") " is one of the following: " (tt "int, flonum, bytevector, s8vector, u8vector, s16vector, u16vector, s32vector, u32vector, f32vector, f64vector"))) (def (sig (procedure "MPI:gather-TYPE:: DATA * SENDCOUNT * ROOT * COMM -> DATA" (id MPI:gather-TYPE))) (p "Gathers data from a group of processes, where each process send data of the same length.  Argument " (tt "SENDCOUNT") " is the number of data elements being sent by each process. " (tt "TYPE") " is one of the following: " (tt "int, flonum, bytevector, s8vector, u8vector, s16vector, u16vector, s32vector, u32vector, f32vector, f64vector"))) (def (sig (procedure "MPI:gatherv-TYPE:: DATA * ROOT * COMM -> DATA" (id MPI:gatherv-TYPE))) (p "Gathers data from a group of processes, where each process can send data of variable length. " (tt "TYPE") " is one of the following: " (tt "int, flonum, bytevector, s8vector, u8vector, s16vector, u16vector, s32vector, u32vector, f32vector, f64vector"))) (def (sig (procedure "MPI:allgather-TYPE:: DATA * ROOT * COMM -> DATA" (id MPI:allgather-TYPE))) (p "Gathers data of variable length from all processes and distributes it to all processes. " (tt "TYPE") " is one of the following: " (tt "int, flonum, bytevector, s8vector, u8vector, s16vector, u16vector, s32vector, u32vector, f32vector, f64vector"))) (def (sig (procedure "MPI:reduce-TYPE:: DATA * OP * ROOT * COMM -> DATA" (id MPI:reduce-TYPE))) (p "Reduces values on all processes within a group, using a global reduce operation, and return the result at the root process. " (tt "OP") " is one of the following: " (tt "MPI:i_max, MPI:i_min, MPI:i_sum, MPI:i_prod, MPI:i_land, MPI:i_lor, MPI:i_xor") " (integer operations); and " (tt "MPI:f_max, MPI:f_min, MPI:f_sum, MPI:f_prod") " (floating point operations). " (tt "TYPE") " is one of the following: " (tt "int, flonum, bytevector, s8vector, u8vector, s16vector, u16vector, s32vector, u32vector, f32vector, f64vector"))) (def (sig (procedure "MPI:allreduce-TYPE:: DATA * OP * COMM -> DATA" (id MPI:allreduce-TYPE))) (p "Reduces values on all processes within a group, using a global reduce operation, and return the result at each process. " (tt "OP") " is one of the following: " (tt "MPI:i_max, MPI:i_min, MPI:i_sum, MPI:i_prod, MPI:i_land, MPI:i_lor, MPI:i_xor") " (integer operations); and " (tt "MPI:f_max, MPI:f_min, MPI:f_sum, MPI:f_prod") " (floating point operations). " (tt "TYPE") " is one of the following: " (tt "int, flonum, bytevector, s8vector, u8vector, s16vector, u16vector, s32vector, u32vector, f32vector, f64vector"))) (def (sig (procedure "MPI:scan-TYPE:: DATA * OP * COMM -> DATA" (id MPI:scan-TYPE))) (p "Computes a partial reduction across the processes in a group. " (tt "OP") " is one of the following: " (tt "MPI:i_max, MPI:i_min, MPI:i_sum, MPI:i_prod, MPI:i_land, MPI:i_lor, MPI:i_xor") " (integer operations); and " (tt "MPI:f_max, MPI:f_min, MPI:f_sum, MPI:f_prod") " (floating point operations). " (tt "TYPE") " is one of the following: " (tt "int, flonum, bytevector, s8vector, u8vector, s16vector, u16vector, s32vector, u32vector, f32vector, f64vector"))))) (section 2 "Examples" (pre "(use mpi)\n\n(MPI:init)\n\n(define comm-world  (MPI:get-comm-world))\n(define size        (MPI:comm-size comm-world))\n(define myrank      (MPI:comm-rank comm-world))\n\n;; Barrier \n(MPI:barrier comm-world)\n\n(if (zero? myrank)\n    (let ((data  \"aa\"))\n      (print myrank \": sending \" data)\n      (MPI:send (string->blob data) 1 0 comm-world)\n      (let ((n (MPI:receive MPI:any-source MPI:any-tag comm-world)))\n\t(print myrank \": received \" (blob->string n))))\n    (let* ((n   (blob->string (MPI:receive MPI:any-source MPI:any-tag comm-world)))\n\t   (n1  (string-append n \"a\")))\n      (print myrank \": received \" n \", resending \" n1)\n      (MPI:send (string->blob n1) (modulo (+ myrank 1) size) 0 comm-world)))\n")) (section 2 "About this egg" (section 3 "Author" (p (int-link "/users/ivan-raikov" "Ivan Raikov"))) (section 3 "Version history" (dl (dt "1.7") (dd "Switched to wiki documentation") (dt "1.6") (dd "Ported to Chicken 4") (dt "1.5") (dd "Added a binding for MPI:spawn") (dt "1.3") (dd "Bug fix in MPI:scatter-int") (dt "1.2") (dd "Bug fix in the meta file") (dt "1.1") (dd "Bug fixes and improvements to the regression tests") (dt "1.0") (dd "Initial release"))) (section 3 "License" (pre "Copyright 2007-2010 Ivan Raikov and the Okinawa Institute of Science and Technology\n\nBased on the Ocaml MPI library by Xavier Leroy. \n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or (at\nyour option) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nA full copy of the GPL license can be found at\n<http://www.gnu.org/licenses/>."))))