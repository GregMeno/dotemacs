(index ("define-foreign-record-type" 0) ("define-foreign-enum-type" 829))
(def (sig (syntax "(define-foreign-record-type name [decl ...] slot ...)" (id define-foreign-record-type))) (p "This macro defines accessor procedures for a C structure definition.  It is the counterpart to Chicken 3's " (tt "define-foreign-record") ", but modeled after SRFI 9's " (tt "define-record-type") " for better hygiene.") (p (tt "NAME") " should either be a symbol or a list of the form " (tt "(TYPENAME FOREIGNNAME)") ". If " (tt "NAME") " is a symbol, then a C declaration will be generated that defines a C struct named " (tt "struct NAME") ". If " (tt "NAME") " is a list, then no struct declaration will be generated and " (tt "FOREIGNNAME") " should name an existing C record type.  A foreign-type specifier named " (tt "NAME") " (or " (tt "TYPENAME") ") will be defined as a pointer to the given C structure."))
(def (sig (syntax "(define-foreign-enum-type (type-name native-type [default-value]) (scheme->number number->scheme) enumspec ...)" (id define-foreign-enum-type))) (p "Defines a foreign-type that maps the elements of a C/C++ enum (or a enum-like list of constants) to and from a set of symbols.  Also defines a pair of conversion procedures which can be used to do this mapping manually, along with a foreign-variable for each enumeration value.") (ul (li (tt "type-name") " is the foreign type name;") (li (tt "native-type") " is the underlying type, e.g. " (tt "int") " or " (tt "(enum \"foo\")") ";") (li (tt "default-value") " is the result of mapping from the native type when no such mapping exists.  When supplied the form is used unquoted, otherwise the result is '();") (li (tt "scheme->number") " is the name of a procedure which will convert a symbol (or list of symbols) into the corresponding numeric enum value;") (li (tt "number->scheme") " is a procedure converting an enum into a symbol;") (li (tt "enumspec") " is a specification for each enum value, described in detail below.")) (p "The two procedures are defined by the macro in lexical scope for your use, and are also used in the foreign-type conversion:") (pre "(define-foreign-type type-name native-type scheme->number number->scheme)") (p "If passed a list of symbols, " (tt "scheme->number") " will combine their numeric values with " (tt "bitwise-ior") ".  However, " (tt "number->scheme") " returns a single symbol and will not decompose a value into its component symbols; rather, you will probably get " (tt "default-value") "."))
