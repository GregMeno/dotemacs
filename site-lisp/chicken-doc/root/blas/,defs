(index ("blas:scopy" 0) ("blas:dcopy" 79) ("blas:ccopy" 158) ("blas:zcopy" 237) ("blas:srot" 538) ("blas:drot" 649) ("blas:sscal" 1139) ("blas:dscal" 1229) ("blas:cscal" 1319) ("blas:zscal" 1409) ("blas:sswap" 1577) ("blas:dswap" 1670) ("blas:cswap" 1763) ("blas:zswap" 1856) ("blas:sdot" 2031) ("blas:ddot" 2119) ("blas:cdotu" 2336) ("blas:zdotu" 2426) ("blas:cdotc" 2650) ("blas:zdotc" 2740) ("blas:saxpy" 3019) ("blas:daxpy" 3120) ("blas:caxpy" 3221) ("blas:zaxpy" 3322) ("blas:siaxpy" 3528) ("blas:diaxpy" 3645) ("blas:ciaxpy" 3762) ("blas:ziaxpy" 3879) ("blas:snrm2" 4185) ("blas:dnrm2" 4264) ("blas:cnrm2" 4343) ("blas:znrm2" 4422) ("blas:sasum" 4567) ("blas:dasum" 4646) ("blas:casum" 4725) ("blas:zasum" 4804) ("blas:samax" 4957) ("blas:damax" 5035) ("blas:camax" 5113) ("blas:zamax" 5191) ("blas:sgemv" 5402) ("blas:dgemv" 5540) ("blas:cgemv" 5678) ("blas:zgemv" 5816) ("blas:sgbmv" 6639) ("blas:dgbmv" 6787) ("blas:cgbmv" 6935) ("blas:zgbmv" 7083) ("blas:chemv" 7991) ("blas:zhemv" 8124) ("blas:chbmv" 8646) ("blas:zhbmv" 8783) ("blas:ssymv" 9351) ("blas:dsymv" 9485) ("blas:ssbmv" 9911) ("blas:dsbmv" 10049) ("blas:strmv" 10521) ("blas:dtrmv" 10644) ("blas:ctrmv" 10767) ("blas:ztrmv" 10890) ("blas:stbmv" 11383) ("blas:dtbmv" 11510) ("blas:ctbmv" 11637) ("blas:ztbmv" 11764) ("blas:strsv" 12302) ("blas:dtrsv" 12434) ("blas:ctrsv" 12558) ("blas:ztrsv" 12682) ("blas:stbsv" 13065) ("blas:dtbsv" 13193) ("blas:ctbsv" 13321) ("blas:ztbsv" 13449) ("blas:sger" 13873) ("blas:dger" 13994) ("blas:siger" 14374) ("blas:diger" 14511) ("blas:cgeru" 14924) ("blas:zgeru" 15047) ("blas:cgerc" 15430) ("blas:zgerc" 15553) ("blas:cher" 15943) ("blas:zher" 16056) ("blas:cher2" 16407) ("blas:zher2" 16533) ("blas:ssyr" 16941) ("blas:dsyr" 17054) ("blas:ssyr2" 17398) ("blas:dsyr2" 17524) ("blas:sgemm" 17911) ("blas:dgemm" 18061) ("blas:cgemm" 18211) ("blas:zgemm" 18361) ("blas:ssymm" 18981) ("blas:dsymm" 19123) ("blas:csymm" 19265) ("blas:zsymm" 19407) ("blas:ssyrk" 19856) ("blas:dsyrk" 19995) ("blas:csyrk" 20134) ("blas:zsyrk" 20273) ("blas:cherk" 20732) ("blas:zherk" 20871) ("blas:ssyr2k" 21344) ("blas:dsyr2k" 21489) ("blas:csyr2k" 21634) ("blas:zsyr2k" 21779) ("blas:cher2k" 22263) ("blas:zher2k" 22408) ("blas:strmm" 22906) ("blas:dtrmm" 23047) ("blas:ctrmm" 23188) ("blas:ztrmm" 23329) ("blas:strsm" 23747) ("blas:dtrsm" 23896) ("blas:ctrsm" 24045) ("blas:ztrsm" 24194))
(def (sig (procedure "blas:scopy:: F32VECTOR -> F32VECTOR " (id blas:scopy))))
(def (sig (procedure "blas:dcopy:: F64VECTOR -> F64VECTOR " (id blas:dcopy))))
(def (sig (procedure "blas:ccopy:: F32VECTOR -> F32VECTOR " (id blas:ccopy))))
(def (sig (procedure "blas:zcopy:: F64VECTOR -> F64VECTOR " (id blas:zcopy))) (p "These procedures return a copy of given input SRFI-4 vector. The returned vector is allocated with the corresponding SRFI-4 constructor, and the input vector is copied to it by the corresponding BLAS copy procedure."))
(def (sig (procedure "blas:srot:: N * X * Y * C * S [INCX * INCY] -> F32VECTOR * F32VECTOR " (id blas:srot))))
(def (sig (procedure "blas:drot:: N * X * Y * C * S [INCX * INCY] -> F64VECTOR * F64VECTOR " (id blas:drot))) (p (tt "xROT") " applies a plane rotation matrix to a sequence of ordered pairs: " (tt "(x_i , y_i)") ", for " (tt "i = 1, 2, ..., n") ".") (p (tt "X") " and " (tt "Y") " are vector of dimensions " (tt "(N-1) * abs(incx) + 1") " and " (tt "(N-1) * abs(incy) + 1") ", respectively.") (p (tt "C") " and " (tt "S") " are respectively the cosine and sine of the plane of rotation."))
(def (sig (procedure "blas:sscal:: N * ALPHA * X [INCX] -> F32VECTOR " (id blas:sscal))))
(def (sig (procedure "blas:dscal:: N * ALPHA * X [INCX] -> F64VECTOR " (id blas:dscal))))
(def (sig (procedure "blas:cscal:: N * ALPHA * X [INCX] -> F32VECTOR " (id blas:cscal))))
(def (sig (procedure "blas:zscal:: N * ALPHA * X [INCX] -> F64VECTOR " (id blas:zscal))) (p (tt "xSCAL") " scales a vector with a scalar: " (tt "x := alpha * x") "."))
(def (sig (procedure "blas:sswap:: N * X * Y [INCX * INCY] -> F32VECTOR " (id blas:sswap))))
(def (sig (procedure "blas:dswap:: N * X * Y [INCX * INCY] -> F64VECTOR " (id blas:dswap))))
(def (sig (procedure "blas:cswap:: N * X * Y [INCX * INCY] -> F32VECTOR " (id blas:cswap))))
(def (sig (procedure "blas:zswap:: N * X * Y [INCX * INCY] -> F64VECTOR " (id blas:zswap))) (p (tt "xSWAP") " interchanges the elements of two vectors: " (tt "x <-> y") "."))
(def (sig (procedure "blas:sdot:: N * X * Y [INCX * INCY] -> NUMBER " (id blas:sdot))))
(def (sig (procedure "blas:ddot:: N * X * Y [INCX * INCY] -> NUMBER " (id blas:ddot))) (p (tt "xDOT") " computes the dot product of two vectors of real values: " (tt "dot := x'*y = \\Sum_{i=1}^{n} (x_i * y_i)") "."))
(def (sig (procedure "blas:cdotu:: N * X * Y [INCX * INCY] -> NUMBER " (id blas:cdotu))))
(def (sig (procedure "blas:zdotu:: N * X * Y [INCX * INCY] -> NUMBER " (id blas:zdotu))) (p (tt "xDOTU") " computes the dot product of two vectors of complex values: " (tt "dotu := x'*y = \\Sum_{i=1}^{n} (x_i * y_i)") "."))
(def (sig (procedure "blas:cdotc:: N * X * Y [INCX * INCY] -> NUMBER " (id blas:cdotc))))
(def (sig (procedure "blas:zdotc:: N * X * Y [INCX * INCY] -> NUMBER " (id blas:zdotc))) (p (tt "xDOTC") " computes the dot product of the conjugates of two complex vectors: " (tt "dotu := conjg(x')*y = \\Sum_{i=1}^{n} (conjg(x_i) * y_i)") ", for " (tt "i = 1, 2, ..., n") "."))
(def (sig (procedure "blas:saxpy:: N * ALPHA * X * Y [INCX * INCY] -> F32VECTOR " (id blas:saxpy))))
(def (sig (procedure "blas:daxpy:: N * ALPHA * X * Y [INCX * INCY] -> F64VECTOR " (id blas:daxpy))))
(def (sig (procedure "blas:caxpy:: N * ALPHA * X * Y [INCX * INCY] -> F32VECTOR " (id blas:caxpy))))
(def (sig (procedure "blas:zaxpy:: N * ALPHA * X * Y [INCX * INCY] -> F64VECTOR " (id blas:zaxpy))) (p (tt "xAXPY") " adds a scalar multiple of a vector to another vector: " (tt "y := alpha * x + y") "."))
(def (sig (procedure "blas:siaxpy:: N * ALPHA * X * Y [INCX * INCY * XOFS * YOFS] -> F32VECTOR " (id blas:siaxpy))))
(def (sig (procedure "blas:diaxpy:: N * ALPHA * X * Y [INCX * INCY * XOFS * YOFS] -> F64VECTOR " (id blas:diaxpy))))
(def (sig (procedure "blas:ciaxpy:: N * ALPHA * X * Y [INCX * INCY * XOFS * YOFS] -> F32VECTOR " (id blas:ciaxpy))))
(def (sig (procedure "blas:ziaxpy:: N * ALPHA * X * Y [INCX * INCY * XOFS * YOFS] -> F64VECTOR " (id blas:ziaxpy))) (p (tt "xIAXPY") " adds a scalar multiple of a vector to another vector, where the beginning of each vector argument can be offset: " (tt "y[yofs:n] := alpha * x[xofs:n] + y[yofs:n]") "."))
(def (sig (procedure "blas:snrm2:: N * X [INCX] -> NUMBER " (id blas:snrm2))))
(def (sig (procedure "blas:dnrm2:: N * X [INCX] -> NUMBER " (id blas:dnrm2))))
(def (sig (procedure "blas:cnrm2:: N * X [INCX] -> NUMBER " (id blas:cnrm2))))
(def (sig (procedure "blas:znrm2:: N * X [INCX] -> NUMBER " (id blas:znrm2))) (p (tt "xNRM2") " computes the Euclidean (L2) norm of a vector."))
(def (sig (procedure "blas:sasum:: N * X [INCX] -> NUMBER " (id blas:sasum))))
(def (sig (procedure "blas:dasum:: N * X [INCX] -> NUMBER " (id blas:dasum))))
(def (sig (procedure "blas:casum:: N * X [INCX] -> NUMBER " (id blas:casum))))
(def (sig (procedure "blas:zasum:: N * X [INCX] -> NUMBER " (id blas:zasum))) (p (tt "xASUM") " sums the absolute values of the elements in a vector."))
(def (sig (procedure "blas:samax:: N * X [INCX] -> INDEX " (id blas:samax))))
(def (sig (procedure "blas:damax:: N * X [INCX] -> INDEX " (id blas:damax))))
(def (sig (procedure "blas:camax:: N * X [INCX] -> INDEX " (id blas:camax))))
(def (sig (procedure "blas:zamax:: N * X [INCX] -> INDEX " (id blas:zamax))) (p (tt "xAMAX") " searches a vector for the first occurrence of its maximum absolute value, and returns the index of that element."))
(def (sig (procedure "blas:sgemv:: ORDER * TRANS * M * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:sgemv))))
(def (sig (procedure "blas:dgemv:: ORDER * TRANS * M * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:dgemv))))
(def (sig (procedure "blas:cgemv:: ORDER * TRANS * M * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:cgemv))))
(def (sig (procedure "blas:zgemv:: ORDER * TRANS * M * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:zgemv))) (p (tt "xGEMV") " performs the matrix-vector multiply-add operation of the form " (tt "y := alpha*op( A )*x + beta*y") ", where " (tt "op( X )") " is one of " (tt "op( A ) = A") " or " (tt "op( A ) = A'") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "M x N") " matrix.") (p (tt "X") " is a vector of size " (tt "(1 + ( N - 1 ) * abs(INCX))") " when argument " (tt "TRANS") " is " (tt "blas:NoTrans") ", and " (tt "(1 + ( M - 1 ) * abs(INCX))") " otherwise. " (tt "Y") " is a vector of size " (tt "(1 + ( M - 1 ) * abs(INCY))") " when argument " (tt "TRANS") " is " (tt "blas:NoTrans") ", and " (tt "(1 + ( N - 1 ) * abs(INCY))") " otherwise."))
(def (sig (procedure "blas:sgbmv:: ORDER * TRANS * M * N * KL * KU * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:sgbmv))))
(def (sig (procedure "blas:dgbmv:: ORDER * TRANS * M * N * KL * KU * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:dgbmv))))
(def (sig (procedure "blas:cgbmv:: ORDER * TRANS * M * N * KL * KU * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:cgbmv))))
(def (sig (procedure "blas:zgbmv:: ORDER * TRANS * M * N * KL * KU * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:zgbmv))) (p (tt "xGBMV") " performs the matrix-vector multiply-add operation of the form " (tt "y := alpha*op( A )*x + beta*y") ", where " (tt "op( X )") " is one of " (tt "op( A ) = A") " or " (tt "op( A ) = A'") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "M x N") " banded matrix, with " (tt "KL") " sub-diagonals and " (tt "KU") " super-diagonals.") (p (tt "X") " is a vector of size " (tt "(1 + ( N - 1 ) * abs(INCX))") " when argument " (tt "TRANS") " is " (tt "blas:NoTrans") ", and " (tt "(1 + ( M - 1 ) * abs(INCX))") " otherwise. " (tt "Y") " is a vector of size " (tt "(1 + ( M - 1 ) * abs(INCY))") " when argument " (tt "TRANS") " is " (tt "blas:NoTrans") ", and " (tt "(1 + ( N - 1 ) * abs(INCY))") " otherwise."))
(def (sig (procedure "blas:chemv:: ORDER * UPLO * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:chemv))))
(def (sig (procedure "blas:zhemv:: ORDER * UPLO * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:zhemv))) (p (tt "xHEMV") " performs the matrix-vector multiply-add operation of the form " (tt "y := alpha*op( A )*x + beta*y") ", where " (tt "op( X )") " is one of " (tt "op( A ) = A") " or " (tt "op( A ) = A'") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "N x N") " Hermitian matrix.") (p (tt "X") " and " (tt "Y") " are " (tt "N") " element vectors."))
(def (sig (procedure "blas:chbmv:: ORDER * UPLO * N * K * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:chbmv))))
(def (sig (procedure "blas:zhbmv:: ORDER * UPLO * N * K * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:zhbmv))) (p (tt "xHBMV") " performs the matrix-vector multiply-add operation of the form " (tt "y := alpha*op( A )*x + beta*y") ", where " (tt "op( X )") " is one of " (tt "op( A ) = A") " or " (tt "op( A ) = A'") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "N x N") " Hermitian banded matrix, with " (tt "K") " super-diagonals.") (p (tt "X") " and " (tt "Y") " are " (tt "N") " element vectors."))
(def (sig (procedure "blas:ssymv::  ORDER * UPLO * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:ssymv))))
(def (sig (procedure "blas:dsymv:: ORDER * UPLO * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:dsymv))) (p (tt "xSYMV") " performs matrix-vector multiply-add operation of the form " (tt "y := alpha*A*x + beta*y") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "N x N") " symmetric matrix.") (p (tt "X") " and " (tt "Y") " are " (tt "N") " element vectors."))
(def (sig (procedure "blas:ssbmv::  ORDER * UPLO * N * K * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:ssbmv))))
(def (sig (procedure "blas:dsbmv:: ORDER * UPLO * N * K * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:dsbmv))) (p (tt "xSBMV") " performs matrix-vector multiply-add operation of the form " (tt "y := alpha*A*B + beta*y") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "N x N") " symmetric banded matrix, with " (tt "K") " super-diagonals.") (p (tt "X") " and " (tt "Y") " are " (tt "N") " element vectors."))
(def (sig (procedure "blas:strmv::  ORDER * UPLO * TRANS * DIAG * N * A * X [LDA * INCX] -> F32VECTOR " (id blas:strmv))))
(def (sig (procedure "blas:dtrmv::  ORDER * UPLO * TRANS * DIAG * N * A * X [LDA * INCX] -> F64VECTOR " (id blas:dtrmv))))
(def (sig (procedure "blas:ctrmv::  ORDER * UPLO * TRANS * DIAG * N * A * X [LDA * INCX] -> F32VECTOR " (id blas:ctrmv))))
(def (sig (procedure "blas:ztrmv::  ORDER * UPLO * TRANS * DIAG * N * A * X [LDA * INCX] -> F64VECTOR " (id blas:ztrmv))) (p (tt "xTRMV") " performs matrix-vector multiply-add operation of the form " (tt "y := alpha*op( A )*x") ", where " (tt "op ( A ) = A") " or " (tt "op ( A ) = A'")) (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "N x N") " upper or lower triangular matrix.") (p (tt "X") " is a vector of length " (tt "(1 + (n - 1) * abs(INCX))") "."))
(def (sig (procedure "blas:stbmv::  ORDER * UPLO * TRANS * DIAG * N * K * A * X [LDA * INCX] -> F32VECTOR " (id blas:stbmv))))
(def (sig (procedure "blas:dtbmv::  ORDER * UPLO * TRANS * DIAG * N * K * A * X [LDA * INCX] -> F64VECTOR " (id blas:dtbmv))))
(def (sig (procedure "blas:ctbmv::  ORDER * UPLO * TRANS * DIAG * N * K * A * X [LDA * INCX] -> F32VECTOR " (id blas:ctbmv))))
(def (sig (procedure "blas:ztbmv::  ORDER * UPLO * TRANS * DIAG * N * K * A * X [LDA * INCX] -> F64VECTOR " (id blas:ztbmv))) (p (tt "xTBMV") " performs matrix-vector multiply-add operation of the form " (tt "y := alpha*A*B + beta*y") ", where " (tt "op ( A ) = A") " or " (tt "op ( A ) = A'")) (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "N x N") " upper or lower triangular banded matrix, with " (tt "K+1") " diagonals.") (p (tt "X") " is a vector of length " (tt "(1 + (n - 1) * abs(INCX))") "."))
(def (sig (procedure "blas:strsv:: ORDER * UPLO * TRANS * DIAG * N * ALPHA * A * B * [LDA * INCB] -> F32VECTOR " (id blas:strsv))))
(def (sig (procedure "blas:dtrsv:: ORDER * UPLO * TRANS * DIAG * N * A * B * [LDA * INCB] -> F64VECTOR " (id blas:dtrsv))))
(def (sig (procedure "blas:ctrsv:: ORDER * UPLO * TRANS * DIAG * N * A * B * [LDA * INCB] -> F32VECTOR " (id blas:ctrsv))))
(def (sig (procedure "blas:ztrsv:: ORDER * UPLO * TRANS * DIAG * N * A * B * [LDA * INCB] -> F64VECTOR " (id blas:ztrsv))) (p (tt "xTRSV") " solves one of the systems of equations " (tt "A*x = b") " or " (tt "A'*x = b") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " is a upper or lower triangular matrix, and " (tt "B") " is a " (tt "N") " element vector."))
(def (sig (procedure "blas:stbsv:: ORDER * UPLO * TRANS * DIAG * N * K * A * B * [LDA * INCB] -> F32VECTOR " (id blas:stbsv))))
(def (sig (procedure "blas:dtbsv:: ORDER * UPLO * TRANS * DIAG * N * K * A * B * [LDA * INCB] -> F64VECTOR " (id blas:dtbsv))))
(def (sig (procedure "blas:ctbsv:: ORDER * UPLO * TRANS * DIAG * N * K * A * B * [LDA * INCB] -> F32VECTOR " (id blas:ctbsv))))
(def (sig (procedure "blas:ztbsv:: ORDER * UPLO * TRANS * DIAG * N * K * A * B * [LDA * INCB] -> F64VECTOR " (id blas:ztbsv))) (p (tt "xTBSV") " solves one of the systems of equations " (tt "A*x = b") " or " (tt "A'*x = b") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " is a upper or lower banded triangular matrix with " (tt "K+1") " diagonals, and " (tt "B") " is a " (tt "N") " element vector."))
(def (sig (procedure "blas:sger:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F32VECTOR " (id blas:sger))))
(def (sig (procedure "blas:dger:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F64VECTOR " (id blas:dger))) (p (tt "xGER") " performs the rank 1 operation " (tt "A := alpha*x*y' + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " is an " (tt "M") " element vector, " (tt "Y") " is an " (tt "N") " element vector, and " (tt "A") " is an " (tt "M x N") " matrix."))
(def (sig (procedure "blas:siger:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY * XOFS * YOFS] -> F32VECTOR " (id blas:siger))))
(def (sig (procedure "blas:diger:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY * XOFS * YOFS] -> F64VECTOR " (id blas:diger))) (p (tt "xIGER") " performs the rank 1 operation " (tt "A := alpha*x[xofs:M]*y'[yofs:N] + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " is an " (tt "M") " element vector, " (tt "Y") " is an " (tt "N") " element vector, and " (tt "A") " is an " (tt "M x N") " matrix."))
(def (sig (procedure "blas:cgeru:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F32VECTOR " (id blas:cgeru))))
(def (sig (procedure "blas:zgeru:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F64VECTOR " (id blas:zgeru))) (p (tt "xGERU") " performs the rank 1 operation " (tt "A := alpha*x*y' + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " is an " (tt "M") " element vector, " (tt "Y") " is an " (tt "N") " element vector, and " (tt "A") " is an " (tt "M x N") " matrix."))
(def (sig (procedure "blas:cgerc:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F32VECTOR " (id blas:cgerc))))
(def (sig (procedure "blas:zgerc:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F64VECTOR " (id blas:zgerc))) (p (tt "xGERC") " performs the rank 1 operation " (tt "A := alpha*x*conjg(y') + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " is an " (tt "M") " element vector, " (tt "Y") " is an " (tt "N") " element vector, and " (tt "A") " is an " (tt "M x N") " matrix."))
(def (sig (procedure "blas:cher:: ORDER * UPLO * N * ALPHA * X * A [LDA * INCX] -> F32VECTOR " (id blas:cher))))
(def (sig (procedure "blas:zher:: ORDER * UPLO * N * ALPHA * X * A [LDA * INCX] -> F64VECTOR " (id blas:zher))) (p (tt "xHER") " performs the Hermitian rank 1 operation " (tt "A := alpha*x*conjg(x') + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " is an " (tt "N") " element vector, and " (tt "A") " is an " (tt "N x N") " Hermitian matrix."))
(def (sig (procedure "blas:cher2:: ORDER * UPLO * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F32VECTOR " (id blas:cher2))))
(def (sig (procedure "blas:zher2:: ORDER * UPLO * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F64VECTOR " (id blas:zher2))) (p (tt "xHER2") " performs the Hermitian rank 2 operation " (tt "A := alpha*x*conjg(y') + conjg(alpha)*y*conjg(x') + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " and " (tt "Y") " are " (tt "N") " element vectors, and " (tt "A") " is an " (tt "N x N") " Hermitian matrix."))
(def (sig (procedure "blas:ssyr:: ORDER * UPLO * N * ALPHA * X * A [LDA * INCX] -> F32VECTOR " (id blas:ssyr))))
(def (sig (procedure "blas:dsyr:: ORDER * UPLO * N * ALPHA * X * A [LDA * INCX] -> F64VECTOR " (id blas:dsyr))) (p (tt "xSYR") " performs the symmetric rank 1 operation " (tt "A := alpha*x*x' + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " is an " (tt "N") " element vector, and " (tt "A") " is an " (tt "N x N") " symmetric matrix."))
(def (sig (procedure "blas:ssyr2:: ORDER * UPLO * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F32VECTOR " (id blas:ssyr2))))
(def (sig (procedure "blas:dsyr2:: ORDER * UPLO * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F64VECTOR " (id blas:dsyr2))) (p (tt "xSYR2") " performs the symmetric rank 2 operation " (tt "A := alpha*x*y' + alpha*y*x' + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " and " (tt "Y") " are " (tt "N") " element vectors, and " (tt "A") " is an " (tt "N x N") " symmetric matrix."))
(def (sig (procedure "blas:sgemm:: ORDER * TRANSA * TRANSB * M * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:sgemm))))
(def (sig (procedure "blas:dgemm:: ORDER * TRANSA * TRANSB * M * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:dgemm))))
(def (sig (procedure "blas:cgemm:: ORDER * TRANSA * TRANSB * M * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:cgemm))))
(def (sig (procedure "blas:zgemm:: ORDER * TRANSA * TRANSB * M * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:zgemm))) (p (tt "xGEMM") " performs matrix-matrix multiply-add operation of the form " (tt "C := alpha*op( A )*op( B ) + beta*C") ", where " (tt "op( X )") " is one of " (tt "op( X ) = X") " or " (tt "op( X ) = X'") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") ", " (tt "B") " and " (tt "C") " are matrices, with " (tt "op( A )") " an " (tt "M x K") " matrix, " (tt "op( B )") " a " (tt "K x N") " matrix and " (tt "C") " an " (tt "M x N") " matrix."))
(def (sig (procedure "blas:ssymm:: ORDER * SIDE * UPLO * M * N * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:ssymm))))
(def (sig (procedure "blas:dsymm:: ORDER * SIDE * UPLO * M * N * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:dsymm))))
(def (sig (procedure "blas:csymm:: ORDER * SIDE * UPLO * M * N * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:csymm))))
(def (sig (procedure "blas:zsymm:: ORDER * SIDE * UPLO * M * N * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:zsymm))) (p (tt "xSYMM") " performs matrix-matrix multiply-add operation of the form " (tt "C := alpha*A*B + beta*C") " or " (tt "C := alpha*B*A + beta*C") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " is a symmetric matrix, and " (tt "B") " and " (tt "C") " are " (tt "M x N") " matrices."))
(def (sig (procedure "blas:ssyrk:: ORDER * UPLO * TRANS * N * K * ALPHA * A * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:ssyrk))))
(def (sig (procedure "blas:dsyrk:: ORDER * UPLO * TRANS * N * K * ALPHA * A * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:dsyrk))))
(def (sig (procedure "blas:csyrk:: ORDER * UPLO * TRANS * N * K * ALPHA * A * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:csyrk))))
(def (sig (procedure "blas:zsyrk:: ORDER * UPLO * TRANS * N * K * ALPHA * A * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:zsyrk))) (p (tt "xSYRK") " performs one of the symmetric rank k operations " (tt "C := alpha*A*A' + beta*C") " or " (tt "C := alpha*A'*A + beta*C") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " is an " (tt "N x K") " or " (tt "K x N") " matrix, and " (tt "C") " is an " (tt "N x N") " symmetric matrix."))
(def (sig (procedure "blas:cherk:: ORDER * UPLO * TRANS * N * K * ALPHA * A * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:cherk))))
(def (sig (procedure "blas:zherk:: ORDER * UPLO * TRANS * N * K * ALPHA * A * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:zherk))) (p (tt "xHERK") " performs one of the hermitian rank k operations " (tt "C := alpha*A*conjg(A') + beta*C") " or " (tt "C := alpha*conjg(A')*A + beta*C") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " is an " (tt "N x K") " or " (tt "K x N") " matrix, and " (tt "C") " is an " (tt "N x N") " hermitian matrix."))
(def (sig (procedure "blas:ssyr2k:: ORDER * UPLO * TRANS * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:ssyr2k))))
(def (sig (procedure "blas:dsyr2k:: ORDER * UPLO * TRANS * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:dsyr2k))))
(def (sig (procedure "blas:csyr2k:: ORDER * UPLO * TRANS * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:csyr2k))))
(def (sig (procedure "blas:zsyr2k:: ORDER * UPLO * TRANS * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:zsyr2k))) (p (tt "xSYR2K") " performs one of the symmetric rank 2k operations " (tt "C := alpha*A*B' + beta*C") " or " (tt "C := alpha*B'*A + beta*C") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " and " (tt "B") " are " (tt "N x K") " or " (tt "K x N") " matrices, and " (tt "C") " is an " (tt "N x N") " symmetric matrix."))
(def (sig (procedure "blas:cher2k:: ORDER * UPLO * TRANS * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:cher2k))))
(def (sig (procedure "blas:zher2k:: ORDER * UPLO * TRANS * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:zher2k))) (p (tt "xHER2K") " performs one of the hermitian rank 2k operations " (tt "C := alpha*A*conjg(B') + beta*C") " or " (tt "C := alpha*conjg(B')*A + beta*C") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " and " (tt "B") " are " (tt "N x K") " or " (tt "K x N") " matrices, and " (tt "C") " is an " (tt "N x N") " hermitian matrix."))
(def (sig (procedure "blas:strmm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B [LDA * LDB] -> F32VECTOR " (id blas:strmm))))
(def (sig (procedure "blas:dtrmm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B [LDA * LDB] -> F64VECTOR " (id blas:dtrmm))))
(def (sig (procedure "blas:ctrmm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B [LDA * LDB] -> F32VECTOR " (id blas:ctrmm))))
(def (sig (procedure "blas:ztrmm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B [LDA * LDB] -> F64VECTOR " (id blas:ztrmm))) (p (tt "xTRMM") " performs matrix-matrix multiply operation of the form " (tt "B := alpha*op( A )*B") " or " (tt "B := alpha*B*op( A )") ".") (p (tt "ALPHA") " is a  scalar, " (tt "A") " is an upper or lower triangular matrix, and " (tt "B") " is an " (tt "M x N") " matrix."))
(def (sig (procedure "blas:strsm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B * [LDA * LDB * LDC] -> F32VECTOR " (id blas:strsm))))
(def (sig (procedure "blas:dtrsm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B * [LDA * LDB * LDC] -> F64VECTOR " (id blas:dtrsm))))
(def (sig (procedure "blas:ctrsm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B * [LDA * LDB * LDC] -> F32VECTOR " (id blas:ctrsm))))
(def (sig (procedure "blas:ztrsm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B * [LDA * LDB * LDC] -> F64VECTOR " (id blas:ztrsm))) (p (tt "xTRSM") " solves one of the matrix equations " (tt "op( A )*X = alpha*B") " or " (tt "X*op( A ) = alpha*B") ".") (p (tt "op( A )") " is one of " (tt "op( A ) = A") " or " (tt "op( A ) = A'") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " is a upper or lower triangular matrix, and " (tt "B") " is a " (tt "M x N") " matrix."))
