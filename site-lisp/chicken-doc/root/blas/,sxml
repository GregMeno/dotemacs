((tags "egg") (section 2 "blas" (p "An interface to level 1, 2 and 3 BLAS linear algebra routines.") (toc)) (section 2 "Usage" (p "(require-extension blas)")) (section 2 "Documentation" (section 3 "Naming conventions for routines" (p "Every routine in the BLAS library comes in four flavors, each prefixed by the letters S, D, C, and Z, respectively. Each letter indicates the format of input data:") (ul (li "S stands for single-precision (32-bit IEEE floating point numbers), ") (li "D stands for double-precision (64-bit IEEE floating point numbers), ") (li "C stands for complex numbers (represented by pairs of 32-bit IEEE floating point numbers), ") (li "Z stands for double complex numbers (represented by pairs of 64-bit IEEE floating point numbers)")) (p "In addition, each BLAS routine in this egg comes in three flavors:") (ul (li "Safe, pure (prefix: " (b "blas:") ") " (i "Safe") " routines check the sizes of their input arguments. For example, if a routine is supplied arguments that indicate that an input matrix is of dimensions " (i "M") "-by-" (i "N") ", then the argument corresponding to that matrix is checked that it is of size " (i "M * N") ".")) (p (i "Pure") " routines do not alter their arguments in any way. A new matrix or vector is allocated for the return value of the routine.") (ul (li "Safe, destructive (prefix: " (b "blas:") ", suffix: !) " (i "Safe") " routines check the sizes of their input arguments. For example, if a routine is supplied arguments that indicate that an input matrix is of dimensions " (i "M") "-by-" (i "N") ", then the argument corresponding to that matrix is checked that it is of size " (i "M * N") ".")) (p (i "Destructive") " routines can modify some or all of their arguments. They  are given names ending in exclamation mark. Please consult the BLAS documentation to determine which functions modify their input arguments.") (ul (li "Unsafe, destructive (prefix: " (b "unsafe-blas:") ", suffix: !) " (i "Unsafe") " routines do not check the sizes of their input arguments. They invoke the corresponding BLAS routines directly. Unsafe routines do not have pure variants.")) (p "For example, function " (i "xGEMM") " (matrix-matrix multiplication) comes in the following variants:") (table (tr (th (b "BLAS name")) (th (b "Safe, pure")) (th (b "Safe, destructive")) (th (b "Unsafe, destructive"))) "\n" (tr (td (i "SGEMM")) (td (i "blas:sgemm")) (td (i "blas:sgemm!")) (td (i "unsafe-blas:sgemm!"))) "\n" (tr (td (i "DGEMM")) (td (i "blas:dgemm")) (td (i "blas:dgemm!")) (td (i "unsafe-blas:dgemm!"))) "\n" (tr (td (i "CGEMM")) (td (i "blas:cgemm")) (td (i "blas:cgemm!")) (td (i "unsafe-blas:cgemm!"))) "\n" (tr (td (i "ZGEMM")) (td (i "blas:zgemm")) (td (i "blas:zgemm!")) (td (i "unsafe-blas:zgemm!"))))) (section 3 "Vector copy routines" (def (sig (procedure "blas:scopy:: F32VECTOR -> F32VECTOR " (id blas:scopy)))) (def (sig (procedure "blas:dcopy:: F64VECTOR -> F64VECTOR " (id blas:dcopy)))) (def (sig (procedure "blas:ccopy:: F32VECTOR -> F32VECTOR " (id blas:ccopy)))) (def (sig (procedure "blas:zcopy:: F64VECTOR -> F64VECTOR " (id blas:zcopy))) (p "These procedures return a copy of given input SRFI-4 vector. The returned vector is allocated with the corresponding SRFI-4 constructor, and the input vector is copied to it by the corresponding BLAS copy procedure."))) (section 3 "BLAS level 1 routines" (section 4 "Conventions" (p "The BLAS level 1 procedures in this egg differ from the actual routines they invoke by the position of the vector increment arguments (" (tt "INCX") " and " (tt "INCY") "). In this egg, these arguments are optional; the default value of " (tt "INCX") " and " (tt "INCY") " is 1.") (p "In the procedure signatures below, these optional arguments are indicated by [ and ] (square brackets).")) (section 4 "Apply plane rotation" (def (sig (procedure "blas:srot:: N * X * Y * C * S [INCX * INCY] -> F32VECTOR * F32VECTOR " (id blas:srot)))) (def (sig (procedure "blas:drot:: N * X * Y * C * S [INCX * INCY] -> F64VECTOR * F64VECTOR " (id blas:drot))) (p (tt "xROT") " applies a plane rotation matrix to a sequence of ordered pairs: " (tt "(x_i , y_i)") ", for " (tt "i = 1, 2, ..., n") ".") (p (tt "X") " and " (tt "Y") " are vector of dimensions " (tt "(N-1) * abs(incx) + 1") " and " (tt "(N-1) * abs(incy) + 1") ", respectively.") (p (tt "C") " and " (tt "S") " are respectively the cosine and sine of the plane of rotation."))) (section 4 "Scale vector" (def (sig (procedure "blas:sscal:: N * ALPHA * X [INCX] -> F32VECTOR " (id blas:sscal)))) (def (sig (procedure "blas:dscal:: N * ALPHA * X [INCX] -> F64VECTOR " (id blas:dscal)))) (def (sig (procedure "blas:cscal:: N * ALPHA * X [INCX] -> F32VECTOR " (id blas:cscal)))) (def (sig (procedure "blas:zscal:: N * ALPHA * X [INCX] -> F64VECTOR " (id blas:zscal))) (p (tt "xSCAL") " scales a vector with a scalar: " (tt "x := alpha * x") "."))) (section 4 "Swap the elements of two vectors" (def (sig (procedure "blas:sswap:: N * X * Y [INCX * INCY] -> F32VECTOR " (id blas:sswap)))) (def (sig (procedure "blas:dswap:: N * X * Y [INCX * INCY] -> F64VECTOR " (id blas:dswap)))) (def (sig (procedure "blas:cswap:: N * X * Y [INCX * INCY] -> F32VECTOR " (id blas:cswap)))) (def (sig (procedure "blas:zswap:: N * X * Y [INCX * INCY] -> F64VECTOR " (id blas:zswap))) (p (tt "xSWAP") " interchanges the elements of two vectors: " (tt "x <-> y") "."))) (section 4 "Real vector dot product" (def (sig (procedure "blas:sdot:: N * X * Y [INCX * INCY] -> NUMBER " (id blas:sdot)))) (def (sig (procedure "blas:ddot:: N * X * Y [INCX * INCY] -> NUMBER " (id blas:ddot))) (p (tt "xDOT") " computes the dot product of two vectors of real values: " (tt "dot := x'*y = \\Sum_{i=1}^{n} (x_i * y_i)") "."))) (section 4 "Complex vector dot product" (def (sig (procedure "blas:cdotu:: N * X * Y [INCX * INCY] -> NUMBER " (id blas:cdotu)))) (def (sig (procedure "blas:zdotu:: N * X * Y [INCX * INCY] -> NUMBER " (id blas:zdotu))) (p (tt "xDOTU") " computes the dot product of two vectors of complex values: " (tt "dotu := x'*y = \\Sum_{i=1}^{n} (x_i * y_i)") "."))) (section 4 "Hermitian vector dot product" (def (sig (procedure "blas:cdotc:: N * X * Y [INCX * INCY] -> NUMBER " (id blas:cdotc)))) (def (sig (procedure "blas:zdotc:: N * X * Y [INCX * INCY] -> NUMBER " (id blas:zdotc))) (p (tt "xDOTC") " computes the dot product of the conjugates of two complex vectors: " (tt "dotu := conjg(x')*y = \\Sum_{i=1}^{n} (conjg(x_i) * y_i)") ", for " (tt "i = 1, 2, ..., n") "."))) (section 4 "Vector multiply-add" (def (sig (procedure "blas:saxpy:: N * ALPHA * X * Y [INCX * INCY] -> F32VECTOR " (id blas:saxpy)))) (def (sig (procedure "blas:daxpy:: N * ALPHA * X * Y [INCX * INCY] -> F64VECTOR " (id blas:daxpy)))) (def (sig (procedure "blas:caxpy:: N * ALPHA * X * Y [INCX * INCY] -> F32VECTOR " (id blas:caxpy)))) (def (sig (procedure "blas:zaxpy:: N * ALPHA * X * Y [INCX * INCY] -> F64VECTOR " (id blas:zaxpy))) (p (tt "xAXPY") " adds a scalar multiple of a vector to another vector: " (tt "y := alpha * x + y") "."))) (section 4 "Vector multiply-add with optional offset" (def (sig (procedure "blas:siaxpy:: N * ALPHA * X * Y [INCX * INCY * XOFS * YOFS] -> F32VECTOR " (id blas:siaxpy)))) (def (sig (procedure "blas:diaxpy:: N * ALPHA * X * Y [INCX * INCY * XOFS * YOFS] -> F64VECTOR " (id blas:diaxpy)))) (def (sig (procedure "blas:ciaxpy:: N * ALPHA * X * Y [INCX * INCY * XOFS * YOFS] -> F32VECTOR " (id blas:ciaxpy)))) (def (sig (procedure "blas:ziaxpy:: N * ALPHA * X * Y [INCX * INCY * XOFS * YOFS] -> F64VECTOR " (id blas:ziaxpy))) (p (tt "xIAXPY") " adds a scalar multiple of a vector to another vector, where the beginning of each vector argument can be offset: " (tt "y[yofs:n] := alpha * x[xofs:n] + y[yofs:n]") "."))) (section 4 "Euclidean norm of a vector" (def (sig (procedure "blas:snrm2:: N * X [INCX] -> NUMBER " (id blas:snrm2)))) (def (sig (procedure "blas:dnrm2:: N * X [INCX] -> NUMBER " (id blas:dnrm2)))) (def (sig (procedure "blas:cnrm2:: N * X [INCX] -> NUMBER " (id blas:cnrm2)))) (def (sig (procedure "blas:znrm2:: N * X [INCX] -> NUMBER " (id blas:znrm2))) (p (tt "xNRM2") " computes the Euclidean (L2) norm of a vector."))) (section 4 "Sum of absolute values of the elements in a vector" (def (sig (procedure "blas:sasum:: N * X [INCX] -> NUMBER " (id blas:sasum)))) (def (sig (procedure "blas:dasum:: N * X [INCX] -> NUMBER " (id blas:dasum)))) (def (sig (procedure "blas:casum:: N * X [INCX] -> NUMBER " (id blas:casum)))) (def (sig (procedure "blas:zasum:: N * X [INCX] -> NUMBER " (id blas:zasum))) (p (tt "xASUM") " sums the absolute values of the elements in a vector."))) (section 4 "Sum of absolute values of the elements in a vector" (def (sig (procedure "blas:samax:: N * X [INCX] -> INDEX " (id blas:samax)))) (def (sig (procedure "blas:damax:: N * X [INCX] -> INDEX " (id blas:damax)))) (def (sig (procedure "blas:camax:: N * X [INCX] -> INDEX " (id blas:camax)))) (def (sig (procedure "blas:zamax:: N * X [INCX] -> INDEX " (id blas:zamax))) (p (tt "xAMAX") " searches a vector for the first occurrence of its maximum absolute value, and returns the index of that element.")))) (section 3 "BLAS level 2 routines" (section 4 "Conventions" (p "The BLAS level 2 procedures in this egg differ from the actual routines they invoke by the position of the leading dimension argument (" (tt "LDA") ")  and the vector increment arguments (" (tt "INCX") " and " (tt "INCY") "). In this egg, these arguments are optional; the default value of " (tt "LDA") "is the largest matrix dimension, depending on the semantics of the respective operation, and the default value of " (tt "INCX") " and " (tt "INCY") " is 1.") (p "In the procedure signatures below, these optional arguments are indicated by [ and ] (square brackets).") (p "Argument " (tt "ORDER") " is one of " (tt "blas:RowMajor") " or " (tt "blas:ColMajor") " to indicate that the input and output matrices are in row-major or column-major form, respectively.") (p "Where present, argument " (tt "TRANS") " can be one of " (tt "blas:NoTrans") " or " (tt "blas:Trans") " to indicate whether the input matrix is to be transposed or not.") (p "Where present, argument " (tt "UPLO") " can be one of " (tt "blas:Upper") " or " (tt "blas:Lower") " to indicate whether the upper or lower triangular part of an input symmetric matrix is to referenced,or to specify the type of an input triangular matrix.") (p "Where present, argument " (tt "DIAG") " can be one of " (tt "blas:NonUnit") " or " (tt "blas:Unit") " to indicate whether an input triangular matrix is unit triangular or not.")) (section 4 "General matrix-vector multiply-add" (def (sig (procedure "blas:sgemv:: ORDER * TRANS * M * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:sgemv)))) (def (sig (procedure "blas:dgemv:: ORDER * TRANS * M * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:dgemv)))) (def (sig (procedure "blas:cgemv:: ORDER * TRANS * M * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:cgemv)))) (def (sig (procedure "blas:zgemv:: ORDER * TRANS * M * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:zgemv))) (p (tt "xGEMV") " performs the matrix-vector multiply-add operation of the form " (tt "y := alpha*op( A )*x + beta*y") ", where " (tt "op( X )") " is one of " (tt "op( A ) = A") " or " (tt "op( A ) = A'") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "M x N") " matrix.") (p (tt "X") " is a vector of size " (tt "(1 + ( N - 1 ) * abs(INCX))") " when argument " (tt "TRANS") " is " (tt "blas:NoTrans") ", and " (tt "(1 + ( M - 1 ) * abs(INCX))") " otherwise. " (tt "Y") " is a vector of size " (tt "(1 + ( M - 1 ) * abs(INCY))") " when argument " (tt "TRANS") " is " (tt "blas:NoTrans") ", and " (tt "(1 + ( N - 1 ) * abs(INCY))") " otherwise."))) (section 4 "Banded matrix-vector multiply-add" (def (sig (procedure "blas:sgbmv:: ORDER * TRANS * M * N * KL * KU * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:sgbmv)))) (def (sig (procedure "blas:dgbmv:: ORDER * TRANS * M * N * KL * KU * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:dgbmv)))) (def (sig (procedure "blas:cgbmv:: ORDER * TRANS * M * N * KL * KU * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:cgbmv)))) (def (sig (procedure "blas:zgbmv:: ORDER * TRANS * M * N * KL * KU * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:zgbmv))) (p (tt "xGBMV") " performs the matrix-vector multiply-add operation of the form " (tt "y := alpha*op( A )*x + beta*y") ", where " (tt "op( X )") " is one of " (tt "op( A ) = A") " or " (tt "op( A ) = A'") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "M x N") " banded matrix, with " (tt "KL") " sub-diagonals and " (tt "KU") " super-diagonals.") (p (tt "X") " is a vector of size " (tt "(1 + ( N - 1 ) * abs(INCX))") " when argument " (tt "TRANS") " is " (tt "blas:NoTrans") ", and " (tt "(1 + ( M - 1 ) * abs(INCX))") " otherwise. " (tt "Y") " is a vector of size " (tt "(1 + ( M - 1 ) * abs(INCY))") " when argument " (tt "TRANS") " is " (tt "blas:NoTrans") ", and " (tt "(1 + ( N - 1 ) * abs(INCY))") " otherwise."))) (section 4 "Hermitian matrix-vector multiply-add" (def (sig (procedure "blas:chemv:: ORDER * UPLO * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:chemv)))) (def (sig (procedure "blas:zhemv:: ORDER * UPLO * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:zhemv))) (p (tt "xHEMV") " performs the matrix-vector multiply-add operation of the form " (tt "y := alpha*op( A )*x + beta*y") ", where " (tt "op( X )") " is one of " (tt "op( A ) = A") " or " (tt "op( A ) = A'") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "N x N") " Hermitian matrix.") (p (tt "X") " and " (tt "Y") " are " (tt "N") " element vectors."))) (section 4 "Hermitian banded matrix-vector multiply-add" (def (sig (procedure "blas:chbmv:: ORDER * UPLO * N * K * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:chbmv)))) (def (sig (procedure "blas:zhbmv:: ORDER * UPLO * N * K * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:zhbmv))) (p (tt "xHBMV") " performs the matrix-vector multiply-add operation of the form " (tt "y := alpha*op( A )*x + beta*y") ", where " (tt "op( X )") " is one of " (tt "op( A ) = A") " or " (tt "op( A ) = A'") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "N x N") " Hermitian banded matrix, with " (tt "K") " super-diagonals.") (p (tt "X") " and " (tt "Y") " are " (tt "N") " element vectors."))) (section 4 "Symmetric matrix-vector multiply-add" (def (sig (procedure "blas:ssymv::  ORDER * UPLO * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:ssymv)))) (def (sig (procedure "blas:dsymv:: ORDER * UPLO * N * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:dsymv))) (p (tt "xSYMV") " performs matrix-vector multiply-add operation of the form " (tt "y := alpha*A*x + beta*y") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "N x N") " symmetric matrix.") (p (tt "X") " and " (tt "Y") " are " (tt "N") " element vectors."))) (section 4 "Banded symmetric matrix-vector multiply-add" (def (sig (procedure "blas:ssbmv::  ORDER * UPLO * N * K * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F32VECTOR " (id blas:ssbmv)))) (def (sig (procedure "blas:dsbmv:: ORDER * UPLO * N * K * ALPHA * A * X * BETA * Y [LDA * INCX * INCY] -> F64VECTOR " (id blas:dsbmv))) (p (tt "xSBMV") " performs matrix-vector multiply-add operation of the form " (tt "y := alpha*A*B + beta*y") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "N x N") " symmetric banded matrix, with " (tt "K") " super-diagonals.") (p (tt "X") " and " (tt "Y") " are " (tt "N") " element vectors."))) (section 4 "Triangular matrix-vector multiply-add" (def (sig (procedure "blas:strmv::  ORDER * UPLO * TRANS * DIAG * N * A * X [LDA * INCX] -> F32VECTOR " (id blas:strmv)))) (def (sig (procedure "blas:dtrmv::  ORDER * UPLO * TRANS * DIAG * N * A * X [LDA * INCX] -> F64VECTOR " (id blas:dtrmv)))) (def (sig (procedure "blas:ctrmv::  ORDER * UPLO * TRANS * DIAG * N * A * X [LDA * INCX] -> F32VECTOR " (id blas:ctrmv)))) (def (sig (procedure "blas:ztrmv::  ORDER * UPLO * TRANS * DIAG * N * A * X [LDA * INCX] -> F64VECTOR " (id blas:ztrmv))) (p (tt "xTRMV") " performs matrix-vector multiply-add operation of the form " (tt "y := alpha*op( A )*x") ", where " (tt "op ( A ) = A") " or " (tt "op ( A ) = A'")) (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "N x N") " upper or lower triangular matrix.") (p (tt "X") " is a vector of length " (tt "(1 + (n - 1) * abs(INCX))") "."))) (section 4 "Banded triangular matrix-vector multiply-add" (def (sig (procedure "blas:stbmv::  ORDER * UPLO * TRANS * DIAG * N * K * A * X [LDA * INCX] -> F32VECTOR " (id blas:stbmv)))) (def (sig (procedure "blas:dtbmv::  ORDER * UPLO * TRANS * DIAG * N * K * A * X [LDA * INCX] -> F64VECTOR " (id blas:dtbmv)))) (def (sig (procedure "blas:ctbmv::  ORDER * UPLO * TRANS * DIAG * N * K * A * X [LDA * INCX] -> F32VECTOR " (id blas:ctbmv)))) (def (sig (procedure "blas:ztbmv::  ORDER * UPLO * TRANS * DIAG * N * K * A * X [LDA * INCX] -> F64VECTOR " (id blas:ztbmv))) (p (tt "xTBMV") " performs matrix-vector multiply-add operation of the form " (tt "y := alpha*A*B + beta*y") ", where " (tt "op ( A ) = A") " or " (tt "op ( A ) = A'")) (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") " is an " (tt "N x N") " upper or lower triangular banded matrix, with " (tt "K+1") " diagonals.") (p (tt "X") " is a vector of length " (tt "(1 + (n - 1) * abs(INCX))") "."))) (section 4 "Triangular matrix equation solve" (def (sig (procedure "blas:strsv:: ORDER * UPLO * TRANS * DIAG * N * ALPHA * A * B * [LDA * INCB] -> F32VECTOR " (id blas:strsv)))) (def (sig (procedure "blas:dtrsv:: ORDER * UPLO * TRANS * DIAG * N * A * B * [LDA * INCB] -> F64VECTOR " (id blas:dtrsv)))) (def (sig (procedure "blas:ctrsv:: ORDER * UPLO * TRANS * DIAG * N * A * B * [LDA * INCB] -> F32VECTOR " (id blas:ctrsv)))) (def (sig (procedure "blas:ztrsv:: ORDER * UPLO * TRANS * DIAG * N * A * B * [LDA * INCB] -> F64VECTOR " (id blas:ztrsv))) (p (tt "xTRSV") " solves one of the systems of equations " (tt "A*x = b") " or " (tt "A'*x = b") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " is a upper or lower triangular matrix, and " (tt "B") " is a " (tt "N") " element vector."))) (section 4 "Banded triangular matrix equation solve" (def (sig (procedure "blas:stbsv:: ORDER * UPLO * TRANS * DIAG * N * K * A * B * [LDA * INCB] -> F32VECTOR " (id blas:stbsv)))) (def (sig (procedure "blas:dtbsv:: ORDER * UPLO * TRANS * DIAG * N * K * A * B * [LDA * INCB] -> F64VECTOR " (id blas:dtbsv)))) (def (sig (procedure "blas:ctbsv:: ORDER * UPLO * TRANS * DIAG * N * K * A * B * [LDA * INCB] -> F32VECTOR " (id blas:ctbsv)))) (def (sig (procedure "blas:ztbsv:: ORDER * UPLO * TRANS * DIAG * N * K * A * B * [LDA * INCB] -> F64VECTOR " (id blas:ztbsv))) (p (tt "xTBSV") " solves one of the systems of equations " (tt "A*x = b") " or " (tt "A'*x = b") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " is a upper or lower banded triangular matrix with " (tt "K+1") " diagonals, and " (tt "B") " is a " (tt "N") " element vector."))) (section 4 "Rank 1 operation" (def (sig (procedure "blas:sger:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F32VECTOR " (id blas:sger)))) (def (sig (procedure "blas:dger:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F64VECTOR " (id blas:dger))) (p (tt "xGER") " performs the rank 1 operation " (tt "A := alpha*x*y' + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " is an " (tt "M") " element vector, " (tt "Y") " is an " (tt "N") " element vector, and " (tt "A") " is an " (tt "M x N") " matrix."))) (section 4 "Rank 1 operation with optional offset" (def (sig (procedure "blas:siger:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY * XOFS * YOFS] -> F32VECTOR " (id blas:siger)))) (def (sig (procedure "blas:diger:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY * XOFS * YOFS] -> F64VECTOR " (id blas:diger))) (p (tt "xIGER") " performs the rank 1 operation " (tt "A := alpha*x[xofs:M]*y'[yofs:N] + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " is an " (tt "M") " element vector, " (tt "Y") " is an " (tt "N") " element vector, and " (tt "A") " is an " (tt "M x N") " matrix."))) (section 4 "Rank 1 operation on complex matrices and vectors" (def (sig (procedure "blas:cgeru:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F32VECTOR " (id blas:cgeru)))) (def (sig (procedure "blas:zgeru:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F64VECTOR " (id blas:zgeru))) (p (tt "xGERU") " performs the rank 1 operation " (tt "A := alpha*x*y' + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " is an " (tt "M") " element vector, " (tt "Y") " is an " (tt "N") " element vector, and " (tt "A") " is an " (tt "M x N") " matrix."))) (section 4 "Rank 1 operation on complex matrices and vectors" (def (sig (procedure "blas:cgerc:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F32VECTOR " (id blas:cgerc)))) (def (sig (procedure "blas:zgerc:: ORDER * M * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F64VECTOR " (id blas:zgerc))) (p (tt "xGERC") " performs the rank 1 operation " (tt "A := alpha*x*conjg(y') + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " is an " (tt "M") " element vector, " (tt "Y") " is an " (tt "N") " element vector, and " (tt "A") " is an " (tt "M x N") " matrix."))) (section 4 "Hermitian rank 1 operation" (def (sig (procedure "blas:cher:: ORDER * UPLO * N * ALPHA * X * A [LDA * INCX] -> F32VECTOR " (id blas:cher)))) (def (sig (procedure "blas:zher:: ORDER * UPLO * N * ALPHA * X * A [LDA * INCX] -> F64VECTOR " (id blas:zher))) (p (tt "xHER") " performs the Hermitian rank 1 operation " (tt "A := alpha*x*conjg(x') + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " is an " (tt "N") " element vector, and " (tt "A") " is an " (tt "N x N") " Hermitian matrix."))) (section 4 "Hermitian rank 2 operation" (def (sig (procedure "blas:cher2:: ORDER * UPLO * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F32VECTOR " (id blas:cher2)))) (def (sig (procedure "blas:zher2:: ORDER * UPLO * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F64VECTOR " (id blas:zher2))) (p (tt "xHER2") " performs the Hermitian rank 2 operation " (tt "A := alpha*x*conjg(y') + conjg(alpha)*y*conjg(x') + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " and " (tt "Y") " are " (tt "N") " element vectors, and " (tt "A") " is an " (tt "N x N") " Hermitian matrix."))) (section 4 "Symmetric rank 1 operation" (def (sig (procedure "blas:ssyr:: ORDER * UPLO * N * ALPHA * X * A [LDA * INCX] -> F32VECTOR " (id blas:ssyr)))) (def (sig (procedure "blas:dsyr:: ORDER * UPLO * N * ALPHA * X * A [LDA * INCX] -> F64VECTOR " (id blas:dsyr))) (p (tt "xSYR") " performs the symmetric rank 1 operation " (tt "A := alpha*x*x' + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " is an " (tt "N") " element vector, and " (tt "A") " is an " (tt "N x N") " symmetric matrix."))) (section 4 "Symmetric rank 2 operation" (def (sig (procedure "blas:ssyr2:: ORDER * UPLO * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F32VECTOR " (id blas:ssyr2)))) (def (sig (procedure "blas:dsyr2:: ORDER * UPLO * N * ALPHA * X * Y * A [LDA * INCX * INCY] -> F64VECTOR " (id blas:dsyr2))) (p (tt "xSYR2") " performs the symmetric rank 2 operation " (tt "A := alpha*x*y' + alpha*y*x' + A") ".") (p (tt "ALPHA") " is a  scalar, " (tt "X") " and " (tt "Y") " are " (tt "N") " element vectors, and " (tt "A") " is an " (tt "N x N") " symmetric matrix.")))) (section 3 "BLAS level 3 routines" (section 4 "Conventions" (p "The BLAS level 3 procedures in this egg differ from the actual routines they invoke by the position of the leading dimension arguments (" (tt "LDA") ", " (tt "LDB") ", and " (tt "LDC") "). In this egg, these arguments are optional, and their default values are set to the largest matrix dimension, depending on the semantics of the respective operation.") (p "In the procedure signatures below, these optional arguments are indicated by [ and ] (square brackets).") (p "Argument " (tt "ORDER") " is one of " (tt "blas:RowMajor") " or " (tt "blas:ColMajor") " to indicate that the input and output matrices are in row-major or column-major form, respectively.") (p "Where present, arguments " (tt "TRANS") ", " (tt "TRANSA") ", " (tt "TRANSB") " can be one of " (tt "blas:NoTrans") " or " (tt "blas:Trans") " to indicate whether the respective input matrices are to be transposed or not.") (p "Where present, argument " (tt "SIDE") " can be one of " (tt "blas:Left") " or " (tt "blas:Right") " to indicate whether an input symmetric matrix appears on the left or right in the respective operation.") (p "Where present, argument " (tt "UPLO") " can be one of " (tt "blas:Upper") " or " (tt "blas:Lower") " to indicate whether the upper or lower triangular part of an input symmetric matrix is to referenced,or to specify the type of an input triangular matrix.") (p "Where present, argument " (tt "DIAG") " can be one of " (tt "blas:NonUnit") " or " (tt "blas:Unit") " to indicate whether an input triangular matrix is unit triangular or not.")) (section 4 "General matrix multiply-add" (def (sig (procedure "blas:sgemm:: ORDER * TRANSA * TRANSB * M * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:sgemm)))) (def (sig (procedure "blas:dgemm:: ORDER * TRANSA * TRANSB * M * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:dgemm)))) (def (sig (procedure "blas:cgemm:: ORDER * TRANSA * TRANSB * M * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:cgemm)))) (def (sig (procedure "blas:zgemm:: ORDER * TRANSA * TRANSB * M * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:zgemm))) (p (tt "xGEMM") " performs matrix-matrix multiply-add operation of the form " (tt "C := alpha*op( A )*op( B ) + beta*C") ", where " (tt "op( X )") " is one of " (tt "op( X ) = X") " or " (tt "op( X ) = X'") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, and " (tt "A") ", " (tt "B") " and " (tt "C") " are matrices, with " (tt "op( A )") " an " (tt "M x K") " matrix, " (tt "op( B )") " a " (tt "K x N") " matrix and " (tt "C") " an " (tt "M x N") " matrix."))) (section 4 "Symmetric matrix multiply-add" (def (sig (procedure "blas:ssymm:: ORDER * SIDE * UPLO * M * N * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:ssymm)))) (def (sig (procedure "blas:dsymm:: ORDER * SIDE * UPLO * M * N * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:dsymm)))) (def (sig (procedure "blas:csymm:: ORDER * SIDE * UPLO * M * N * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:csymm)))) (def (sig (procedure "blas:zsymm:: ORDER * SIDE * UPLO * M * N * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:zsymm))) (p (tt "xSYMM") " performs matrix-matrix multiply-add operation of the form " (tt "C := alpha*A*B + beta*C") " or " (tt "C := alpha*B*A + beta*C") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " is a symmetric matrix, and " (tt "B") " and " (tt "C") " are " (tt "M x N") " matrices."))) (section 4 "Symmetric rank k operation" (def (sig (procedure "blas:ssyrk:: ORDER * UPLO * TRANS * N * K * ALPHA * A * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:ssyrk)))) (def (sig (procedure "blas:dsyrk:: ORDER * UPLO * TRANS * N * K * ALPHA * A * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:dsyrk)))) (def (sig (procedure "blas:csyrk:: ORDER * UPLO * TRANS * N * K * ALPHA * A * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:csyrk)))) (def (sig (procedure "blas:zsyrk:: ORDER * UPLO * TRANS * N * K * ALPHA * A * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:zsyrk))) (p (tt "xSYRK") " performs one of the symmetric rank k operations " (tt "C := alpha*A*A' + beta*C") " or " (tt "C := alpha*A'*A + beta*C") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " is an " (tt "N x K") " or " (tt "K x N") " matrix, and " (tt "C") " is an " (tt "N x N") " symmetric matrix."))) (section 4 "Hermitian rank k operation" (def (sig (procedure "blas:cherk:: ORDER * UPLO * TRANS * N * K * ALPHA * A * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:cherk)))) (def (sig (procedure "blas:zherk:: ORDER * UPLO * TRANS * N * K * ALPHA * A * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:zherk))) (p (tt "xHERK") " performs one of the hermitian rank k operations " (tt "C := alpha*A*conjg(A') + beta*C") " or " (tt "C := alpha*conjg(A')*A + beta*C") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " is an " (tt "N x K") " or " (tt "K x N") " matrix, and " (tt "C") " is an " (tt "N x N") " hermitian matrix."))) (section 4 "Symmetric rank 2k operation" (def (sig (procedure "blas:ssyr2k:: ORDER * UPLO * TRANS * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:ssyr2k)))) (def (sig (procedure "blas:dsyr2k:: ORDER * UPLO * TRANS * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:dsyr2k)))) (def (sig (procedure "blas:csyr2k:: ORDER * UPLO * TRANS * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:csyr2k)))) (def (sig (procedure "blas:zsyr2k:: ORDER * UPLO * TRANS * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:zsyr2k))) (p (tt "xSYR2K") " performs one of the symmetric rank 2k operations " (tt "C := alpha*A*B' + beta*C") " or " (tt "C := alpha*B'*A + beta*C") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " and " (tt "B") " are " (tt "N x K") " or " (tt "K x N") " matrices, and " (tt "C") " is an " (tt "N x N") " symmetric matrix."))) (section 4 "Hermitian rank 2k operation" (def (sig (procedure "blas:cher2k:: ORDER * UPLO * TRANS * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F32VECTOR " (id blas:cher2k)))) (def (sig (procedure "blas:zher2k:: ORDER * UPLO * TRANS * N * K * ALPHA * A * B * BETA * C [LDA * LDB * LDC] -> F64VECTOR " (id blas:zher2k))) (p (tt "xHER2K") " performs one of the hermitian rank 2k operations " (tt "C := alpha*A*conjg(B') + beta*C") " or " (tt "C := alpha*conjg(B')*A + beta*C") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " and " (tt "B") " are " (tt "N x K") " or " (tt "K x N") " matrices, and " (tt "C") " is an " (tt "N x N") " hermitian matrix."))) (section 4 "Triangular matrix multiply" (def (sig (procedure "blas:strmm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B [LDA * LDB] -> F32VECTOR " (id blas:strmm)))) (def (sig (procedure "blas:dtrmm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B [LDA * LDB] -> F64VECTOR " (id blas:dtrmm)))) (def (sig (procedure "blas:ctrmm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B [LDA * LDB] -> F32VECTOR " (id blas:ctrmm)))) (def (sig (procedure "blas:ztrmm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B [LDA * LDB] -> F64VECTOR " (id blas:ztrmm))) (p (tt "xTRMM") " performs matrix-matrix multiply operation of the form " (tt "B := alpha*op( A )*B") " or " (tt "B := alpha*B*op( A )") ".") (p (tt "ALPHA") " is a  scalar, " (tt "A") " is an upper or lower triangular matrix, and " (tt "B") " is an " (tt "M x N") " matrix."))) (section 4 "Triangular matrix equation solve" (def (sig (procedure "blas:strsm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B * [LDA * LDB * LDC] -> F32VECTOR " (id blas:strsm)))) (def (sig (procedure "blas:dtrsm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B * [LDA * LDB * LDC] -> F64VECTOR " (id blas:dtrsm)))) (def (sig (procedure "blas:ctrsm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B * [LDA * LDB * LDC] -> F32VECTOR " (id blas:ctrsm)))) (def (sig (procedure "blas:ztrsm:: ORDER * SIDE * UPLO * TRANSA * DIAG * M * N * ALPHA * A * B * [LDA * LDB * LDC] -> F64VECTOR " (id blas:ztrsm))) (p (tt "xTRSM") " solves one of the matrix equations " (tt "op( A )*X = alpha*B") " or " (tt "X*op( A ) = alpha*B") ".") (p (tt "op( A )") " is one of " (tt "op( A ) = A") " or " (tt "op( A ) = A'") ".") (p (tt "ALPHA") " and " (tt "BETA") " are  scalars, " (tt "A") " is a upper or lower triangular matrix, and " (tt "B") " is a " (tt "M x N") " matrix."))))) (section 2 "Examples" (pre "\n(use srfi-4 blas)\n\n(define order blas:ColMajor)\n(define transa blas:NoTrans)\n\n(define m 4)\n(define n 4)\n\n(define alpha 1)\n(define beta 0)\n\n(define a\t\t\t\t; column-major order!\n  (f64vector 1 2 3 4\n\t     1 1 1 1\n\t     3 4 5 6\n\t     5 6 7 8) )\n\n(define x (f64vector 1 2 1 1))\n(define y (f64vector 0 0 0 0))\n   \n(blas:dgemv! order transa m n alpha a x beta y)\n\n(print y)")) (section 2 "About this egg" (section 3 "Author" (p (int-link "/users/felix-winkelmann" "Felix Winkelmann") " and " (int-link "/users/ivan-raikov" "Ivan Raikov"))) (section 3 "Version history" (dl (dt "2.7") (dd "Switched to wiki documentation") (dt "2.6") (dd "Ported to Chicken 4") (dt "2.5") (dd "Build script updated for better cross-platform compatibility") (dt "2.4") (dd "Added iger procedures; fixed a bug in the default arguments of level 2 routines") (dt "2.3") (dd "Added iaxpy procedures; fixed a bug in the default arguments of level 1 routines") (dt "2.2") (dd "Fixed a bug in the renaming of C routines") (dt "2.1") (dd "Added eggdoc property to meta file") (dt "2.0") (dd "An overhaul of the library to introduce safe, unsafe, and pure variants of each routine") (dt "1.8") (dd "Added icopy procedures [by Ivan Raikov]") (dt "1.7") (dd "Support for Mac OS X added [by Will Farr]") (dt "1.6") (dd "Fixed bug in blas library test code") (dt "1.5") (dd "Added support for CLAPACK [by Ivan Raikov]") (dt "1.4") (dd "Added support for atlas CBLAS library [by Stu Glaser]") (dt "1.3") (dd "Tries to find a proper CBLAS library (currently only GSL)") (dt "1.2") (dd "Adapted to new FFI macro-names") (dt "1.1") (dd "Adapted to new setup scheme"))) (section 3 "License" (pre "Copyright (c) 2003-2006, Felix L. Winkelmann \nCopyright (c) 2007-2010 Ivan Raikov\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n  Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n  Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\n  Neither the name of the author nor the names of its contributors may\nbe used to endorse or promote products derived from this software\nwithout specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\nBUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\nCOPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\nOF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\nTORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE."))))