(index ("database?" 0) ("error-database" 131) ("check-database" 324) ("statement?" 541) ("error-statement" 687) ("check-statement" 883) ("open-database" 1104) ("define-collation" 1392) ("define-function" 2275) ("define-function" 2275) ("set-busy-handler!" 4323) ("make-busy-timeout" 5093) ("interrupt!" 5543) ("auto-committing?" 5753) ("change-count" 6027) ("last-insert-rowid" 6366) ("finalize!" 6592) ("finalize!" 6592) ("prepare" 7404) ("source-sql" 7640) ("column-count" 7767) ("column-name" 8023) ("column-declared-type" 8337) ("bind-parameter-count" 8733) ("bind-parameter-index" 9022) ("bind-parameter-name" 9355) ("bind!" 9716) ("bind-parameters!" 10544) ("step!" 10992) ("column-type" 11364) ("column-data" 11851) ("reset!" 12772) ("call-with-temporary-statements" 12984) ("execute" 13411) ("execute" 13411) ("update" 13717) ("update" 13717) ("first-result" 14180) ("first-result" 14180) ("first-row" 14753) ("first-row" 14753) ("fold-row" 15252) ("fold-row" 15252) ("for-each-row" 15813) ("for-each-row" 15813) ("map-row" 16278) ("map-row" 16278) ("with-transaction" 16737) ("sql-complete?" 17340) ("enable-shared-cache!" 17499) ("database-version" 17721) ("database-memory-used" 17863) ("database-memory-highwater" 18034))
(def (sig (procedure "(database? OBJECT) => BOOLEAN" (id database?))) (p "Checks whether a value represents an SQLite database."))
(def (sig (procedure "(error-database LOCATION OBJECT [ARGUMENT-NAME]) => VOID" (id error-database))) (p "Raises a type error saying that a database was expected instead of the given value."))
(def (sig (procedure "(check-database LOCATION OBJECT [ARGUMENT-NAME]) => VOID" (id check-database))) (p "Raises a type error like " (tt "error-database") " does, unless the given value satisfies " (tt "database?")))
(def (sig (procedure "(statement? OBJECT) => BOOLEAN" (id statement?))) (p "Checks whether the value " (tt "v") " represents an SQL statement."))
(def (sig (procedure "(error-statement LOCATION OBJECT [ARGUMENT-NAME]) => VOID" (id error-statement))) (p "Raises a type error saying that a statement was expected instead of the given value."))
(def (sig (procedure "(check-statement LOCATION OBJECT [ARGUMENT-NAME]) => VOID" (id check-statement))) (p "Raises a type error like " (tt "error-statement") " does, unless the given value satisfies " (tt "statement?")))
(def (sig (procedure "(open-database PATH) => DATABASE" (id open-database))) (p "Opens the indicated database file and returns a database object for it.") (p "The given path is subject to the same special expansion as paths passed to " (tt "open-input-file") " and similar procedures."))
(def (sig (procedure "(define-collation DATABASE NAME [PROC]) => VOID" (id define-collation))) (p "If a procedure is given, registers a new collation sequence identified by " (tt "name") " for use in the context of database handle " (tt "db") ". If no procedure is passed, the collation sequence with the given name is removed.") (p (tt "PROC") " should have the signature " (tt "(PROC STRING STRING) => FIXNUM") ". It should return a negative number if the first argument sorts before the second, a positive number if the second sorts before the first and zero if they are equal.") (p "As " (tt "PROC") " will be called in a callback context from within " (tt "step!") ", safety measures are installed to avoid throwing any exceptions, invoking continuations or returning invalid values from it. Attempts to do so will result in a " (tt "0") " return value and warning messages."))
(def (sig (procedure "(define-function DATABASE NAME N PROC) => VOID" (id define-function)) (procedure "(define-function DATABASE NAME N STEP-PROC SEED [FINAL-PROC]) => VOID" (id define-function))) (p "Registers a new SQL function identified by " (tt "NAME") " for use in the context of the given database handle. If " (tt "STEP-PROC") " and " (tt "SEED") " are given, the new function becomes an aggregate function. Once registered, functions cannot be deleted.") (p (tt "N") " is the number of parameters the new SQL function takes or " (tt "-1") " to allow any number of arguments.") (p (tt "PROC") " should have the signature " (tt "(PROC . PARAMS) => OBJECT") ". It is called with the " (tt "N") " parameters given to the SQL function converted into Scheme objects like by " (tt "column-data") ". The return value is converted into an SQLite data object like by " (tt "bind!") ". A return value satisfying " (tt "sql-null?") " corresponds to " (tt "NULL") " in SQLite.") (p (tt "STEP-PROC") " should have the signature " (tt "(STEP-PROC SEED PARAMS) => SEED") ". It is called with the parameters given to the SQL function for every row being processed. The seed value passed is initially the one given as an argument to " (tt "define-function") "; for subsequent calls it is the last value returned by " (tt "STEP-PROC") " and after completion of " (tt "FINAL-PROC") " it will be the initial value again.") (p (tt "FINAL-PROC") " should have the signature " (tt "(FINAL-PROC SEED) => OBJECT") " and transforms the last seed value into the value to be returned from the aggregate function. If it is not explicitly specified, " (tt "STEP-PROC") " defaults to the identity function.") (p "As " (tt "PROC") ", " (tt "STEP-PROC") " and " (tt "FINAL-PROC") " will be called in a callback context from within " (tt "step!") ", safety measures are installed to avoid throwing any exceptions, invoking continuations or returning invalid values from them. Attempts to do such things will result in " (tt "NULL") " return values and warning messages."))
(def (sig (procedure "(set-busy-handler! DATABASE PROC) => VOID" (id set-busy-handler!))) (p "Installs the supplied procedure as the application's busy handler, or removes it if " (tt "#f") ".  When the database returns a busy error code, the egg will invoke this handler repeatedly until it returns " (tt "#f") ". The handler will be called with arguments " (tt "DATABASE") " and " (tt "COUNT") " (number of times invoked for the same operation).") (p "As " (tt "PROC") " is not called in a callback context, it is legal to invoke captured continuations, and it is safe in the presence of multiple threads.  In general, this handler should give up at some point to avoid possible deadlock.") (p "For an example handler, see the code of " (tt "make-busy-timeout") "."))
(def (sig (procedure "(make-busy-timeout MS) => PROC" (id make-busy-timeout))) (p "Returns a handler suitable for use with " (tt "set-busy-handler!") ". It polls in increasing intervals until the timeout in milliseconds is reached. The handler is non-blocking.") (highlight scheme "(define open-database/timeout\n(let ((handler (make-busy-timeout 2000)))\n(lambda (db-name)\n(let ((db (open-database db-name)))\n(set-busy-handler! db handler)\ndb"))
(def (sig (procedure "(interrupt! DATABASE) => VOID" (id interrupt!))) (p "Cancels any running database operation as soon as possible.") (p "This function is always successful and never throws an exception."))
(def (sig (procedure "(auto-committing? DATABASE) => BOOLEAN" (id auto-committing?))) (p "Checks whether the database is currently in auto committing mode, i.e. no transaction is currently active.") (p "This function always returns a state and never throws an exception."))
(def (sig (procedure "(change-count DATABASE [TOTAL]) => CARDINAL-INTEGER" (id change-count))) (p "Returns the number of rows changed by the last statement (if " (tt "(not TOTAL)") ", which is the default) or since the database was opened (if " (tt "TOTAL") ").") (p "This function always returns a count and never throws an exception."))
(def (sig (procedure "(last-insert-rowid DATABASE) => INTEGER" (id last-insert-rowid))) (p "Returns the row ID of the last row inserted in " (tt "db") ". This function always returns a number and never throws an exception."))
(def (sig (procedure "(finalize! DATABASE [FINALIZE-STATEMENTS?]) => VOID" (id finalize!)) (procedure "(finalize! STATEMENT) => VOID" (id finalize!))) (p "Closes the given database or finalizes the given statement.") (p "Every statement must be finalized to free its resources and discard it before the database itself can be finalized. However, if " (tt "FINALIZE-STATEMENTS?") " is not " (tt "#f") ", finalizing the database triggers automatic finalization of all statements first. " (tt "FINALIZE-STATEMENTS?") " defaults to " (tt "#f") ".") (p "Note that both the SQLite3 egg and the SQLite3 library itself try to detect the use of already finalized statement or database handles in API calls, but the detection is not always possible and you might crash the program by using an already finalized handle."))
(def (sig (procedure "(prepare DATABASE SQL) => STATEMENT, SQL" (id prepare))) (p "Compiles the first SQL statement in " (tt "SQL") " and returns a statement and the tail of the SQL code, which was not compiled (or an empty string)."))
(def (sig (procedure "(source-sql STATEMENT) => STRING" (id source-sql))) (p "Retrieves the SQL source code of a statement."))
(def (sig (procedure "(column-count STATEMENT) => CARDINAL-INTEGER" (id column-count))) (p "Can be applied to any statement and returns the number of columns it will return as results.") (p "This procedure always succeeds and never throws an exception."))
(def (sig (procedure "(column-name STATEMENT I) => STRING" (id column-name))) (p "Can be applied to any statement and returns the name of the column number " (tt "I") " (counting from 0) as a string or " (tt "#f") " if the column has no name.") (p "This procedure always succeeds and never throws an exception."))
(def (sig (procedure "(column-declared-type STATEMENT I) => STRING" (id column-declared-type))) (p "Can be applied to any statement and returns the declared type (as given in the " (tt "CREATE") " statement) of the column number " (tt "I") " (counting from 0) as a string or " (tt "#f") " if the column has no declared type.") (p "This procedure always succeeds and never throws an exception."))
(def (sig (procedure "(bind-parameter-count STATEMENT) => CARDINAL-INTEGER" (id bind-parameter-count))) (p "Can be applied to any statement and returns the number of free parameters that can be bound in the statement.") (p "This procedure always succeeds and never throws an exception."))
(def (sig (procedure "(bind-parameter-index STATEMENT NAME) => CARDINAL-INTEGER" (id bind-parameter-index))) (p "Can be applied to any statement and returns the index of the bindable parameter called " (tt "NAME") " or " (tt "#f") " if no such parameter exists.") (p "This procedure always succeeds and never throws an exception."))
(def (sig (procedure "(bind-parameter-name STATEMENT I) => STRING" (id bind-parameter-name))) (p "Can be applied to any statement and returns the name of the bindable parameter number " (tt "I") " (counting from 0) or " (tt "#f") " if no such parameter exists or the parameter has no name.") (p "This procedure always succeeds and never throws an exception."))
(def (sig (procedure "(bind! STATEMENT I OBJECT) => VOID" (id bind!))) (p "Can be applied to any statement to bind its free parameter number " (tt "I") "(counting from 0) to the given value. Scheme types of the value map to SQLite types as follows:") (table (tr (th " Scheme type") (th "SQLite type")) "\n" (tr (td (tt "boolean?")) (td "integer: " (tt "#t") " = " (tt "1") ", " (tt "#f") " = " (tt "0"))) "\n" (tr (td (tt "fixnum?")) (td (tt "integer"))) "\n" (tr (td (tt "real?")) (td (tt "float"))) "\n" (tr (td (tt "string?")) (td (tt "text"))) "\n" (tr (td (tt "blob?")) (td (tt "blob"))) "\n" (tr (td (tt "sql-null?")) (td (tt "null")))) (p "Unless there is internal trouble in SQLite, this method should always succeeds and never throw an exception. For invalid parameter indices the method just silently does nothing."))
(def (sig (procedure "(bind-parameters! STATEMENT . PARAMETERS) => VOID" (id bind-parameters!))) (p "Resets the statement and binds all its free parameters.") (p "In addition to just listing the values to bind to the statement's parameters in sequence, you may specify parameters prefixed by keywords that are resolved to parameter indices by prefixing their names with " (tt "\":\"") " and resolving them using " (tt "bind-parameter-index") "."))
(def (sig (procedure "(step! STATEMENT) => BOOLEAN" (id step!))) (p "Single-steps the execution of " (tt "STATEMENT") " and returns " (tt "#t") " if a result row was produced, " (tt "#f") " if no further results are available as the statement has been stepped through. This procedure must be called at least once before any results can be retrieved from the statement."))
(def (sig (procedure "(column-type STATEMENT I) => SYMBOL" (id column-type))) (p "Can be applied to a statement that has just been stepped (otherwise it returns " (tt "#f") ") and returns the SQLite type of the result column number " (tt "I") " (counting from 0) as a symbol.") (p "The return value can be one of the symbols " (tt "null") ", " (tt "integer") ", " (tt "float") ", " (tt "text") " or " (tt "blob") ".") (p "This procedure always succeeds and never throws an exception."))
(def (sig (procedure "(column-data STATEMENT I) => OBJECT" (id column-data))) (p "Can be applied to a statement that has just been stepped. Consults " (tt "column-type") " and " (tt "column-declared-type") " to determine the type of the indicated column and to return its data as an appropriate Scheme object:") (table (tr (th "SQLite type") (th "Scheme type")) "\n" (tr (td (tt "integer") ", declared " (tt "\"bool\"") "\"") (td (tt "boolean?"))) "\n" (tr (td (tt "integer")) (td (tt "integer?"))) "\n" (tr (td (tt "float")) (td (tt "real?"))) "\n" (tr (td (tt "text")) (td (tt "string?"))) "\n" (tr (td (tt "blob")) (td (tt "blob?"))) "\n" (tr (td (tt "null")) (td (tt "sql-null?")))) (p "The declared type of a column is considered to be boolean if the type declaration contains the character sequence \"" (tt "bool") "\" anywhere, ignoring case.") (p "This procedure always succeeds and never throws an exception."))
(def (sig (procedure "(reset! STATEMENT) => VOID" (id reset!))) (p "Can be applied to any statement and resets it such that execution using " (tt "step!") " will perform all operations of the statement again."))
(def (sig (procedure "(call-with-temporary-statements PROC DATABASE . SQLS) => OBJECT" (id call-with-temporary-statements))) (p "Compiles the SQL sources into statements in the context of " (tt "DATABASE") ", applies " (tt "PROC") " to these statements and returns " (tt "PROC") "'s result. The statements are created and finalized in " (tt "dynamic-wind") " entry and exit blocks around the application of " (tt "PROC") "."))
(def (sig (procedure "(execute STATEMENT . PARAMETERS) => VOID)" (id execute)) (procedure "(execute DATABASE SQL . PARAMETERS) => VOID" (id execute))) (p "(Compiles the given SQL), resets the statement, binds the statement's free parameters and executes the statement ignoring possible results from it."))
(def (sig (procedure "(update STATEMENT . PARAMETERS) => CARDINAL-INTEGER" (id update)) (procedure "(update DATABASE SQL . PARAMETERS) => CARDINAL-INTEGER" (id update))) (p "(Compiles the given SQL), resets the statement, binds the statement's free parameters and executes the specified statement ignoring possible results from it, returning the result of applying " (tt "change-count") " to the affected database after the execution of the statement instead."))
(def (sig (procedure "(first-result STATEMENT . PARAMETERS) => OBJECT" (id first-result)) (procedure "(first-result DATABASE SQL . PARAMETERS) => OBJECT" (id first-result))) (p "(Compiles the given SQL), resets the statement, binds the statement's free parameters and single-steps the statement once returning the value of the first column in the first result row. Resets the statement again just before returning.") (p "If the given statement does not yield any results, an " (tt "(exn sqlite3)") " is thrown with the " (tt "status") "-property set to " (tt "done") "."))
(def (sig (procedure "(first-row STATEMENT . PARAMETERS) => LIST" (id first-row)) (procedure "(first-row DATABASE SQL . PARAMETERS) => LIST" (id first-row))) (p "(Compiles the given SQL), resets the statement, binds the statement's free parameters and single-steps the statement once returning all columns in the first result row as a list.") (p "If the given statement does not yield any results, an " (tt "(exn sqlite3)") " is thrown with the " (tt "status") "-property set to " (tt "done") "."))
(def (sig (procedure "(fold-row PROC INIT STATEMENT . PARAMETERS) => OBJECT" (id fold-row)) (procedure "(fold-row PROC INIT DATABASE SQL . PARAMETERS) => OBJECT" (id fold-row))) (p "(Compiles the given SQL), resets the statement, binds the statement's free parameters and executes it step by step. After each step, the column values of the current result row are retrieved and " (tt "PROC") " is applied to the current folded value, set to " (tt "INIT") " in the first step, and the column values. The result of the application becomes the new folded value."))
(def (sig (procedure "(for-each-row PROC STATEMENT . PARAMETERS) => VOID" (id for-each-row)) (procedure "(for-each-row PROC DATABASE SQL . PARAMETERS) => VOID" (id for-each-row))) (p "(Compiles the given SQL), resets the statement, binds the statement's free parameters and executes it step by step. After each step, the column values of the current result row are retrieved and " (tt "PROC") " is applied to them. The results of this application are discarded."))
(def (sig (procedure "(map-row PROC STATEMENT . PARAMETERS) => LIST" (id map-row)) (procedure "(map-row PROC DATABASE SQL . PARAMETERS) => LIST" (id map-row))) (p "(Compiles the given SQL), resets the statement, binds the statement's free parameters and executes it step by step. After each step, the column values of the current result row are retrieved and " (tt "PROC") " is applied to them. The results of these applications are collected into a list."))
(def (sig (procedure "(with-transaction DATABASE THUNK [TYPE]) => OBJECT" (id with-transaction))) (p "Runs " (tt "THUNK") " within the scope of a transaction on the database and returns the return value from " (tt "THUNK") ".") (p "The transaction is committed upon exit from " (tt "THUNK") " if " (tt "THUNK") " returns a true value. If " (tt "THUNK") " returns a false value or throws an exception, the transaction is rolled back.") (p "The " (tt "TYPE") "\" of the transaction can be specified as one of the symbols " (tt "deferred") " (the default), " (tt "immediate") " or " (tt "exclusive") "."))
(def (sig (procedure "(sql-complete? SQL) => BOOLEAN" (id sql-complete?))) (p "Checks whether " (tt "SQL") " comprises at least one complete SQL statement."))
(def (sig (procedure "(enable-shared-cache! BOOLEAN) => VOID" (id enable-shared-cache!))) (p "Enables (or disables) the sharing of the database cache and schema data structures between connections to the same database."))
(def (sig (procedure "(database-version) => STRING" (id database-version))) (p "Returns a string identifying the version of SQLite in use."))
(def (sig (procedure "(database-memory-used) => CARDINAL-INTEGER" (id database-memory-used))) (p "Returns the amount of memory currently in use by the database engine."))
(def (sig (procedure "(database-memory-highwater [RESET?]) => CARDINAL-INTEGER" (id database-memory-highwater))) (p "Returns the maximum amount of memory that was in use by the database engine since the counter was last reset or since the program started. Resets the counter if " (tt "RESET?") " is not " (tt "#f") ". " (tt "RESET?") " defaults to " (tt "#f") "."))
