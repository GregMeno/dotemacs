((section 2 "Sqlite3" (section 3 "Description" (p "Bindings to version 3.x of the SQLite API.")) (section 3 "Author" (p (link "http://www.chust.org/" "Thomas Chust"))) (section 3 "Requirements" (ul (li (int-link "check-errors")) (li (int-link "synch")) (li (int-link "miscmacros")) (li (int-link "matchable")) (li (int-link "sql-null")))) (section 3 "Documentation" (p "The API of SQLite changed significantly from version 2.x to 3.x. These are new bindings to the modified API, which are reasonably complete -- most procedures that take callback arguments are missing, though.") (p "For in-depth information on the functionality of the routines and general information you should consult the " (link "http://www.sqlite.org/" "SQLite documentation") " as well as this manual.") (section 4 "Exceptions" (p "Unless otherwise indicated, all procedures and methods in this egg may throw an exception of the kind " (tt "(exn sqlite3)") " if something goes wrong. This exception will contain a " (tt "status") " property indicating the return value of the operation that failed:") (dl (dt (tt "error")) (dd "SQL error or missing database") (dt (tt "internal")) (dd "An internal logic error in SQLite") (dt (tt "permission")) (dd "Access permission denied") (dt (tt "abort")) (dd "Callback routine requested an abort") (dt (tt "busy")) (dd "The database file is locked") (dt (tt "locked")) (dd "A table in the database is locked") (dt (tt "no-memory")) (dd "A malloc() failed") (dt (tt "read-only")) (dd "Attempt to write a readonly database") (dt (tt "interrupt")) (dd "Operation terminated by " (tt "sqlite-interrupt()")) (dt (tt "io-error")) (dd "Some kind of disk I/O error occurred") (dt (tt "corrupt")) (dd "The database disk image is malformed") (dt (tt "not-found")) (dd "(Internal Only) Table or record not found") (dt (tt "full")) (dd "Insertion failed because database is full") (dt (tt "cant-open")) (dd "Unable to open the database file") (dt (tt "protocol")) (dd "Database lock protocol error") (dt (tt "empty")) (dd "(Internal Only) Database table is empty") (dt (tt "schema")) (dd "The database schema changed") (dt (tt "too-big")) (dd "Too much data for one row of a table") (dt (tt "constraint")) (dd "Abort due to contraint violation") (dt (tt "mismatch")) (dd "Data type mismatch") (dt (tt "misuse")) (dd "Library used incorrectly") (dt (tt "no-lfs")) (dd "Uses OS features not supported on host") (dt (tt "authorization")) (dd "Authorization denied") (dt (tt "done")) (dd (tt "step!") " has finished executing, so no further data is ready"))) (section 4 "Abstract data types" (def (sig (procedure "(database? OBJECT) => BOOLEAN" (id database?))) (p "Checks whether a value represents an SQLite database.")) (def (sig (procedure "(error-database LOCATION OBJECT [ARGUMENT-NAME]) => VOID" (id error-database))) (p "Raises a type error saying that a database was expected instead of the given value.")) (def (sig (procedure "(check-database LOCATION OBJECT [ARGUMENT-NAME]) => VOID" (id check-database))) (p "Raises a type error like " (tt "error-database") " does, unless the given value satisfies " (tt "database?"))) (def (sig (procedure "(statement? OBJECT) => BOOLEAN" (id statement?))) (p "Checks whether the value " (tt "v") " represents an SQL statement.")) (def (sig (procedure "(error-statement LOCATION OBJECT [ARGUMENT-NAME]) => VOID" (id error-statement))) (p "Raises a type error saying that a statement was expected instead of the given value.")) (def (sig (procedure "(check-statement LOCATION OBJECT [ARGUMENT-NAME]) => VOID" (id check-statement))) (p "Raises a type error like " (tt "error-statement") " does, unless the given value satisfies " (tt "statement?")))) (section 4 "Managing databases" (def (sig (procedure "(open-database PATH) => DATABASE" (id open-database))) (p "Opens the indicated database file and returns a database object for it.") (p "The given path is subject to the same special expansion as paths passed to " (tt "open-input-file") " and similar procedures.")) (def (sig (procedure "(define-collation DATABASE NAME [PROC]) => VOID" (id define-collation))) (p "If a procedure is given, registers a new collation sequence identified by " (tt "name") " for use in the context of database handle " (tt "db") ". If no procedure is passed, the collation sequence with the given name is removed.") (p (tt "PROC") " should have the signature " (tt "(PROC STRING STRING) => FIXNUM") ". It should return a negative number if the first argument sorts before the second, a positive number if the second sorts before the first and zero if they are equal.") (p "As " (tt "PROC") " will be called in a callback context from within " (tt "step!") ", safety measures are installed to avoid throwing any exceptions, invoking continuations or returning invalid values from it. Attempts to do so will result in a " (tt "0") " return value and warning messages.")) (def (sig (procedure "(define-function DATABASE NAME N PROC) => VOID" (id define-function)) (procedure "(define-function DATABASE NAME N STEP-PROC SEED [FINAL-PROC]) => VOID" (id define-function))) (p "Registers a new SQL function identified by " (tt "NAME") " for use in the context of the given database handle. If " (tt "STEP-PROC") " and " (tt "SEED") " are given, the new function becomes an aggregate function. Once registered, functions cannot be deleted.") (p (tt "N") " is the number of parameters the new SQL function takes or " (tt "-1") " to allow any number of arguments.") (p (tt "PROC") " should have the signature " (tt "(PROC . PARAMS) => OBJECT") ". It is called with the " (tt "N") " parameters given to the SQL function converted into Scheme objects like by " (tt "column-data") ". The return value is converted into an SQLite data object like by " (tt "bind!") ". A return value satisfying " (tt "sql-null?") " corresponds to " (tt "NULL") " in SQLite.") (p (tt "STEP-PROC") " should have the signature " (tt "(STEP-PROC SEED PARAMS) => SEED") ". It is called with the parameters given to the SQL function for every row being processed. The seed value passed is initially the one given as an argument to " (tt "define-function") "; for subsequent calls it is the last value returned by " (tt "STEP-PROC") " and after completion of " (tt "FINAL-PROC") " it will be the initial value again.") (p (tt "FINAL-PROC") " should have the signature " (tt "(FINAL-PROC SEED) => OBJECT") " and transforms the last seed value into the value to be returned from the aggregate function. If it is not explicitly specified, " (tt "STEP-PROC") " defaults to the identity function.") (p "As " (tt "PROC") ", " (tt "STEP-PROC") " and " (tt "FINAL-PROC") " will be called in a callback context from within " (tt "step!") ", safety measures are installed to avoid throwing any exceptions, invoking continuations or returning invalid values from them. Attempts to do such things will result in " (tt "NULL") " return values and warning messages.")) (def (sig (procedure "(set-busy-handler! DATABASE PROC) => VOID" (id set-busy-handler!))) (p "Installs the supplied procedure as the application's busy handler, or removes it if " (tt "#f") ".  When the database returns a busy error code, the egg will invoke this handler repeatedly until it returns " (tt "#f") ". The handler will be called with arguments " (tt "DATABASE") " and " (tt "COUNT") " (number of times invoked for the same operation).") (p "As " (tt "PROC") " is not called in a callback context, it is legal to invoke captured continuations, and it is safe in the presence of multiple threads.  In general, this handler should give up at some point to avoid possible deadlock.") (p "For an example handler, see the code of " (tt "make-busy-timeout") ".")) (def (sig (procedure "(make-busy-timeout MS) => PROC" (id make-busy-timeout))) (p "Returns a handler suitable for use with " (tt "set-busy-handler!") ". It polls in increasing intervals until the timeout in milliseconds is reached. The handler is non-blocking.") (highlight scheme "(define open-database/timeout\n(let ((handler (make-busy-timeout 2000)))\n(lambda (db-name)\n(let ((db (open-database db-name)))\n(set-busy-handler! db handler)\ndb")) (def (sig (procedure "(interrupt! DATABASE) => VOID" (id interrupt!))) (p "Cancels any running database operation as soon as possible.") (p "This function is always successful and never throws an exception.")) (def (sig (procedure "(auto-committing? DATABASE) => BOOLEAN" (id auto-committing?))) (p "Checks whether the database is currently in auto committing mode, i.e. no transaction is currently active.") (p "This function always returns a state and never throws an exception.")) (def (sig (procedure "(change-count DATABASE [TOTAL]) => CARDINAL-INTEGER" (id change-count))) (p "Returns the number of rows changed by the last statement (if " (tt "(not TOTAL)") ", which is the default) or since the database was opened (if " (tt "TOTAL") ").") (p "This function always returns a count and never throws an exception.")) (def (sig (procedure "(last-insert-rowid DATABASE) => INTEGER" (id last-insert-rowid))) (p "Returns the row ID of the last row inserted in " (tt "db") ". This function always returns a number and never throws an exception.")) (def (sig (procedure "(finalize! DATABASE [FINALIZE-STATEMENTS?]) => VOID" (id finalize!)) (procedure "(finalize! STATEMENT) => VOID" (id finalize!))) (p "Closes the given database or finalizes the given statement.") (p "Every statement must be finalized to free its resources and discard it before the database itself can be finalized. However, if " (tt "FINALIZE-STATEMENTS?") " is not " (tt "#f") ", finalizing the database triggers automatic finalization of all statements first. " (tt "FINALIZE-STATEMENTS?") " defaults to " (tt "#f") ".") (p "Note that both the SQLite3 egg and the SQLite3 library itself try to detect the use of already finalized statement or database handles in API calls, but the detection is not always possible and you might crash the program by using an already finalized handle."))) (section 4 "Managing statements" (def (sig (procedure "(prepare DATABASE SQL) => STATEMENT, SQL" (id prepare))) (p "Compiles the first SQL statement in " (tt "SQL") " and returns a statement and the tail of the SQL code, which was not compiled (or an empty string).")) (def (sig (procedure "(source-sql STATEMENT) => STRING" (id source-sql))) (p "Retrieves the SQL source code of a statement.")) (def (sig (procedure "(column-count STATEMENT) => CARDINAL-INTEGER" (id column-count))) (p "Can be applied to any statement and returns the number of columns it will return as results.") (p "This procedure always succeeds and never throws an exception.")) (def (sig (procedure "(column-name STATEMENT I) => STRING" (id column-name))) (p "Can be applied to any statement and returns the name of the column number " (tt "I") " (counting from 0) as a string or " (tt "#f") " if the column has no name.") (p "This procedure always succeeds and never throws an exception.")) (def (sig (procedure "(column-declared-type STATEMENT I) => STRING" (id column-declared-type))) (p "Can be applied to any statement and returns the declared type (as given in the " (tt "CREATE") " statement) of the column number " (tt "I") " (counting from 0) as a string or " (tt "#f") " if the column has no declared type.") (p "This procedure always succeeds and never throws an exception.")) (def (sig (procedure "(bind-parameter-count STATEMENT) => CARDINAL-INTEGER" (id bind-parameter-count))) (p "Can be applied to any statement and returns the number of free parameters that can be bound in the statement.") (p "This procedure always succeeds and never throws an exception.")) (def (sig (procedure "(bind-parameter-index STATEMENT NAME) => CARDINAL-INTEGER" (id bind-parameter-index))) (p "Can be applied to any statement and returns the index of the bindable parameter called " (tt "NAME") " or " (tt "#f") " if no such parameter exists.") (p "This procedure always succeeds and never throws an exception.")) (def (sig (procedure "(bind-parameter-name STATEMENT I) => STRING" (id bind-parameter-name))) (p "Can be applied to any statement and returns the name of the bindable parameter number " (tt "I") " (counting from 0) or " (tt "#f") " if no such parameter exists or the parameter has no name.") (p "This procedure always succeeds and never throws an exception.")) (def (sig (procedure "(bind! STATEMENT I OBJECT) => VOID" (id bind!))) (p "Can be applied to any statement to bind its free parameter number " (tt "I") "(counting from 0) to the given value. Scheme types of the value map to SQLite types as follows:") (table (tr (th " Scheme type") (th "SQLite type")) "\n" (tr (td (tt "boolean?")) (td "integer: " (tt "#t") " = " (tt "1") ", " (tt "#f") " = " (tt "0"))) "\n" (tr (td (tt "fixnum?")) (td (tt "integer"))) "\n" (tr (td (tt "real?")) (td (tt "float"))) "\n" (tr (td (tt "string?")) (td (tt "text"))) "\n" (tr (td (tt "blob?")) (td (tt "blob"))) "\n" (tr (td (tt "sql-null?")) (td (tt "null")))) (p "Unless there is internal trouble in SQLite, this method should always succeeds and never throw an exception. For invalid parameter indices the method just silently does nothing.")) (def (sig (procedure "(bind-parameters! STATEMENT . PARAMETERS) => VOID" (id bind-parameters!))) (p "Resets the statement and binds all its free parameters.") (p "In addition to just listing the values to bind to the statement's parameters in sequence, you may specify parameters prefixed by keywords that are resolved to parameter indices by prefixing their names with " (tt "\":\"") " and resolving them using " (tt "bind-parameter-index") ".")) (def (sig (procedure "(step! STATEMENT) => BOOLEAN" (id step!))) (p "Single-steps the execution of " (tt "STATEMENT") " and returns " (tt "#t") " if a result row was produced, " (tt "#f") " if no further results are available as the statement has been stepped through. This procedure must be called at least once before any results can be retrieved from the statement.")) (def (sig (procedure "(column-type STATEMENT I) => SYMBOL" (id column-type))) (p "Can be applied to a statement that has just been stepped (otherwise it returns " (tt "#f") ") and returns the SQLite type of the result column number " (tt "I") " (counting from 0) as a symbol.") (p "The return value can be one of the symbols " (tt "null") ", " (tt "integer") ", " (tt "float") ", " (tt "text") " or " (tt "blob") ".") (p "This procedure always succeeds and never throws an exception.")) (def (sig (procedure "(column-data STATEMENT I) => OBJECT" (id column-data))) (p "Can be applied to a statement that has just been stepped. Consults " (tt "column-type") " and " (tt "column-declared-type") " to determine the type of the indicated column and to return its data as an appropriate Scheme object:") (table (tr (th "SQLite type") (th "Scheme type")) "\n" (tr (td (tt "integer") ", declared " (tt "\"bool\"") "\"") (td (tt "boolean?"))) "\n" (tr (td (tt "integer")) (td (tt "integer?"))) "\n" (tr (td (tt "float")) (td (tt "real?"))) "\n" (tr (td (tt "text")) (td (tt "string?"))) "\n" (tr (td (tt "blob")) (td (tt "blob?"))) "\n" (tr (td (tt "null")) (td (tt "sql-null?")))) (p "The declared type of a column is considered to be boolean if the type declaration contains the character sequence \"" (tt "bool") "\" anywhere, ignoring case.") (p "This procedure always succeeds and never throws an exception.")) (def (sig (procedure "(reset! STATEMENT) => VOID" (id reset!))) (p "Can be applied to any statement and resets it such that execution using " (tt "step!") " will perform all operations of the statement again."))) (section 4 "Simple statement interface" (def (sig (procedure "(call-with-temporary-statements PROC DATABASE . SQLS) => OBJECT" (id call-with-temporary-statements))) (p "Compiles the SQL sources into statements in the context of " (tt "DATABASE") ", applies " (tt "PROC") " to these statements and returns " (tt "PROC") "'s result. The statements are created and finalized in " (tt "dynamic-wind") " entry and exit blocks around the application of " (tt "PROC") ".")) (def (sig (procedure "(execute STATEMENT . PARAMETERS) => VOID)" (id execute)) (procedure "(execute DATABASE SQL . PARAMETERS) => VOID" (id execute))) (p "(Compiles the given SQL), resets the statement, binds the statement's free parameters and executes the statement ignoring possible results from it.")) (def (sig (procedure "(update STATEMENT . PARAMETERS) => CARDINAL-INTEGER" (id update)) (procedure "(update DATABASE SQL . PARAMETERS) => CARDINAL-INTEGER" (id update))) (p "(Compiles the given SQL), resets the statement, binds the statement's free parameters and executes the specified statement ignoring possible results from it, returning the result of applying " (tt "change-count") " to the affected database after the execution of the statement instead.")) (def (sig (procedure "(first-result STATEMENT . PARAMETERS) => OBJECT" (id first-result)) (procedure "(first-result DATABASE SQL . PARAMETERS) => OBJECT" (id first-result))) (p "(Compiles the given SQL), resets the statement, binds the statement's free parameters and single-steps the statement once returning the value of the first column in the first result row. Resets the statement again just before returning.") (p "If the given statement does not yield any results, an " (tt "(exn sqlite3)") " is thrown with the " (tt "status") "-property set to " (tt "done") ".")) (def (sig (procedure "(first-row STATEMENT . PARAMETERS) => LIST" (id first-row)) (procedure "(first-row DATABASE SQL . PARAMETERS) => LIST" (id first-row))) (p "(Compiles the given SQL), resets the statement, binds the statement's free parameters and single-steps the statement once returning all columns in the first result row as a list.") (p "If the given statement does not yield any results, an " (tt "(exn sqlite3)") " is thrown with the " (tt "status") "-property set to " (tt "done") ".")) (def (sig (procedure "(fold-row PROC INIT STATEMENT . PARAMETERS) => OBJECT" (id fold-row)) (procedure "(fold-row PROC INIT DATABASE SQL . PARAMETERS) => OBJECT" (id fold-row))) (p "(Compiles the given SQL), resets the statement, binds the statement's free parameters and executes it step by step. After each step, the column values of the current result row are retrieved and " (tt "PROC") " is applied to the current folded value, set to " (tt "INIT") " in the first step, and the column values. The result of the application becomes the new folded value.")) (def (sig (procedure "(for-each-row PROC STATEMENT . PARAMETERS) => VOID" (id for-each-row)) (procedure "(for-each-row PROC DATABASE SQL . PARAMETERS) => VOID" (id for-each-row))) (p "(Compiles the given SQL), resets the statement, binds the statement's free parameters and executes it step by step. After each step, the column values of the current result row are retrieved and " (tt "PROC") " is applied to them. The results of this application are discarded.")) (def (sig (procedure "(map-row PROC STATEMENT . PARAMETERS) => LIST" (id map-row)) (procedure "(map-row PROC DATABASE SQL . PARAMETERS) => LIST" (id map-row))) (p "(Compiles the given SQL), resets the statement, binds the statement's free parameters and executes it step by step. After each step, the column values of the current result row are retrieved and " (tt "PROC") " is applied to them. The results of these applications are collected into a list."))) (section 4 "Utility functions" (def (sig (procedure "(with-transaction DATABASE THUNK [TYPE]) => OBJECT" (id with-transaction))) (p "Runs " (tt "THUNK") " within the scope of a transaction on the database and returns the return value from " (tt "THUNK") ".") (p "The transaction is committed upon exit from " (tt "THUNK") " if " (tt "THUNK") " returns a true value. If " (tt "THUNK") " returns a false value or throws an exception, the transaction is rolled back.") (p "The " (tt "TYPE") "\" of the transaction can be specified as one of the symbols " (tt "deferred") " (the default), " (tt "immediate") " or " (tt "exclusive") ".")) (def (sig (procedure "(sql-complete? SQL) => BOOLEAN" (id sql-complete?))) (p "Checks whether " (tt "SQL") " comprises at least one complete SQL statement.")) (def (sig (procedure "(enable-shared-cache! BOOLEAN) => VOID" (id enable-shared-cache!))) (p "Enables (or disables) the sharing of the database cache and schema data structures between connections to the same database.")) (def (sig (procedure "(database-version) => STRING" (id database-version))) (p "Returns a string identifying the version of SQLite in use.")) (def (sig (procedure "(database-memory-used) => CARDINAL-INTEGER" (id database-memory-used))) (p "Returns the amount of memory currently in use by the database engine.")) (def (sig (procedure "(database-memory-highwater [RESET?]) => CARDINAL-INTEGER" (id database-memory-highwater))) (p "Returns the maximum amount of memory that was in use by the database engine since the counter was last reset or since the program started. Resets the counter if " (tt "RESET?") " is not " (tt "#f") ". " (tt "RESET?") " defaults to " (tt "#f") ".")))) (section 3 "Changelog" (ul (li "3.5.1 Corrected parameter error checks for define-function") (li "3.5.0 Switched to less error prone internal C API") (li "3.4.0 Added optional automatic statement finalization when a database is finalized") (li "3.3.1 Added bindings for database memory statistics") (li "3.3.0 Switched to using " (tt "(sql-null)") " for " (tt "NULL") " values") (li "3.2.1 Added a test suite") (li "3.2.0 Removed the unsafe busy handler and timeout APIs, since a safe API exists") (li "3.1.0 " (tt "bind-parameters!") " can now handle keyword arguments") (li "3.0.0 Ported to CHICKEN 4, removed dependencies on TinyCLOS and EasyFFI") (li "2.0.8 Add busy handler callbacks; ensure finalize! is called on exception. [Jim Ursetto]") (li "2.0.7 Restore error reporting. [Jim Ursetto]") (li "2.0.6 Add " (tt "enable-shared-cache!") ", requires 3.3.0 or later. [Jim Ursetto]") (li "2.0.5 Added some <boolean> support. Change for NULL (<void>) handling. [Kon Lovett]") (li "2.0.4 Added " (tt "sqlite3:fold-row") " & " (tt "sqlite3:bind-parameters!") ". Fix for introduced bug in " (tt "sqlite3:changes") ". [Kon Lovett]") (li "2.0.3 Added " (tt "sqlite3:null-value") ", " (tt "sqlite3:null-value?") ", and " (tt "sqlite3:null") ". [Kon Lovett]") (li "2.0.2 Use of extended " (tt "define-foreign-enum") ". Removed deprecated " (tt "pointer") " use. [Kon Lovett]") (li "2.0.1 Deprecated " (tt "<byte-vector>") ", use " (tt "<blob>") " [Kon Lovett]") (li "2.0.0 Now using " (tt "(void)") " to represent " (tt "NULL")) (li "1.5.9 dll extension not used anymore in newer chickens [felix]") (li "1.5.8 Update for synch 1.3 [Kon Lovett]") (li "1.5.7 Updated compiler flags to pull in tinyclos and easyffi") (li "1.5.6 Replaced deprecated synch operations [Kon Lovett]") (li "1.5.5 Correction in the documentation, added " (tt "sqlite3:with-transaction")) (li "1.5.4 Typo fixed thanks to the new imports checking code") (li "1.5.3 Proper multithreading locks for the callback code") (li "1.5.2 Code cleanups") (li "1.5.1 Potential memory leaks removed") (li "1.5.0 Support for user defined collation sequences and functions has been added") (li "1.4.0 Stale statement handles due to schema changes are now automagically recompiled to keep them valid") (li "1.3.1 Several small routines added") (li "1.3.0 Special hacks removed as CVS version of SQLite3.3.4 has been fixed") (li "1.2.0 Special hacks to deal with \"valid\" " (tt "NULL") " statements") (li "1.1.4 Tightened security measures against " (tt "#f") " pointers") (li "1.1.3 Integers not fitting in a fixnum are now read correctly from the database [thanks to Zbigniew]") (li "1.1.2 Setup file patched to call compiled output .dll on Windows") (li "1.1.1 All procedures now reset prepared statements where you would do that by hand anyway") (li "1.1.0 Promoted " (tt "sqlite3:call-with-temporary-statement") " to " (tt "sqlite3:call-with-temporary-statements") " and fixed a really stupid coding mistake in " (tt "sqlite3:changes")) (li "1.0.3 Fixed C compiler warnings") (li "1.0.2 Added a typecheck for increased safety") (li "1.0.1 Fixed type mistakes in the source") (li "1.0.0 Initial release"))) (section 3 "License" (pre " Copyright (c) 2005-2009, Thomas Chust <chust@web.de>.  All rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n \n Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer. Redistributions in\n binary form must reproduce the above copyright notice, this list of\n conditions and the following disclaimer in the documentation and/or\n other materials provided with the distribution. Neither the name of the\n author nor the names of its contributors may be used to endorse or\n promote products derived from this software without specific prior\n written permission.\n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\n CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."))))