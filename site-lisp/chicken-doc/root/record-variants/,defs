(index ("define-record-variant" 0) ("define-record-type-variant" 2294))
(def (sig (syntax "(define-record-variant name-spec variant-spec slot1 slot2 ...)" (id define-record-variant))) (p "where:") (pre "name-spec := (variant-name original-name) | variant-name\nvariant-spec := (variant-type ...)\nvariant-type := unsafe | unchecked | inline") (p "Defines alternate accessor procedures to the existing record " (tt "original-name") " according to " (tt "variant-spec") ".  The accessors will be defined using " (tt "variant-name") ", as if " (tt "(define-record variant-name slot1 slot2 ...)") " had been invoked, but they will operate on records of type " (tt "original-name") ".") (p "Variant type may be one of:") (ul (li (tt "inline") ", so procedure definitions use " (tt "define-inline") ";") (li (tt "unchecked") ", so accessors do not check the record type;") (li (tt "unsafe") ", so accessors use " (tt "##sys#slot") " and " (tt "##sys#setslot") " instead of the safe " (tt "block-ref!") " and " (tt "block-set!"))) (p "and any combination of " (tt "variant-type") " is allowed in " (tt "variant-spec") ".") (p "A constructor, " (tt "make-VARIANT-NAME") ", is defined to create a record of the original type.  If you are defining a variant on an existing record, this is here essentially for completeness, as " (tt "unsafe") " and " (tt "unchecked") " don't have any effect on the constructor -- though " (tt "inline") " will inline it.") (p "Additionally, one new procedure over " (tt "define-record") " is created:") (p (tt "(check-VARIANT-NAME x)") ": Checks that " (tt "x") " is of the corresponding record type and returns " (tt "x") " if so; otherwise throws an error.  When compiled in unsafe mode no check is performed, regardless of " (tt "variant-type") ".") (p (tt "unsafe") " and " (tt "unchecked") " accessors are dangerous and should only be used internally in a module.  Only use these when you are absolutely sure the object is of the correct type; it is " (i "highly") " recommended to use " (tt "(check-VARIANT-NAME x)") " or call an original accessor before using these, after which the correct type is guaranteed.  (Assuming no side effects anywhere else!)") (p "Note that " (tt "(define-record-variant foo () x y)") " is equivalent to " (tt "(define-record foo x y)") " except that a " (tt "check-foo") " procedure will be generated."))
(def (sig (syntax "(define-record-type-variant name-spec variant-spec pred-spec constructor field-spec)" (id define-record-type-variant))) (p "where:") (pre "name-spec := (variant-name original-name) | variant-name\nvariant-spec := (variant-type ...)\nvariant-type := unsafe | unchecked | inline\npred-spec := (predicate checker) | (predicate) | predicate\nconstructor, field-spec: as in SRFI 9") (p "Defines alternate accessor procedures to the existing SRFI 9 record-type " (tt "original-name") " according to " (tt "variant-spec") ".") (p (tt "name-spec") " acts as it does in " (tt "define-record-variant") ", including constructor generation behavior.") (p (tt "pred-spec") " may be a predicate identifier or a list containing a predicate identifier and optionally a \"checker\" identifier.  The checker identifier is used as the name of the generated " (tt "check-VARIANT-NAME") " procedure, which again behaves as in " (tt "define-record-variant") ".  If the checker identifier is omitted, no check procedure is generated.") (p "See " (tt "define-record-variant") " and SRFI 9 for further details."))
