((tags "egg") (section 3 "Description" (p "SRFI-34 Exception Handling for Programs")) (section 3 "Examples" (p "Examples are in examples/srfi-34-examples.scm.") (highlight scheme ";;; \n;;; (raise OBJ)\n;;;\n\n(require-extension srfi-34)\n\n(raise 'heck)\n\n;;; The default exception handler calls error aborting the script.") (highlight scheme ";;;\n;;; (guard (VAR CLAUSE1 CLAUSE2 ...) BODY)\n;;;\n\n;;; Use guard to wrap code that might raise an exception so that the default\n;;; handler doesn't abort the program\n\n(require-extension srfi-34)\n\n;;; This will print:\n;;;   Doing some stuff\n;;;   Caught an unidentified flying exception: bizarre-exception\n;;; and then it will return the 'bizarre-exception\n(guard ( e \n       [(eq? e 'weird-exception)\n        (display \"Caught a weird-exception\")(newline)]\n       [(eq? e 'odd-exception)\n        (display \"Caught an odd-exception\")(newline)]\n       [else \n\t(display \"Caught an unidentified flying exception: \")\n\t(write e)(newline)\n\te])\n       (display \"Doing some stuff\")(newline)\n       (raise 'bizarre-exception)\n       (display \"Won't get here\")(newline) )") (highlight scheme ";;;\n;;; The => syntax for guard: Example 1\n;;;\n(require-extension srfi-34)\n\n;;; This will return: 42\n(guard (condition\n         ((assq 'a condition) => cdr)\n         ((assq 'b condition)))\n  (raise (list (cons 'a 42))))") (highlight scheme ";;;\n;;; The => syntax for guard: Example 2 \n;;;\n(require-extension srfi-34)\n\n;;; This will return: (b . 23)\n(guard (condition\n         ((assq 'a condition) => cdr)\n         ((assq 'b condition)))\n  (raise (list (cons 'b 23))))") (highlight scheme ";;;\n;;; ( with-exception-handler HANDLER THUNK )\n;;;\n\n;;; This example demonstrates a lower level procedure that I don't think would \n;;; ordinarily be used.  The guard macro takes care of the continuation \n;;; plumbing you see here for you, ultimately doing something like this.\n;;; There is also a similar 'with-exception-handlers' documented in the srfi.\n\n(require-extension srfi-34)\n\n(call-with-current-continuation\n  ;;; We want control to resume at k if an exception is raised, not\n  ;;; to continue normally at the next line after the call to raise.\n  ;;; ( raise is smart enough call error if it finds that the exception\n  ;;; handler returns control to it instead of to another continuation as\n  ;;; it should )\n  (lambda (k)\n    (with-exception-handler\n      ;;; This is the exception handler that gets stored in \n      ;;; in the dynamic environment. Ultimately, it passes control to \n      ;;; k because returning is an error\n      (lambda (e)\n        (display \"I handled an exception: \")(write e)(newline)\n        (display \"Passing it to previous continuation\")(newline)\n        (k e))\n      ;;; This is the thunk that may throw an exception\n      (lambda ()\n        (display \"Doing more stuff\")(newline)\n        (raise 'yet-another-exception)\n        (display \"Won't get here\")(newline)))) )\n")) (section 3 "Author" (p "SRFI-34 Reference Implementation Authors: Richard Kelsey, Michael Sperber.") (p "Packaged as an egg by " (int-link "Ben Clark"))) (section 3 "License" (p "Derived (almost verbatim) from the reference implementation of srfi-34. The copyright on that code is:") (p "<blockquote> Copyright (C) Richard Kelsey, Michael Sperber (2002). All Rights Reserved.") (p "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:") (p "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.") (p "THE SOFTWARE IS PROVIDED ASIS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </blockquote>") (p "Modifications are copyright " (int-link "Ben Clark") " (2007), governed by the same conditions. Any errors are mine.")) (section 3 "Documentation" (p "NOTE: Chicken implements SFRI-12, a withdrawn SRFI that is nonetheless a more featureful exception system than the one implemented in SRFI-34.  If you don't need SFRI-34 for portablility to some other scheme, there is no reason to use this egg over the SFRI-12 functionality chicken provides out of the box.") (p "NOTE: This egg has been updated to use Chicken's native handlers, so it should work as expected now.  What this boils down to: all this egg does is define a " (tt "guard") " macro.  The exceptions system is provided by Chicken itself, and raise is provided by srfi-18.  This eggdoc is entirely OUT OF DATE.") (p "srfi-34.egg contains the reference implementation of srfi-34 packaged as a chicken egg.") (p "See http://srfi.schemers.org/srfi-34/srfi-34.html for additional documentation") (p "The module maintains a list of exception handlers using dynamic-wind. This list begins it's life defined thusly:") (highlight scheme "(define *current-exception-handlers*\n  (list (lambda (condition)\n          (error \"unhandled exception\" condition))))") (p "A naked call to " (b "raise") " would end up calling the default handler procedure contained in the *current-exception-handlers* list, aborting the program.") (hr) (p (b "procedure: (raise OBJ)")) (p "Raise an exception. OBJ can be any scheme object. Invokes the 'current exception handler' thunk, which is the car of the *current-exception-handlers* list. This handler thunk handles the exception OBJ.") (p "The handler thunk should then either call error to stop program execution, or it should have stored the continuation at which to resume execution of the program after handling the exception, and pass it's result to that continuation where the program's flow of execution will resume.") (p "Installing an exception handler that returns will cause the raise procedure to abort the program by call error, alerting that the exception handler thunk erroneously returned control to the raise procedure instead of to a different continuation as it should.") (hr) (p (b "macro: (guard (VAR CLAUSE1 CLAUSE2 ...) BODY )")) (p "Syntax: Each clause should have the same form as a cond clause.") (p "Semantics: Whereas raise is analogous to the throw commonly found in other languages, guard is analogous to the try/catch syntax often implemented. VAR gets bound to the exception thrown by BODY, and then the CLAUSEs which have access to VAR, are evaluated until one of the tests succeeds, and the corresponding code gets run. As with cond, the else test always succeeds and so can be used to handle general exceptions.") (p "Notes: guard also supports " (b "=" ">") " in the clauses. If the test returns a useful value, then " (b "=" ">") " can be used to specify a procedure to apply to that value in that case. See the examples section and the srfi for clarification on this.") (hr) (p (b "procedure: (with-exception-handler HANDLER THUNK)")) (p "Returns the result(s) of invoking thunk. Handler must be a procedure that accepts one argument. It is installed as the current exception handler for the dynamic extent (as determined by dynamic-wind) of the invocation of thunk.") (hr)) (section 3 "Version" (ul (li "0.5 thread-safety fixes by Joerg Wittenberger [felix]") (li "0.4 setup-script fixes by Christian Kellermann") (li "0.3 Port to Chicken 4 [C-Keen]") (li "0.2 20080726 [elf]  Working release.") (li "0.1 Initial release"))))