(index ("open-database" 0) ("close-database" 473) ("prepare" 696) ("prepare-transient" 1236) ("prepared-cache-size" 1420) ("step" 1902) ("reset" 2476) ("finalize" 2623) ("resurrect" 3059) ("bind" 3432) ("bind-parameters" 3943) ("bind-parameter-count" 4237) ("column-name" 4637) ("column-names" 4900) ("column-count" 5114) ("column-type" 5305) ("column-data" 5868) ("row-data" 6754) ("row-alist" 7037) ("change-count" 7255) ("total-change-count" 7560) ("last-insert-rowid" 7884) ("call-with-database" 8117) ("sql" 8378) ("query" 8719) ("query*" 9266) ("fetch" 9897) ("fetch-alist" 10579) ("fetch-all" 10787) ("for-each-row" 11025) ("for-each-row*" 11025) ("map-rows" 12068) ("map-rows*" 12068) ("fold-rows" 12804) ("fold-rows*" 12804) ("first-column" 13843) ("exec" 14082) ("exec*" 14247) ("with-transaction" 15447) ("with-deferred-transaction" 15447) ("with-immediate-transaction" 15447) ("with-exclusive-transaction" 15447) ("rollback" 16623) ("commit" 16939) ("autocommit?" 17344) ("error-code" 17513) ("error-message" 17627) ("raise-database-errors" 17750) ("set-busy-handler!" 18345) ("busy-timeout" 19250) ("schema" 19596) ("print-schema" 19716) ("flush-cache!" 19933) ("finalized?" 20037) ("library-version" 20293))
(def (sig (procedure "(open-database filename)" (id open-database))) (p "Opens " (tt "filename") ", a sqlite3 database.  If no database exists, one is created transparently.  " (tt "filename") " may also be one of the following symbols:") (ul (li (tt "memory") ": a new database in memory unique to this connection") (li (tt "temp") " or " (tt "temporary") ": a new temporary database on disk, visible only to this connection")) (p "Returns a #<sqlite-database> object."))
(def (sig (procedure "(close-database db)" (id close-database))) (p "Closes the database connection " (tt "db") ".") (p "The prepared statement cache is flushed and any transient statements are finalized before closing."))
(def (sig (procedure "(prepare db sql)" (id prepare))) (p "Looks up a prepared statement in the statement cache.  If not found, it prepares a new statement and caches it, returning the statement.  If found, the statement is reset if need be, and returned.  An exception is thrown if a statement we pulled from cache is currently running --- in other words, has been stepped at least once and has not yet returned " (tt "SQLITE_DONE") ". (NB: warn and reset would also be acceptable behavior.)") (p "Returns a #<sqlite-statement> object."))
(def (sig (procedure "(prepare-transient db sql)" (id prepare-transient))) (p "Same as " (tt "prepare") ", but bypasses the cache completely.  This procedure is subject to removal."))
(def (sig (parameter "(prepared-cache-size n) [default: 100]" (id prepared-cache-size))) (p "Sets the capacity of the prepared statement cache, in statements. Set to 0 to disable the cache; this is not recommended.") (p "When the cache reaches capacity and a new statement is prepared, the least recently used statement is finalized and drops off the cache.") (p "This setting takes effect only upon initiating a new connection, and the statement cache is unique per connection."))
(def (sig (procedure "(step statement)" (id step))) (p "Steps " (tt "statement") " and returns one of the following:") (ul (li (tt "'row") ": a row was returned (" (tt "SQLITE_ROW") ")") (li (tt "'done") ": the statement is done executing (" (tt "SQLITE_DONE") ")") (li (tt "#f") ": step failed due to error")) (p (tt "#f") " is only ever returned if raising exceptions is disabled. Completion of execution is still considered a \"success\" and so the true value " (tt "'done") " is returned, rather than " (tt "#f") ".") (p "Upon database error, the statement is reset."))
(def (sig (procedure "(reset statement)" (id reset))) (p "Resets " (tt "statement") " to the beginning of its program, returning the statement."))
(def (sig (procedure "(finalize statement)" (id finalize))) (p "Finalize " (tt "statement") ".  Finalizing a finalized statement or a cached statement is a no-op.  Finalizing a statement on a closed database is also a no-op.  Cached statements are finalized as they expire, and all other statements known to the SQLite library are automatically finalized when the database is closed, so it is rarely necessary to call this directly."))
(def (sig (procedure "(resurrect statement)" (id resurrect))) (p "Resurrects a previously finalized statement " (tt "s") " or, if still alive, just resets it.  Returns " (tt "s") ", which is also modified in place.") (p "Resurrection is accomplished simply by re-preparing the original SQL associated with the statement.  Afterwards, the statement may be used normally."))
(def (sig (procedure "(bind statement index value)" (id bind))) (p "Bind parameter at " (tt "index") " of " (tt "statement") " to " (tt "value") ", and returns " (tt "statement") ".  The variable " (tt "index") " may be an integer (the first parameter is 1, not 0) or a string for a named parameter --- for example, \"$key\", \":key\" or \"@key\".  For named parameters, the " (tt "$") ", " (tt ":") " or " (tt "@") " must be included in the string.  A reference to an invalid index will throw an exception."))
(def (sig (procedure "(bind-parameters statement . parameters)" (id bind-parameters))) (p "Convenience function which binds " (tt "parameters") " to indices 1 .. n, in order.  The number of parameters must match the statement's " (tt "bind-parameter-count") ", or an error will be signaled."))
(def (sig (procedure "(bind-parameter-count statement)" (id bind-parameter-count))) (p "Returns the number of bound parameter slots in this prepared statement.  Technically, this returns the highest-numbered parameter, so the count may not really be a \"count\" if you bound a explicitly numbered parameter \"?nnn\".  This extension does not play well with explicitly numbered parameters, anyway."))
(def (sig (procedure "(column-name statement index)" (id column-name))) (p "Return the name of the specified result set column as a symbol.  The statement need not have been stepped to retrieve column names or column count.") (pre "(column-name s 1)\n; => key"))
(def (sig (procedure "(column-names statement)" (id column-names))) (p "Convenience function which returns a list of all column names for the result set, in order.") (pre "(column-names s)\n; => (rowid key val)"))
(def (sig (procedure "(column-count statement)" (id column-count))) (p "Return the number of columns in the result set returned by the prepared statement.") (pre "(column-count s)\n; => 3"))
(def (sig (procedure "(column-type statement index)" (id column-type))) (p "Returns the type of the indexed column in the current row.  SQLite is dynamically typed and the column types are unique to each row.") (table (tr (th "Symbol") (th "Database type")) "\n" (tr (td "integer") (td "SQLITE_INTEGER")) "\n" (tr (td "float") (td "SQLITE_FLOAT")) "\n" (tr (td "text") (td "SQLITE_TEXT")) "\n" (tr (td "blob") (td "SQLITE_BLOB")) "\n" (tr (td "null") (td "SQLITE_NULL"))) (pre "(map (lambda (i) (column-type s i))\n     (list 0 1 2))\n; => (integer text text)"))
(def (sig (procedure "(column-data statement index)" (id column-data))) (p "Returns the data from the indexed column in the current row.") (table (tr (th "Column type") (th "Scheme type")) "\n" (tr (td "integer") (td "Exact or inexact number")) "\n" (tr (td "float") (td "Inexact number")) "\n" (tr (td "text") (td "String")) "\n" (tr (td "blob") (td "Blob")) "\n" (tr (td "null") (td "'()"))) (pre "(map (lambda (i) (column-data s i))\n     (list 0 1 2))\n; => (1 \"foo\" \"bar\")") (p (tt "integer") " values are retrieved with " (tt "sqlite3_column_int64") ".  On a 32-bit machine, values outside the signed 31-bit fixnum range are returned as inexact numbers.  On a 64-bit machine, values outside the signed 63-bit fixnum range are returned as inexact numbers.  Note that inexact numbers are 64-bit floating point values, and can only accurately represent 53 bits of an integer."))
(def (sig (procedure "(row-data statement)" (id row-data))) (p "Retrieve a list of column data from the current row.  If the last execution of " (tt "step") " returned " (tt "done") ", a NULL value will be returned for every column.") (pre "(row-data s)\n; => (1 \"foo\" \"bar\")"))
(def (sig (procedure "(row-alist statement)" (id row-alist))) (p "Retrieve an alist mapping column names to column data for the current row.") (pre "(row-alist s)\n; => ((rowid . 1) (key . \"foo\") (val . \"bar\"))"))
(def (sig (procedure "(change-count db)" (id change-count))) (p "Returns the number of database rows that were changed or inserted or deleted by the most recently completed SQL statement, not including triggers, as in " (link "http://www.sqlite.org/capi3ref.html#sqlite3_changes" "sqlite3_changes") "."))
(def (sig (procedure "(total-change-count db)" (id total-change-count))) (p "Returns the number of row changes caused by INSERT, UPDATE or DELETE statements since the database connection was opened, including triggers, as in " (link "http://www.sqlite.org/capi3ref.html#sqlite3_total_changes" "sqlite3_total_changes") "."))
(def (sig (procedure "(last-insert-rowid db)" (id last-insert-rowid))) (p "Get the ROWID of the last successful INSERT, as in " (link "http://www.sqlite.org/capi3ref.html#sqlite3_last_insert_rowid" "sqlite3_last_insert_rowid") "."))
(def (sig (procedure "(call-with-database filename proc)" (id call-with-database))) (p "Opens a database, calls " (tt "proc") " with the database object and then closes the database on return.  If an error occurs in proc, the database is closed immediately."))
(def (sig (procedure "(sql db sql-str)" (id sql))) (p "Creates a statement object associated with the database connection " (tt "db") " and the SQL " (tt "sql-str") ".  Preparation of the statement is deferred until needed.  This is a normal statement in every respect except that it must be " (tt "resurrect") "ed before it can be used."))
(def (sig (procedure "(query proc statement . args)" (id query))) (p "Resurrects s, binds args to s and performs a " (tt "query*") ".  This is the usual way to perform a query unless you need to bind arguments manually, need more control or are using the low-level interface, in which case you can use " (tt "query*") " if desired.") (p "You typically call " (tt "query") " or " (tt "query*") " with one of the provided result fetching procedures; naturally, you can also pass your own procedure to perform whichever operations you would like."))
(def (sig (procedure "(query* proc statement)" (id query*))) (p "Calls " (tt "(proc s)") " and resets the statement immediately afterward, to avoid locking the database.  If an exception occurs during proc, the statement will still be reset.  The statement is not reset before execution.") (p "The entire purpose of " (tt "query*") " is to ensure a statement is reset after it is executed.  If a statement were left in a running state --- for example, if an uncaught exception occurs during proc, or you simply do not exhaust its the result set --- then the database will be locked for writing until the statement is finalized."))
(def (sig (procedure "(fetch s)" (id fetch))) (p "Fetch the next row of the result set.  This is the equivalent to performing a " (tt "step") " followed by a " (tt "row-data") " call, and works with both the high- and low-level interfaces.  If the statement has finished executing, fetch returns '().  These query procedures do not reset the statement before or afterward; one may do so using " (tt "reset") " or " (tt "query") ".") (pre "(fetch s)\n; => (1 \"foo\" \"bar\")\n(fetch s)\n; => (2 \"baz\" \"quux\")\n(fetch s)\n; => ()\n(fetch s)\n; => error\n(query fetch s)\n; => (1 \"foo\" \"bar\")\n(query fetch s)\n; => (1 \"foo\" \"bar\")\n(fetch s)\n; => (1 \"foo\" \"bar\")"))
(def (sig (procedure "(fetch-alist s)" (id fetch-alist))) (p "Equivalent to " (tt "step") " followed by " (tt "row-alist") ".") (pre "(query fetch-alist s)\n; ((rowid . 1) (key . \"foo\") (val . \"bar\"))"))
(def (sig (procedure "(fetch-all s)" (id fetch-all))) (p "Calls " (tt "fetch") " until it returns " (tt "'()") ", and collects the result into a list.") (pre "(query fetch-all s)\n; => ((1 \"foo\" \"bar\")\n      (2 \"baz\" \"quux\"))"))
(def (sig (procedure "(for-each-row proc)" (id for-each-row)) (procedure "(for-each-row* proc)" (id for-each-row*))) (p "Returns a procedure suitable for passing to " (tt "query") ", taking one argument, a statement object.") (p "The procedure will call fetch once for each row and call your callback as " (tt "(proc row)") ", discarding the results.") (pre "(query (for-each-row\n         (lambda (x) (print \"row: \" x)))\n       s)\n; row: (1 foo bar)\n; row: (2 baz quux)\n; => undefined") (p (tt "for-each-row*") " behaves like " (tt "for-each-row") ", but your callback is invoked with one argument for each column value.  For example, these produce equivalent results:") (pre "(query (for-each-row (match-lambda ((name sql)\n                        (print \"table: \" name \" sql: \" sql \";\"))))\n       (sql db \"select name, sql from sqlite_master;\"))  \n(query (for-each-row* (lambda (name sql)\n                        (print \"table: \" name \" sql: \" sql \";\")))\n       (sql db \"select name, sql from sqlite_master;\"))"))
(def (sig (procedure "(map-rows proc)" (id map-rows)) (procedure "(map-rows* proc)" (id map-rows*))) (p "Return a procedure suitable for passing to " (tt "query") ", taking one argument, a statement object.") (p "The procedure will call fetch once for each row and call " (tt "(proc row)") ", collecting the results into a list, in order.") (pre "(query (map-rows car) s)\n; => (1 2)") (p "Another example; these two produce equivalent results:") (pre "(query (map-rows car) (sql db \"select name, sql from sqlite_master;\"))\n(map car (query fetch-all (sql db \"select name, sql from sqlite_master;\")))") (p (tt "map-rows*") " behaves like " (tt "map-rows") ", but your callback is invoked with one argument for each column value."))
(def (sig (procedure "(fold-rows kons knil)" (id fold-rows)) (procedure "(fold-rows* kons knil)" (id fold-rows*))) (p "Calls " (tt "(kons x xs)") " once for each row, where " (tt "x") " is the current row data and " (tt "xs") " is the seed (previous return value from " (tt "kons") ").  The initial seed is " (tt "knil") ".") (pre "(query (fold-rows cons '()) s)\n; => ((2 \"baz\" \"quux\") (1 \"foo\" \"bar\"))") (pre ";; sum the returned rowids \n(query (fold-rows (lambda (x xs) (+ (car x) xs))\n                  0)\n       s)\n; => 3") (pre ";; that was contrived, you should actually do the sum in the database\n(car (query fetch (sql db \"select sum(rowid) from mytable;\")))\n; => 3") (p (tt "fold-rows*") " behaves like " (tt "fold-rows") ", but the " (tt "kons") " callback is invoked with one column for each argument value, plus the seed as the last argument -- for example, as " (tt "(kons x y z seed)") ".  This turns out to be quite inefficient and makes little sense, so " (tt "fold-rows*") " is deprecated as of 0.4.2."))
(def (sig (procedure "(first-column row)" (id first-column))) (p "Returns the first column of " (tt "row") ", or " (tt "#f") " if the row is '().") (pre "(first-column (query fetch (sql db \"select sum(rowid) from mytable;\")))\n; => 3"))
(def (sig (procedure "(exec s . args)" (id exec))) (p "Resurrects statement " (tt "s") ", binds " (tt "args") " to " (tt "s") " and performs an " (tt "exec*") "."))
(def (sig (procedure "(exec* s)" (id exec*))) (p "Executes statement " (tt "sql") ", returning the number of changes (if the result set has no columns as in " (tt "INSERT") ", " (tt "DELETE") ", " (tt "UPDATE") ") or the first row (if column data is returned as in " (tt "SELECT") ").  In the latter case, it is like performing a (query* fetch s), but is more efficient.") (p "Resurrection is omitted, as it would wipe out any bindings.  Reset is NOT done beforehand; it is cheap, but the user must reset before a bind anyway.") (p "Note: Reset afterward is not guaranteed; it is done only if a row was returned and fetch did not throw an error, to avoid locking the database.  An error in step should not leave the statement open, but an error in retrieving column data will (such as a string > 16MB) -- this is a flaw in the current implementation.") (pre "(exec (sql db \"INSERT INTO cache(key, val) values(?, ?);\")\n      \"chicken\" 4)\n; => 1\n(exec (sql db \"SELECT * FROM cache WHERE key = ?;\")\n      \"chicken\")\n; => (\"chicken\" \"4\")\n(first-column (exec (sql db \"SELECT val FROM cache;\")))\n; => \"bar\"\n(first-column (exec (sql db \"SELECT val FROM cache;\")))\n; => \"bar\""))
(def (sig (procedure "(with-transaction db thunk #!optional (type deferred))" (id with-transaction)) (procedure "(with-deferred-transaction db thunk)" (id with-deferred-transaction)) (procedure "(with-immediate-transaction db thunk)" (id with-immediate-transaction)) (procedure "(with-exclusive-transaction db thunk)" (id with-exclusive-transaction))) (p "Executes " (tt "thunk") " within a " (tt "BEGIN TRANSACTION") " block, and returns the value of " (tt "thunk") ".  The optional " (tt "type") " may be one of the symbols " (tt "deferred") ", " (tt "immediate") ", or " (tt "exclusive") ".  You may also use the named convenience functions instead of the optional parameter.") (p "The transaction is committed with " (tt "(commit db)") " if " (tt "thunk") " returns a true value.  Escaping or re-entering the dynamic extent of " (tt "thunk") " will not commit or rollback the in-progress transaction.  However, if an exception occurs during " (tt "thunk") ", or " (tt "thunk") " returns " (tt "#f") ", or the commit fails, the transaction will be rolled back with " (tt "(rollback db)") ".  If this rollback fails, that is a critical error and you should likely abort."))
(def (sig (procedure "(rollback db)" (id rollback))) (p "Rollback current transaction.  Unconditionally resets running queries before doing so, as rollback would fail if read or read/write queries are running.  Successful rollback returns a true value.  Rolling back in autocommit mode also returns a true value."))
(def (sig (procedure "(commit db)" (id commit))) (p "Commit current transaction.  This does not rollback running queries, because running read queries are acceptable, and the behavior in the presence of pending write statements is unclear.  If the commit fails, you can always rollback, which will reset the pending queries.") (p "Successful commit, or commit in autocommit mode, returns a true value."))
(def (sig (procedure "(autocommit? db)" (id autocommit?))) (p "Returns " (tt "#t") " if the database is in autocommit mode, or " (tt "#f") " if within a transaction."))
(def (sig (procedure "(error-code db)" (id error-code))) (p "Returns the last database error code as a symbol."))
(def (sig (procedure "(error-message db)" (id error-message))) (p "Returns the last database error message as a string."))
(def (sig (parameter "(raise-database-errors BOOLEAN) [default: #t]" (id raise-database-errors))) (p "Set to " (tt "#t") " to raise an exception on database error, " (tt "#f") " to return a false value.  Note that certain critical errors, such as \"misuse of interface\" and arity mismatches of bound parameters will raise exceptions regardless.  Procedures in this extension that utilize the low-level interface are written to work correctly with both " (tt "#f") " return values and errors.") (p "Disabling raising of database errors is intended for experts and this option may be removed."))
(def (sig (procedure "(set-busy-handler! db proc)" (id set-busy-handler!))) (p "Register the busy handler " (tt "proc") " on the open connection " (tt "db") "; the handler will be called repeatedly when a " (tt "prepare") " or " (tt "step") " operation returns SQLITE_BUSY.  It is passed the two arguments " (tt "(db count)") ", which are the associated database connection and the number of times this busy handler has been invoked so far for this operation. The procedure should return " (tt "#f") " to stop retrying and have the operation return a BUSY error to the caller, or " (tt "#t") " if the busy operation should be retried.") (p "By default, no busy handler is registered.  Busy handlers are unique to each connection and must be registered after the connection is open.") (pre "(call-with-database \n (lambda (db)\n  (set-busy-handler! db (busy-timeout 10000)) ; 10 second timeout\n  ...))"))
(def (sig (procedure "(busy-timeout ms)" (id busy-timeout))) (p "Return a procedure suitable for use in set-busy-handler!, implementing a spinning busy timeout using the SQLite3 busy wait algorithm.  This handler will wait up to " (tt "ms") " milliseconds total before giving up. Other threads may be scheduled while this one is busy-waiting."))
(def (sig (procedure "(schema db)" (id schema))) (p "Returns a list of SQL statements making up the database schema."))
(def (sig (procedure "(print-schema db)" (id print-schema))) (p "Displays the database schema to the current output port; the result is similar to using " (tt ".schema") " at the " (tt "sqlite3") " command prompt."))
(def (sig (procedure "(flush-cache! db)" (id flush-cache!))) (p "Flush the prepared statement cache,"))
(def (sig (procedure "(finalized? statement)" (id finalized?))) (p "Returns " (tt "#t") " if the statement is finalized or has never been prepared.") (pre "(finalized? (sql db \"select 1;\"))     ; => #t\n(finalized? (prepare db \"select 1;\")) ; => #f"))
(def (sig (string "library-version" (id library-version))) (p "A string representing the SQLite3 library version (e.g. \"3.6.11\")."))
