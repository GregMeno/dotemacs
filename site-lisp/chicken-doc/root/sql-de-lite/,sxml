((section 2 "sql-de-lite" (p (b "sql-de-lite") " is an experimental interface to SQLite 3 for Chicken 4.  The API is subject to change.") (p (b "sql-de-lite") " has the following advantages and disadvantages over the " (b "sqlite3") " extension:") (ul (li "Integrated SQLite3 library") (li "Faster") (li "Prepared statements are cached, finalized and resurrected as needed") (li "Rollbacks and database closing can proceed even if statements are open") (li "Alternate high-level API") (li "User-defined SQL functions are not supported") (li "Raised exceptions contain less information")) (toc) (section 3 "Installation" (p "Starting with " (b "sql-de-lite") " 0.4.0, the SQLite 3 library is included with the egg.  It will be automatically built if the system library is missing or too old; otherwise, the system library is used. You can also override the egg's choice of internal or external library.") (p "In most cases, the following will do the right thing:") (pre "chicken-install sql-de-lite") (p "The goal of this automatic detection is ensure that you can just depend on this extension without requiring a separate library install step from your users.") (section 4 "Built-in library" (p "SQLite 3.7.0.1 is included in the egg and will be linked in statically if the system library is missing or older than 3.7.0.1.  The built-in library is compiled with FTS3 (full text search) enabled.") (p "Additionally, a copy of the SQLite3 command shell is installed with your Chicken binaries as " (tt "chicken-sqlite3") ".") (p "To force the use of the built-in library, pass the " (tt "sql-de-lite-internal-lib") " feature to " (tt "chicken-install") ".  This requires Chicken 4.5.1 or later.") (pre "chicken-install -D sql-de-lite-internal-lib sql-de-lite")) (section 4 "External library" (p "A SQLite library installed in the default system library location will be used instead of the built-in library, if present and recent enough.") (p "To force the use of an external library, pass the " (tt "sql-de-lite-external-lib") " feature to " (tt "chicken-install") ".  This requires Chicken 4.5.1 or later.") (pre "chicken-install -D sql-de-lite-external-lib sql-de-lite") (p "If you force an external library to be used, the build will fail unless the library is present and recent enough not to cause link errors.  The extension assumes you know what you doing, and does not enforce a minimum library version.  It is probably necessary to use 3.6.x or later, and the latest stable is always recommended.")) (section 4 "Non-standard library location" (p "You can point the build process at a library in a non-standard location--for example, under your home directory--by setting " (tt "CSC_OPTIONS") " appropriately.") (pre "export CSC_OPTIONS=\"-I$HOME/local/include -L$HOME/local/lib\"\nchicken-install sql-de-lite")) (section 4 "Your own built-in library, static" (p "If you want to use your own built-in library, retrieve the egg source, " (link "http://www.sqlite.org/download.html" "download the SQLite amalgamation") " zip file or tarball, then extract it into " (tt "sqlite3/") " inside the egg directory.") (pre "chicken-install -r sql-de-lite\ncd sql-de-lite\ncurl -O http://www.sqlite.org/sqlite-amalgamation-3_7_0_1.zip\nunzip sqlite-amalgamation-3_7_0_1.zip -d sqlite3\nchicken-install          # build and install the egg") (p "All we really need is " (tt "shell.c") ", " (tt "sqlite3.c") ", and " (tt "sqlite3.h") " from the amalgamation.  Autoconf is not used.") (p "Currently, there is no way to override the compilation options to SQLite3 from " (tt "chicken-install") ".  If you need to do so, edit the " (tt "sql-de-lite.setup") " file."))) (section 3 "Low-level interface" (p "The low-level interface maps closely to the underlying library API.  It may be used in tandem with or instead of the high-level API as desired.") (section 4 "Opening the database" (def (sig (procedure "(open-database filename)" (id open-database))) (p "Opens " (tt "filename") ", a sqlite3 database.  If no database exists, one is created transparently.  " (tt "filename") " may also be one of the following symbols:") (ul (li (tt "memory") ": a new database in memory unique to this connection") (li (tt "temp") " or " (tt "temporary") ": a new temporary database on disk, visible only to this connection")) (p "Returns a #<sqlite-database> object."))) (section 4 "Closing the database" (def (sig (procedure "(close-database db)" (id close-database))) (p "Closes the database connection " (tt "db") ".") (p "The prepared statement cache is flushed and any transient statements are finalized before closing."))) (section 4 "Preparing a SQL statement" (def (sig (procedure "(prepare db sql)" (id prepare))) (p "Looks up a prepared statement in the statement cache.  If not found, it prepares a new statement and caches it, returning the statement.  If found, the statement is reset if need be, and returned.  An exception is thrown if a statement we pulled from cache is currently running --- in other words, has been stepped at least once and has not yet returned " (tt "SQLITE_DONE") ". (NB: warn and reset would also be acceptable behavior.)") (p "Returns a #<sqlite-statement> object.")) (def (sig (procedure "(prepare-transient db sql)" (id prepare-transient))) (p "Same as " (tt "prepare") ", but bypasses the cache completely.  This procedure is subject to removal.")) (def (sig (parameter "(prepared-cache-size n) [default: 100]" (id prepared-cache-size))) (p "Sets the capacity of the prepared statement cache, in statements. Set to 0 to disable the cache; this is not recommended.") (p "When the cache reaches capacity and a new statement is prepared, the least recently used statement is finalized and drops off the cache.") (p "This setting takes effect only upon initiating a new connection, and the statement cache is unique per connection."))) (section 4 "Stepping the statement" (def (sig (procedure "(step statement)" (id step))) (p "Steps " (tt "statement") " and returns one of the following:") (ul (li (tt "'row") ": a row was returned (" (tt "SQLITE_ROW") ")") (li (tt "'done") ": the statement is done executing (" (tt "SQLITE_DONE") ")") (li (tt "#f") ": step failed due to error")) (p (tt "#f") " is only ever returned if raising exceptions is disabled. Completion of execution is still considered a \"success\" and so the true value " (tt "'done") " is returned, rather than " (tt "#f") ".") (p "Upon database error, the statement is reset."))) (section 4 "Resetting a statement" (def (sig (procedure "(reset statement)" (id reset))) (p "Resets " (tt "statement") " to the beginning of its program, returning the statement."))) (section 4 "Finalizing a statement" (def (sig (procedure "(finalize statement)" (id finalize))) (p "Finalize " (tt "statement") ".  Finalizing a finalized statement or a cached statement is a no-op.  Finalizing a statement on a closed database is also a no-op.  Cached statements are finalized as they expire, and all other statements known to the SQLite library are automatically finalized when the database is closed, so it is rarely necessary to call this directly.")) (def (sig (procedure "(resurrect statement)" (id resurrect))) (p "Resurrects a previously finalized statement " (tt "s") " or, if still alive, just resets it.  Returns " (tt "s") ", which is also modified in place.") (p "Resurrection is accomplished simply by re-preparing the original SQL associated with the statement.  Afterwards, the statement may be used normally."))) (section 4 "Binding parameters" (def (sig (procedure "(bind statement index value)" (id bind))) (p "Bind parameter at " (tt "index") " of " (tt "statement") " to " (tt "value") ", and returns " (tt "statement") ".  The variable " (tt "index") " may be an integer (the first parameter is 1, not 0) or a string for a named parameter --- for example, \"$key\", \":key\" or \"@key\".  For named parameters, the " (tt "$") ", " (tt ":") " or " (tt "@") " must be included in the string.  A reference to an invalid index will throw an exception.")) (def (sig (procedure "(bind-parameters statement . parameters)" (id bind-parameters))) (p "Convenience function which binds " (tt "parameters") " to indices 1 .. n, in order.  The number of parameters must match the statement's " (tt "bind-parameter-count") ", or an error will be signaled.")) (def (sig (procedure "(bind-parameter-count statement)" (id bind-parameter-count))) (p "Returns the number of bound parameter slots in this prepared statement.  Technically, this returns the highest-numbered parameter, so the count may not really be a \"count\" if you bound a explicitly numbered parameter \"?nnn\".  This extension does not play well with explicitly numbered parameters, anyway."))) (section 4 "Obtaining result data" (p "In this section's examples, we assume a simple database has been created with the following commands:") (pre "CREATE TABLE cache(key text, val text);\nINSERT INTO cache(key,val) VALUES('foo', 'bar'); \nINSERT INTO cache(key,val) VALUES('baz', 'quux');") (p "and a SELECT statement has been prepared and stepped once:") (pre "(define s (prepare db \"SELECT rowid, * from cache;\"))\n(step s)  ; => row") (p "and " (tt "s") " is implicitly reset between examples.") (def (sig (procedure "(column-name statement index)" (id column-name))) (p "Return the name of the specified result set column as a symbol.  The statement need not have been stepped to retrieve column names or column count.") (pre "(column-name s 1)\n; => key")) (def (sig (procedure "(column-names statement)" (id column-names))) (p "Convenience function which returns a list of all column names for the result set, in order.") (pre "(column-names s)\n; => (rowid key val)")) (def (sig (procedure "(column-count statement)" (id column-count))) (p "Return the number of columns in the result set returned by the prepared statement.") (pre "(column-count s)\n; => 3")) (def (sig (procedure "(column-type statement index)" (id column-type))) (p "Returns the type of the indexed column in the current row.  SQLite is dynamically typed and the column types are unique to each row.") (table (tr (th "Symbol") (th "Database type")) "\n" (tr (td "integer") (td "SQLITE_INTEGER")) "\n" (tr (td "float") (td "SQLITE_FLOAT")) "\n" (tr (td "text") (td "SQLITE_TEXT")) "\n" (tr (td "blob") (td "SQLITE_BLOB")) "\n" (tr (td "null") (td "SQLITE_NULL"))) (pre "(map (lambda (i) (column-type s i))\n     (list 0 1 2))\n; => (integer text text)")) (def (sig (procedure "(column-data statement index)" (id column-data))) (p "Returns the data from the indexed column in the current row.") (table (tr (th "Column type") (th "Scheme type")) "\n" (tr (td "integer") (td "Exact or inexact number")) "\n" (tr (td "float") (td "Inexact number")) "\n" (tr (td "text") (td "String")) "\n" (tr (td "blob") (td "Blob")) "\n" (tr (td "null") (td "'()"))) (pre "(map (lambda (i) (column-data s i))\n     (list 0 1 2))\n; => (1 \"foo\" \"bar\")") (p (tt "integer") " values are retrieved with " (tt "sqlite3_column_int64") ".  On a 32-bit machine, values outside the signed 31-bit fixnum range are returned as inexact numbers.  On a 64-bit machine, values outside the signed 63-bit fixnum range are returned as inexact numbers.  Note that inexact numbers are 64-bit floating point values, and can only accurately represent 53 bits of an integer.")) (def (sig (procedure "(row-data statement)" (id row-data))) (p "Retrieve a list of column data from the current row.  If the last execution of " (tt "step") " returned " (tt "done") ", a NULL value will be returned for every column.") (pre "(row-data s)\n; => (1 \"foo\" \"bar\")")) (def (sig (procedure "(row-alist statement)" (id row-alist))) (p "Retrieve an alist mapping column names to column data for the current row.") (pre "(row-alist s)\n; => ((rowid . 1) (key . \"foo\") (val . \"bar\"))")) (def (sig (procedure "(change-count db)" (id change-count))) (p "Returns the number of database rows that were changed or inserted or deleted by the most recently completed SQL statement, not including triggers, as in " (link "http://www.sqlite.org/capi3ref.html#sqlite3_changes" "sqlite3_changes") ".")) (def (sig (procedure "(total-change-count db)" (id total-change-count))) (p "Returns the number of row changes caused by INSERT, UPDATE or DELETE statements since the database connection was opened, including triggers, as in " (link "http://www.sqlite.org/capi3ref.html#sqlite3_total_changes" "sqlite3_total_changes") ".")) (def (sig (procedure "(last-insert-rowid db)" (id last-insert-rowid))) (p "Get the ROWID of the last successful INSERT, as in " (link "http://www.sqlite.org/capi3ref.html#sqlite3_last_insert_rowid" "sqlite3_last_insert_rowid") ".")))) (section 3 "High-level interface" (section 4 "call-with-database" (def (sig (procedure "(call-with-database filename proc)" (id call-with-database))) (p "Opens a database, calls " (tt "proc") " with the database object and then closes the database on return.  If an error occurs in proc, the database is closed immediately."))) (section 4 "Statements" (def (sig (procedure "(sql db sql-str)" (id sql))) (p "Creates a statement object associated with the database connection " (tt "db") " and the SQL " (tt "sql-str") ".  Preparation of the statement is deferred until needed.  This is a normal statement in every respect except that it must be " (tt "resurrect") "ed before it can be used."))) (section 4 "Query" (def (sig (procedure "(query proc statement . args)" (id query))) (p "Resurrects s, binds args to s and performs a " (tt "query*") ".  This is the usual way to perform a query unless you need to bind arguments manually, need more control or are using the low-level interface, in which case you can use " (tt "query*") " if desired.") (p "You typically call " (tt "query") " or " (tt "query*") " with one of the provided result fetching procedures; naturally, you can also pass your own procedure to perform whichever operations you would like.")) (def (sig (procedure "(query* proc statement)" (id query*))) (p "Calls " (tt "(proc s)") " and resets the statement immediately afterward, to avoid locking the database.  If an exception occurs during proc, the statement will still be reset.  The statement is not reset before execution.") (p "The entire purpose of " (tt "query*") " is to ensure a statement is reset after it is executed.  If a statement were left in a running state --- for example, if an uncaught exception occurs during proc, or you simply do not exhaust its the result set --- then the database will be locked for writing until the statement is finalized.")) (section 5 "Query procedures" (def (sig (procedure "(fetch s)" (id fetch))) (p "Fetch the next row of the result set.  This is the equivalent to performing a " (tt "step") " followed by a " (tt "row-data") " call, and works with both the high- and low-level interfaces.  If the statement has finished executing, fetch returns '().  These query procedures do not reset the statement before or afterward; one may do so using " (tt "reset") " or " (tt "query") ".") (pre "(fetch s)\n; => (1 \"foo\" \"bar\")\n(fetch s)\n; => (2 \"baz\" \"quux\")\n(fetch s)\n; => ()\n(fetch s)\n; => error\n(query fetch s)\n; => (1 \"foo\" \"bar\")\n(query fetch s)\n; => (1 \"foo\" \"bar\")\n(fetch s)\n; => (1 \"foo\" \"bar\")")) (def (sig (procedure "(fetch-alist s)" (id fetch-alist))) (p "Equivalent to " (tt "step") " followed by " (tt "row-alist") ".") (pre "(query fetch-alist s)\n; ((rowid . 1) (key . \"foo\") (val . \"bar\"))")) (def (sig (procedure "(fetch-all s)" (id fetch-all))) (p "Calls " (tt "fetch") " until it returns " (tt "'()") ", and collects the result into a list.") (pre "(query fetch-all s)\n; => ((1 \"foo\" \"bar\")\n      (2 \"baz\" \"quux\"))")) (def (sig (procedure "(for-each-row proc)" (id for-each-row)) (procedure "(for-each-row* proc)" (id for-each-row*))) (p "Returns a procedure suitable for passing to " (tt "query") ", taking one argument, a statement object.") (p "The procedure will call fetch once for each row and call your callback as " (tt "(proc row)") ", discarding the results.") (pre "(query (for-each-row\n         (lambda (x) (print \"row: \" x)))\n       s)\n; row: (1 foo bar)\n; row: (2 baz quux)\n; => undefined") (p (tt "for-each-row*") " behaves like " (tt "for-each-row") ", but your callback is invoked with one argument for each column value.  For example, these produce equivalent results:") (pre "(query (for-each-row (match-lambda ((name sql)\n                        (print \"table: \" name \" sql: \" sql \";\"))))\n       (sql db \"select name, sql from sqlite_master;\"))  \n(query (for-each-row* (lambda (name sql)\n                        (print \"table: \" name \" sql: \" sql \";\")))\n       (sql db \"select name, sql from sqlite_master;\"))")) (def (sig (procedure "(map-rows proc)" (id map-rows)) (procedure "(map-rows* proc)" (id map-rows*))) (p "Return a procedure suitable for passing to " (tt "query") ", taking one argument, a statement object.") (p "The procedure will call fetch once for each row and call " (tt "(proc row)") ", collecting the results into a list, in order.") (pre "(query (map-rows car) s)\n; => (1 2)") (p "Another example; these two produce equivalent results:") (pre "(query (map-rows car) (sql db \"select name, sql from sqlite_master;\"))\n(map car (query fetch-all (sql db \"select name, sql from sqlite_master;\")))") (p (tt "map-rows*") " behaves like " (tt "map-rows") ", but your callback is invoked with one argument for each column value.")) (def (sig (procedure "(fold-rows kons knil)" (id fold-rows)) (procedure "(fold-rows* kons knil)" (id fold-rows*))) (p "Calls " (tt "(kons x xs)") " once for each row, where " (tt "x") " is the current row data and " (tt "xs") " is the seed (previous return value from " (tt "kons") ").  The initial seed is " (tt "knil") ".") (pre "(query (fold-rows cons '()) s)\n; => ((2 \"baz\" \"quux\") (1 \"foo\" \"bar\"))") (pre ";; sum the returned rowids \n(query (fold-rows (lambda (x xs) (+ (car x) xs))\n                  0)\n       s)\n; => 3") (pre ";; that was contrived, you should actually do the sum in the database\n(car (query fetch (sql db \"select sum(rowid) from mytable;\")))\n; => 3") (p (tt "fold-rows*") " behaves like " (tt "fold-rows") ", but the " (tt "kons") " callback is invoked with one column for each argument value, plus the seed as the last argument -- for example, as " (tt "(kons x y z seed)") ".  This turns out to be quite inefficient and makes little sense, so " (tt "fold-rows*") " is deprecated as of 0.4.2.")) (def (sig (procedure "(first-column row)" (id first-column))) (p "Returns the first column of " (tt "row") ", or " (tt "#f") " if the row is '().") (pre "(first-column (query fetch (sql db \"select sum(rowid) from mytable;\")))\n; => 3")))) (section 4 "Execute" (def (sig (procedure "(exec s . args)" (id exec))) (p "Resurrects statement " (tt "s") ", binds " (tt "args") " to " (tt "s") " and performs an " (tt "exec*") ".")) (def (sig (procedure "(exec* s)" (id exec*))) (p "Executes statement " (tt "sql") ", returning the number of changes (if the result set has no columns as in " (tt "INSERT") ", " (tt "DELETE") ", " (tt "UPDATE") ") or the first row (if column data is returned as in " (tt "SELECT") ").  In the latter case, it is like performing a (query* fetch s), but is more efficient.") (p "Resurrection is omitted, as it would wipe out any bindings.  Reset is NOT done beforehand; it is cheap, but the user must reset before a bind anyway.") (p "Note: Reset afterward is not guaranteed; it is done only if a row was returned and fetch did not throw an error, to avoid locking the database.  An error in step should not leave the statement open, but an error in retrieving column data will (such as a string > 16MB) -- this is a flaw in the current implementation.") (pre "(exec (sql db \"INSERT INTO cache(key, val) values(?, ?);\")\n      \"chicken\" 4)\n; => 1\n(exec (sql db \"SELECT * FROM cache WHERE key = ?;\")\n      \"chicken\")\n; => (\"chicken\" \"4\")\n(first-column (exec (sql db \"SELECT val FROM cache;\")))\n; => \"bar\"\n(first-column (exec (sql db \"SELECT val FROM cache;\")))\n; => \"bar\"")))) (section 3 "Transactions" (section 4 "with-transaction" (def (sig (procedure "(with-transaction db thunk #!optional (type deferred))" (id with-transaction)) (procedure "(with-deferred-transaction db thunk)" (id with-deferred-transaction)) (procedure "(with-immediate-transaction db thunk)" (id with-immediate-transaction)) (procedure "(with-exclusive-transaction db thunk)" (id with-exclusive-transaction))) (p "Executes " (tt "thunk") " within a " (tt "BEGIN TRANSACTION") " block, and returns the value of " (tt "thunk") ".  The optional " (tt "type") " may be one of the symbols " (tt "deferred") ", " (tt "immediate") ", or " (tt "exclusive") ".  You may also use the named convenience functions instead of the optional parameter.") (p "The transaction is committed with " (tt "(commit db)") " if " (tt "thunk") " returns a true value.  Escaping or re-entering the dynamic extent of " (tt "thunk") " will not commit or rollback the in-progress transaction.  However, if an exception occurs during " (tt "thunk") ", or " (tt "thunk") " returns " (tt "#f") ", or the commit fails, the transaction will be rolled back with " (tt "(rollback db)") ".  If this rollback fails, that is a critical error and you should likely abort."))) (section 4 "rollback" (def (sig (procedure "(rollback db)" (id rollback))) (p "Rollback current transaction.  Unconditionally resets running queries before doing so, as rollback would fail if read or read/write queries are running.  Successful rollback returns a true value.  Rolling back in autocommit mode also returns a true value."))) (section 4 "commit" (def (sig (procedure "(commit db)" (id commit))) (p "Commit current transaction.  This does not rollback running queries, because running read queries are acceptable, and the behavior in the presence of pending write statements is unclear.  If the commit fails, you can always rollback, which will reset the pending queries.") (p "Successful commit, or commit in autocommit mode, returns a true value."))) (section 4 "autocommit?" (def (sig (procedure "(autocommit? db)" (id autocommit?))) (p "Returns " (tt "#t") " if the database is in autocommit mode, or " (tt "#f") " if within a transaction.")))) (section 3 "Error handling" (p "Currently, a generic exception is raised when a database error occurs; information about the specific error is not available within the exception.  However, this can still be obtained using the " (tt "error-code") " and " (tt "error-message") " interface.") (def (sig (procedure "(error-code db)" (id error-code))) (p "Returns the last database error code as a symbol.")) (def (sig (procedure "(error-message db)" (id error-message))) (p "Returns the last database error message as a string.")) (def (sig (parameter "(raise-database-errors BOOLEAN) [default: #t]" (id raise-database-errors))) (p "Set to " (tt "#t") " to raise an exception on database error, " (tt "#f") " to return a false value.  Note that certain critical errors, such as \"misuse of interface\" and arity mismatches of bound parameters will raise exceptions regardless.  Procedures in this extension that utilize the low-level interface are written to work correctly with both " (tt "#f") " return values and errors.") (p "Disabling raising of database errors is intended for experts and this option may be removed."))) (section 3 "Busy handling" (p "Busy handling is done outside of the library, instead of inside the library busy handler, because with SRFI-18 threads it is not legal to yield within a callback.  The backoff algorithm of sqlite3_busy_timeout is reimplemented.") (p "SQLite can deadlock in certain situations and to avoid this will return SQLITE_BUSY immediately rather than invoking the busy handler. However if there is no busy handler, we cannot tell a retryable SQLITE_BUSY from a deadlock one.  To gain deadlock protection we register a simple busy handler which sets a flag indicating this BUSY is retryable.  This is done without invoking a callback into Scheme.") (section 4 "set-busy-handler!" (def (sig (procedure "(set-busy-handler! db proc)" (id set-busy-handler!))) (p "Register the busy handler " (tt "proc") " on the open connection " (tt "db") "; the handler will be called repeatedly when a " (tt "prepare") " or " (tt "step") " operation returns SQLITE_BUSY.  It is passed the two arguments " (tt "(db count)") ", which are the associated database connection and the number of times this busy handler has been invoked so far for this operation. The procedure should return " (tt "#f") " to stop retrying and have the operation return a BUSY error to the caller, or " (tt "#t") " if the busy operation should be retried.") (p "By default, no busy handler is registered.  Busy handlers are unique to each connection and must be registered after the connection is open.") (pre "(call-with-database \n (lambda (db)\n  (set-busy-handler! db (busy-timeout 10000)) ; 10 second timeout\n  ...))"))) (section 4 "busy-timeout" (def (sig (procedure "(busy-timeout ms)" (id busy-timeout))) (p "Return a procedure suitable for use in set-busy-handler!, implementing a spinning busy timeout using the SQLite3 busy wait algorithm.  This handler will wait up to " (tt "ms") " milliseconds total before giving up. Other threads may be scheduled while this one is busy-waiting.")))) (section 3 "Miscellaneous" (def (sig (procedure "(schema db)" (id schema))) (p "Returns a list of SQL statements making up the database schema.")) (def (sig (procedure "(print-schema db)" (id print-schema))) (p "Displays the database schema to the current output port; the result is similar to using " (tt ".schema") " at the " (tt "sqlite3") " command prompt.")) (def (sig (procedure "(flush-cache! db)" (id flush-cache!))) (p "Flush the prepared statement cache,")) (def (sig (procedure "(finalized? statement)" (id finalized?))) (p "Returns " (tt "#t") " if the statement is finalized or has never been prepared.") (pre "(finalized? (sql db \"select 1;\"))     ; => #t\n(finalized? (prepare db \"select 1;\")) ; => #f")) (def (sig (string "library-version" (id library-version))) (p "A string representing the SQLite3 library version (e.g. \"3.6.11\")."))) (section 3 "Notes" (section 4 "SRFI-18 threads" (p "If you are operating on the same database in multiple threads, you must open a new connection per thread.  Reusing the same connection will result in corruption."))) (section 3 "Bugs" (p "Assuredly many, among which is the lack of a good high-level interface to named parameters.")) (section 3 "About this egg" (section 4 "Version history" (dl (dt "0.4.2") (dd "Upgrade to SQLite 3.7.3; fix " (tt "fold-rows*") " (and deprecate it)") (dt "0.4.1") (dd "Drop dependency on " (int-link "easyffi")) (dt "0.4.0") (dd "Add integrated SQLite3 library") (dt "0.3.0") (dd "Initial release"))) (section 4 "Author" (p (link "http://3e8.org" "Jim Ursetto"))) (section 4 "License" (p "The egg is BSD-licensed.  The SQLite 3 library is public domain.")))))