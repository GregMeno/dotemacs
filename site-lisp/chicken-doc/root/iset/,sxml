((tags "egg") (section 2 "iset" (toc) (section 3 "Description" (p "Integer sets.")) (section 3 "Author" (p (int-link "/users/alex-shinn" "Alex Shinn"))) (section 3 "Requirements" (p "None")) (section 3 "Documentation" (section 4 "Bit-vectors" (p "Bit-vectors provide an abstract interface to bitwise operations typically done with integers.  They may in fact be implemented as integers on implementations with bignums, or they may be implemented by other means such as vectors which may be more efficient.  These vectors are meant to be used as flags and sets, not integer values, and thus are operations are ones-complement (there are no negative bit-vectors).") (section 5 "Creating bit-vectors" (def (sig (procedure "(make-bit-vector size)" (id make-bit-vector))) (p "A 'zero' bit-vector, with a hint that we wish to use " (tt "SIZE") " bits.")) (def (sig (procedure "(make-bit-vector size #t)" (id make-bit-vector))) (p "Same as above but initialize the all bit elements to " (tt "#t") " (= the integer 2^SIZE-1)")) (def (sig (procedure "(integer->bit-vector n)" (id integer->bit-vector))) (p "Create a bit-vector with bits initialized to the corresponds bits in fixnum N")) (def (sig (procedure "(bit-vector-copy bv)" (id bit-vector-copy))) (p "Make a copy of the bit-vector BV"))) (section 5 "Bit-vector predicates" (def (sig (procedure "(bit-vector? obj)" (id bit-vector?))) (p (tt "#t") " iff OBJ is a valid bit-vector, which is not necessarily a disjoint type")) (def (sig (procedure "(bit-vector-empty? bv)" (id bit-vector-empty?))) (p (tt "#t") " iff BV has no bits set (the bit-vector equivalent of the ZERO? procedure)")) (def (sig (procedure "(bit-vector-full? bv to)" (id bit-vector-full?))) (p (tt "#t") " iff BV has all bits lower than TO set (the low end is 2^i-1)") (p "The individual bits in the vector are accessed and set as boolean values:"))) (section 5 "Accessing bit-vector elements" (def (sig (procedure "(bit-vector-ref bv i)" (id bit-vector-ref))) (p (tt "#t") " if the I-th bit in BV is set, else " (tt "#f"))) (def (sig (procedure "(bit-vector-set bv i x)" (id bit-vector-set))) (p "Return a new copy of BV with the I-th bit set to boolean x (off iff X is " (tt "#f") ")")) (def (sig (procedure "(bit-vector-set! bv i x)" (id bit-vector-set!))) (p "In-place update version of the above, is allowed but not required to mutate BV"))) (section 5 "Bitwise operations on bit-vectors" (p "The following procedures are direct analogues of the corresponding SRFI-33 bitwise operations:") (def (sig (procedure "(bit-vector-length bv)" (id bit-vector-length))) (p (tt "integer-length") ": the index of the largest bit set in BV")) (def (sig (procedure "(bit-vector-count bv)" (id bit-vector-count))) (p (tt "bit-count") ": the number of set bits in BV")) (def (sig (procedure "(bit-vector-shift bv n)" (id bit-vector-shift))) (p (tt "arithmetic-shift"))) (def (sig (procedure "(bit-vector-and bv ...)" (id bit-vector-and))) (p (tt "bitwise-and"))) (def (sig (procedure "(bit-vector-ior bv ...)" (id bit-vector-ior))) (p (tt "bitwise-ior"))) (def (sig (procedure "(bit-vector-xor bv ...)" (id bit-vector-xor))) (p (tt "bitwise-xor"))) (def (sig (procedure "(bit-vector-eqv bv ...)" (id bit-vector-eqv))) (p (tt "bitwise-eqv"))) (def (sig (procedure "(bit-vector-nand bv ...)" (id bit-vector-nand))) (p (tt "bitwise-nand"))) (def (sig (procedure "(bit-vector-nor bv ...)" (id bit-vector-nor))) (p (tt "bitwise-nor")) (p "The following in-place update equivalents are also available, which are allowed, but not required, to mutate their first argument only:")) (def (sig (procedure "(bit-vector-shift! bv n)" (id bit-vector-shift!)) (procedure "(bit-vector-and! bv ...)" (id bit-vector-and!)) (procedure "(bit-vector-ior! bv ...)" (id bit-vector-ior!)) (procedure "(bit-vector-xor! bv ...)" (id bit-vector-xor!)) (procedure "(bit-vector-eqv! bv ...)" (id bit-vector-eqv!)) (procedure "(bit-vector-nand! bv ...)" (id bit-vector-nand!)) (procedure "(bit-vector-nor! bv ...)" (id bit-vector-nor!)))))) (section 4 "Integer sets" (p "An integer set is a set of exact integers optimized for minimal space usage and fast membership lookup.  General set operations are provided based on the character set operations found in SRFI-14.") (section 5 "Creating isets" (def (sig (procedure "(make-iset)" (id make-iset))) (p "An empty integer set.")) (def (sig (procedure "(make-iset n)" (id make-iset))) (p "A set of the single integer N.")) (def (sig (procedure "(make-iset n m)" (id make-iset))) (p "A set of the range of all integers from N-M inclusive."))) (section 5 "SRFI-14 analogues" (p "The following procedures are provided as direct analogs of the SRFI-14 procedures, accepting and returning isets and integers in place of char-sets and characters:") (def (sig (procedure "(iset-copy is)" (id iset-copy))) (p "A new copy of IS")) (def (sig (procedure "(iset n ...)" (id iset))) (p "An iset containing the elements N...")) (def (sig (procedure "(list->iset ls [base-is])" (id list->iset))) (p "An iset containing all the integers in list LS, union BASE-IS if provided")) (def (sig (procedure "(list->iset! ls base-is)" (id list->iset!))) (p "Same as above, allowed but not required to modify base-is")) (def (sig (procedure "(iset-size is)" (id iset-size))) (p "Return the # of elements in IS")) (def (sig (procedure "(iset-contains? is n)" (id iset-contains?))) (p "Test N for membership in IS")) (def (sig (procedure "(iset->list is)" (id iset->list))) (p "Returns a list of all integers in IS")) (def (sig (procedure "(iset-any pred is)" (id iset-any))) (p "Apply PRED to every element of IS, returning the first value returned by PRED that is not " (tt "#f") ", if any (order unspecified)")) (def (sig (procedure "(iset-every pred is)" (id iset-every))) (p "Returns " (tt "#t") " if every element of IS satisfies the predicate PRED (order unspecified)")) (def (sig (procedure "(iset? obj)" (id iset?))) (p (tt "#t") " iff obj is an integer set.")) (def (sig (procedure "(iset= is ...)" (id iset=))) (p (tt "#t") " iff all arguments are equivalent integer sets.")) (def (sig (procedure "(iset<= is ...)" (id iset<=))) (p (tt "#t") " iff the arguments are monotonically increasing sets.")) (def (sig (procedure "(iset>= is ...)" (id iset>=))) (p (tt "#t") " iff the arguments are monotonically decreasing sets.")) (def (sig (procedure "(iset-fold kons knil is)" (id iset-fold))) (p (tt "char-set-fold"))) (def (sig (procedure "(iset-unfold f p g [base-is])" (id iset-unfold))) (p (tt "char-set-unfold"))) (def (sig (procedure "(iset-unfold! f p g base-is)" (id iset-unfold!))) (p (tt "char-set-unfold!"))) (def (sig (procedure "(iset-for-each proc is)" (id iset-for-each))) (p (tt "char-set-for-each"))) (def (sig (procedure "(iset-map proc is)" (id iset-map))) (p (tt "char-set-map"))) (def (sig (procedure "(iset-filter pred is [bas-is])" (id iset-filter))) (p (tt "char-set-filter"))) (def (sig (procedure "(iset-filter! pred is base-is)" (id iset-filter!))) (p (tt "char-set-filter!"))) (def (sig (procedure "(iset-cursor iset)" (id iset-cursor)) (procedure "(iset-ref iset cursor)" (id iset-ref)) (procedure "(iset-cursor-next iset cursor)" (id iset-cursor-next)) (procedure "(end-of-iset? iset)" (id end-of-iset?))) (p "Cursor-based traversal of isets.")) (def (sig (procedure "(iset-adjoin is n ...)" (id iset-adjoin))) (p (tt "char-set-adjoin"))) (def (sig (procedure "(iset-delete is n ...)" (id iset-delete))) (p (tt "char-set-delete"))) (def (sig (procedure "(iset-adjoin! is n ...)" (id iset-adjoin!))) (p (tt "char-set-adjoin!"))) (def (sig (procedure "(iset-delete! is n ...)" (id iset-delete!))) (p (tt "char-set-delete!"))) (def (sig (procedure "(iset-union is1 ...)" (id iset-union))) (p (tt "char-set-union"))) (def (sig (procedure "(iset-intersection is1 ...)" (id iset-intersection))) (p (tt "char-set-intersection"))) (def (sig (procedure "(iset-difference is1 is2 ...)" (id iset-difference))) (p (tt "char-set-difference"))) (def (sig (procedure "(iset-xor is1 ...)" (id iset-xor))) (p (tt "char-set-xor"))) (def (sig (procedure "(iset-diff+intersection is1 is2 ...)" (id iset-diff+intersection))) (p (tt "char-set-diff+intersection"))) (def (sig (procedure "(iset-union! is1 ...)" (id iset-union!))) (p (tt "char-set-union!"))) (def (sig (procedure "(iset-intersection! is1 ...)" (id iset-intersection!))) (p (tt "char-set-intersection!"))) (def (sig (procedure "(iset-difference! is1 is2 ...)" (id iset-difference!))) (p (tt "char-set-difference!"))) (def (sig (procedure "(iset-xor! is1 ...)" (id iset-xor!))) (p (tt "char-set-xor!"))) (def (sig (procedure "(iset-diff+intersection! is1 is2 ...)" (id iset-diff+intersection!))) (p (tt "char-set-diff+intersection!")))))) (section 3 "Changelog" (ul (li "1.7 Fix bug that caused some " (tt "iset-union") " operations to fail in case of overlapping sets. Fix another bug that caused a negative bit-vector-shift of a multi-byte bitvector to clobber the least significant byte with zero.") (li "1.6 Converted to tags/trunk/branches structure in svn") (li "1.5 Port to hygienic chicken, fix overflow bug in bit-vector-full? [Peter Bex]") (li "1.4 Workaround in " (tt "bit-vector-copy") " for zero-length vectors.") (li "1.3 Fixed " (tt "bit-vector-copy") " export but no define [by Kon Lovett]") (li "1.2 Added " (tt "iset-optimize") " and " (tt "iset-balance") ", fixed some bugs") (li "1.1 Added cursors") (li "1.0 Initial release"))) (section 3 "License" (pre " Copyright (c) 2004-2006, Alex Shinn\n All rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions\n are met:\n 1. Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n 3. The name of the author may not be used to endorse or promote products\n    derived from this software without specific prior written permission.\n \n THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."))))