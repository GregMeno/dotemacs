(index ("make-bit-vector" 0) ("make-bit-vector" 151) ("integer->bit-vector" 322) ("bit-vector-copy" 481) ("bit-vector?" 588) ("bit-vector-empty?" 738) ("bit-vector-full?" 901) ("bit-vector-ref" 1132) ("bit-vector-set" 1263) ("bit-vector-set!" 1427) ("bit-vector-length" 1584) ("bit-vector-count" 1725) ("bit-vector-shift" 1849) ("bit-vector-and" 1949) ("bit-vector-ior" 2042) ("bit-vector-xor" 2135) ("bit-vector-eqv" 2228) ("bit-vector-nand" 2321) ("bit-vector-nor" 2417) ("bit-vector-shift!" 2652) ("bit-vector-and!" 2652) ("bit-vector-ior!" 2652) ("bit-vector-xor!" 2652) ("bit-vector-eqv!" 2652) ("bit-vector-nand!" 2652) ("bit-vector-nor!" 2652) ("make-iset" 3088) ("make-iset" 3169) ("make-iset" 3261) ("iset-copy" 3379) ("iset" 3458) ("list->iset" 3550) ("list->iset!" 3698) ("iset-size" 3830) ("iset-contains?" 3923) ("iset->list" 4025) ("iset-any" 4126) ("iset-every" 4323) ("iset?" 4486) ("iset=" 4579) ("iset<=" 4695) ("iset>=" 4819) ("iset-fold" 4943) ("iset-unfold" 5034) ("iset-unfold!" 5134) ("iset-for-each" 5235) ("iset-map" 5333) ("iset-filter" 5416) ("iset-filter!" 5517) ("iset-cursor" 5620) ("iset-ref" 5620) ("iset-cursor-next" 5620) ("end-of-iset?" 5620) ("iset-adjoin" 5891) ("iset-delete" 5984) ("iset-adjoin!" 6077) ("iset-delete!" 6173) ("iset-union" 6269) ("iset-intersection" 6358) ("iset-difference" 6468) ("iset-xor" 6576) ("iset-diff+intersection" 6659) ("iset-union!" 6788) ("iset-intersection!" 6880) ("iset-difference!" 6993) ("iset-xor!" 7104) ("iset-diff+intersection!" 7190))
(def (sig (procedure "(make-bit-vector size)" (id make-bit-vector))) (p "A 'zero' bit-vector, with a hint that we wish to use " (tt "SIZE") " bits."))
(def (sig (procedure "(make-bit-vector size #t)" (id make-bit-vector))) (p "Same as above but initialize the all bit elements to " (tt "#t") " (= the integer 2^SIZE-1)"))
(def (sig (procedure "(integer->bit-vector n)" (id integer->bit-vector))) (p "Create a bit-vector with bits initialized to the corresponds bits in fixnum N"))
(def (sig (procedure "(bit-vector-copy bv)" (id bit-vector-copy))) (p "Make a copy of the bit-vector BV"))
(def (sig (procedure "(bit-vector? obj)" (id bit-vector?))) (p (tt "#t") " iff OBJ is a valid bit-vector, which is not necessarily a disjoint type"))
(def (sig (procedure "(bit-vector-empty? bv)" (id bit-vector-empty?))) (p (tt "#t") " iff BV has no bits set (the bit-vector equivalent of the ZERO? procedure)"))
(def (sig (procedure "(bit-vector-full? bv to)" (id bit-vector-full?))) (p (tt "#t") " iff BV has all bits lower than TO set (the low end is 2^i-1)") (p "The individual bits in the vector are accessed and set as boolean values:"))
(def (sig (procedure "(bit-vector-ref bv i)" (id bit-vector-ref))) (p (tt "#t") " if the I-th bit in BV is set, else " (tt "#f")))
(def (sig (procedure "(bit-vector-set bv i x)" (id bit-vector-set))) (p "Return a new copy of BV with the I-th bit set to boolean x (off iff X is " (tt "#f") ")"))
(def (sig (procedure "(bit-vector-set! bv i x)" (id bit-vector-set!))) (p "In-place update version of the above, is allowed but not required to mutate BV"))
(def (sig (procedure "(bit-vector-length bv)" (id bit-vector-length))) (p (tt "integer-length") ": the index of the largest bit set in BV"))
(def (sig (procedure "(bit-vector-count bv)" (id bit-vector-count))) (p (tt "bit-count") ": the number of set bits in BV"))
(def (sig (procedure "(bit-vector-shift bv n)" (id bit-vector-shift))) (p (tt "arithmetic-shift")))
(def (sig (procedure "(bit-vector-and bv ...)" (id bit-vector-and))) (p (tt "bitwise-and")))
(def (sig (procedure "(bit-vector-ior bv ...)" (id bit-vector-ior))) (p (tt "bitwise-ior")))
(def (sig (procedure "(bit-vector-xor bv ...)" (id bit-vector-xor))) (p (tt "bitwise-xor")))
(def (sig (procedure "(bit-vector-eqv bv ...)" (id bit-vector-eqv))) (p (tt "bitwise-eqv")))
(def (sig (procedure "(bit-vector-nand bv ...)" (id bit-vector-nand))) (p (tt "bitwise-nand")))
(def (sig (procedure "(bit-vector-nor bv ...)" (id bit-vector-nor))) (p (tt "bitwise-nor")) (p "The following in-place update equivalents are also available, which are allowed, but not required, to mutate their first argument only:"))
(def (sig (procedure "(bit-vector-shift! bv n)" (id bit-vector-shift!)) (procedure "(bit-vector-and! bv ...)" (id bit-vector-and!)) (procedure "(bit-vector-ior! bv ...)" (id bit-vector-ior!)) (procedure "(bit-vector-xor! bv ...)" (id bit-vector-xor!)) (procedure "(bit-vector-eqv! bv ...)" (id bit-vector-eqv!)) (procedure "(bit-vector-nand! bv ...)" (id bit-vector-nand!)) (procedure "(bit-vector-nor! bv ...)" (id bit-vector-nor!))))
(def (sig (procedure "(make-iset)" (id make-iset))) (p "An empty integer set."))
(def (sig (procedure "(make-iset n)" (id make-iset))) (p "A set of the single integer N."))
(def (sig (procedure "(make-iset n m)" (id make-iset))) (p "A set of the range of all integers from N-M inclusive."))
(def (sig (procedure "(iset-copy is)" (id iset-copy))) (p "A new copy of IS"))
(def (sig (procedure "(iset n ...)" (id iset))) (p "An iset containing the elements N..."))
(def (sig (procedure "(list->iset ls [base-is])" (id list->iset))) (p "An iset containing all the integers in list LS, union BASE-IS if provided"))
(def (sig (procedure "(list->iset! ls base-is)" (id list->iset!))) (p "Same as above, allowed but not required to modify base-is"))
(def (sig (procedure "(iset-size is)" (id iset-size))) (p "Return the # of elements in IS"))
(def (sig (procedure "(iset-contains? is n)" (id iset-contains?))) (p "Test N for membership in IS"))
(def (sig (procedure "(iset->list is)" (id iset->list))) (p "Returns a list of all integers in IS"))
(def (sig (procedure "(iset-any pred is)" (id iset-any))) (p "Apply PRED to every element of IS, returning the first value returned by PRED that is not " (tt "#f") ", if any (order unspecified)"))
(def (sig (procedure "(iset-every pred is)" (id iset-every))) (p "Returns " (tt "#t") " if every element of IS satisfies the predicate PRED (order unspecified)"))
(def (sig (procedure "(iset? obj)" (id iset?))) (p (tt "#t") " iff obj is an integer set."))
(def (sig (procedure "(iset= is ...)" (id iset=))) (p (tt "#t") " iff all arguments are equivalent integer sets."))
(def (sig (procedure "(iset<= is ...)" (id iset<=))) (p (tt "#t") " iff the arguments are monotonically increasing sets."))
(def (sig (procedure "(iset>= is ...)" (id iset>=))) (p (tt "#t") " iff the arguments are monotonically decreasing sets."))
(def (sig (procedure "(iset-fold kons knil is)" (id iset-fold))) (p (tt "char-set-fold")))
(def (sig (procedure "(iset-unfold f p g [base-is])" (id iset-unfold))) (p (tt "char-set-unfold")))
(def (sig (procedure "(iset-unfold! f p g base-is)" (id iset-unfold!))) (p (tt "char-set-unfold!")))
(def (sig (procedure "(iset-for-each proc is)" (id iset-for-each))) (p (tt "char-set-for-each")))
(def (sig (procedure "(iset-map proc is)" (id iset-map))) (p (tt "char-set-map")))
(def (sig (procedure "(iset-filter pred is [bas-is])" (id iset-filter))) (p (tt "char-set-filter")))
(def (sig (procedure "(iset-filter! pred is base-is)" (id iset-filter!))) (p (tt "char-set-filter!")))
(def (sig (procedure "(iset-cursor iset)" (id iset-cursor)) (procedure "(iset-ref iset cursor)" (id iset-ref)) (procedure "(iset-cursor-next iset cursor)" (id iset-cursor-next)) (procedure "(end-of-iset? iset)" (id end-of-iset?))) (p "Cursor-based traversal of isets."))
(def (sig (procedure "(iset-adjoin is n ...)" (id iset-adjoin))) (p (tt "char-set-adjoin")))
(def (sig (procedure "(iset-delete is n ...)" (id iset-delete))) (p (tt "char-set-delete")))
(def (sig (procedure "(iset-adjoin! is n ...)" (id iset-adjoin!))) (p (tt "char-set-adjoin!")))
(def (sig (procedure "(iset-delete! is n ...)" (id iset-delete!))) (p (tt "char-set-delete!")))
(def (sig (procedure "(iset-union is1 ...)" (id iset-union))) (p (tt "char-set-union")))
(def (sig (procedure "(iset-intersection is1 ...)" (id iset-intersection))) (p (tt "char-set-intersection")))
(def (sig (procedure "(iset-difference is1 is2 ...)" (id iset-difference))) (p (tt "char-set-difference")))
(def (sig (procedure "(iset-xor is1 ...)" (id iset-xor))) (p (tt "char-set-xor")))
(def (sig (procedure "(iset-diff+intersection is1 is2 ...)" (id iset-diff+intersection))) (p (tt "char-set-diff+intersection")))
(def (sig (procedure "(iset-union! is1 ...)" (id iset-union!))) (p (tt "char-set-union!")))
(def (sig (procedure "(iset-intersection! is1 ...)" (id iset-intersection!))) (p (tt "char-set-intersection!")))
(def (sig (procedure "(iset-difference! is1 is2 ...)" (id iset-difference!))) (p (tt "char-set-difference!")))
(def (sig (procedure "(iset-xor! is1 ...)" (id iset-xor!))) (p (tt "char-set-xor!")))
(def (sig (procedure "(iset-diff+intersection! is1 is2 ...)" (id iset-diff+intersection!))) (p (tt "char-set-diff+intersection!")))
