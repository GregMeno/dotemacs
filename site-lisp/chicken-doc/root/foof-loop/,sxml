((tags "egg") (section 2 "foof-loop: A Simple, Extensible Scheme Looping Facility" (p "This is the reference manual for foof-loop version 8.  This file was written by Taylor R. Campbell and is placed in the Public Domain.  All warranties are disclaimed.") (p "The most recently released version of this file is permanently stored at " (link "http://mumble.net/~campbell/scheme/foof-loop.txt") ".") (toc)) (section 2 "Requirements" (p "None")) (section 2 "Introduction" (p "Looping is one of the most fundamental concepts of computer programs, and it is not a simple concept that can be described succinctly once and for all programs; therefore, it is in our interest to have some way to write loops clearly.  Although there are far too many kinds of loops -- perhaps an infinite number -- for any one framework to give a name to each conceivable way to express them, we should like to have a cohesive framework for expressing a large subset of the common kinds of loops in a flexible but simple way.") (section 3 "Basic Looping: Named LET versus DO versus LOOP" (p "Let us begin with a simple example: a loop that counts the number of elements satisfying a certain predicate in a sequence.  What sort of sequence?  We shall try lists first.  In standard Scheme, this might be written with named LET or DO; let us choose DO, simply because it is slightly more concise for this form of loop:") (pre " (define (count-matching-items list predicate)\n   (do ((list list (cdr list))\n        (count 0\n               (if (predicate (car list))\n                   (+ count 1)\n                   count)))\n       ((null-list? list) count)))") (p "This is fairly straightforward, but if we wish to substitute a vector for a list, we must alter the structure of the loop so that it steps through the indices of the vector, rather than through the list's structure.  That is, we must write in precise detail the *means* of looping:") (pre " (define (count-matching-items vector predicate)\n   (do ((index 0 (+ index 1))\n        (count 0\n               (if (predicate (vector-ref vector index))\n                   (+ count 1)\n                   count)))\n       ((= index (vector-length vector))\n        count)))") (p "Even worse, if we wish to count the matching items read from an input port, we must restructure the whole loop using named LET, because we need to perform an action when the loop is entered *before* the termination condition:") (pre " (define (count-matching-items reader input-port predicate)\n   (let continue ((count 0))\n     (let ((item (reader input-port)))\n       (if (eof-object? item)\n           count\n           (continue (if (predicate item)\n                         (+ count 1)\n                         count))))))") (p "We should like a notation that allows the programmer to specify *what* iteration, not *how* to iterate.  We want to give the programmer the tools to request iteration over each element in a list, or each element in a vector, or each item read from an input port.  LOOP lets us do so:") (pre " (define (count-matching-items list predicate)\n   (loop ((for item (in-list list))\n          (with count 0\n            (if (predicate item)\n                (+ count 1)\n                count)))\n     => count))") (p "How do we read this mountain of syntactic sugar?  The first part is LOOP, which is the name of the macro that invokes the whole construct. The second part is a list of iteration clauses, each of which acts in parallel through the whole iteration; that is, there are no nested loops here.  (FOR ITEM (IN-LIST LIST)) asks for ITEM to be bound to each element of the list LIST; (WITH COUNT 0 <update>) asks COUNT to be a variable initialized to 0 and updated at each iteration to the value of <update>.  Finally, the return value of the loop, once any of the iterators can go no further (in this case, once we have run through all elements of LIST), is specified with the `=>' token followed by the expression to return -- here, the number of matching items we counted.") (p "We desired a way to write *what* iteration, and not *how*, and LOOP lets us do so.  If what we want is to iterate over each element of a vector, we need simply substitute IN-VECTOR for IN-LIST.  If what we want is to iterate for each item read from an input port, we need simply substitute IN-PORT.") (p "(This code still must specify information about what type of sequence we are iterating through -- IN-VECTOR vs IN-LIST &c. --, and we might wish to elide that as well and substitute IN-COLLECTION or IN-SEQUENCE, or even IN-ASSOCIATION for alists & hash tables &c., but we do not provide any built-in mechanism for doing so.  The author has, however, designed a generic collection iteration protocol, based on Dylan's, for which there are such LOOP iterators as IN-COLLECTION &c.  They fall outside the scope of this introduction, however.)")) (section 3 "Explicit Control of Iteration" (p "An astute reader might wonder why we need a `=>' token to indicate the final value returned by the loop; a differently astute reader might wonder how LOOP can possibly be as general as DO or named LET without any program body inside the loop.  We can, in fact, write a program body, and distinguishing the final expression from the body is precisely the reason for the `=>' token.  Indeed, not only can we write an arbitrary program body as in DO, but we can even give a name to the loop and specify where to continue to the next iteration as we please. For example, if we wished to *find* a matching item, rather than to count all of them, we could write a procedure to do so thus:") (pre " (define (find-matching-item list if-absent predicate)\n   (loop continue ((for item (in-list list)))\n     => (if-absent)\n     (if (predicate item)\n         item\n         (continue))))") (p "In this example, the loop continues only if ITEM fails to satisfy PREDICATE.  Only if we have run through every element of LIST, and found none satisfying PREDICATE, shall we evaluate the final expression and call IF-ABSENT.  Again, we can always substitute IN-VECTOR, IN-PORT, or any other iterator as we please, for IN-LIST here.") (p "In fact, not only can we give a name to the loop and invoke it explicitly to continue iteration, but we are not limited to calling it in tail positions in the loop body.  We could, for example, write a (single-list) MAP procedure thus:") (pre " (define (map procedure list)\n   (loop recur ((for element (in-list list)))\n     => '()\n     (cons (procedure element) (recur))))") (p "If there are no more elements in LIST, then the loop yields the empty list; otherwise, it recursively processes the remaining elements of the list, and constructs a pair of the mapped ELEMENT and all the mapped remaining elements.") (p "Finally, we need not supply a final expression at all, in which case what the loop returns by default is unspecified.  For example, to write each element of a list LIST followed by a newline, we could use the following program:") (pre " (loop ((for element (in-list list)))\n   (write element)\n   (newline))")) (section 3 "Updating Loop Variables" (p "A third sort of astute reader may wonder still how LOOP can be as expressive and flexible as named LET, which allows for the updates of loop variables (which we introduced in LOOP using WITH clauses) when the loop procedure is called.  In fact, LOOP is a drop-in replacement for named LET, provided that we use the loop procedure only in operator positions, because it is not actually a procedure but a macro, for reasons that will become apparent shortly.  The following procedure's meaning is invariant whether we write LOOP or LET:") (pre " (define (reverse-map procedure list)\n   (let continue ((list list) (result '()))\n     (if (null-list? list)\n         result\n         (continue (cdr list)\n                   (cons (procedure (car list) result))))))") (p "As loop clauses, (<variable> <initializer>) and (WITH <variable> <initializer>) are both equivalent to named LET bindings, and we can update the variables by passing new values to the named loop.  As with named LET, the update is purely functional; that is, it works by rebinding, *not* by assignment.") (p "But one of the primary gripes one hears with named LET is the distance between the list of loop variables and the expressions by which they are updated.  The matter is not helped by the only association between the two: position.  In LOOP, on the other hand, we may choose whichever of positional and named update we please.  For example, if we wish to partition a list by a predicate by adding an element to one of two resultant lists, and leaving the other untouched, we might write this (following SRFI 1's specification of the procedure):") (pre " (define (partition predicate list)\n   (loop continue ((for element (in-list list))\n                   (with satisfied '())\n                   (with unsatisfied '()))\n     => (values (reverse satisfied)\n                (reverse unsatisfied))\n     (if (predicate element)\n         (continue (=> satisfied (cons element satisfied)))\n         (continue (=> unsatisfied (cons element unsatisfied))))))")) (section 3 "Iterator-Supplied Loop Variables" (p "Sometimes it is not enough just to step through each element of a list or a vector; we may need to find where in the sequence we are, or move to another position.  Some iterators, therefore, can expose the underlying loop variables, specific to each iterator.  IN-LIST exposes the pair whose car is the current element of the list.  It also ensures that modifying the cdr of that pair is safe and does not affect the iteration, so we can reverse a list destructively like so:") (pre " (define (reverse! list)\n   (loop ((for element pair (in-list list))\n          (with tail '() pair))\n     => tail\n     (set-cdr! pair tail)))") (p "We step through the list, letting TAIL be () initially and then the last pair we encountered; for each pair we encounter, we set its cdr to be the current tail.  We happen not to use ELEMENT here, although we could easily turn this into a REVERSE-MAP! procedure like so:") (pre " (define (reverse-map! procedure list)\n   (loop ((for element pair (in-list list))\n          (with tail '() pair))\n     => tail\n     (set-car! pair (procedure element))\n     (set-cdr! pair tail)))") (p "Often, in processing certain sorts of lists, we find nested sublists which we want to coalesce into the containing list; Scheme's BEGIN works like this.  We can flatten as we go along by updating the loop variable of IN-LIST explicitly, rather than simply letting it to be implicitly updated to the cdr of the current pair:") (pre " (define (flatten-begins list)\n   (loop continue ((for element pair (in-list list))\n                   (with subforms '()))\n     => (reverse subforms)\n     (if (and (pair? element)\n              (eq? 'BEGIN (car element)))\n         (continue (=> pair (append (cdr element) (cdr pair))))\n         (continue (=> subforms (cons element subforms))))))") (p "In the case of vector iterators, the underlying loop variable is the index into the vector.  For instance, to shuffle the contents of a vector by the Fisher-Yates method, given a procedure (RANDOM-INTEGER <exclusive upper bound>), we might write this:") (pre " (define (shuffle-vector! vector)\n   (loop ((for element i (in-vector vector)))\n     (let ((j (random-integer (+ i 1))))\n       (vector-set! vector i (vector-ref vector j))\n       (vector-set! vector j element))))")) (section 3 "Numeric Iteration" (p "There are two iterators supplied for iterating over numbers: UP-FROM and DOWN-FROM.  (These violate the convention of the prefix of `IN-' on iterator names, but after long and arduous discussion of the matter, the author and his minions concluded that these are better than any of the alternatives that were considered.)  For example, to construct a list of a given length that contains the result of applying a given procedure to each respective index in the list, we could write this:") (pre " (define (list-tabulate length procedure)\n   (loop ((for index (up-from 0 (to length)))\n          (with list '() (cons (procedure index) list)))\n     => (reverse list)))") (p "NOTE: The keyword TO is part of the syntax of UP-FROM which specifies an upper bound for the iteration.  It is *not* a separate procedure or special operator.") (p "We can step by a specified increment as well by adding an on argument (BY <increment>); for instance, to produce a list of the even integers less than N, we might write this:") (pre " (loop ((for integer (up-from 0 (to N) (by 2)))\n        (with evens '() (cons integer evens)))\n   => (reverse evens))") (p "We can also omit TO in order to get an unbounded iteration, which presumably we intend to terminate by some other means.  For example, to find the length of a list (which we assume to be finite and non- circular), we might write the following:") (pre " (define (unsafe-length list)\n   (loop ((for element (in-list list))\n          (for length (up-from 0)))\n     => length))") (p "(FOR <variable> (UP-FROM <start> [(TO <end>)] [(BY <step>)])) iterates with <variable> initially bound to <start> and then updated at each iteration to <step> added to its current value, until its value has reached or exceeded <end>.  DOWN-FROM works slightly differently, however, and illustrates an important point in the design of LOOP, which I shall give its own paragraph to emphasize its significance.") (p "Lower bounds are inclusive.  Upper bounds are exclusive.") (p "This means that, while UP-FROM includes the start and excludes the end, DOWN-FROM, which has the same syntax, excludes the start and includes the end, if it is reached.  (It may be the case that <start> - <end> is not an even multiple of <step>, in which case <end> will be excluded anyway.)  This bears repeating.") (p "Lower bounds are inclusive.  Upper bounds are exclusive.") (p "Whether we are iterating forward or backward, over ranges of numbers or elements of vectors (with IN-VECTOR-REVERSE, which is just like IN-VECTOR except that it iterates over the reverse sequence of elements), the lower bound of the iteration is inclusive and the upper bound of the iteration is exclusive.") (p "This has an important consequence for the nature of the loop variable in DOWN-FROM (or IN-VECTOR-REVERSE, or any other iteration of numbers from positive infinity toward negative infinity): the decrement is subtracted from the loop variable's value on *entry* to the loop.  This means that if the variable is initialized to 0, its first value in the loop body will be -1, not 0; and if it is updated to N, the next value that it will have in the loop body (if it satisfies no termination condition) will be N - 1.") (p "Let me say it one more time, just to be sure that the reader understands.") (p "Lower bounds are inclusive.  Upper bounds are exclusive.") (p "The reason for this design decision is that reverse iteration is extremely counter-intuitive, and any inconsistency in convention is sure to be an eternal source of off-by-one errors.  This is not to say that off-by-one errors are impossible, but that they are much easier to accidentally stumble upon in reverse iteration.  The use of inclusive lower bounds and exclusive upper bounds is already very much established in Scheme, and it has some convenient properties for many programs.") (p "Where one must use any other sort of bounds, because such bounds are the exception rather than the rule, programmers should draw attention to the fact, because this is so easy to mix up inadvertently.  If possible, use inclusive lower bounds and exclusive upper bounds, but if it is truly necessary to use any other class of bounds, they should be expressed explicitly using WITH, LET, and UNTIL clauses.  For example, to loop with inclusive bounds on both ends, write") (pre " (loop (...\n        (with i start (+ i step))\n        (until (> i stop))\n        ...)\n   ...).")) (section 3 "Accumulating Results" (p "At this point, the only iterators we have seen are those that step through sequences.  Every time we have accumulated, say, a list of values as the result of a loop, we have always had to write it with a manual loop variable, a manual CONS, and a manual REVERSE at the end. We can simplify this by using accumulating iterators such as LISTING. If we use LISTING, (single-list) MAP becomes:") (pre " (define (map procedure list)\n   (loop ((for element (in-list list))\n          (for result (listing (procedure element))))\n     => result))") (p "Accumulators, as the reader has probably noticed, are not named according to the `IN-' convention for iterators.  Instead, they are named with an `-ING' suffix.  Furthermore, most of them follow the same basic structure:") (pre " (FOR <accumulated-result> \n      (<accumulating> [(INITIAL <initial value>)]\n                      <datum or conditions>))") (p "<Initial value> is something to seed the accumulation with.  In LISTING, for example, it is the tail of the list after all the accumulated elements.") (p "There are several ways to express the accumulation of a datum.  The simplest is with an expression whose value is always accumulated; we showed that above in the most recent definition of MAP.  We may also accumulate based on the value of a condition; for example, to filter from a list only those items that satisfy a predicate, we might write the following:") (pre " (define (filter predicate list)\n   (loop ((for element (in-list list))\n          (for result\n               (listing element\n                        (if (predicate element)))))\n     => result))") (p "Sometimes the value of the condition is also needed to compute the datum to accumulate, so we may also express the accumulation with a notation much like COND's `=>' clause, and accumulate a list of all non-false values yielded by a procedure applied to each element of a list:") (pre " (define (filter-map procedure list)\n   (loop ((for element (in-list list))\n          (for result\n               (listing (procedure list) => (lambda (x) x))))\n     => result))") (p "Finally, the `=>' clause may be preceded by a test, to support multiple return values and to allow the passage of #F to the procedure following the `=>', as in SRFI 61's extended COND.  An example of this is left to the imagination of the reader.") (p "Along with LISTING, there are three other similar list-related accumulators: LISTING-REVERSE, APPENDING, and APPENDING-REVERSE.  For elements elt_0, elt_1, ..., elt_n-1, elt_n, LISTING yields") (pre " (LIST elt_0 elt_1 ... elt_n-1 elt_n);") (p "LISTING-REVERSE yields") (pre " (LIST elt_n elt_n-1 ... elt_1 elt_0);") (p "APPENDING yields") (pre " (APPEND elt_0 elt_1 ... elt_n-1 elt_n);") (p "and APPENDING-REVERSE yields") (pre " (APPEND (REVERSE elt_n) \n         (REVERSE elt_n-1)\n         ... \n         (REVERSE elt_1)\n         (REVERSE elt_0)),") (p "although it can be implemented considerably more efficiently than (APPENDING (REVERSE ...)).") (p "There are also two destructive list-related accumulators: LISTING! and LISTING-INTO!.  While LISTING must build up a list in reverse and then reverse it at the end, which requires twice as many cons cells as the result uses, LISTING! builds up a list forward by setting the cdr of each previous pair constructed, and requires only one intermediate cons cell, the initial one.  LISTING-INTO! uses no intermediate cons cells because it is seeded with an initial pair to set the cdr of:") (pre " (let ((x (cons 'initial '())))\n   (loop ((for i (up-from 0 (to 10)))\n          (for result (listing-into! x (* i i) (if (even? i))))))\n   x)\n ;Value: (INITIAL 0 4 16 36 64)") (p "LISTING! and LISTING-INTO! are dangerous, however, because they are non-reentrant -- that is, it is unsafe to use them where non-local control transfers to reenter the loop body may occur, or where the loop may be continued at multiple different points.")) (section 3 "Other LOOP Clauses: Local Bindings, Explicit Termination Conditions" (p "So far we have seen FOR and WITH clauses in LOOP expressions -- FOR to dispatch to some specialized iterator, and WITH to express manual loop variables.  These are the main clauses of interest, but there are four others: WHILE, UNTIL, LET, and LET-VALUES.") (p "WHILE and UNTIL allow the programmer to specify termination conditions for the loop following which the final expression will be evaluated. Although it is possible to explicitly continue the loop in one arm of a conditional, this requires some boilerplate to invoke the final expression as well in the other arm of the conditional.  For example, this procedure reads lines from an input port until an empty line, and returns a list of the non-empty lines, assuming a READ-LINE procedure:") (pre " (define (read-non-empty-lines input-port)\n   (loop ((for line (in-port input-port read-line))\n          (until (string-empty? line))\n          (for lines (listing line)))\n     => lines))") (p "Iteration will terminate either when READ-LINE returns an EOF object, tested implicitly by IN-PORT, or when the line read is an empty string, tested explicitly by the user.  In either case, LISTING will bind LINES to the list of lines in the final expression, which we return there.") (p "(LET <variable> <expression>) binds <variable> to <expression>, after it has been determined that none of the FOR iterators have run out, and after all of their variables have been bound.  <Variable> is visible inside the loop body.  (LET-VALUES <bvl> <producer>) is similar, but it binds multiple values, rather than a single value; (LET <variable> <expression>) is equivalent to (LET-VALUES (<variable>) <expression>).") (p "All variables bound by the iterators are visible in the right-hand sides of LET & LET-VALUES clauses, and all those variables as well as all variables on the left-hand sides of LET & LET-VALUES clauses are visible in the user termination conditions -- those supplied by WHILE and UNTIL -- and in the loop body.") (p "This concludes the introduction to foof-loop.  The rest of this document contains a reference manual for foof-loop as well as some further material."))) (section 2 "Loop Structure" (p "LOOP forms have the following structure:") (pre " (LOOP [<loop-name>] (<loop-clause> ...)\n   [=> <final-expression>]\n   [<body>])") (p "<loop-clause> may have one of the following forms:") (pre " (<variable> <initializer> [<update>])\n (WITH <variable> <initializer> [<update>])\n (FOR <variable> ... (<iterator> <argument> ...))\n (LET <variable> <expression>)\n (WHILE <condition>)\n (UNTIL <condition>)") (p "A loop operates by stepping through each iterator in parallel until one of them runs out; that is, when one of its termination conditions holds.  When this happens, if the <final-expression> is supplied, it is evaluated in an environment with the final values of all the loop variables bound, as well as any final bindings supplied by the iterators.") (p "If <loop-name> is not supplied, the loop implicitly proceeds at the end of the loop body, which may be empty.  If <loop-name> is supplied, it is bound to a macro that the loop body must call to explicitly proceed the loop.  This macro may be called arbitrarily many times, in tail or non-tail positions; it is appropriate for recursive loops.  (Note, though, that some iterators are non-reentrant, which makes multiple calls unsafe.  These iterators are discouraged, however, and by convention are marked with a suffix of `!'; examples of non-reentrant iterators include LISTING! and LISTING-INTO!.)") (p "The macro <loop-name> accepts arguments by which to update the loop variables.  Arguments may be passed by position, or by name, or both. Positional arguments come first; they correspond with the first loop variables in the same positions specified in WITH clauses.  Arguments passed by name to update the named loop variables are written with the form (=> <variable> <update>).") (p "All arguments are optional; positional arguments supply values for the first arguments that are supplied.  All loop variables have default update values, if they are not explicitly updated when the macro <loop-name> is invokes: those created by (WITH <variable> <initializer> <update>) clauses are by default updated to the value of <update>, those created by (WITH <variable> <initializer>) remain the same at the next iteration, and those created by iterators are updated by means that the iterator supplies implicitly.") (pre " (loop continue ((with a 0)\n                 (with b '()\n                   ;; Default update for B:\n                   (cons a b))\n                 (for c d (in-list '(i j k p q r))))\n   (write (list a b c d))\n   (newline)\n   (continue (+ a 1)    ;First position, for the first (WITH A 0).\n             (=> d (cddr d))))   ;D is from (FOR C D (IN-LIST ...)).\n ;; Output:\n ;(0 () i (i j k p q r))\n ;(1 (0) k (k p q r))\n ;(2 (1 0) q (q r))") (p "In the loop, there are several classes of variable bindings that may arise:") (ul (li "/Loop variables/ are variables that are initialized at the beginning of the loop and updated at every iteration non- destructively -- that is, by rebinding through procedure call, not by assignment.  Loop variables are bound in the user termination conditions, the user variable expressions, the loop body, and the final expression.") (li "/Entry variables/ are variables whose values are computed when each iteration of the loop is entered, before the termination conditions have been tested.  They cannot be updated like loop variables; each is always initialized on loop entry to the value of the same expression.  This means that the expression need not be duplicated at the beginning of the loop and when the loop is continued.  Entry variables are bound in the user termination conditions, the user variable expressions, the loop body, and the final expression.") (li "/Body variables/ are variables whose values are computed at each iteration of the loop only if iteration has not been terminated from iterator termination conditions.  Body variables are bound in the user termination conditions, the user variable expressions, and the loop body.") (li "/User variables/ are variables whose values are computed after all iterator termination conditions have failed, and after the body variables have been bound, but before the user termination conditions have been tested.  User variables are introduced by LET and LET-VALUES clauses in LOOP.  User variables are bound only in the user termination conditions and the loop body.") (li "/Final variables/ are variables that are computed once at the end of the loop, once any termination condition has been met.  Final variables are bound only in the final expression.")) (p "The loop iteration is controlled by the loop clauses:") (pre " (WITH <variable> <initializer> [<update>])") (p "Introduces a loop variable named <variable>, initialized to the value of <initializer>.  On each iteration of the loop, the variable may be explicitly updated; if it is not explicitly updated, but there was an <update> expression supplied, then the variable is updated to the value of that expression in an environment where all the loop variables, entry variables, body variables, and user variables are bound; otherwise, <variable> remains unchanged at the next iteration of the loop.") (pre " (<variable> <initializer> [<update>])") (p "Identical to (WITH <variable> <initializer> [<update>]).  This alternative form is provided so that the LOOP syntax is compatible with named LET, and very similar to DO.  For instance,") (pre "     (let next ((x 0))\n       (if (< x 10)\n           (begin (write x) (next (+ x 1))))),\n\n     (loop next ((x 0))\n       (if (< x 10)\n           (begin (write x) (next (+ x 1))))),\n\n     (do ((x 0 (+ x 1)))\n         ((>= x 10))\n       (write x)), and\n\n     (loop ((x 0 (+ x 1))\n            (until (>= x 10)))\n       (write x))") (pre "   are all equivalent.") (pre "   The WITH syntax is preferred; it has greater visual distinction,\n   and it it is easier for pretty-printers to indent better with less\n   effort.") (pre " (FOR <variable> ... (<iterator> <argument> ...))") (p "General iteration form.  Although <iterator> can do anything with the <variable>s and <argument>s, by covention the <variable>s are variables to be bound in the loop body or the final expression, and the <argument>s are expressions or directives controlling the iteration.") (p "No guarantees are made preserving the ordering of the FOR clauses; it is an error to rely on any properties of the ordering.") (pre " (LET <variable> <expression>)\n (LET-VALUES <bvl> <expression>)") (p "These introduce user variable bindings.  LET binds <variable> to the single value of <expression> inside the body bindings and before the user termination conditions and loop body.  LET-VALUES binds all the variables in the bound variable list <bvl> to the respective values in the multiple values returned by <expression>. (LET <variable> <expression>) is equivalent to the clause (LET-VALUES (<variable>) <expression>).") (pre " (WHILE <condition>)\n (UNTIL <condition>)") (p "User-supplied termination conditions.  The termination conditions are evaluated in an environment where all of the loop variables, entry variables, body variables, and user variables are bound.  All of the iterator-supplied termination conditions are guaranteed to have failed.") (section 3 "Lazy Loops" (p "(LAZY-LOOP <loop-name> (<loop-clause> ...)") (pre " => <final-expression>\n <body>)") (p "Lazily evaluated variant of LOOP, dependent upon SRFI 45 (Primitives for Expressing Iterative Lazy Algoritms).  This is equivalent to a LOOP form wrapped in a LAZY form with all calls to the <loop-name> also wrapped in LAZY forms.  (See the SRFI 45 for details on LAZY.) The loop's body and final expression both must yield promises in the sense of DELAY or LAZY.") (pre "   ;;; Assume SRFI-40-style streams (see SRFI 40, A Library of\n   ;;; Streams, for details, particularly on even versus odd streams).\n   ;;; Also assume an IN-STREAM iterator.\n\n   (define (stream-filter predicate stream)\n     (lazy-loop filter ((for element (in-stream stream)))\n       => stream-nil\n       (if (predicate element)\n           (stream-cons element (filter))\n           (filter))))\n\n   ;;; The above definition of STREAM-FILTER is equivalent to the\n   ;;; following:\n\n   (define (stream-filter predicate stream)\n     (lazy\n      (loop filter ((for element (in-stream stream)))\n        => stream-nil\n        (if (predicate element)\n            (stream-cons element (lazy (filter)))\n            (lazy (filter))))))") (p "The laziness annotations are added around the whole loop and calls to the loop, rather than the loop body, in order to delay any outer bindings of the loop (for example, all expressions supplied as arguments to loop iterators) and any loop variable updates when recursively invoking the loop.")) (section 3 "Loop Expansion" (p "When a LOOP form is fully processed and expanded, the result resembles this:") (pre " (LET-VALUES ((<outer-bvl> <outer-producer>)\n              ...)\n   (DEFINE (LOOP-PROCEDURE <loop-variable> ...)\n     (LET-VALUES ((<entry-bvl> <entry-producer>)\n                  ...)\n       (LET ((FINISH (LAMBDA ()\n                       (LET-VALUES ((<final-bvl> <final-producer>))\n                         <final-expression>))))\n         (IF (OR <termination-condition> ...)\n             (FINISH)\n             (LET-VALUES ((<body-bvl> <body-producer>)\n                          ...)\n               (LET-VALUES ((<user-bvl> <user-producer>)\n                            ...)\n                 (IF (OR <user-termination-condition> ...)\n                     (FINISH)\n                     <loop-body>)))))))\n   (LOOP-PRODEDURE <loop-initializer> ...))") (p "Each <*-bvl> is a bound variable list supplied by an iterator or by the user.  Each <*-producer> is an expression yielding multiple values to be distributed to the corresponding bound variable list.  The <user-bvl>s are from user-supplied LET and LET-VALUES clauses in loops; the <user-termination-conditions> are from user-supplied WHILE and UNTIL clauses in loops.") (p "LOOP-PROCEDURE is a name invisible to all of the forms involved in the loop except for the macro to which the loop's name is bound in the loop body.  This macro processes its positional and named arguments to form a call to LOOP-PROCEDURE by supplying default update expressions according to WITH clauses or what the iterators provide.")) (section 3 "Efficiency Concerns" (p "One of the primary goals of LOOP is to generate efficient code.  It should be possible to write floating-point matrix multiplication routines as fast with LOOP as by hand, and perhaps faster because the details of the matrix operations can be swept under the rug of a matrix iterator.  There may be some questions, however, of the efficiency of the code that LOOP generates.") (section 4 "Use of Assignment" (p "Many other loop macros, such as Common Lisp LOOP, SRFI 42 Eager Comprehensions, and others, update loop variables by assignment, rather than rebinding.  Even hand-written loops using named LET or DO are written with assignment, because it is more convenient with large numbers of loop variables which would otherwise have to be enumerated repeatedly for every recursive call to the loop procedure.") (p "This is a death-knell for efficient code, especially in many highly optimizing Scheme compilers, because most Scheme compilers generate heap-allocated cells to store mutable variables.  Compilers' lives are simplified by assuming that all variables are immutable; they are free to move references to the variables about as they please.  The analysis necessary to transform a program with SET! into a program without SET! but with explicit, heap-allocated cells is trivial, and allows compilers to make the assumption that variables are immutable; subsequently eliding those cells anywhere but in closure references is considerably harder, and not worth the effort for idiomatic Scheme code.") (p "It may be the case that a pure tree interpreter can execute assignment- ridden code more efficiently than procedure calls with large numbers of arguments, because of the overhead of recursively processing each of those arguments.  It is also the case that tree interpreters are slow anyway.") (p "Using assignment to update loop variables is a losing proposition in the end.  LOOP never introduces assignments to mutable variables; all loop variables are updated by recursive procedure call, i.e. rebinding. Custom iterators are discouraged from doing this as well, although nothing prevents it.")) (section 4 "Local Closure for FINISH" (p "Because the construction of a closure for FINISH is costly in many Scheme implementations which have extremely naive compilers, the current implementation of LOOP creates the closure only if necessary to preserve scoping; it will integrate the body of FINISH if and only if there are no user termination conditions, or there are no iterator- supplied termination conditions, iterator-supplied body bindings, and user-supplied bindings around the body.") (p "However, programmers who are worried about the closure for FINISH would most likely be better served by a Scheme implementation that goes to the slighest effort necessary to recognize the local closure and fold the unconditional jumps into the code for the conditional.")) (section 4 "Multiple Return Values" (p "Opponents of multiple return values may object to the pervasion of LET-VALUES throughout the expansion and the inefficiency thereof in Scheme implementations that do not subscribe earnestly to the doctrine of multiple return values.  LET-VALUES is the only way to allow iterators to bind multiple variables that may have complex inter- dependencies without the indirection and cost of intermediate data structures.") (p "There is no cost on Scheme systems with efficient support for multiple return values.  There will be a cost in Scheme systems with costly multiple return values, whether LOOP uses multiple return values, and incurs the cost implicitly, or whether LOOP generates code to construct intermediate data structures.  But on Scheme systems with efficient multiple return value support, LOOP incurs no cost.  Essentially, by using multiple return values, LOOP defers the question of the cost to the Scheme implementation, rather than incurring cost *wherever* it is used by generating code that *always* constructs intermediate data structures.") (p "Furthermore, for most cases, there is only a single return value anyway.  LET-VALUES itself need not incur whatever overhead of multiple return values there is simply by recognizing single-value cases. Unfortunately, the reference implementation of SRFI 11 does not do this, and will generate CALL-WITH-VALUES invocations for every binding clause in the LET-VALUES.  Here is an implementation that avoids this:") (pre " [[http://mumble.net/~campbell/scheme/let-values.scm]]")) (section 4 "Index Variables and Generic Arithmetic" (p "Many Scheme implementations provide specialized arithmetic for limited integers fixed to a width that fits inside machine registers; using this arithmetic is much faster than generic arithmetic, where safety and overflow are not issues.  These limited integers, often called `fixnums', are typically guaranteed to be the domain of vector indices.") (p "LOOP generates generic arithmetic for index variables, in iterators such as UP-FROM and IN-VECTOR.  There are a number of reasons for this:") (ol (li "There is no portable specialized arithmetic for LOOP to use.") (li "LOOP is not meant only for code inside inner loops that must be as fast as possible; programs written with LOOP should not fail obscurely because they passed some iterator a non-fixnum value where a fixnum was expected.") (li "The set of built-in iterators would be complicated by support for fixnum arithmetic.  Do we add, for example, UP-FROM-FIXNUM, UP-FROM-UNSIGNED-FIXNUM, and so on?  Do we have IN-VECTOR, IN-VECTOR/UNSAFE, and so on?") (li "Programs that use fixnum arithmetic are harder to understand, because with fixnum arithmetic comes a plethora of subtle implications on the program.  For example, the usual formula for finding the average of two integers -- (QUOTIENT (+ A B) 2) -- is no longer valid under fixnum arithmetic, because the sum may overflow the bounds of fixnums.  A program that once used Scheme vectors but has been converted to use sparse vectors, which allow arbitrary integer indices, may no longer be able to use fixnum arithmetic.")) (p "It is up to the compiler to specialize the generic arithmetic where appropriate, such as the indices inside IN-VECTOR, and to insert pre- loop type and range checks where appropriate.  Programmers who use compilers incapable of this should consider finding better compilers, or improving the ones they use.") (p "Common Lisp, by comparison, has no specialized arithmetic either; rather, it has programmer-supplied declarations regarding the types of variables' values.  This is even more specific than specialized arithmetic, and does not require the introduction of N new arithmetic routines for every kind of specialized arithmetic, so it composes with macros well.  This would be a better way to go about improving the efficiency of arithmetic, and it would require minimal changes to LOOP -- at most, support for iterators to supply declarations in the loop.")))) (section 2 "Built-in Iterators" (section 3 "Iterating across Lists" (pre " (FOR <element> [<pair>] (IN-LIST <list> [<successor>]))") (p "Iterates for each successive pair in <list>, binding the variable <pair>, if supplied, to that pair, and the variable <element> to the car of that pair.  The successor of the pair is taken by applying <successor> to the current pair.  The iteration runs out when the successor is no longer a pair.") (p "<Successor>, if supplied, must be a unary procedure.  The default value of <successor> is CDR.  <List> and <successor> are evaluated once before the loop begins.") (p "<Pair> is a loop variable; its value in the final expression is unspecified.") (p "<Element> is a body variable.") (p "The next pair is taken before the loop body, so the loop body may reliably apply SET-CDR!, or its equivalent for the given successor procedure, to the pair, without altering the iteration.  Note, though, that <successor> will be called irrespective of whether <pair> is updated explicitly.") (pre "   (loop ((for a (in-list '(a b c)))\n          (for b (in-list '(p q r))))\n     (write (list a b))\n     (newline))\n   ;; Output:\n   ;(a p)\n   ;(b q)\n   ;(c r)\n\n   (loop ((for x (in-list '(1 2 3)))\n          (with y 0 (+ y (* x 2))))\n     => y)\n   ;Value: 12") (pre "   ;;; PAIR-FOLD from SRFI 1.") (pre "   (define (pair-fold kons knil list)\n     (loop ((for elt pair (in-list list))\n            (with knil knil (kons pair knil)))\n       => knil))") (hr) (pre " (FOR <elements> [<pairs>] (IN-LISTS <lists> [<tail>]))") (p "Iterates for each successive pair in each parallel element of <lists>, binding the variable <pairs>, if supplied, to be a list of those pairs, and the variable <elements> to a list of the cars of those pairs, prepended to the value of <tail> evaluated at each iteration. If no <tail> is supplied, its default value is the empty list.  The successor of each pair is taken by CDR.  The iteration runs out when any successor is no longer a pair.") (p "<Lists> must be a non-empty list; it is an error if otherwise.  It is evaluated once before the loop begins.") (p "<Pairs> is a loop variable; its value in the final expression is unspecified.") (p "<Elements> is a body variable.") (p "The cdrs are taken before the loop body, so the loop body may reliably apply SET-CDR! to any of the pairs without altering the iteration.") (pre "   ;;; Transpose a matrix represented as a nested list.") (pre "   (loop ((for columns (in-lists '((a b c) (d e f))))\n          (with rows '() (cons columns rows)))\n     => rows)\n   ;Value: ((c f) (b e) (a d))\n\n   (define (every? predicate list . lists)\n     (loop proceed ((for elts (in-lists (cons list lists))))\n       (and (apply predicate elts)\n            (proceed))))\n\n   (define (any predicate list . lists)\n     (loop proceed ((for elts (in-lists (cons list lists))))\n       (or (apply predicate elts)\n           (proceed))))") (pre "   ;;; SRFI 1's signature for FOLD.  Notice that KNIL is the *last*\n   ;;; argument to the FOLD procedure, so we have to tack it on to the\n   ;;; end of the argument list.") (pre "   (define (fold kons knil list . lists)\n     (loop ((with knil knil (apply kons arguments))\n            (for arguments \n                 (in-lists (cons list lists)\n                           (cons knil '()))))\n       => knil))")) (section 3 "Iterating across Vectors and Strings" (pre " (FOR <element> [<index>] (IN-VECTOR         <vector> [<low> [<high>]]))\n (FOR <element> [<index>] (IN-STRING         <string> [<low> [<high>]]))\n (FOR <element> [<index>] (IN-VECTOR-REVERSE <vector> [<high> [<low>]]))\n (FOR <element> [<index>] (IN-STRING-REVERSE <string> [<high> [<low>]]))") (p "These iterate for each successive index in the vector or string, respectively, binding the variable <index>, if supplied, to that index, and the variable <element> to the element at that index.") (p "IN-VECTOR and IN-STRING run from <low>, inclusive, to <high>, exclusive; IN-VECTOR-REVERSE and IN-STRING-REVERSE run from <high>, exclusive, to <low>, inclusive.") (p "<Vector> or <string> must be a vector or a string, respectively. <Low> and <high>, if supplied, must be exact, non-negative integers, and valid bounds for <string> or <vector>.  The default values of <low> and <high> are 0 and the length of the vector or string, respectively.  <Vector>, <string>, <low>, and <high> are all evaluated once before the loop begins.") (p "<Index> is a loop variable; its value in the final expression is the value of the last bound of iteration (the value of <high> for IN-VECTOR and IN-STRING; the value of <low> for IN-VECTOR-REVERSE and IN-STRING-REVERSE).  With the reverse iterators, IN-VECTOR-REVERSE and IN-STRING-REVERSE, explicitly updating <index> when continuing the loop will cause the next value seen by the loop body to be one *less* than what the index was updated to.  That is, on loop entry, <index> is assumed to be an exclusive upper bound, and so it is tested for termination and then decremented to find the actual index.") (p "<Element> is a body variable.") (p "Because the lower bound is inclusive and the upper bound is exclusive, for IN-VECTOR and IN-STRING, the first value of <index> is <low>, and the value of <index> in the final expression is <high>; while for IN-VECTOR-REVERSE and IN-STRING-REVERSE, the first value of <index> in the loop body is one less than <high>, and the value of <index> in the final expression is <low>.") (pre "   (loop ((for a i (in-vector '#(foo bar baz)))\n          (for b j (in-string-reverse \"abcdefghi\" 6 3)))\n     => (list i j)\n     (write (list a i b j))\n     (newline))\n   ;Value: (3 3)") (pre "   ;; Output:\n   ;(foo 0 f 5)\n   ;(bar 1 e 4)\n   ;(baz 2 d 3)") (pre "   ;;; Find the first index of an element satisfying a predicate.") (pre "   (define (vector-index vector predicate)\n     (loop proceed ((for elt index (in-vector vector)))\n       (if (predicate elt)\n           index\n           (proceed))))") (pre "   ;;; Copy characters from one string to another.") (pre "   (define (string-copy! target tstart source sstart send)\n     (loop ((for char (in-string source sstart send))\n            (with index tstart (+ index 1)))\n       (string-set! target index char)))\n\n   (loop proceed \n       ((for v i\n          (in-vector\n           '#(a b c d e f g h i j k l m n o p q r s t u v w x y z))))\n     (write (list v i))\n     (newline)\n     (proceed (=> i (+ 1 (* i 2)))))\n   ;; Output:\n   ;(a 0)\n   ;(b 1)\n   ;(d 3)\n   ;(h 7)\n   ;(p 15)")) (section 3 "Iterating through Input" (pre " (FOR <datum> (IN-PORT <input-port> [<reader> [<eof?>]]))") (p "Iterates for successive data read from <input-port>, binding the variable <datum> to the datum read by applying the value of <reader>. Iteration terminates when the datum read satisfies the predicate <eof?>.") (p "<Input-port> must be an input port.  <Reader> and <eof?>, if supplied, must be unary procedures.  The default value of <reader> is READ-CHAR, and the default value of <eof?> is EOF-OBJECT?. <Input-port>, <reader>, and <eof?> are all evaluated once before the loop begins.") (pre " <Datum> is an entry variable.") (pre "   (define (read-line input-port)\n     (let ((initial (peek-char input-port)))\n       (if (eof-object? initial)\n           initial\n           (loop ((for char (in-port input-port))\n                  (until (char=? char #\\newline))\n                  (with chars '() (cons char chars)))\n             => (list->string (reverse chars))))))\n\n   (define (read-all input-port)\n     (loop ((for datum (in-port input-port read))\n            (with data '() (cons datum data)))\n       => (reverse data)))") (hr) (pre " (FOR <datum> (IN-FILE <pathname> [<reader> [<eof?>]]))") (p "Opens an input port from the file named by <pathname>, iterates as with IN-PORT from the newly opened input port, and closes the input port after iteration terminates.") (pre " <Datum> is an entry variable.") (pre "   (define (read-lines-from-file pathname)\n     (loop ((for line (in-file pathname read-line))\n            (with lines '() (cons line lines)))\n       => (reverse lines)))\n\n   (define (file-length pathname)\n     (loop ((for char (in-file pathname))\n            (with count 0 (+ count 1)))\n       => count))")) (section 3 "Iterating over Numbers" (pre " (FOR <number> (UP-FROM   <low>  [(TO <high>)] [(BY <step>)]))\n (FOR <number> (DOWN-FROM <high> [(TO <low>)]  [(BY <step>)]))") (p "Iterates for each successive number starting at <low> and incrementing by <step> at every iteration, for UP-FROM; or starting at <high> and decrementing by <step> at every iteration, for DOWN-FROM.  <Number> is bound to the current number.  If the TO parameter is supplied, iteration terminates when the number exceeds the given bound.") (p "<Low>, <high>, and <step> must all be exact numbers.   If a TO parameter is supplied, they must furthermore all be real numbers. They are all evaluated once before the loop begins.") (p "<Number> is a loop variable, *and*, in DOWN-FROM, an entry variable. If it is updated explicitly, its value at the next iteration in the loop's body will be one <step> *less* than what it was updated to explicitly.  Because of this, although it is initialized to <high>, it will never have a value of <high> (unless it is explicitly updated to the value of (+ <high> <step>)).") (pre "   (define (iota count start step)\n     (loop ((for n (up-from 0 (to count)))\n            (for result (listing (+ start (* n step)))))\n       => result))") (pre "   ;;; Note that the following is incorrect, if the arguments to IOTA\n   ;;; may be inexact numbers:") (pre "   (define (iota count start step)\n     (loop ((for n (up-from start\n                            (to (+ start (* count step)))\n                            (by step)))\n            (for result (listing n)))\n       => result))\n\n   (define (sieve n)\n     (let ((table (make-bit-string (- n 2) #t)))\n       (define (prime? k) (bit-string-ref table (- k 2)))\n       (define (not-prime! k) (bit-string-clear! table (- k 2)))\n       (define (purge-multiples i)\n         (loop ((for j (up-from (* i i)\n                                (to n)\n                                (by i))))\n           (not-prime! j)))\n       (loop proceed ((for i (up-from 2 (to n)))\n                      (with primes '()))\n         => (reverse primes)\n         (if (prime? i)\n             (begin (purge-multiples i)\n                    (proceed (=> primes (cons i primes))))\n             (proceed)))))\n\n   (define (vector-quick-sort! elt< vector start end)\n     (loop sort ((start start) (end end))\n       (if (< 1 (- end start))\n           (let ((pivot (select-pivot vector start end)))\n             (loop continue ((i start) (j end))\n               (let ((i (loop scan ((for i (up-from i)))\n                          (if (elt< (vector-ref vector i) pivot)\n                              (scan)\n                              i)))\n                     (j (loop scan ((for j (down-from j)))\n                          (if (elt< pivot (vector-ref vector j))\n                              (scan)\n                              j))))\n                 (if (< i j)\n                     (begin (vector-exchange! vector i j)\n                            (continue (+ i 1) j))\n                     (begin (sort (=> end i))\n                            (sort (=> start (+ j 1)))))))))))")) (section 3 "Accumulating" (p "Accumulating iterators all follow the same basic forms: accumulate each value of an expression into a result, with an optional condition for the accumulation.  Accumulators differ according to the way that they accumulate, whether the intermediate result of accumulation is available in the body of the loop or whether only the fully accumulated result is available in the final expression, and whether the accumulator accepts an optional initial value argument.") (p "The syntax of accumulators is as follows:") (ul (li "Unconditional:")) (pre "   (FOR <result> (<accumulating> <datum>))") (p "<Datum> is evaluated at each iteration in an environment with all loop, entry, and body variables bound from the current iteration.") (ul (li "Conditional -- evaluate and accumulate <datum> if and only if <condition> is not false:")) (pre "   (FOR <result> (<accumulating> <datum> (IF <condition>)))") (p "<Datum> and <condition> are evaluated at each iteration in an environment with all loop, entry, and body variables bound from the current iteration.") (ul (li "Conditional -- if <condition> is not false, apply the value of <mapper> to the value of <condition> to yield the value to accumulate:")) (pre "   (FOR <result> (<accumulating> <condition> => <mapper>))") (p "<Condition> and <mapper> are evaluated at each iteration in an environment with all loop, entry, and body variables bound from the current iteration.  <Mapper> is evaluated only if <condition> is not false.") (ul (li "Generalized conditional, as in SRFI 61-style `=>' clauses in COND -- evaluate <generator>, and if <tester> applied to all the values returned by <generator> returns true, accumulate the value returned by <mapper> when applied to all the values returned by <generator>:")) (pre "   (FOR <result> (<accumulating> <generator> <tester> => <mapper>))") (p "<Generator>, <tester>, and <mapper> are evaluated at each iteration in an environment with all loop, entry, and body variables bound from the current iteration.  <Mapper> is evaluated only if <test> yields true.") (p "Some accumulators also have initial values, supplied with an optional (INITIAL <initial-value>) form before any of the other arguments to the accumulator.") (p "Accumulators that are allowed to operate by destructively modifying internal state are marked with `!' suffixes.  These accumulators are /non-reentrant/, which means that it is unsafe to write loops that may be recursively run more than once, and that non-local re-entry may destroy values returned from the loop.") (section 4 "Accumulating Lists" (pre " (FOR <result> (LISTING [(INITIAL <tail>)] ...))\n (FOR <result> (LISTING-REVERSE [(INITIAL <tail>)] ...))") (p "These each produce lists of the accumulated data with a final cdr of <tail>.  LISTING yields a list in the order that the data were produced; LISTING-REVERSE yields a list in the reverse order of that.") (p "<Tail>, if supplied, is evaluated once before the beginning of the loop.  The default value of <tail> is the empty list.") (p "For LISTING, <result> is a final variable.") (p "For LISTING-REVERSE, <result> is a loop variable; its value in the final expression is the accumulated list in reverse.") (pre "   (define (list-tabulate length procedure)\n     (loop ((for i (up-from 0 (to length)))\n            (for list (listing (procedure i))))\n       => list))\n\n   (define (take list count)\n     (loop ((for i (up-from 0 (to count)))\n            (for elt (in-list list))\n            (for prefix (listing elt)))\n       => prefix))\n\n   (define (append-reverse list tail)\n     (loop ((for elt (in-list list))\n            (for result (listing-reverse (initial tail) list)))\n       => result))\n\n   (define (unzip5 list)\n     (loop ((for component (in-list list))\n            (for result1 (listing (first component)))\n            (for result2 (listing (second component)))\n            (for result3 (listing (third component)))\n            (for result4 (listing (fourth component)))\n            (for result5 (listing (fifth component))))\n       => (values result1 result2 result3 result4 result5)))") (hr) (pre " (FOR <result> (APPENDING [(INITIAL <tail>)] ...))\n (FOR <result> (APPENDING-REVERSE [(INITIAL <tail>)] ...))") (p "These append the accumulated data into a list with a final cdr of <tail>.  APPENDING maintains the order of the lists and their elements; APPENDING-REVERSE reverses the elements of the lists.  The accumulated data must all be proper lists.") (p "<Tail>, if supplied, is evaluated once in the environment outside the loop.  The default value of <tail> is the empty list.") (p "For APPENDING, <result> is a final variable.") (p "For APPENDING-REVERSE, <result> is a loop variable; its value in the final expression is the reverse-concatenated list.") (pre "   (define (concatenate lists)\n     (loop ((for list (in-list lists))\n            (for result (appending list)))\n       => list))") (hr) (pre " (FOR <result> (LISTING! [(INITIAL <tail>)] ...))\n (FOR <result> (LISTING-INTO! <pair> [(INITIAL <tail>)] ...))") (p "LISTING! builds up a list with a final cdr of <tail>.  LISTING-INTO! builds up a list with a final cdr of <tail> and destructively stores it in the cdr of <pair>.  Both use as little intermediate storage as possible, which may involve using destructive operations, and as a consequence are non-reentrant.") (p "<Tail>, if supplied, is evaluated once in the environment outside the loop.  The default value of <tail> is the empty list.") (p "<Result> is a final variable.")) (section 4 "Accumulating Numerical Results" (pre " (FOR <result> (SUMMING [(INITIAL <initial-sum>)] ...))\n (FOR <result> (MULTIPLYING [(INITIAL <initial-product>)] ...))") (p "Accumulates sums or products by adding the accumulated data to <initial-sum>, or multiplying the accumulated data by <initial-product>.") (p "<Initial-sum> and <initial-product>, if supplied, must be numbers, and are evaluated once before the loop begins.  The default value of <initial-sum> is 0, and the default value of <initial-product> is 1.") (pre " <Result> is a loop variable.") (pre "   (define (count predicate list)\n     (loop ((for elt (in-list list))\n            (for count (summing 1 (if (predicate elt)))))\n       => count))") (hr) (pre " (FOR <result> (MINIMIZING [(INITIAL <initial-minimum>)] ...))\n (FOR <result> (MAXIMIZING [(INITIAL <initial-maximum>)] ...))") (p "Finds the minimum or maximum datum accumulated.  If an initial value expression is provided, it is evaluated once before the beginning of the loop, all of the data involved must be real numbers, and <result> will be a real number.  If no initial value is provided, the data must be either real numbers or false, and <result> will be either a real number or false.") (p "<Result> is a loop variable.")))) (section 2 "Writing Custom Iterators" (p "(NOTE:  This section documents the implementation of iterators for Taylor R. Campbell's current version of foof-loop.  It does *not* document the version originally written by Alex Shinn (after whose nickname, `foof', the system is named), which has a somewhat less flexible interface for custom iterators.)") (p "One of the main goals of foof-loop is extensibility.  To accomplish this goal, writing custom iterators is a simple matter of specifying the syntax of the iterator, all of the loop variables and other variables bound by the loop, and the loop's termination conditions.  In order to implement foof-loop in portable SYNTAX-RULES, iterators are macros in continuation-passing style.") (p "When LOOP encounters a clause of the form") (pre " (FOR <variable> ... (<iterator> . <arguments>)),") (p "it invokes <iterator> as (<iterator> (<variable> ...) <arguments> <continuation> . <environment>), where the environment is simply information that LOOP needs in order to continue processing the other loop clauses, and where the continuation is a macro that returns control back to LOOP given a description of all the variables bound by and termination conditions tested for the iterator at hand.") (p "The continuation should be invoked as follows:") (pre " (continuation\n  ((<outer-bvl> <outer-producer>) ...)\n  ;; Outer variables to be bound once outside the whole loop.\n  ;; Each <outer-producer> is evaluated once in the enclosing\n  ;; environment of the LOOP form.\n\n  ((<loop-variable> <initializer> <update>) ...)\n  ;; Loop variables.  Each <initializer> is evaluated in an\n  ;; environment where the outer variables are bound.  Each <update>\n  ;; is evaluated in an environment where the outer variables, loop\n  ;; variables, entry variables, and body variables are all bound.\n\n  ((<entry-bvl> <entry-producer>) ...)\n  ;; Entry variables, to be bound each time the loop is entered.\n  ;; Each <entry-producer> is evaluated in an environment where the\n  ;; outer variables and loop variables are bound.\n\n  (<termination-condition> ...)\n  ;; Conditions that will terminate the loop.  These are all evaluated\n  ;; in an environment where the outer variables, loop variables, and\n  ;; entry variables are bound.  The first condition, of any loop\n  ;; clause, that holds true will terminate the iteration, short-\n  ;; circuiting the rest of the termination conditions.\n\n  ((<body-bvl> <body-producer>) ...)\n  ;; Variables to be bound around the body of the loop, if the loop\n  ;; does not terminate.\n\n  ((<final-bvl> <final-producer>) ...)\n  ;; Variables to be bound around the final expression of the loop, if\n  ;; the loop does terminate.\n\n  . environment).") (p "The <*-bvl>s are bound variable lists, and the variables in them are bound to the respective values of the corresponding <*-producer> expressions, as with LET-VALUES.  The bindings are made in parallel, also as with LET-VALUES.  To make interdependent bindings, use multiple return values in a single binding clause.") (p "The ordering of the arguments to the continuation is intended to reflect the ordering of control through the loop: first the outer bindings are made, then the loop variables are initialized, then the entry bindings are made, then the termination conditions are tested, and finally either the body bindings or the final bindings are made, depending on the termination conditions.") (p "For example, here is a simplified definition of IN-LIST, omitting support for a user-supplied loop variable, a user-supplied list successor procedure, and the guarantee that SET-CDR! may be safely applied to the pair without altering the iteration.  (For the sake of concision, we use the name `next' for the continuation and `rest' for the environment.)  In this simplified IN-LIST, we expect one variable in FOR and one argument after IN-LIST -- i.e., (FOR <element-variable> (IN-LIST <list-expression>)) --; hence, the initial two arguments to the actual macro are `(element-variable)' and `(list-expression)'.") (pre " (define-syntax in-list\n   (syntax-rules ()\n     ((IN-LIST (element-variable) (list-expression) next . rest)\n      (next (((LIST) list-expression))      ;Outer bindings\n            ((PAIR LIST (CDR PAIR)))        ;Loop variables\n            ()                              ;Entry bindings\n            ((NOT (PAIR? PAIR)))            ;Termination conditions\n            (((element-variable)            ;Body bindings\n              (CAR PAIR)))\n            ()                              ;Final bindings\n            . rest))))") (section 3 "Reporting Syntax Errors" (p "The above definition of IN-LIST will work, but, if used incorrectly, it would yield a strange, incomprehensible syntax error to the casual user of foof-loop, involving a great deal of state internal to the LOOP macro.  This is not what users like to see; rather, users like to see useful, comprehensible error messages that are directly related to what they wrote.  Therefore, foof-loop provides two conveniences for reporting syntax errors: SYNTACTIC-ERROR and LOOP-CLAUSE-ERROR.  The former is a more general way to report errors in macros:") (pre " (SYNTACTIC-ERROR <message> <form> ...)") (p "will cause an error to be reported when this form is expanded, ideally involving the given message and subforms.  Many loop iterators are implemented in terms of internal utilities handling the general patterns of several specialized cases, such as IN-VECTOR and IN-STRING, which generate very similar code.  In order to report specific syntax errors that correspond with what was actually the input to the LOOP macro, these iterators pass error context descriptors to one another. Error context is of the form") (pre " (<name> (<variable> ...) <arguments> <message>),") (p "where <name> is the name of the iterator, the <variable>s are the forms passed in the FOR clause before the iterator, <arguments> is the tail of the iterator subform inside the FOR clause, and <message> is a message explaining the error (which cannot be constructed from <name> due to liminations in SYNTAX-RULES).  The macro LOOP-CLAUSE-ERROR invokes SYNTACTIC-ERROR with a FOR form that corresponds with the original FOR form seen by LOOP.  That is,") (pre " (LOOP-CLAUSE-ERROR (<name> (<variable> ...) <arguments> <message>))") (p "expands to") (pre " (SYNTACTIC-ERROR <message>\n                  (FOR <variable> ...\n                       (<name> . <arguments>))).") (p "Using LOOP-CLAUSE-ERROR for more robust syntax error notification, we can write the simplified IN-LIST by adding a fall-through syntax rule that matches any possible invocation of the iterator from LOOP:") (pre " (define-syntax in-list\n   (syntax-rules ()\n     ((IN-LIST (element-variable) (list-expression) next . rest)\n      (next (((LIST) list-expression))      ;Outer bindings\n            ((PAIR LIST (CDR PAIR)))        ;Loop variables\n            ()                              ;Entry bindings\n            ((NOT (PAIR? PAIR)))            ;Termination conditions\n            (((element-variable)            ;Body bindings\n              (CAR PAIR)))\n            ()                              ;Final bindings\n            . rest))\n\n     ((IN-LIST variables arguments next . rest)\n      ;; Ignore NEXT and REST; we only report the syntax error.\n      (LOOP-CLAUSE-ERROR \n       (IN-LIST variables arguments\n                \"Malformed IN-LIST form in LOOP:\")))))") (p "With the appropriate definition of SYNTACTIC-ERROR shown below, if we misuse IN-LIST, we get a helpful error message in most Schemes, along these lines:") (pre " (loop ((for x y z (in-list)))\n   (body x y z))") (pre " Syntax error: Malformed IN-LIST clause in LOOP:\n               (for x y z (in-list))") (section 4 "Pitfalls of Reporting Syntax Errors" (p "It is important to remember the principle behind passing error context to any macros in terms of which iterators are implemented: to present coherent syntax errors reporting the original iterator form.  In an ideal world, this would always be easy, but because we are limited to te tools of SYNTAX-RULES and SYNTAX-RULES alone, this is not as easy as we should like.  There are cases where it is convenient, for example, to supply default values for optional parameters by recursively calling the iterator macro.  This means, though, that if there is a syntax error for some other reason -- for example, if some of the arguments are named, or there are optional variables *and* optional arguments --, which goes undetected until some default values have been supplied, the wrong form will be reported to the user.") (p "To avoid this, it is better to rewrite iterators into invocations of internal macros that take error context as an extra parameter.  This precludes writing one iterator in terms of another one, however, which is an unfortunate consequence of the way that foof-loop is designed, which is itself an unfortunate consequence of the tools available.  We should like to be able to have a macro debugger that can examine the expansion history of the forms leading up to a syntax error, but this is not a reliably portable concept; few Schemes even record the expansion history (only one that I know of, MIT Scheme).") (p "Unfortunately, at the moment, foof-loop does not provide facilities for anything more than reporting syntax errors based on SYNTAX-RULES patterns alone.  For example, there is no way to verify that a variable to be bound is, in fact, a variable; if the user writes anything other than a variable, there will probably be a very strange error much later on involving invalid definitions with strange lambda lists.  It is not difficult to conceive of the interface to such checks; however, they are considerably more trouble to implement than they would be worth in program development at the moment.")))) (section 2 "Porting to New Schemes" (p "The implementation of foof-loop is divided into three files, one of which is optional but useful:") (ul (li "foof-loop.scm implements the main LOOP macro and the built-in iterators.") (li "syn-param.scm implements a general macro for producing local macros that accept named parameters with the form `(=> <name> <value>)'.") (li "let-values.scm is optional, but implements a portable LET-VALUES form (see SRFI 11) that gracefully handles single-value cases in order to avoid superfluous uses of CALL-WITH-VALUES.  This definition of LET-VALUES is more likely to work in Scheme systems that have incorrect implementations of multiple return values, such as MIT Scheme, although problems may still arise with (VALUES X), for example.")) (p "Ideally, these files should be loaded into their own modules, or a single module for foof-loop, if your Scheme system supports a module system or any form of namespace separation.  If this is not the case, you may wish to prefix some of the identifiers in the files that name internal operations in order to avoid namespace clashes.") (p "The implementation of foof-loop is strictly limited to R5RS Scheme except for one element, which is a utility to signal syntax errors during macro expansion.  (SYNTACTIC-ERROR message irritants ...) is a *macro* that should signal an error, ideally involving the message and irritants supplied.  A legal, though not ideal, definition with R5RS is:") (pre " (define-syntax syntactic-error (syntax-rules ()))") (p "Here is a better definition, for Scheme48, if we open the SIGNALS and NODES structures in the for-syntax environment (but note that this is a sequence of interactive commands, hence the prompt, and *not* code to store in a file to load):") (pre " > ,for-syntax ,open signals nodes\n > (define-syntax syntactic-error\n     (lambda (form rename compare)\n       (apply syntax-error (map schemify (cdr form))))\n     ())       ;No auxiliary names") (p "Note that if your Scheme does not support SYNTAX-RULES, it is not R5RS- compliant, and it cannot load foof-loop.  Also note that foof-loop uses some very complicated patterns of SYNTAX-RULES, so expansion of LOOP forms may be slow and taxing on your Scheme system's resources. Unfortunately, there is no other way to do this portably.  Finally, note that Scheme systems that preserve the case of symbols in source code are not R5RS-compliant and cannot load foof-loop.  If your Scheme system by default preserves case, but has an option for folding case, you must set that option first.")) (section 2 "Design Notes and Rationale" (p "For a comparison of (an older rendition of) foof-loop with other contemporary looping macros, see the Usenet article with message-id <1157562097.001179.11470@i42g2000cwa.googlegroups.com> posted on comp.lang.scheme in September of 2006.  Also, for extended comparative examples, see " (link "http://mumble.net/~campbell/scheme/loop-comparison.scm") ". These design notes pertain more specifically to choices made for Taylor R. Campbell's variant of the macro.") (section 3 "Bounding Intervals" (p "Always, in the built-in iterators' bounding intervals -- for iteration over ranges of numbers, over segments of vectors, &c. --, the lower bound is inclusive and the upper bound is exclusive.  It doesn't matter whether one starts from the upper bound and goes to the lower bound or vice versa: the lower bound is inclusive and the upper bound is exclusive.") (p "My experience is that any inconsistency in this regard is a damning path to confusing doom of program clarity.  Off-by-one errors are still possible, of course, especially if the looping macros are mixed with other systems that do not follow this strict convention.  However, between R5RS and foof-loop, it is *much* easier to do the right thing from the start, without having to meticulously adjust any upper bounds, especially for backward iteration that starts from the upper bound.  If you find that you are performing such meticulous adjustment, ask yourself whether you are doing the right thing, and if the answer is `yes', I'd like to hear about it.") (p "To reiterate, since this is very important:") (pre " The lower bound is always inclusive.\n The upper bound is always exclusive.\n It does not matter which bound you start from.") (p "If you write any of your own custom iterators that involve any sort of bounding intervals, *PLEASE* adhere to these rules unless you have an extremely good reason not to, which I'd like to hear about if you do."))))