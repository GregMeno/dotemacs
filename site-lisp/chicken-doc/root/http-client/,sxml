((tags "egg") (section 2 "http-client" (toc) (section 3 "Description" (p "Http-client is a highlevel HTTP client library.")) (section 3 "Author" (p (int-link "/users/peter-bex" "Peter Bex"))) (section 3 "Requirements" (p "Requires the " (int-link "intarweb") " and " (int-link "openssl") " extensions.")) (section 3 "Documentation" (p "This egg is still under development; the API might change a bit in future versions.") (section 4 "Main request procedures" (def (sig (procedure "(call-with-response request writer reader)" (id call-with-response))) (p "This is the core http-client procedure.  It is only necessary to use this when you want the most control over the request/response cycle. " (tt "request") " is the request object that contains information about the request to perform.  " (tt "reader") " is a procedure that receives the response object and should read the request body, " (tt "writer") " is a procedure that receives the request object and should write the request body.") (p "The " (tt "writer") " should be prepared to be called several times; if the response is a redirect or some other status that indicates the server wants the client to perform a new request, the writer should be ready to write a request body for this new request. In case digest authentication with message integrity checking is used, " (tt "writer") " is always invoked at least twice, once to determine the message digest of the response and once to actually write the response.") (p "Returns three values: The result of the call to " (tt "reader") ", the request-uri of the last request and the response object. The request-uri is useful because this is to be used as the base uri of the document. This can differ from the initial request in the presence of redirects.")) (def (sig (procedure "(call-with-input-request uri-or-request writer reader)" (id call-with-input-request))) (p "This procedure is a convenience wrapper around " (tt "call-with-response") ".") (p "It is much less strict - " (tt "uri-or-request") " can be an " (int-link "intarweb") " request object, but also an uri-common object or even a string with the URI in it, in which case a request object will be automatically constructed around the URI, using the " (tt "GET") " method.") (p (tt "writer") " can be either " (tt "#f") " (in which case nothing is written), a string containing the raw data to send, an alist (in which case the data is written out as using www-form-urlencoding, useful for POST requests), or a procedure that accepts a port and writes the response data to it.  If you supply a procedure, do not forget to set the " (tt "content-length") " header!  In the other cases, the length is calculated and the header automatically set for you.  If you supplied an alist, the " (tt "content-type") " header is automatically set to " (tt "application/x-www-form-urlencoded") ".") (p (tt "reader") " is a procedure which accepts a port and reads out the data.") (p "Returns three values: The result of the call to " (tt "reader") ", the request-uri of the last request and the response object.  If the response code is not in the 200 class, it will throw an exception of type " (tt "(exn http client-error)") ", " (tt "(exn http server-error)") " or " (tt "(exn http unexpected-server-response)") ", depending on the response code.  This includes " (tt "404 not found") " (which is a " (tt "client-error") ").")) (def (sig (procedure "(with-input-from-request uri-or-request write-thunk read-thunk)" (id with-input-from-request))) (p "Same as " (tt "call-with-input-request") ", except this accepts thunks (lambdas of no arguments) which will be executed with the current input (or output) port to the request or response port, respectively.") (highlight scheme "(use http-client)\n\n(with-input-from-request \"http://wiki.call-cc.org/\" #f read-string)\n => ;; [the chicken wiki page HTML contents]\n\n\n(use http-client uri-common intarweb)\n\n;; Perform a POST of the key \"test\" with value \"value\" to an echo service\n(with-input-from-request\n  (make-request method: 'POST\n                uri: (uri-reference \"http://localhost/echo-service\"))\n  '((test . \"value\")) read-string)\n => \"You posted: test=value\""))) (section 4 "Request handling parameters" (def (sig (parameter "(max-retry-attempts [number])" (id max-retry-attempts))) (p "When a request fails because of an I/O or network problem (or simply because the remote end closed a persistent connection while we were doing something else), the library will try to establish a new connection and perform the request again.  This parameter controls how many times this is allowed to be done.  If " (tt "#f") ", it will never give up.") (p "Defaults to 1.")) (def (sig (parameter "(retry-request? [predicate])" (id retry-request?))) (p "This procedure is invoked when a retry should take place, to determine if it should take place at all.  It should be a procedure accepting a request object and returning " (tt "#f") " or a true value.  If the value is true, the new request will be sent.  Otherwise, the error that caused the retry attempt will be re-raised.") (p "Defaults to " (tt "idempotent?") ", from " (int-link "intarweb") ".  This is because non-idempotent requests cannot be safely retried when it is unknown whether the previous request reached the server or not.")) (def (sig (parameter "(max-redirect-depth [number])" (id max-redirect-depth))) (p "The maximum number of allowed redirects, or " (tt "#f") " if there is no limit.  Currently there's no automatic redirect loop detection algorithm implemented.  If zero, no redirects will be followed at all.") (p "Defaults to 5.")) (def (sig (parameter "(client-software [software-spec])" (id client-software))) (p "This is the names, versions and comments of the software packages that the client is using, for use in the " (tt "user-agent") " header which is automatically added to each request.") (p "Defaults to " (tt "((\"Chicken Scheme HTTP-client\" VERSION #f))") ", where " (tt "VERSION") " is the version of this egg."))) (section 4 "Connection management" (def (sig (procedure "(close-connection! uri)" (id close-connection!))) (p "Close the connection to the server associated with the URI.")) (def (sig (procedure "(close-all-connections!)" (id close-all-connections!))) (p "Close all connections to all servers."))) (section 4 "Cookie management" (p "http-client's cookie management is supposed to be as automatic and DWIMmy as possible.  This means it will write any cookie as instructed by a server and all stored cookies are automatically sent back to the server upon a new request.") (p "However, in some cases you may want to take control of how cookies are stored.") (p "The API described here should be considered unstable and it may change dramatically when someone comes up with a better way to handle cookies.") (def (sig (procedure "(get-cookies-for-uri uri)" (id get-cookies-for-uri))) (p "Fetch a list of all cookies which ought to be sent to the given URI. Cookies are vectors of two elements: a name/value pair and an alist of attributes.  In other words, these are the exact same values you can put in a " (tt "cookie") " header.")) (def (sig (procedure "(store-cookie! cookie-info set-cookie)" (id store-cookie!))) (p "Store a cookie in the cookiejar corresponding to the Set-Cookie header given by " (tt "set-cookie") ".  This overwrites any cookie that is equal to this cookie, as defined by RFC 2965, section 3.3.3.  Practically, this means that when the cookie's name, domain and path are equal to an existant one, it will be overwritten by the new one.  These attributes are taken from the " (tt "cookie-info") " alist and expected to be there.") (p "Generally, attributes should be taken from " (tt "set-cookie") ", but if missing they ought to be taken from the request URI that responded with the " (tt "set-cookie") ".")) (def (sig (procedure "(delete-cookie! cookie-name cookie-info)" (id delete-cookie!))) (p "Removes any cookie from the cookiejar that is equal to the given cookie (again, in the sense of RFC 2965, section 3.3.3). The " (tt "cookie-name") " must match and the " (tt "path") " and " (tt "domain") " values for the " (tt "cookie-info") " alist must match."))) (section 4 "Authentication support" (p "When a 401 Unauthorized response is received, in most interactive clients, the user is normally asked to authenticate.  To support this type of interaction, http-client offers the following parameter:") (def (sig (parameter "(determine-username/password [HANDLER])" (id determine-username/password))) (p "The procedure in this parameter is called whenever the remote host requests authentication via a 401 Unauthorized response.") (p "The " (tt "HANDLER") " is a procedure of two arguments; the URI for the resource currently being requested and the realm (a string) which wants credentials.  The procedure should return two string values: the username and the password to use for authentication.") (p "The default value is a procedure which extracts the username and password components from the URI.") (p "For proxy authentication support, see " (tt "determine-proxy-username/password") " in the next section."))) (section 4 "Proxy support" (p "http-client has support for sending requests through proxy servers.") (def (sig (parameter "(determine-proxy [HANDLER])" (id determine-proxy))) (p "Whenever a request is sent, the library invokes the procedure stored in this parameter to determine through what proxy to send the request, if any.") (p "The " (tt "HANDLER") " procedure receives one argument, the URI about to be requested, and returns either an URI-common absolute URI object representing the proxy or " (tt "#f") " if no proxy should be used.") (p "The URI's path and query, if present, are ignored; only the scheme and authority (host, port, username, password) are used.") (p "The default value of this parameter is " (tt "determine-proxy-from-environment") ".") (p "If you just want to disable proxy support, you can do:") (highlight scheme "(determine-proxy (constantly #f))   ; From unit data-structures")) (def (sig (procedure "(determine-proxy-from-environment URI)" (id determine-proxy-from-environment))) (p "This procedure implements the common behaviour of HTTP software under UNIX:") (ul (li "First it checks if the requested URI's host (or an asterisk) is listed in the " (tt "NO_PROXY") " environment variable (if suffixed with a port number, the port is also compared).  If a match is found, no proxy is used.") (li "Then it will check if the " (tt "$(protocol)_proxy") " or the " (tt "$(PROTOCOL)_PROXY") " variable (in that order) are set.  If so, that's used.  " (tt "protocol") " here actually means \"scheme\", so the URI's scheme is used, suffixed with " (tt "_proxy") ". This means " (tt "http_proxy") " is used for HTTP requests and " (tt "https_proxy") " is used for HTTPS requests.") (li "If there's still no match, it looks for " (tt "all_proxy") " or " (tt "ALL_PROXY") ", in that order. If one of these environment variables are set, that value is used as a fallback proxy.") (li "Finally, if none of these checks resulted in a proxy URI, no proxy will be used.")) (p "Some UNIX software expects plain hostnames or hostname port combinations separated by colons, but (currently) this library expects full URIs, like most modern UNIX programs.")) (def (sig (parameter "(determine-proxy-username/password [HANDLER])" (id determine-proxy-username/password))) (p "The procedure in this parameter is called whenever the proxy requests authentication via a 407 Proxy Authentication Required response. This basically works the same as authentication against an origin server.") (p "The " (tt "HANDLER") " is a procedure of two arguments; the URI for the " (i "proxy") " currently being used and the realm (a string) which wants credentials.  The procedure should return two string values: the username and the password to use for authentication.") (p "The default value is a procedure which extracts the username and password components from the proxy's URI.")))) (section 3 "Changelog" (ul (li "trunk Fix redirection code on 303, and off-by-1 mistake in redirects count (thanks to Moritz Heidkamp). Add arguments to exn objects (thanks to Christian Kellermann)") (li "0.3 Fixed handling of missing Path parameters in set-cookie headers. Reported by Hugo Arregui. Improve set-cookie handling by only passing Path and Domain when matching Set-Cookie header included those parameters.") (li "0.2 Added proxy support and many many bugfixes") (li "0.1 Initial version"))) (section 3 "License" (pre " Copyright (c) 2008-2011, Peter Bex\n Parts copyright (c) 2000-2004, Felix L. Winkelmann\n All rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n \n Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n \n Redistributions in binary form must reproduce the above copyright\n notice, this list of conditions and the following disclaimer in the\n documentation and/or other materials provided with the distribution.\n \n Neither the name of the author nor the names of its contributors may\n be used to endorse or promote products derived from this software\n without specific prior written permission.\n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n OF THE POSSIBILITY OF SUCH DAMAGE."))))