((tags "manual") (toc) (section 2 "Unit regex" (p "This library unit provides support for regular expressions. The regular expression package used is " (tt "irregex") " written by Alex Shinn. Irregex supports most Perl-extensions and is written completely in Scheme.") (p "This library unit exposes two APIs: the standard Chicken API described below, and the original irregex API.  You may use either API or both:") (pre "(require-library regex)   ; required for either API, or both\n(import regex)            ; import the Chicken regex API\n(import irregex)          ; import the original irregex API") (p "Regular expressions may be either POSIX-style strings (with most PCRE extensions) or an SCSH-style SRE. There is no " (tt "(rx ...)") " syntax - just use normal Scheme lists, with quasiquote if you like.") (section 3 "grep" (def (sig (procedure "(grep REGEX LIST [ACCESSOR])" (id grep))) (p "Returns all items of " (tt "LIST") " that match the regular expression " (tt "REGEX") ".  This procedure could be defined as follows:") (highlight scheme "(define (grep regex lst)\n  (filter (lambda (x) (string-search regex x)) lst) )") (p (tt "ACCESSOR") " is an optional accessor-procedure applied to each element before doing the match. It should take a single argument and return a string that will then be used in the regular expression matching. " (tt "ACCESSOR") " defaults to the identity function."))) (section 3 "glob->regexp" (def (sig (procedure "(glob->regexp PATTERN [SRE?])" (id glob->regexp))) (p "Converts the file-pattern " (tt "PATTERN") " into a regular expression.") (highlight scheme "(glob->regexp \"foo.*\")\n=> \"foo\\..*\"") (p (tt "PATTERN") " should follow \"glob\" syntax. Allowed wildcards are") (pre "*\n[C...]\n[C1-C2]\n[-C...]\n?") (p (tt "glob->regexp") " returns a regular expression object if the optional argument " (tt "SRE?") " is false or not given, otherwise the SRE of the computed regular expression is returned."))) (section 3 "regexp" (def (sig (procedure "(regexp STRING [IGNORECASE [IGNORESPACE [UTF8]]])" (id regexp))) (p "Returns a precompiled regular expression object for " (tt "string") ". The optional arguments " (tt "IGNORECASE") ", " (tt "IGNORESPACE") " and " (tt "UTF8") " specify whether the regular expression should be matched with case- or whitespace-differences ignored, or whether the string should be treated as containing UTF-8 encoded characters, respectively.") (p "Note that code that uses regular expressions heavily should always use them in precompiled form, which is likely to be much faster than passing strings to any of the regular-expression routines described below."))) (section 3 "regexp?" (def (sig (procedure "(regexp? X)" (id regexp?))) (p "Returns " (tt "#t") " if " (tt "X") " is a precompiled regular expression, or " (tt "#f") " otherwise."))) (section 3 "string-match") (section 3 "string-match-positions" (def (sig (procedure "(string-match REGEXP STRING)" (id string-match)) (procedure "(string-match-positions REGEXP STRING)" (id string-match-positions))) (p "Matches the regular expression in " (tt "REGEXP") " (a string or a precompiled regular expression) with " (tt "STRING") " and returns either " (tt "#f") " if the match failed, or a list of matching groups, where the first element is the complete match.  For each matching group the result-list contains either: " (tt "#f") " for a non-matching but optional group; a list of start- and end-position of the match in " (tt "STRING") " (in the case of " (tt "string-match-positions") "); or the matching substring (in the case of " (tt "string-match") "). Note that the exact string is matched. For searching a pattern inside a string, see below. Note also that " (tt "string-match") " is implemented by calling " (tt "string-search") " with the regular expression wrapped in " (tt "^ ... $") ".") (p "If invoked with a precompiled regular expression argument (by using " (tt "regexp") "), " (tt "string-match") " is identical to " (tt "string-search") "."))) (section 3 "string-search") (section 3 "string-search-positions" (def (sig (procedure "(string-search REGEXP STRING [START [RANGE]])" (id string-search)) (procedure "(string-search-positions REGEXP STRING [START [RANGE]])" (id string-search-positions))) (p "Searches for the first match of the regular expression in " (tt "REGEXP") " with " (tt "STRING") ". The search can be limited to " (tt "RANGE") " characters."))) (section 3 "string-split-fields" (def (sig (procedure "(string-split-fields REGEXP STRING [MODE [START]])" (id string-split-fields))) (p "Splits " (tt "STRING") " into a list of fields according to " (tt "MODE") ", where " (tt "MODE") " can be the keyword " (tt "#:infix") " (" (tt "REGEXP") " matches field separator), the keyword " (tt "#:suffix") " (" (tt "REGEXP") " matches field terminator) or " (tt "#t") " (" (tt "REGEXP") " matches field), which is the default.") (highlight scheme "(define s \"this is a string 1, 2, 3,\")\n\n(string-split-fields \"[^ ]+\" s)\n\n  => (\"this\" \"is\" \"a\" \"string\" \"1,\" \"2,\" \"3,\")\n\n(string-split-fields \" \" s #:infix)\n\n  => (\"this\" \"is\" \"a\" \"string\" \"1,\" \"2,\" \"3,\")\n\n(string-split-fields \",\" s #:suffix)\n \n  => (\"this is a string 1\" \" 2\" \" 3\")"))) (section 3 "string-substitute" (def (sig (procedure "(string-substitute REGEXP SUBST STRING [MODE])" (id string-substitute))) (p "Searches substrings in " (tt "STRING") " that match " (tt "REGEXP") " and substitutes them with the string " (tt "SUBST") ". The substitution can contain references to subexpressions in " (tt "REGEXP") " with the " (tt "\\NUM") " notation, where " (tt "NUM") " refers to the NUMth parenthesized expression. The optional argument " (tt "MODE") " defaults to 1 and specifies the number of the match to be substituted. Any non-numeric index specifies that all matches are to be substituted.") (highlight scheme "(string-substitute \"([0-9]+) (eggs|chicks)\" \"\\\\2 (\\\\1)\" \"99 eggs or 99 chicks\" 2)\n=> \"99 eggs or chicks (99)\"") (p "Note that a regular expression that matches an empty string will signal an error."))) (section 3 "string-substitute*" (def (sig (procedure "(string-substitute* STRING SMAP [MODE])" (id string-substitute*))) (p "Substitutes elements of " (tt "STRING") " with " (tt "string-substitute") " according to " (tt "SMAP") ". " (tt "SMAP") " should be an association-list where each element of the list is a pair of the form " (tt "(MATCH . REPLACEMENT)") ". Every occurrence of the regular expression " (tt "MATCH") " in " (tt "STRING") " will be replaced by the string " (tt "REPLACEMENT")) (highlight scheme "(string-substitute* \"<h1>Hello, world!</h1>\" '((\"<[/A-Za-z0-9]+>\" . \"\")))\n\n=>  \"Hello, world!\""))) (section 3 "regexp-escape" (def (sig (procedure "(regexp-escape STRING)" (id regexp-escape))) (p "Escapes all special characters in " (tt "STRING") " with " (tt "\\") ", so that the string can be embedded into a regular expression.") (highlight scheme "(regexp-escape \"^[0-9]+:.*$\")\n=>  \"\\\\^\\\\[0-9\\\\]\\\\+:.\\n.\\\\*\\\\$\""))) (section 3 "Extended SRE Syntax" (p "The following table summarizes the SRE syntax, with detailed explanations following.") (pre " ;; basic patterns\n <string>                          ; literal string\n (seq <sre> ...)                   ; sequence\n (: <sre> ...)\n (or <sre> ...)                    ; alternation\n \n ;; optional/multiple patterns\n (? <sre> ...)                     ; 0 or 1 matches\n (* <sre> ...)                     ; 0 or more matches\n (+ <sre> ...)                     ; 1 or more matches\n (= <n> <sre> ...)                 ; exactly <n> matches\n (>= <n> <sre> ...)                ; <n> or more matches\n (** <from> <to> <sre> ...)        ; <n> to <m> matches\n (?? <sre> ...)                    ; non-greedy (non-greedy) pattern: (0 or 1)\n (*? <sre> ...)                    ; non-greedy kleene star\n (**? <from> <to> <sre> ...)       ; non-greedy range\n \n ;; submatch patterns\n (submatch <sre> ...)              ; numbered submatch\n (submatch-named <name> <sre> ...) ; named submatch\n (=> <name> <sre> ...)\n (backref <n-or-name>)             ; match a previous submatch\n \n ;; toggling case-sensitivity\n (w/case <sre> ...)                ; enclosed <sre>s are case-sensitive\n (w/nocase <sre> ...)              ; enclosed <sre>s are case-insensitive\n \n ;; character sets\n <char>                            ; singleton char set\n (<string>)                        ; set of chars\n (or <cset-sre> ...)               ; set union\n (~ <cset-sre> ...)                ; set complement (i.e. [^...])\n (- <cset-sre> ...)                ; set difference\n (& <cset-sre> ...)                ; set intersection\n (/ <range-spec> ...)              ; pairs of chars as ranges\n \n ;; named character sets\n any\n nonl\n ascii\n lower-case     lower\n upper-case     upper\n alphabetic     alpha\n numeric        num\n alphanumeric   alphanum  alnum\n punctuation    punct\n graphic        graph\n whitespace     white     space\n printing       print\n control        cntrl\n hex-digit      xdigit\n \n ;; assertions and conditionals\n bos eos                           ; beginning/end of string\n bol eol                           ; beginning/end of line\n bow eow                           ; beginning/end of word\n nwb                               ; non-word-boundary\n (look-ahead <sre> ...)            ; zero-width look-ahead assertion\n (look-behind <sre> ...)           ; zero-width look-behind assertion\n (neg-look-ahead <sre> ...)        ; zero-width negative look-ahead assertion\n (neg-look-behind <sre> ...)       ; zero-width negative look-behind assertion\n (atomic <sre> ...)                ; for (?>...) independent patterns\n (if <test> <pass> [<fail>])       ; conditional patterns\n commit                            ; don't backtrack beyond this (i.e. cut)\n \n ;; backwards compatibility\n (posix-string <string>)           ; embed a POSIX string literal") (section 4 "Basic SRE Patterns" (p "The simplest SRE is a literal string, which matches that string exactly.") (pre " (string-search \"needle\" \"hayneedlehay\") => <match>") (p "By default the match is case-sensitive, though you can control this either with the compiler flags or local overrides:") (pre " (string-search \"needle\" \"haynEEdlehay\") => #f\n \n (string-search (irregex \"needle\" 'i) \"haynEEdlehay\") => <match>\n \n (string-search '(w/nocase \"needle\") \"haynEEdlehay\") => <match>") (p "You can use " (tt "w/case") " to switch back to case-sensitivity inside a " (tt "w/nocase") ":") (pre " (string-search '(w/nocase \"SMALL\" (w/case \"BIG\")) \"smallBIGsmall\") => <match>\n \n (string-search '(w/nocase \"small\" (w/case \"big\")) \"smallBIGsmall\") => #f") (p "Of course, literal strings by themselves aren't very interesting regular expressions, so we want to be able to compose them. The most basic way to do this is with the " (tt "seq") " operator (or its abbreviation " (tt ":") "), which matches one or more patterns consecutively:") (pre " (string-search '(: \"one\" space \"two\" space \"three\") \"one two three\") => <match>") (p "As you may have noticed above, the " (tt "w/case") " and " (tt "w/nocase") " operators allowed multiple SREs in a sequence - other operators that take any number of arguments (e.g. the repetition operators below) allow such implicit sequences.") (p "To match any one of a set of patterns use the or alternation operator:") (pre " (string-search '(or \"eeney\" \"meeney\" \"miney\") \"meeney\") => <match>") (pre " (string-search '(or \"eeney\" \"meeney\" \"miney\") \"moe\") => #f")) (section 4 "SRE Repetition Patterns" (p "There are also several ways to control the number of times a pattern is matched. The simplest of these is " (tt "?") " which just optionally matches the pattern:") (pre " (string-search '(: \"match\" (? \"es\") \"!\") \"matches!\") => <match>\n \n (string-search '(: \"match\" (? \"es\") \"!\") \"match!\") => <match>\n \n (string-search '(: \"match\" (? \"es\") \"!\") \"matche!\") => #f") (p "To optionally match any number of times, use " (tt "*") ", the Kleene star:") (pre " (string-search '(: \"<\" (* (~ #\\>)) \">\") \"<html>\") => <match>\n \n (string-search '(: \"<\" (* (~ #\\>)) \">\") \"<>\") => <match>\n \n (string-search '(: \"<\" (* (~ #\\>)) \">\") \"<html\") => #f") (p "Often you want to match any number of times, but at least one time is required, and for that you use " (tt "+") ":") (pre " (string-search '(: \"<\" (+ (~ #\\>)) \">\") \"<html>\") => <match>\n \n (string-search '(: \"<\" (+ (~ #\\>)) \">\") \"<a>\") => <match>\n \n (string-search '(: \"<\" (+ (~ #\\>)) \">\") \"<>\") => #f") (p "More generally, to match at least a given number of times, use " (tt ">=") ":") (pre " (string-search '(: \"<\" (>= 3 (~ #\\>)) \">\") \"<table>\") => <match>") (pre " (string-search '(: \"<\" (>= 3 (~ #\\>)) \">\") \"<pre>\") => <match>") (pre " (string-search '(: \"<\" (>= 3 (~ #\\>)) \">\") \"<tr>\") => #f") (p "To match a specific number of times exactly, use {=}:") (pre " (string-search '(: \"<\" (= 4 (~ #\\>)) \">\") \"<html>\") => <match>\n \n (string-search '(: \"<\" (= 4 (~ #\\>)) \">\") \"<table>\") => #f") (p "And finally, the most general form is " (tt "**") " which specifies a range of times to match. All of the earlier forms are special cases of this.") (pre " (string-search '(: (= 3 (** 1 3 numeric) \".\") (** 1 3 numeric)) \"192.168.1.10\") => <match>") (pre " (string-search '(: (= 3 (** 1 3 numeric) \".\") (** 1 3 numeric)) \"192.0168.1.10\") => #f") (p "There are also so-called \"non-greedy\" variants of these repetition operators, by convention suffixed with an additional " (tt "?") ". Since the normal repetition patterns can match any of the allotted repetition range, these operators will match a string if and only if the normal versions matched. However, when the endpoints of which submatch matched where are taken into account (specifically, all matches when using string-search since the endpoints of the match itself matter), the use of a non-greedy repetition can change the result.") (p "So, whereas " (tt "?") " can be thought to mean \"match or don't match,\" " (tt "??") " means \"don't match or match.\" " (tt "*") " typically consumes as much as possible, but " (tt "*?") " tries first to match zero times, and only consumes one at a time if that fails. If you have a greedy operator followed by a non-greedy operator in the same pattern, they can produce surprisins results as they compete to make the match longer or shorter. If this seems confusing, that's because it is. Non-greedy repetitions are defined only in terms of the specific backtracking algorithm used to implement them, which for compatibility purposes always means the Perl algorithm. Thus, when using these patterns you force IrRegex to use a backtracking engine, and can't rely on efficient execution.")) (section 4 "SRE Character Sets" (p "Perhaps more common than matching specific strings is matching any of a set of characters. You can use the or alternation pattern on a list of single-character strings to simulate a character set, but this is too clumsy for everyday use so SRE syntax allows a number of shortcuts.") (p "A single character matches that character literally, a trivial character class. More conveniently, a list holding a single element which is a string refers to the character set composed of every character in the string.") (pre " (string-match '(* #\\-) \"---\") => <match>\n \n (string-match '(* #\\-) \"-_-\") => #f\n \n (string-match '(* (\"aeiou\")) \"oui\") => <match>\n \n (string-match '(* (\"aeiou\")) \"ouais\") => #f") (p "Ranges are introduced with the " (tt "/") " operator. Any strings or characters in the " (tt "/") " are flattened and then taken in pairs to represent the start and end points, inclusive, of character ranges.") (pre " (string-match '(* (/ \"AZ09\")) \"R2D2\") => <match>\n \n (string-match '(* (/ \"AZ09\")) \"C-3PO\") => #f") (p "In addition, a number of set algebra operations are provided. or, of course, has the same meaning, but when all the options are character sets it can be thought of as the set union operator. This is further extended by the " (tt "&") " set intersection, " (tt "-") " set difference, and " (tt "~") " set complement operators.") (pre " (string-match '(* (& (/ \"az\") (~ (\"aeiou\")))) \"xyzzy\") => <match>\n \n (string-match '(* (& (/ \"az\") (~ (\"aeiou\")))) \"vowels\") => #f") (pre " (string-match '(* (- (/ \"az\") (\"aeiou\"))) \"xyzzy\") => <match>\n \n (string-match '(* (- (/ \"az\") (\"aeiou\"))) \"vowels\") => #f")) (section 4 "SRE Assertion Patterns" (p "There are a number of times it can be useful to assert something about the area around a pattern without explicitly making it part of the pattern. The most common cases are specifically anchoring some pattern to the beginning or end of a word or line or even the whole string. For example, to match on the end of a word:") (pre " (string-match '(: \"foo\" eow) \"foo\") => <match>\n \n (string-match '(: \"foo\" eow) \"foo!\") => <match>\n \n (string-match '(: \"foo\" eow) \"foof\") => #f") (p "The " (tt "bow") ", " (tt "bol") ", " (tt "eol") ", " (tt "bos") " and " (tt "eos") " work similarly. " (tt "nwb") " asserts that you are not in a word-boundary - if replaced for " (tt "eow") " in the above examples it would reverse all the results.") (p "There is no " (tt "wb") ", since you tend to know from context whether it would be the beginning or end of a word, but if you need it you can always use (or bow eow).") (p "Somewhat more generally, Perl introduced positive and negative look-ahead and look-behind patterns. Perl look-behind patterns are limited to a fixed length, however the IrRegex versions have no such limit.") (pre " (string-match '(: \"regular\" (look-ahead \" expression\")) \"regular expression\") => <match>") (p "The most general case, of course, would be an and pattern to complement the or pattern - all the patterns must match or the whole pattern fails. This may be provided in a future release, although it (and look-ahead and look-behind assertions) are unlikely to be compiled efficiently.") (hr) (p "Previous: " (int-link "Unit extras")) (p "Next: " (int-link "Unit srfi-1"))))))