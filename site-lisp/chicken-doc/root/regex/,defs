(index ("grep" 0) ("glob->regexp" 578) ("regexp" 1100) ("regexp?" 1768) ("string-match" 1928) ("string-match-positions" 1928) ("string-search" 3040) ("string-search-positions" 3040) ("string-split-fields" 3394) ("string-substitute" 4193) ("string-substitute*" 5015) ("regexp-escape" 5608))
(def (sig (procedure "(grep REGEX LIST [ACCESSOR])" (id grep))) (p "Returns all items of " (tt "LIST") " that match the regular expression " (tt "REGEX") ".  This procedure could be defined as follows:") (highlight scheme "(define (grep regex lst)\n  (filter (lambda (x) (string-search regex x)) lst) )") (p (tt "ACCESSOR") " is an optional accessor-procedure applied to each element before doing the match. It should take a single argument and return a string that will then be used in the regular expression matching. " (tt "ACCESSOR") " defaults to the identity function."))
(def (sig (procedure "(glob->regexp PATTERN [SRE?])" (id glob->regexp))) (p "Converts the file-pattern " (tt "PATTERN") " into a regular expression.") (highlight scheme "(glob->regexp \"foo.*\")\n=> \"foo\\..*\"") (p (tt "PATTERN") " should follow \"glob\" syntax. Allowed wildcards are") (pre "*\n[C...]\n[C1-C2]\n[-C...]\n?") (p (tt "glob->regexp") " returns a regular expression object if the optional argument " (tt "SRE?") " is false or not given, otherwise the SRE of the computed regular expression is returned."))
(def (sig (procedure "(regexp STRING [IGNORECASE [IGNORESPACE [UTF8]]])" (id regexp))) (p "Returns a precompiled regular expression object for " (tt "string") ". The optional arguments " (tt "IGNORECASE") ", " (tt "IGNORESPACE") " and " (tt "UTF8") " specify whether the regular expression should be matched with case- or whitespace-differences ignored, or whether the string should be treated as containing UTF-8 encoded characters, respectively.") (p "Note that code that uses regular expressions heavily should always use them in precompiled form, which is likely to be much faster than passing strings to any of the regular-expression routines described below."))
(def (sig (procedure "(regexp? X)" (id regexp?))) (p "Returns " (tt "#t") " if " (tt "X") " is a precompiled regular expression, or " (tt "#f") " otherwise."))
(def (sig (procedure "(string-match REGEXP STRING)" (id string-match)) (procedure "(string-match-positions REGEXP STRING)" (id string-match-positions))) (p "Matches the regular expression in " (tt "REGEXP") " (a string or a precompiled regular expression) with " (tt "STRING") " and returns either " (tt "#f") " if the match failed, or a list of matching groups, where the first element is the complete match.  For each matching group the result-list contains either: " (tt "#f") " for a non-matching but optional group; a list of start- and end-position of the match in " (tt "STRING") " (in the case of " (tt "string-match-positions") "); or the matching substring (in the case of " (tt "string-match") "). Note that the exact string is matched. For searching a pattern inside a string, see below. Note also that " (tt "string-match") " is implemented by calling " (tt "string-search") " with the regular expression wrapped in " (tt "^ ... $") ".") (p "If invoked with a precompiled regular expression argument (by using " (tt "regexp") "), " (tt "string-match") " is identical to " (tt "string-search") "."))
(def (sig (procedure "(string-search REGEXP STRING [START [RANGE]])" (id string-search)) (procedure "(string-search-positions REGEXP STRING [START [RANGE]])" (id string-search-positions))) (p "Searches for the first match of the regular expression in " (tt "REGEXP") " with " (tt "STRING") ". The search can be limited to " (tt "RANGE") " characters."))
(def (sig (procedure "(string-split-fields REGEXP STRING [MODE [START]])" (id string-split-fields))) (p "Splits " (tt "STRING") " into a list of fields according to " (tt "MODE") ", where " (tt "MODE") " can be the keyword " (tt "#:infix") " (" (tt "REGEXP") " matches field separator), the keyword " (tt "#:suffix") " (" (tt "REGEXP") " matches field terminator) or " (tt "#t") " (" (tt "REGEXP") " matches field), which is the default.") (highlight scheme "(define s \"this is a string 1, 2, 3,\")\n\n(string-split-fields \"[^ ]+\" s)\n\n  => (\"this\" \"is\" \"a\" \"string\" \"1,\" \"2,\" \"3,\")\n\n(string-split-fields \" \" s #:infix)\n\n  => (\"this\" \"is\" \"a\" \"string\" \"1,\" \"2,\" \"3,\")\n\n(string-split-fields \",\" s #:suffix)\n \n  => (\"this is a string 1\" \" 2\" \" 3\")"))
(def (sig (procedure "(string-substitute REGEXP SUBST STRING [MODE])" (id string-substitute))) (p "Searches substrings in " (tt "STRING") " that match " (tt "REGEXP") " and substitutes them with the string " (tt "SUBST") ". The substitution can contain references to subexpressions in " (tt "REGEXP") " with the " (tt "\\NUM") " notation, where " (tt "NUM") " refers to the NUMth parenthesized expression. The optional argument " (tt "MODE") " defaults to 1 and specifies the number of the match to be substituted. Any non-numeric index specifies that all matches are to be substituted.") (highlight scheme "(string-substitute \"([0-9]+) (eggs|chicks)\" \"\\\\2 (\\\\1)\" \"99 eggs or 99 chicks\" 2)\n=> \"99 eggs or chicks (99)\"") (p "Note that a regular expression that matches an empty string will signal an error."))
(def (sig (procedure "(string-substitute* STRING SMAP [MODE])" (id string-substitute*))) (p "Substitutes elements of " (tt "STRING") " with " (tt "string-substitute") " according to " (tt "SMAP") ". " (tt "SMAP") " should be an association-list where each element of the list is a pair of the form " (tt "(MATCH . REPLACEMENT)") ". Every occurrence of the regular expression " (tt "MATCH") " in " (tt "STRING") " will be replaced by the string " (tt "REPLACEMENT")) (highlight scheme "(string-substitute* \"<h1>Hello, world!</h1>\" '((\"<[/A-Za-z0-9]+>\" . \"\")))\n\n=>  \"Hello, world!\""))
(def (sig (procedure "(regexp-escape STRING)" (id regexp-escape))) (p "Escapes all special characters in " (tt "STRING") " with " (tt "\\") ", so that the string can be embedded into a regular expression.") (highlight scheme "(regexp-escape \"^[0-9]+:.*$\")\n=>  \"\\\\^\\\\[0-9\\\\]\\\\+:.\\n.\\\\*\\\\$\""))
