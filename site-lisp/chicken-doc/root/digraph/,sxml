((tags "egg") (section 2 "digraph" (p "Directed graph in adjacency list format.") (toc)) (section 2 "Usage" (p "(require-extension digraph)")) (section 2 "Documentation" (p "The " (tt "digraph") " library is an implementation of a directed graph, where the edges are stored as adjacency lists indexed by node number.") (p "The library defines a digraph \"object\" -- a procedure that takes a method name as a symbol, and returns the procedure that implements the respective operation.") (section 3 "Directed graph procedures" (p "The digraph object is created by procedure " (tt "make-digraph") ", which is the only user-visible procedure defined in this egg:") (def (sig (procedure "make-digraph:: NAME INFO [NODE-LIST [SUCC-LIST [PRED-LIST]]] -> SELECTOR" (id make-digraph))) (p "where:") (ul (li (tt "NAME") " is the graph name (string or symbol)") (li (tt "INFO") " is an optional metadata object of an arbitrary type or " (tt "#f")) (li (tt "NODE-LIST") " is an optional list of nodes to be inserted in the graph; each element of the list must be of the form " (tt "(N INFO)") " where " (tt "N") " is a unique node number (integer), and " (tt "INFO") " is an optional metadata object describing the node. ") (li (tt "SUCC-LIST") " and " (tt "PRED-LIST") " can be used to define the graph edges upon graph creation. If supplied, these arguments must be lists in which every element is of the form " (tt "(I J INFO)") ", where " (tt "I") " and " (tt "J") " are node numbers, and " (tt "INFO") " is an optional metadata object.")) (p "The returned selector procedure can take one of the following arguments:") (dl (dt (tt "'name")) (dd "returns the graph name (string or symbol)") (dt (tt "'info")) (dd "returns the graph metadata (arbitrary type)") (dt (tt "'new-id!")) (dd "returns a procedure with no arguments, which returns the lowest available node number") (dt (tt "'add-node!")) (dd "returns a procedure " (tt "LAMBDA N INFO") " which inserts in the graph node with number " (tt "N") " and metadata " (tt "INFO") "; if the node already exists in the graph, it will be overwritten with the new metadata") (dt (tt "'add-edge!")) (dd "returns a procedure " (tt "LAMBDA EDGE") " which inserts in the graph the specifed edge; the edge is given by a list of the form " (tt "(I J INFO)") ", where " (tt "I") " and " (tt "J") " are source and destination nodes, respectively, and " (tt "INFO") " is edge metadata of arbitrary type") (dt (tt "'remove-node!")) (dd "returns a procedure " (tt "LAMBDA N") " which removes node " (tt "N") " and all its edges from the graph") (dt (tt "'nodes")) (dd "returns a procedure with no arguments, which returns a list with the nodes of the graph and their metadata") (dt (tt "'edges")) (dd "returns a procedure with no arguments, which returns a list with the edges of the graph and their metadata") (dt (tt "'roots")) (dd "returns a procedure with no arguments, which returns a list with all nodes in the graph that do not have an predecessor") (dt (tt "'order")) (dd "returns a procedure with no arguments, which returns the number of nodes in the graph") (dt (tt "'size")) (dd "returns a procedure with no arguments, which returns the number of edges in the graph") (dt (tt "'capacity")) (dd "returns a procedure with no arguments, which returns the size of the underlying dynamic vector") (dt (tt "'succ")) (dd "returns a procedure " (tt "LAMBDA N") " which returns a list with the successor nodes of node " (tt "N")) (dt (tt "'pred")) (dd "returns a procedure " (tt "LAMBDA N") " which returns a list with the predecessor nodes of node " (tt "N")) (dt (tt "'succ-list")) (dd "returns a procedure with no arguments  which returns a list containing the successor nodes for each node.") (dt (tt "'pred-list")) (dd "returns a procedure with no arguments  which returns a list containing the predecessor nodes for each node.") (dt (tt "'out-edges")) (dd "returns a procedure " (tt "LAMBDA N") " which returns a list with the outgoing edges of node " (tt "N")) (dt (tt "'in-edges")) (dd "returns a procedure " (tt "LAMBDA N") " which returns a list with the incoming edges of node " (tt "N")) (dt (tt "'has-edge")) (dd "returns a procedure " (tt "LAMBDA I J") " which returns true if edge " (tt "I -> J") " exists in the graph and false otherwise") (dt (tt "'has-node")) (dd "returns a procedure " (tt "LAMBDA N") " which returns true if node " (tt "N") " exists in the graph and false otherwise") (dt (tt "'node-info")) (dd "returns a procedure " (tt "LAMBDA N") " which returns the metadata for node " (tt "N")) (dt (tt "'node-info-set!")) (dd "returns a procedure " (tt "LAMBDA N V") " which sets the metadata for node " (tt "N")) (dt (tt "'foreach-node")) (dd "returns an iterator procedure " (tt "LAMBDA F") " which iterates over the nodes in the graph by invoking function " (tt "F") " on the node number and metadata of each node") (dt (tt "'foreach-edge")) (dd "returns an iterator procedure " (tt "LAMBDA F") " which iterates over the edges in the graph by invoking function " (tt "F") " on each edge") (dt (tt "'debug")) (dd "returns a list with the internal representation of the graph"))))) (section 2 "Examples" (pre ";; example adapted from graph example in the Boost library documentation\n(require-extension srfi-1)\n(require-extension digraph)\n(define g (make-digraph 'depgraph \"dependency graph\"))\n\n(define used-by\n   (list \n     (cons 'dax_h 'foo_cpp) (cons 'dax_h 'bar_cpp) (cons 'dax_h 'yow_h)\n     (cons 'yow_h 'bar_cpp) (cons 'yow_h 'zag_cpp) (cons 'boz_h 'bar_cpp)\n     (cons 'boz_h 'zig_cpp) (cons 'boz_h 'zag_cpp) (cons 'zow_h 'foo_cpp)\n     (cons 'foo_cpp 'foo_o) (cons 'foo_o 'libfoobar_a) \n     (cons 'bar_cpp 'bar_o) (cons 'bar_o 'libfoobar_a) \n     (cons 'libfoobar_a 'libzigzag_a) (cons 'zig_cpp 'zig_o) \n     (cons 'zig_o 'libzigzag_a) (cons 'zag_cpp 'zag_o) \n     (cons 'zag_o 'libzigzag_a) (cons 'libzigzag_a 'killerapp)))\n\n\n(define node-list (delete-duplicates \n\t\t   (concatenate (list (map car used-by) (map cdr used-by)))))\n\n(define node-ids (list-tabulate (length node-list) values))\n \n(for-each (lambda (i n) ((g 'add-node!) i n)) node-ids node-list)\n(define node-map (zip node-list node-ids))\n\n(for-each (lambda (e) \n\t    (match e ((ni . nj) (let ((i (car (alist-ref ni node-map)))\n\t\t\t\t      (j (car (alist-ref nj node-map))))\n\t\t\t\t  ((g 'add-edge!) (list i j (format \"~A->~A\" ni nj)))))\n\t\t   (else (error \"invalid edge \" e))))\n\t  used-by)\n(print ((g 'nodes)))\n(print ((g 'edges)))\n\n((g 'remove-node!) 0)\n(print ((g 'nodes)))\n(print ((g 'edges)))")) (section 2 "About this egg" (section 3 "Author" (p (int-link "/users/ivan-raikov" "Ivan Raikov"))) (section 3 "Version history" (dl (dt "1.13") (dd "Added test as a test dependency") (dt "1.12") (dd "Converted documentation to wiki format") (dt "1.11") (dd "Ported to Chicken 4") (dt "1.10") (dd "Now using matchable extension") (dt "1.9") (dd "Added procedures pred-list and succ-list") (dt "1.8") (dd "Added procedure node-info-set!") (dt "1.7") (dd "Build script updated for better cross-platform compatibility") (dt "1.6") (dd "Test infrastructure changed to use testbase") (dt "1.5") (dd "Bug fixes in set-out-edges! and set-in-edges! [thanks to Andreas Scholta]") (dt "1.4") (dd "License upgrade to GPL v3") (dt "1.3") (dd "Updated the roots procedure to match the documentation") (dt "1.2") (dd "Minor changes to the setup script") (dt "1.1") (dd "Added support for chicken-setup -test") (dt "1.0") (dd "Initial release"))) (section 3 "License" (pre "Copyright 2007-2010 Ivan Raikov and the Okinawa Institute of Science and Technology\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or (at\nyour option) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nA full copy of the GPL license can be found at\n<http://www.gnu.org/licenses/>."))))