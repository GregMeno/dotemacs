((tags "egg") (section 2 "sandbox" (toc) (section 3 "Description" (p "Safe evaluation of basic Scheme expressions.")) (section 3 "Author" (p (int-link "/users/felix winkelmann" "felix winkelmann"))) (section 3 "Requirements" (p (int-link "matchable"))) (section 3 "Download" (p (link "http://www.call-with-current-continuation.org/eggs/sandbox.egg" "sandbox.egg"))) (section 3 "Documentation" (p "This extension provides a " (i "safe") " evaluation context for basic Scheme expressions (R5RS without optional, input- or output forms). The following standard Scheme procedures are not available:") (pre " display\n write\n read\n read-char\n peek-char\n write-char\n eof-object?\n char-ready?\n newline\n open-input-file\n open-output-file\n close-input-port\n close-output-port\n with-input-from-file\n with-output-from-file\n call-with-input-file\n call-with-output-file\n input-port?\n output-port?\n current-input-port\n current-output-port\n load\n transcript-on\n transcript-off\n null-environment\n scheme-report-environment\n interaction-environment") (p (tt "eval") " is provided but does only accept a single argument.") (p "Runaway evaluation (for example by executing endless loops) and excessive allocation can be caught by specifying appropriate limits on execution time and storage.  The execution environment is fully thread safe.") (section 4 "safe-eval" (def (sig (procedure " (safe-eval EXPRESSION #!key ENVIRONMENT FUEL ALLOCATION-LIMIT)" (id safe-eval))) (p "Evaluates " (tt "EXPRESSION") " in a safe evaluation context. " (tt "FUEL") " specifies how much " (i "fuel") " the pre-translation and evaluation has before an exception will be raised. " (tt "ALLOCATION-LIMIT") " gives (a rough) estimation over the maximal size of storage that may be allocated during the evalution of " (tt "EXPRESSION") ". " (tt "FUEL") " and " (tt "ALLOCATION-LIMIT") " default to " (tt "#f") ", meaning no limit is given.") (p (tt "ENVIRONMENT") " specifies the evaluation environment that should be used, and defaults to the value of " (tt "default-safe-environment") ".") (p "Should an error occur during the execution of EXPRESSION, a composite condition of the original error condition and a condition of the kind " (tt "sandbox") " will be signalled.") (p "Note that de-allocation is not tracked, only allocation."))) (section 4 "current-fuel" (def (sig (parameter "current-fuel" (id current-fuel))) (p "A parameter holding the current amount " (i "fuel") ". If this counter reaches zero during the pre-translation or execution of an evaluated expression an error is signalled. The initial value is " (tt "#f") ", meaning no limit is given."))) (section 4 "current-allocation-limit" (def (sig (parameter "current-allocation-limit" (id current-allocation-limit))) (p "A parameter holding the current maximum storage that an evaluated expression may allocate. If the total size of allocated storage exceeds this limit (given in bytes) and error is signalled. The initial value is " (tt "#f") ", meaning no limit is given.") (p "Note that this limit is a rough estimate."))) (section 4 "safe-environment?" (def (sig (procedure "(safe-environment? X)" (id safe-environment?))) (p "Returns " (tt "#t") " if " (tt "X") " is a safe environment object or " (tt "#f") " otherwise."))) (section 4 "current-safe-environment" (def (sig (parameter "current-safe-environment" (id current-safe-environment))) (p "A parameter holding the current evaluation environment. The initial value is the value of " (tt "default-safe-environment") "."))) (section 4 "default-safe-environment" (def (sig (constant "default-safe-environment" (id default-safe-environment))) (p "An evaluation environment containing a basic R5RS environment without I/O procedures.</dd>"))) (section 4 "make-safe-environment" (def (sig (procedure "(make-safe-environment #!key NAME PARENT MUTABLE EXTENDABLE)" (id make-safe-environment))) (p "Creates a fresh evaluation environment with a given " (tt "NAME") " and parent environment " (tt "PARENT") ". Whn a binding is looked up and can not be found in the current environment, then the chain of parent environments will be checked for a matching binding.") (p "If " (tt "MUTABLE") " is not given or false, then this environment is not mutable and bindings in this environment may not be changed with " (tt "set!") ". If " (tt "EXTENDABLE") " is not given or true, then the environment may be extended with new global bindings."))) (section 4 "safe-environment-ref" (def (sig (procedure "(safe-environment-ref ENVIRONMENT ID [DEFAULT])" (id safe-environment-ref))) (p "Returns the current value of the variable named " (tt "ID") " in " (tt "ENVIRONMENT") " or " (tt "DEFAULT") " if the " (tt "ENVIRONMENT") " or it's parent environments do not contain a binding with this name. If " (tt "DEFAULT") " is not given, " (tt "#f") " will be returned."))) (section 4 "safe-environment-set!" (def (sig (procedure "(safe-environment-set! ENVIRONMENT ID VALUE)" (id safe-environment-set!))) (p "Sets the value of the variable named " (tt "ID") " in " (tt "ENVIRONMENT") " to value, creating a new binding if no variable with this name exists (it doesn't check the parent environment).  Use this procedure to add additional primitives to an evaluation context:") (highlight scheme "(define my-env\n  (make-safe-environment parent: default-safe-environment) )\n\n(safe-environment-set!\n  my-env 'hello\n  (lambda (arg) \n    (display \"Hello, \")\n    (display arg)\n    (display \"!\\n\") ) )\n\n(safe-eval '(hello \"you\") environment: my-env)\n\n; prints:\n\nHello, you!") (p "This procedure doesn't care whether an environment is mutable (or extendable) or not."))) (section 4 "safe-environment-remove!" (def (sig (procedure "(safe-environment-remove! ENVIRONMENT ID)" (id safe-environment-remove!))) (p "Removes the binding for " (tt "ID") " in the given environment or does nothing if no such binding exists."))) (section 4 "safe-environment-macro-set!" (def (sig (procedure "(safe-environment-macro-set! ENVIRONMENT ID PROC)" (id safe-environment-macro-set!))) (p "Defines or changes the macro-expander procedure for the macro with the name " (tt "ID") " to " (tt "PROC") ", which should be a procedure of one argument, the list of arguments (unevaluated) passed to the macro."))) (section 4 "safe-environment-macro-remove!" (def (sig (procedure "(safe-environment-macro-remove! ENVIRONMENT ID)" (id safe-environment-macro-remove!))) (p "Removes the macro-binding for " (tt "ID") " in the given environment or does nothing if no such binding exists.")))) (section 3 "Example" (highlight scheme "(safe-eval 123)\n => 123\n\n(safe-eval 'abc)\n => ;; error\n\n(define env (make-safe-environment))\n(safe-eval '(+ 3 4) environment: env)\n => ;; error: environment is empty and has no parent\n\n(define env2 (make-safe-environment parent: default-safe-environment))\n(safe-eval '(+ 3 4) environment: env2)\n => 7\n\n(safe-eval '(define abc 99) environment: env2)\n(safe-eval 'abc environment: env2)\n => 99\n\n(safe-eval '(define abc 99) environment: (make-safe-environment extendable: #f))\n => ;; error\n\n(safe-eval '(set! + 100))\n => ;; error: binding not mutable\n\n(safe-eval '(set! + 100) environment: env2)\n => ;; error: the same (binding is inherited)\n\n(safe-eval '(set! abc 100) environment: env2)\n => ;; error\n\n(safe-eval '(let loop () (loop)))\n => ;; never terminates\n\n(safe-eval '(let loop () (loop)) fuel: 1000)\n => ;; error (\"out of fuel\")\n\n(safe-eval '(make-vector 100))\n => ;; a 100-element vector\n\n(safe-eval '(make-vector 100) allocation-limit: 100)\n => ;; error (\"allocation limit exceeded\")")) (section 3 "Changelog" (ul (li "1.7 setup-script fixes [Thanks to Christian, once again]") (li "1.6 ported to CHICKEN 4 [Thanks to Christian Kellermann]") (li "1.5 " (tt "apply") " didn't handle circular lists [Thanks to Goran Weinholt]") (li "1.4 Added proper setup script; uses trace-buffer and lambda-info") (li "1.3 Fixed problem with older chicken versions [Thanks to Alejandro Forero Cuervo]") (li "1.2 Keyword fix was incorrect [Thanks to Alex again]") (li "1.1 " (tt "safe-eval") " now handles keywords [Thanks to Alex Shinn]; added internal support for extended number types") (li "1.0 Initial release"))) (section 3 "License" (pre " Copyright (c) 2004, Felix L. Winkelmann\n All rights reserved.\n \n Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following\n conditions are met:\n \n   Redistributions of source code must retain the above copyright notice, this list of conditions and the following\n     disclaimer. \n   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following\n     disclaimer in the documentation and/or other materials provided with the distribution. \n   Neither the name of the author nor the names of its contributors may be used to endorse or promote\n     products derived from this software without specific prior written permission. \n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\n CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n POSSIBILITY OF SUCH DAMAGE."))))