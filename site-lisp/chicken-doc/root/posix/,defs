(index ("fcntl/dupfd" 0) ("fcntl/getfd" 0) ("fcntl/setfd" 0) ("fcntl/getfl" 0) ("fcntl/setfl" 0) ("fileno/stdin" 274) ("fileno/stdout" 274) ("fileno/stderr" 274) ("open/rdonly" 552) ("open/wronly" 552) ("open/rdwr" 552) ("open/read" 552) ("open/write" 552) ("open/creat" 552) ("open/append" 552) ("open/excl" 552) ("open/noctty" 552) ("open/nonblock" 552) ("open/trunc" 552) ("open/sync" 552) ("open/fsync" 552) ("open/binary" 552) ("open/text" 552) ("perm/irusr" 1364) ("perm/iwusr" 1364) ("perm/ixusr" 1364) ("perm/irgrp" 1364) ("perm/iwgrp" 1364) ("perm/ixgrp" 1364) ("perm/iroth" 1364) ("perm/iwoth" 1364) ("perm/ixoth" 1364) ("perm/irwxu" 1364) ("perm/irwxg" 1364) ("perm/irwxo" 1364) ("perm/isvtx" 1364) ("perm/isuid" 1364) ("perm/isgid" 1364) ("change-directory" 2044) ("current-directory" 2180) ("create-directory" 2454) ("delete-directory" 2721) ("directory" 2887) ("directory?" 3252) ("glob" 3474) ("set-root-directory!" 3785) ("call-with-input-pipe" 4071) ("call-with-output-pipe" 4071) ("close-input-pipe" 4486) ("close-output-pipe" 4486) ("create-pipe" 4775) ("open-input-pipe" 5003) ("open-output-pipe" 5341) ("with-input-from-pipe" 5703) ("with-output-to-pipe" 5703) ("create-fifo" 7160) ("fifo?" 7406) ("duplicate-fileno" 7573) ("file-close" 7883) ("file-open" 8024) ("file-mkstemp" 9167) ("file-read" 9906) ("file-select" 10335) ("file-write" 11245) ("file-control" 11555) ("open-input-file*" 11829) ("open-output-file*" 11829) ("port->fileno" 12318) ("file-access-time" 12513) ("file-change-time" 12513) ("file-modification-time" 12513) ("set!" 12513) ("file-stat" 13127) ("file-position" 14030) ("file-size" 14201) ("regular-file?" 14517) ("file-owner" 14818) ("file-permissions" 14981) ("file-read-access?" 15272) ("file-write-access?" 15272) ("file-execute-access?" 15272) ("file-type" 15632) ("character-device?" 16141) ("block-device?" 16141) ("socket?" 16141) ("file-truncate" 16569) ("set-file-position!" 16884) ("set!" 16884) ("change-file-mode" 17467) ("change-file-owner" 17818) ("current-process-id" 18114) ("parent-process-id" 18238) ("process-group-id" 18374) ("process-execute" 18524) ("process-fork" 19328) ("process-run" 19635) ("process-run" 19635) ("process-signal" 20099) ("process-wait" 20373) ("process" 21212) ("process" 21212) ("process*" 22428) ("process*" 22428) ("sleep" 22923) ("create-session" 23143) ("symbolic-link?" 23315) ("create-symbolic-link" 23559) ("read-symbolic-link" 23767) ("file-link" 24066) ("current-user-id" 24223) ("current-effective-user-id" 24392) ("user-information" 24596) ("current-group-id" 25123) ("current-effective-group-id" 25296) ("group-information" 25553) ("get-groups" 25930) ("set-groups!" 26060) ("initialize-groups" 26286) ("set-process-group-id!" 26581) ("file-lock" 26813) ("file-lock/blocking" 27302) ("file-test-lock" 27545) ("file-unlock" 27863) ("set-alarm!" 28005) ("set-signal-handler!" 28265) ("signal-handler" 28793) ("set-signal-mask!" 28945) ("signal-mask" 29203) ("signal-masked?" 29314) ("signal-mask!" 29469) ("signal-unmask!" 29599) ("signal/term" 29737) ("signal/kill" 29737) ("signal/int" 29737) ("signal/hup" 29737) ("signal/fpe" 29737) ("signal/ill" 29737) ("signal/segv" 29737) ("signal/abrt" 29737) ("signal/trap" 29737) ("signal/quit" 29737) ("signal/alrm" 29737) ("signal/vtalrm" 29737) ("signal/prof" 29737) ("signal/io" 29737) ("signal/urg" 29737) ("signal/chld" 29737) ("signal/cont" 29737) ("signal/stop" 29737) ("signal/tstp" 29737) ("signal/pipe" 29737) ("signal/xcpu" 29737) ("signal/xfsz" 29737) ("signal/usr1" 29737) ("signal/usr2" 29737) ("signal/winch" 29737) ("get-environment-variables" 31020) ("setenv" 31261) ("unsetenv" 31520) ("memory-mapped-file?" 31751) ("map-file-to-memory" 31947) ("memory-mapped-file-pointer" 32909) ("unmap-file-from-memory" 33096) ("seconds->local-time" 33538) ("local-time->seconds" 34651) ("local-timezone-abbreviation" 34913) ("seconds->string" 35069) ("seconds->utc-time" 35349) ("utc-time->seconds" 35599) ("time->string" 35828) ("string->time" 36323) ("_exit" 36799) ("errno/perm" 37113) ("errno/noent" 37113) ("errno/srch" 37113) ("errno/intr" 37113) ("errno/io" 37113) ("errno/noexec" 37113) ("errno/badf" 37113) ("errno/child" 37113) ("errno/nomem" 37113) ("errno/acces" 37113) ("errno/fault" 37113) ("errno/busy" 37113) ("errno/notdir" 37113) ("errno/isdir" 37113) ("errno/inval" 37113) ("errno/mfile" 37113) ("errno/nospc" 37113) ("errno/spipe" 37113) ("errno/pipe" 37113) ("errno/again" 37113) ("errno/rofs" 37113) ("errno/exist" 37113) ("errno/wouldblock" 37113) ("find-files" 38160) ("get-host-name" 40347) ("system-information" 40483) ("set-buffering-mode!" 40700) ("terminal-name" 41076) ("terminal-port?" 41219) ("terminal-size" 41390) ("create-pipe" 41708) ("process-wait" 41976) ("process-execute" 42246) ("process" 42246) ("process*" 42246) ("process-spawn" 42762))
(def (sig (constant "fcntl/dupfd" (id fcntl/dupfd)) (constant "fcntl/getfd" (id fcntl/getfd)) (constant "fcntl/setfd" (id fcntl/setfd)) (constant "fcntl/getfl" (id fcntl/getfl)) (constant "fcntl/setfl" (id fcntl/setfl))) (p "Operations used with " (tt "file-control") "."))
(def (sig (constant "fileno/stdin" (id fileno/stdin)) (constant "fileno/stdout" (id fileno/stdout)) (constant "fileno/stderr" (id fileno/stderr))) (p "Standard I/O file descriptor numbers, used with procedures such as " (tt "open-input-file*") " which take file descriptors."))
(def (sig (constant "open/rdonly" (id open/rdonly)) (constant "open/wronly" (id open/wronly)) (constant "open/rdwr" (id open/rdwr)) (constant "open/read" (id open/read)) (constant "open/write" (id open/write)) (constant "open/creat" (id open/creat)) (constant "open/append" (id open/append)) (constant "open/excl" (id open/excl)) (constant "open/noctty" (id open/noctty)) (constant "open/nonblock" (id open/nonblock)) (constant "open/trunc" (id open/trunc)) (constant "open/sync" (id open/sync)) (constant "open/fsync" (id open/fsync)) (constant "open/binary" (id open/binary)) (constant "open/text" (id open/text))) (p "Open flags used with the " (tt "file-open") " procedure.  " (tt "open/read") " is a convenience synonym for " (tt "open/rdonly") ", as is " (tt "open/write") " for " (tt "open/wronly") "."))
(def (sig (constant "perm/irusr" (id perm/irusr)) (constant "perm/iwusr" (id perm/iwusr)) (constant "perm/ixusr" (id perm/ixusr)) (constant "perm/irgrp" (id perm/irgrp)) (constant "perm/iwgrp" (id perm/iwgrp)) (constant "perm/ixgrp" (id perm/ixgrp)) (constant "perm/iroth" (id perm/iroth)) (constant "perm/iwoth" (id perm/iwoth)) (constant "perm/ixoth" (id perm/ixoth)) (constant "perm/irwxu" (id perm/irwxu)) (constant "perm/irwxg" (id perm/irwxg)) (constant "perm/irwxo" (id perm/irwxo)) (constant "perm/isvtx" (id perm/isvtx)) (constant "perm/isuid" (id perm/isuid)) (constant "perm/isgid" (id perm/isgid))) (p "Permission bits used with, for example, " (tt "file-open") "."))
(def (sig (procedure "(change-directory NAME)" (id change-directory))) (p "Changes the current working directory to " (tt "NAME") "."))
(def (sig (procedure "(current-directory [DIR])" (id current-directory))) (p "Returns the name of the current working directory. If the optional argument " (tt "DIR") " is given, then " (tt "(current-directory DIR)") " is equivalent to " (tt "(change-directory DIR)") "."))
(def (sig (procedure "(create-directory NAME #!optional PARENTS?)" (id create-directory))) (p "Creates a directory with the pathname " (tt "NAME") ".  If the " (tt "PARENTS?") " argument is given and not false, any nonexistent parent directories are also created."))
(def (sig (procedure "(delete-directory NAME)" (id delete-directory))) (p "Deletes the directory with the pathname " (tt "NAME") ". The directory has to be empty."))
(def (sig (procedure "(directory [PATHNAME [SHOW-DOTFILES?]])" (id directory))) (p "Returns a list with all files that are contained in the directory with the name " (tt "PATHNAME") " (which defaults to the value of " (tt "(current-directory)") "). Files beginning with " (tt ".") " are included only if " (tt "SHOW-DOTFILES?") " is given and not " (tt "#f") "."))
(def (sig (procedure "(directory? FILE)" (id directory?))) (p "Returns " (tt "#t") " if " (tt "FILE") " designates directory. Otherwise, it returns " (tt "#f") ". " (tt "FILE") " may be a pathname or a file-descriptor."))
(def (sig (procedure "(glob PATTERN1 ...)" (id glob))) (p "Returns a list of the pathnames of all existing files matching " (tt "PATTERN1 ...") ", which should be strings containing the usual file-patterns (with " (tt "*") " matching zero or more characters and " (tt "?") " matching zero or one character)."))
(def (sig (procedure "(set-root-directory! STRING)" (id set-root-directory!))) (p "Sets the root directory for the current process to the path given in " (tt "STRING") " (using the " (tt "chroot") " function). If the current process has no root permissions, the operation will fail."))
(def (sig (procedure "(call-with-input-pipe CMDLINE PROC [MODE])" (id call-with-input-pipe)) (procedure "(call-with-output-pipe CMDLINE PROC [MODE])" (id call-with-output-pipe))) (p "Call " (tt "PROC") " with a single argument: a input- or output port for a pipe connected to the subprocess named in " (tt "CMDLINE") ". If " (tt "PROC") " returns normally, the pipe is closed and any result values are returned."))
(def (sig (procedure "(close-input-pipe PORT)" (id close-input-pipe)) (procedure "(close-output-pipe PORT)" (id close-output-pipe))) (p "Closes the pipe given in " (tt "PORT") " and waits until the connected subprocess finishes. The exit-status code of the invoked process is returned."))
(def (sig (procedure "(create-pipe)" (id create-pipe))) (p "The fundamental pipe-creation operator. Calls the C function " (tt "pipe()") " and returns 2 values: the file-descriptors of the input- and output-ends of the pipe."))
(def (sig (procedure "(open-input-pipe CMDLINE [MODE])" (id open-input-pipe))) (p "Spawns a subprocess with the command-line string " (tt "CMDLINE") " and returns a port, from which the output of the process can be read. If " (tt "MODE") " is specified, it should be the keyword " (tt "#:text") " (the default) or " (tt "#:binary") "."))
(def (sig (procedure "(open-output-pipe CMDLINE [MODE])" (id open-output-pipe))) (p "Spawns a subprocess with the command-line string " (tt "CMDLINE") " and returns a port. Anything written to that port is treated as the input for the process.  If " (tt "MODE") " is specified, it should be the keyword " (tt "#:text") " (the default) or " (tt "#:binary") "."))
(def (sig (procedure "(with-input-from-pipe CMDLINE THUNK [MODE])" (id with-input-from-pipe)) (procedure "(with-output-to-pipe CMDLINE THUNK [MODE])" (id with-output-to-pipe))) (p "Temporarily set the value of " (tt "current-input-port/current-output-port") " to a port for a pipe connected to the subprocess named in " (tt "CMDLINE") " and call the procedure " (tt "THUNK") " with no arguments. After " (tt "THUNK") " returns normally the pipe is closed and the standard input-/output port is restored to its previous value and any result values are returned.") (highlight scheme "(with-output-to-pipe\n  \"gs -dNOPAUSE -sDEVICE=jpeg -dBATCH -sOutputFile=signballs.jpg -g600x600 -q -\"\n  (lambda ()\n    (print #<<EOF\n %!IOPSC-1993 %%Creator: HAYAKAWA Takashi<xxxxxxxx@xx.xxxxxx.xx.xx>\n /C/neg/d/mul/R/rlineto/E/exp/H{{cvx def}repeat}def/T/dup/g/gt/r/roll/J/ifelse 8\n H/A/copy(z&v4QX&93r9AxYQOZomQalxS2w!!O&vMYa43d6r93rMYvx2dca!D&cjSnjSnjjS3o!v&6A\n X&55SAxM1CD7AjYxTTd62rmxCnTdSST0g&12wECST!&!J0g&D1!&xM0!J0g!l&544dC2Ac96ra!m&3A\n F&&vGoGSnCT0g&wDmlvGoS8wpn6wpS2wTCpS1Sd7ov7Uk7o4Qkdw!&Mvlx1S7oZES3w!J!J!Q&7185d\n Z&lx1CS9d9nE4!k&X&MY7!&1!J!x&jdnjdS3odS!N&mmx1C2wEc!G&150Nx4!n&2o!j&43r!U&0777d\n ]&2AY2A776ddT4oS3oSnMVC00VV0RRR45E42063rNz&v7UX&UOzF!F!J![&44ETCnVn!a&1CDN!Y&0M\n V1c&j2AYdjmMdjjd!o&1r!M){( )T 0 4 3 r put T(/)g{T(9)g{cvn}{cvi}J}{($)g[]J}J\n cvx}forall/moveto/p/floor/w/div/S/add 29 H[{[{]setgray fill}for Y}for showpage\n EOF\n ) ) )"))
(def (sig (procedure "(create-fifo FILENAME [MODE])" (id create-fifo))) (p "Creates a FIFO with the name " (tt "FILENAME") " and the permission bits " (tt "MODE") ", which defaults to") (highlight scheme " (+ perm/irwxu perm/irwxg perm/irwxo)"))
(def (sig (procedure "(fifo? FILE)" (id fifo?))) (p "Returns " (tt "#t") " if " (tt "FILE") " names a FIFO. " (tt "FILE") " may be a filename or a file-descriptor."))
(def (sig (procedure "(duplicate-fileno OLD [NEW])" (id duplicate-fileno))) (p "If " (tt "NEW") " is given, then the file-descriptor " (tt "NEW") " is opened to access the file with the file-descriptor " (tt "OLD") ". Otherwise a fresh file-descriptor accessing the same file as " (tt "OLD") " is returned."))
(def (sig (procedure "(file-close FILENO)" (id file-close))) (p "Closes the input/output file with the file-descriptor " (tt "FILENO") "."))
(def (sig (procedure "(file-open FILENAME FLAGS [MODE])" (id file-open))) (p "Opens the file specified with the string " (tt "FILENAME") " and open-flags " (tt "FLAGS") " using the C function " (tt "open(2)") ". On success a file-descriptor for the opened file is returned.") (p (tt "FLAGS") " is a bitmask of " (tt "open/...") " values " (b "or") "ed together using " (tt "bitwise-ior") " (or simply added together).  You must provide exactly one of the access flags " (tt "open/rdonly") ", " (tt "open/wronly") ", or " (tt "open/rdwr") ".  Additionally, you may provide zero or more creation flags (" (tt "open/creat") ", " (tt "open/excl") ", " (tt "open/trunc") ", and " (tt "open/noctty") ") and status flags (the remaining " (tt "open/...") " values).  For example, to open a possibly new output file for appending:") (pre "(file-open \"/tmp/hen.txt\" (+ open/wronly open/append open/creat))") (p "The optional " (tt "MODE") " should be a bitmask composed of one or more permission values like " (tt "perm/irusr") " and is only relevant when a new file is created. The default mode is " (tt "perm/irwxu | perm/irgrp | perm/iroth") "."))
(def (sig (procedure "(file-mkstemp TEMPLATE-FILENAME)" (id file-mkstemp))) (p "Create a file based on the given " (tt "TEMPLATE-FILENAME") ", in which the six last characters must be " (i "XXXXXX") ".  These will be replaced with a string that makes the filename unique.  The file descriptor of the created file and the generated filename is returned.  See the " (tt "mkstemp(3)") " manual page for details on how this function works.  The template string given is not modified.") (p "Example usage:") (highlight scheme " (let-values (((fd temp-path) (file-mkstemp \"/tmp/mytemporary.XXXXXX\")))\n  (let ((temp-port (open-output-file* fd)))\n    (format temp-port \"This file is ~A.~%\" temp-path)\n    (close-output-port temp-port)))"))
(def (sig (procedure "(file-read FILENO SIZE [BUFFER])" (id file-read))) (p "Reads " (tt "SIZE") " bytes from the file with the file-descriptor " (tt "FILENO") ".  If a string or bytevector is passed in the optional argument " (tt "BUFFER") ", then this string will be destructively modified to contain the read data. This procedure returns a list with two values: the buffer containing the data and the number of bytes read."))
(def (sig (procedure "(file-select READFDLIST WRITEFDLIST [TIMEOUT])" (id file-select))) (p "Waits until any of the file-descriptors given in the lists " (tt "READFDLIST") " and " (tt "WRITEFDLIST") " is ready for input or output, respectively. If the optional argument " (tt "TIMEOUT") " is given and not false, then it should specify the number of seconds after which the wait is to be aborted (the value may be a floating point number). This procedure returns two values: the lists of file-descriptors ready for input and output, respectively. " (tt "READFDLIST") " and " (b "WRITEFDLIST") " may also by file-descriptors instead of lists.  In this case the returned values are booleans indicating whether input/output is ready by " (tt "#t") " or " (tt "#f") " otherwise.  You can also pass " (tt "#f") " as " (tt "READFDLIST") " or " (tt "WRITEFDLIST") " argument, which is equivalent to " (tt "()") "."))
(def (sig (procedure "(file-write FILENO BUFFER [SIZE])" (id file-write))) (p "Writes the contents of the string or bytevector " (tt "BUFFER") " into the file with the file-descriptor " (tt "FILENO") ". If the optional argument " (tt "SIZE") " is given, then only the specified number of bytes are written."))
(def (sig (procedure "(file-control FILENO COMMAND [ARGUMENT])" (id file-control))) (p "Performs the fcntl operation " (tt "COMMAND") " with the given " (tt "FILENO") " and optional " (tt "ARGUMENT") ". The return value is meaningful depending on the " (tt "COMMAND") "."))
(def (sig (procedure "(open-input-file* FILENO [OPENMODE])" (id open-input-file*)) (procedure "(open-output-file* FILENO [OPENMODE])" (id open-output-file*))) (p "Opens file for the file-descriptor " (tt "FILENO") " for input or output and returns a port.  " (tt "FILENO") " should be a positive exact integer. " (tt "OPENMODE") " specifies an additional mode for opening the file (currently only the keyword " (tt "#:append") " is supported, which opens an output-file for appending)."))
(def (sig (procedure "(port->fileno PORT)" (id port->fileno))) (p "If " (tt "PORT") " is a file- or tcp-port, then a file-descriptor is returned for this port. Otherwise an error is signaled."))
(def (sig (procedure "(file-access-time FILE)" (id file-access-time)) (procedure "(file-change-time FILE)" (id file-change-time)) (procedure "(file-modification-time FILE)" (id file-modification-time)) (procedure "(set! (file-modification-time FILE) SECONDS)" (id set!))) (p "Returns time (in seconds) of the last access, modification or change of " (tt "FILE") ". " (tt "FILE") " may be a filename or a file-descriptor. If the file does not exist, an error is signaled.") (p (tt "(set! (file-modification-time FILE) SECONDS)") " sets the access- and modification time of " (tt "FILE") " to " (tt "SECONDS") "."))
(def (sig (procedure "(file-stat FILE [LINK])" (id file-stat))) (p "Returns a 13-element vector with the following contents: inode-number, mode (as with " (tt "file-permissions") "), number of hard links, uid of owner (as with " (tt "file-owner") "), gid of owner, size (as with " (tt "file-size") ") and access-, change- and modification-time (as with " (tt "file-access-time") ", " (tt "file-change-time") " and " (tt "file-modification-time") ", device id, device type (for special file inode, blocksize and blocks allocated.  On Windows systems the last 4 values are undefined.") (p "By default, symbolic links are followed and the status of the referenced file is returned; however, if the optional argument " (tt "LINK") " is given and not " (tt "#f") ", the status of the link itself is returned.") (p "Note that for very large files, the " (tt "file-size") " value may be an inexact integer."))
(def (sig (procedure "(file-position FILE)" (id file-position))) (p "Returns the current file position of " (tt "FILE") ", which should be a port or a file-descriptor."))
(def (sig (procedure "(file-size FILE)" (id file-size))) (p "Returns the size of the file designated by " (tt "FILE") ".  " (tt "FILE") " may be a filename or a file-descriptor.  If the file does not exist, an error is signaled. Note that for very large files, " (tt "file-size") " may return an inexact integer."))
(def (sig (procedure "(regular-file? FILENAME)" (id regular-file?))) (p "Returns true, if " (tt "FILENAME") " names a regular file (not a directory, socket, etc.)  This operation follows symbolic links; use either " (tt "symbolic-link?") " or " (tt "file-type") " if you need to test for symlinks."))
(def (sig (procedure "(file-owner FILE)" (id file-owner))) (p "Returns the user-id of " (tt "FILE") ".  " (tt "FILE") " may be a filename or a file-descriptor."))
(def (sig (procedure "(file-permissions FILE)" (id file-permissions))) (p "Returns the permission bits for " (tt "FILE") ". You can test this value by performing bitwise operations on the result and the " (tt "perm/...") " values.  " (tt "FILE") " may be a filename or a file-descriptor."))
(def (sig (procedure "(file-read-access? FILENAME)" (id file-read-access?)) (procedure "(file-write-access? FILENAME)" (id file-write-access?)) (procedure "(file-execute-access? FILENAME)" (id file-execute-access?))) (p "These procedures return " (tt "#t") " if the current user has read, write or execute permissions on the file named " (tt "FILENAME") "."))
(def (sig (procedure "(file-type FILE [LINK [ERROR]])" (id file-type))) (p "Returns the file-type for " (tt "FILE") ", which should be a filename or file-descriptor. If " (tt "LINK") " is given and true, symbolic-links are not followed:") (pre " regular-file\n directory\n fifo\n socket\n symbolic-link\n character-device\n block-device") (p "Note that not all types are supported on every platform. If " (tt "ERROR") " is given and false, " (tt "file-type") " signals an error if the file does not exist."))
(def (sig (procedure "(character-device? FILE)" (id character-device?)) (procedure "(block-device? FILE)" (id block-device?)) (procedure "(socket? FILE)" (id socket?))) (p "These procedures return " (tt "#t") " if " (tt "FILE") " given is of the appropriate type. " (tt "FILE") " may be a filename or a file-descriptor. Note that these operations follow symbolic links. If the file does not exist, " (tt "#f") " is returned."))
(def (sig (procedure "(file-truncate FILE OFFSET)" (id file-truncate))) (p "Truncates the file " (tt "FILE") " to the length " (tt "OFFSET") ", which should be an integer. If the file-size is smaller or equal to " (tt "OFFSET") " then nothing is done.  " (tt "FILE") " should be a filename or a file-descriptor."))
(def (sig (procedure "(set-file-position! FILE POSITION [WHENCE])" (id set-file-position!)) (procedure "(set! (file-position FILE) POSITION)" (id set!))) (p "Sets the current read/write position of " (tt "FILE") " to " (tt "POSITION") ", which should be an exact integer. " (tt "FILE") " should be a port or a file-descriptor.  " (tt "WHENCE") " specifies how the position is to interpreted and should be one of the values " (tt "seek/set, seek/cur") " and " (tt "seek/end") ". It defaults to " (tt "seek/set") ".") (p "Exceptions: " (tt "(exn bounds)") ", " (tt "(exn i/o file)")))
(def (sig (procedure "(change-file-mode FILENAME MODE)" (id change-file-mode))) (p "Changes the current file mode of the file named " (tt "FILENAME") " to " (tt "MODE") " using the " (tt "chmod()") " system call.  The " (tt "perm/...") " variables contain the various permission bits and can be combinded with the " (tt "bitwise-ior") " procedure."))
(def (sig (procedure "(change-file-owner FILENAME UID GID)" (id change-file-owner))) (p "Changes the owner information of the file named " (tt "FILENAME") " to the user- and group-ids " (tt "UID") " and " (tt "GID") " (which should be exact integers) using the " (tt "chown()") " system call."))
(def (sig (procedure "(current-process-id)" (id current-process-id))) (p "Returns the process ID of the current process."))
(def (sig (procedure "(parent-process-id)" (id parent-process-id))) (p "Returns the process ID of the parent of the current process."))
(def (sig (procedure "(process-group-id PID)" (id process-group-id))) (p "Returns the process group ID of the process specified by " (tt "PID") "."))
(def (sig (procedure "(process-execute PATHNAME [ARGUMENT-LIST [ENVIRONMENT-LIST]])" (id process-execute))) (p "Creates a new child process and replaces the running process with it using the C library function " (tt "execvp(3)") ". If the optional argument " (tt "ARGUMENT-LIST") " is given, then it should contain a list of strings which are passed as arguments to the subprocess. If the optional argument " (tt "ENVIRONMENT-LIST") " is supplied, then the library function " (tt "execve(2)") " is used, and the environment passed in " (tt "ENVIRONMENT-LIST") " (which should be of the form " (tt "(\"<NAME>=<VALUE>\" ...)") " is given to the invoked process. Note that " (tt "execvp(3)") " respects the current setting of the " (tt "PATH") " environment variable while " (tt "execve(3)") " does not."))
(def (sig (procedure "(process-fork [THUNK])" (id process-fork))) (p "Creates a new child process with the UNIX system call " (tt "fork()") ". Returns either the PID of the child process or 0. If " (tt "THUNK") " is given, then the child process calls it as a procedure with no arguments and terminates."))
(def (sig (procedure "(process-run COMMANDLINE)" (id process-run)) (procedure "(process-run COMMAND ARGUMENT-LIST)" (id process-run))) (p "Creates a new child process. The PID of the new process is returned.") (ul (li "The single parameter version passes the " (tt "COMMANDLINE") " to the system shell, so usual argument expansion can take place.") (li "The multiple parameter version directly invokes the " (tt "COMMAND") " with the " (tt "ARGUMENT-LIST") ".")))
(def (sig (procedure "(process-signal PID [SIGNAL])" (id process-signal))) (p "Sends " (tt "SIGNAL") " to the process with the id " (tt "PID") " using the UNIX system call " (tt "kill()") ". " (tt "SIGNAL") " defaults to the value of the variable " (tt "signal/term") "."))
(def (sig (procedure "(process-wait [PID [NOHANG]])" (id process-wait))) (p "Suspends the current process until the child process with the id " (tt "PID") " has terminated using the UNIX system call " (tt "waitpid()") ". If " (tt "PID") " is not given, then this procedure waits for any child process. If " (tt "NOHANG") " is given and not " (tt "#f") " then the current process is not suspended.  This procedure returns three values:") (ul (li (tt "PID") " or 0, if " (tt "NOHANG") " is true and the child process has not terminated yet.") (li (tt "#t") " if the process exited normally or " (tt "#f") " otherwise.") (li "either the exit status, if the process terminated normally or the signal number that terminated/stopped the process.")) (p "Note that suspending the current process implies that all threads are suspended as well."))
(def (sig (procedure "(process COMMANDLINE)" (id process)) (procedure "(process COMMAND ARGUMENT-LIST [ENVIRONMENT-LIST])" (id process))) (p "Creates a subprocess and returns three values: an input port from which data written by the sub-process can be read, an output port from which any data written to will be received as input in the sub-process and the process-id of the started sub-process. Blocking reads and writes to or from the ports returned by " (tt "process") " only block the current thread, not other threads executing concurrently.") (ul (li "The single parameter version passes the string " (tt "COMMANDLINE") " to the host-system's shell that is invoked as a subprocess.") (li "The multiple parameter version directly invokes the " (tt "COMMAND") " as a subprocess. The " (tt "ARGUMENT-LIST") " is directly passed, as is " (tt "ENVIRONMENT-LIST") ".")) (p "Not using the shell may be preferrable for security reasons.") (p "Once both the input- and output ports are closed, an implicit " (tt "waitpid(3)") " is done to wait for the subprocess to finish or to reap a subprocess that has terminated. If the subprocess has not finished, waiting for it will necessarily block all executing threads."))
(def (sig (procedure "(process* COMMANDLINE)" (id process*)) (procedure "(process* COMMAND ARGUMENT-LIST [ENVIRONMENT-LIST])" (id process*))) (p "Like " (tt "process") " but returns 4 values: an input port from which data written by the sub-process can be read, an output port from which any data written to will be received as input in the sub-process, the process-id of the started sub-process, and an input port from which data written by the sub-process to " (tt "stderr") " can be read."))
(def (sig (procedure "(sleep SECONDS)" (id sleep))) (p "Puts the process to sleep for " (tt "SECONDS") ". Returns either 0 if the time has completely elapsed, or the number of remaining seconds, if a signal occurred."))
(def (sig (procedure "(create-session)" (id create-session))) (p "Creates a new session if the calling process is not a process group leader and returns the session ID."))
(def (sig (procedure "(symbolic-link? FILENAME)" (id symbolic-link?))) (p "Returns true, if " (tt "FILENAME") " names a symbolic link. If no such file exists, " (tt "#f") " is returned.  This operation does not follow symbolic links itself."))
(def (sig (procedure "(create-symbolic-link OLDNAME NEWNAME)" (id create-symbolic-link))) (p "Creates a symbolic link with the filename " (tt "NEWNAME") " that points to the file named " (tt "OLDNAME") "."))
(def (sig (procedure "(read-symbolic-link FILENAME [CANONICALIZE])" (id read-symbolic-link))) (p "Returns the filename to which the symbolic link " (tt "FILENAME") " points. If " (tt "CANONICALIZE") " is given and true, then symbolic links are resolved repeatedly until the result is not a link."))
(def (sig (procedure "(file-link OLDNAME NEWNAME)" (id file-link))) (p "Creates a hard link from " (tt "OLDNAME") " to " (tt "NEWNAME") " (both strings)."))
(def (sig (procedure "(current-user-id)" (id current-user-id))) (pre "[setter] (set! (current-user-id) UID)") (p "Get or set the real user-id of the current process."))
(def (sig (procedure "(current-effective-user-id)" (id current-effective-user-id))) (pre "[setter] (set! (current-effective-user-id) UID)") (p "Get or set the effective user-id of the current process."))
(def (sig (procedure "(user-information USER [AS-VECTOR])" (id user-information))) (p "If " (tt "USER") " specifes a valid username (as a string) or user ID, then the user database is consulted and a list of 7 values are returned: the user-name, the encrypted password, the user ID, the group ID, a user-specific string, the home directory and the default shell. When " (tt "AS-VECTOR") " is " (tt "#t") " a vector of 7 elements is returned instead of a list. If no user with this name or id then " (tt "#f") " is returned."))
(def (sig (procedure "(current-group-id)" (id current-group-id))) (pre "[setter] (set! (current-group-id) GID)") (p "Get or set the real group-id of the current process."))
(def (sig (procedure "(current-effective-group-id)" (id current-effective-group-id))) (pre "[setter] (set! (current-effective-group-id) GID)") (p "Get or set the effective group-id of the current process. ID can be found, then " (tt "#f") " is returned."))
(def (sig (procedure "(group-information GROUP)" (id group-information))) (p "If " (tt "GROUP") " specifies a valid group-name or group-id, then this procedure returns a list of four values: the group-name, the encrypted group password, the group ID and a list of the names of all group members. If no group with the given name or ID exists, then " (tt "#f") " is returned."))
(def (sig (procedure "(get-groups)" (id get-groups))) (p "Returns a list with the supplementary group IDs of the current user."))
(def (sig (procedure "(set-groups! GIDLIST)" (id set-groups!))) (p "Sets the supplementrary group IDs of the current user to the IDs given in the list " (tt "GIDLIST") ".") (p "Only the superuser may invoke this procedure."))
(def (sig (procedure "(initialize-groups USERNAME BASEGID)" (id initialize-groups))) (p "Sets the supplementrary group IDs of the current user to the IDs from the user with name " (tt "USERNAME") " (a string), including " (tt "BASEGID") ".") (p "Only the superuser may invoke this procedure."))
(def (sig (procedure "(set-process-group-id! PID PGID)" (id set-process-group-id!))) (pre "[setter] (set! (process-group-id PID) PGID)") (p "Sets the process group ID of the process specifed by " (tt "PID") " to " (tt "PGID") "."))
(def (sig (procedure "(file-lock PORT [START [LEN]])" (id file-lock))) (p "Locks the file associated with " (tt "PORT") " for reading or writing (according to whether " (tt "PORT") " is an input- or output-port). " (tt "START") " specifies the starting position in the file to be locked and defaults to 0. " (tt "LEN") " specifies the length of the portion to be locked and defaults to " (tt "#t") ", which means the complete file. " (tt "file-lock") " returns a " (i "lock") "-object."))
(def (sig (procedure "(file-lock/blocking PORT [START [LEN]])" (id file-lock/blocking))) (p "Similar to " (tt "file-lock") ", but if a lock is held on the file, the current process blocks (including all threads) until the lock is released."))
(def (sig (procedure "(file-test-lock PORT [START [LEN]])" (id file-test-lock))) (p "Tests whether the file associated with " (tt "PORT") " is locked for reading or writing (according to whether " (tt "PORT") " is an input- or output-port) and returns either " (tt "#f") " or the process-id of the locking process."))
(def (sig (procedure "(file-unlock LOCK)" (id file-unlock))) (p "Unlocks the previously locked portion of a file given in " (tt "LOCK") "."))
(def (sig (procedure "(set-alarm! SECONDS)" (id set-alarm!))) (p "Sets an internal timer to raise the " (tt "signal/alrm") " after " (tt "SECONDS") " are elapsed.  You can use the " (tt "set-signal-handler!") " procedure to write a handler for this signal."))
(def (sig (procedure "(set-signal-handler! SIGNUM PROC)" (id set-signal-handler!))) (p "Establishes the procedure of one argument " (tt "PROC") " as the handler for the signal with the code " (tt "SIGNUM") ". " (tt "PROC") " is called with the signal number as its sole argument. If the argument " (tt "PROC") " is " (tt "#f") " then any signal handler will be removed, and the corresponding signal set to " (tt "SIG_IGN") ".") (p "Note that is is unspecified in which thread of execution the signal handler will be invoked."))
(def (sig (procedure "(signal-handler SIGNUM)" (id signal-handler))) (p "Returns the signal handler for the code " (tt "SIGNUM") " or " (tt "#f") "."))
(def (sig (procedure "(set-signal-mask! SIGLIST)" (id set-signal-mask!))) (p "Sets the signal mask of the current process to block all signals given in the list " (tt "SIGLIST") ".  Signals masked in that way will not be delivered to the current process."))
(def (sig (procedure "(signal-mask)" (id signal-mask))) (p "Returns the signal mask of the current process."))
(def (sig (procedure "(signal-masked? SIGNUM)" (id signal-masked?))) (p "Returns whether the signal for the code " (tt "SIGNUM") " is currently masked."))
(def (sig (procedure "(signal-mask! SIGNUM)" (id signal-mask!))) (p "Masks (blocks) the signal for the code " (tt "SIGNUM") "."))
(def (sig (procedure "(signal-unmask! SIGNUM)" (id signal-unmask!))) (p "Unmasks (unblocks) the signal for the code " (tt "SIGNUM") "."))
(def (sig (constant "signal/term" (id signal/term)) (constant "signal/kill" (id signal/kill)) (constant "signal/int" (id signal/int)) (constant "signal/hup" (id signal/hup)) (constant "signal/fpe" (id signal/fpe)) (constant "signal/ill" (id signal/ill)) (constant "signal/segv" (id signal/segv)) (constant "signal/abrt" (id signal/abrt)) (constant "signal/trap" (id signal/trap)) (constant "signal/quit" (id signal/quit)) (constant "signal/alrm" (id signal/alrm)) (constant "signal/vtalrm" (id signal/vtalrm)) (constant "signal/prof" (id signal/prof)) (constant "signal/io" (id signal/io)) (constant "signal/urg" (id signal/urg)) (constant "signal/chld" (id signal/chld)) (constant "signal/cont" (id signal/cont)) (constant "signal/stop" (id signal/stop)) (constant "signal/tstp" (id signal/tstp)) (constant "signal/pipe" (id signal/pipe)) (constant "signal/xcpu" (id signal/xcpu)) (constant "signal/xfsz" (id signal/xfsz)) (constant "signal/usr1" (id signal/usr1)) (constant "signal/usr2" (id signal/usr2)) (constant "signal/winch" (id signal/winch))) (p "These variables contain signal codes for use with " (tt "process-signal") ",  " (tt "set-signal-handler!") ",  " (tt "signal-handler") ",  " (tt "signal-masked?") ",  " (tt "signal-mask!") ",  or " (tt "signal-unmask!") "."))
(def (sig (procedure "(get-environment-variables)" (id get-environment-variables))) (p "Returns a association list of the environment variables and their current values (see also " (link "http://srfi.schemers.org/srfi-98/" "SRFI-98") ")."))
(def (sig (procedure "(setenv VARIABLE VALUE)" (id setenv))) (p "Sets the environment variable named " (tt "VARIABLE") " to " (tt "VALUE") ". Both arguments should be strings. If the variable is not defined in the environment, a new definition is created."))
(def (sig (procedure "(unsetenv VARIABLE)" (id unsetenv))) (p "Removes the definition of the environment variable " (tt "VARIABLE") " from the environment of the current process. If the variable is not defined, nothing happens."))
(def (sig (procedure "(memory-mapped-file? X)" (id memory-mapped-file?))) (p "Returns " (tt "#t") ", if " (tt "X") " is an object representing a memory mapped file, or " (tt "#f") " otherwise."))
(def (sig (procedure "(map-file-to-memory ADDRESS LEN PROTECTION FLAG FILENO [OFFSET])" (id map-file-to-memory))) (p "Maps a section of a file to memory using the C function " (tt "mmap()") ".  " (tt "ADDRESS") " should be a foreign pointer object or " (tt "#f") "; " (tt "LEN") " specifies the size of the section to be mapped; " (tt "PROTECTION") " should be one or more of the flags " (tt "prot/read, prot/write, prot/exec") " or " (tt "prot/none") " " (b "bitwise-ior") "ed together; " (tt "FLAG") " should be one or more of the flags " (tt "map/fixed, map/shared, map/private, map/anonymous") " or " (tt "map/file") "; " (tt "FILENO") " should be the file-descriptor of the mapped file. The optional argument " (tt "OFFSET") " gives the offset of the section of the file to be mapped and defaults to 0. This procedure returns an object representing the mapped file section.  The procedure " (tt "move-memory!") " can be used to access the mapped memory."))
(def (sig (procedure "(memory-mapped-file-pointer MMAP)" (id memory-mapped-file-pointer))) (p "Returns a machine pointer to the start of the memory region to which the file is mapped."))
(def (sig (procedure "(unmap-file-from-memory MMAP [LEN])" (id unmap-file-from-memory))) (p "Unmaps the section of a file mapped to memory using the C function " (tt "munmap()") ".  " (tt "MMAP") " should be a mapped file as returned by the procedure " (tt "map-file-to-memory") ".  The optional argument " (tt "LEN") " specifies the length of the section to be unmapped and defaults to the complete length given when the file was mapped."))
(def (sig (procedure "(seconds->local-time [SECONDS])" (id seconds->local-time))) (p "Breaks down the time value represented in " (tt "SECONDS") " into a 10 element vector of the form " (tt "#(seconds minutes hours mday month year wday yday dstflag timezone)") ", in the following format:") (dl (dt "seconds (0)") (dd "the number of seconds after the minute (0 - 59)") (dt "minutes (1)") (dd "the number of minutes after the hour (0 - 59)") (dt "hours (2)") (dd "the number of hours past midnight (0 - 23)") (dt "mday (3)") (dd "the day of the month (1 - 31)") (dt "month (4)") (dd "the number of months since january (0 - 11)") (dt "year (5)") (dd "the number of years since 1900") (dt "wday (6)") (dd "the number of days since Sunday (0 - 6)") (dt "yday (7)") (dd "the number of days since January 1 (0 - 365)") (dt "dstflag (8)") (dd "a flag that is true if Daylight Saving Time is in effect at the time described.") (dt "timezone (9)") (dd "the difference between UTC and the latest local standard time, in seconds west of UTC.")) (p (tt "SECONDS") " defaults to the value of " (tt "(current-seconds)") "."))
(def (sig (procedure "(local-time->seconds VECTOR)" (id local-time->seconds))) (p "Converts the ten-element vector " (tt "VECTOR") " representing the time value relative to the current timezone into the number of seconds since the first of January, 1970 UTC."))
(def (sig (procedure "(local-timezone-abbreviation)" (id local-timezone-abbreviation))) (p "Returns the abbreviation for the local timezone as a string."))
(def (sig (procedure "(seconds->string [SECONDS])" (id seconds->string))) (p "Converts the local time represented in " (tt "SECONDS") " into a string of the form " (tt "\"Tue May 21 13:46:22 1991\"") ". " (tt "SECONDS") " defaults to the value of " (tt "(current-seconds)") "."))
(def (sig (procedure "(seconds->utc-time [SECONDS])" (id seconds->utc-time))) (p "Similar to " (tt "seconds->local-time") ", but interpretes " (tt "SECONDS") " as UTC time. " (tt "SECONDS") " defaults to the value of " (tt "(current-seconds)") "."))
(def (sig (procedure "(utc-time->seconds VECTOR)" (id utc-time->seconds))) (p "Converts the ten-element vector " (tt "VECTOR") " representing the UTC time value into the number of seconds since the first of January, 1970 UTC."))
(def (sig (procedure "(time->string VECTOR [FORMAT])" (id time->string))) (p "Converts the broken down time represented in the 10 element vector " (tt "VECTOR") " into a string of the form represented by the " (tt "FORMAT") " string. The default time form produces something like " (tt "\"Tue May 21 13:46:22 1991\"") ".") (p "The " (tt "FORMAT") " string follows the rules for the C library procedure " (tt "strftime") ". The default " (tt "FORMAT") " string is \"%a %b %e %H:%M:%S %Z %Y\"."))
(def (sig (procedure "(string->time TIME [FORMAT])" (id string->time))) (p "Converts a string of the form represented by the " (tt "FORMAT") " string into the broken down time represented in a 10 element vector. The default time form understands something like " (tt "\"Tue May 21 13:46:22 1991\"") ".") (p "The " (tt "FORMAT") " string follows the rules for the C library procedure " (tt "strptime") ". The default " (tt "FORMAT") " string is \"%a %b %e %H:%M:%S %Z %Y\"."))
(def (sig (procedure "(_exit [CODE])" (id _exit))) (p "Exits the current process without flushing any buffered output (using the C function " (tt "_exit") ").  Note that the " (tt "exit-handler") " is not called when this procedure is invoked. The optional return-code " (tt "CODE") " defaults to " (tt "0") "."))
(def (sig (constant "errno/perm" (id errno/perm)) (constant "errno/noent" (id errno/noent)) (constant "errno/srch" (id errno/srch)) (constant "errno/intr" (id errno/intr)) (constant "errno/io" (id errno/io)) (constant "errno/noexec" (id errno/noexec)) (constant "errno/badf" (id errno/badf)) (constant "errno/child" (id errno/child)) (constant "errno/nomem" (id errno/nomem)) (constant "errno/acces" (id errno/acces)) (constant "errno/fault" (id errno/fault)) (constant "errno/busy" (id errno/busy)) (constant "errno/notdir" (id errno/notdir)) (constant "errno/isdir" (id errno/isdir)) (constant "errno/inval" (id errno/inval)) (constant "errno/mfile" (id errno/mfile)) (constant "errno/nospc" (id errno/nospc)) (constant "errno/spipe" (id errno/spipe)) (constant "errno/pipe" (id errno/pipe)) (constant "errno/again" (id errno/again)) (constant "errno/rofs" (id errno/rofs)) (constant "errno/exist" (id errno/exist)) (constant "errno/wouldblock" (id errno/wouldblock))) (p "These variables contain error codes as returned by " (tt "errno") "."))
(def (sig (procedure "(find-files DIRECTORY #!key test action seed limit dotfiles follow-symlinks)" (id find-files))) (p "Recursively traverses the contents of " (tt "DIRECTORY") " (which should be a string) and invokes the procedure " (tt "action") " for all files in which the procedure " (tt "test") " is true.  " (tt "test") " may be a procedure of one argument or a regular-expression string that will be matched with a full pathname using " (tt "string-match") ".  " (tt "action") " should be a procedure of two arguments: the currently encountered file and the result of the previous invocation of " (tt "action") ", or, if this is the first invocation, the value of " (tt "seed") ". " (tt "test") " defaults to " (tt "(constantly #t)") ", " (tt "action") " defaults to " (tt "cons") ", " (tt "seed") " defaults to " (tt "()") ".  " (tt "limit") " should be a procedure of one argument that is called for each nested directory and which should return true, if that directory is to be traversed recursively. " (tt "limit") " may also be an exact integer that gives the maximum recursion depth. For example, a depth of " (tt "0") " means that only files in the top-level, specified directory are to be traversed. In this case, all nested directories are ignored.  " (tt "limit") " may also be " (tt "#f") " (the default), which is equivalent to " (tt "(constantly #t)") ".") (p "If " (tt "dotfiles") " is given and true, then files starting with a \"" (tt ".") "\" character will not be ignored (but note that \"" (tt ".") "\" and \"" (tt "..") "\"  are always ignored). if " (tt "follow-symlinks") " is given and true, then the traversal of a symbolic link that points to a directory will recursively traverse the latter. By default, symbolic links are not followed.") (p "Note that " (tt "action") " is called with the full pathname of each file, including the directory prefix.") (p "This procedure's signature was changed in CHICKEN 4.6.   In older versions, " (tt "find-files") " has a different signature:") (pre " (find-files DIRECTORY [TEST [ACTION [SEED [LIMIT]]]])") (p "The old signature is still supported in CHICKEN 4.6 for compatibility reasons, but is deprecated."))
(def (sig (procedure "(get-host-name)" (id get-host-name))) (p "Returns the hostname of the machine that this process is running on."))
(def (sig (procedure "(system-information)" (id system-information))) (p "Invokes the UNIX system call " (tt "uname()") " and returns a list of 5 values: system-name, node-name, OS release, OS version and machine."))
(def (sig (procedure "(set-buffering-mode! PORT MODE [BUFSIZE])" (id set-buffering-mode!))) (p "Sets the buffering-mode for the file associated with " (tt "PORT") " to " (tt "MODE") ", which should be one of the keywords " (tt "#:full") ", " (tt "#:line") " or " (tt "#:none") ". If " (tt "BUFSIZE") " is specified it determines the size of the buffer to be used (if any)."))
(def (sig (procedure "(terminal-name PORT)" (id terminal-name))) (p "Returns the name of the terminal that is connected to " (tt "PORT") "."))
(def (sig (procedure "(terminal-port? PORT)" (id terminal-port?))) (p "Returns " (tt "#t") " if " (tt "PORT") " is connected to a terminal and " (tt "#f") " otherwise."))
(def (sig (procedure "(terminal-size PORT)" (id terminal-size))) (p "Returns two values, the number of columns and rows of the terminal that is connected to " (tt "PORT") " or " (tt "0") ", " (tt "0") " if the terminal size can not be obtained. On Windows, this procedure always returns " (tt "0") ", " (tt "0") "."))
(def (sig (procedure "(create-pipe [MODE])" (id create-pipe))) (p "The optional parameter " (tt "MODE") ", default " (tt "open/binary | open/noinherit") ". This can be " (tt "open/binary") " or " (tt "open/text") ", optionally or'ed with " (tt "open/noinherit") "."))
(def (sig (procedure "(process-wait [PID [NOHANG]])" (id process-wait))) (p (tt "process-wait") " always returns " (tt "#t") " for a terminated process and only the exit status is available. (Windows does not provide signals as an interprocess communication method.)"))
(def (sig (procedure "(process-execute PATHNAME [ARGUMENT-LIST [ENVIRONMENT-LIST [EXACT-FLAG]]])" (id process-execute)) (procedure "(process COMMAND ARGUMENT-LIST [ENVIRONMENT-LIST [EXACT-FLAG]])" (id process)) (procedure "(process* COMMAND ARGUMENT-LIST [ENVIRONMENT-LIST [EXACT-FLAG]])" (id process*))) (p "The optional parameter " (tt "EXACT-FLAG") ", default " (tt "#f") ". When " (tt "#f") " any argument string with embedded whitespace will be wrapped in quotes. When " (tt "#t") " no such wrapping occurs."))
(def (sig (procedure "(process-spawn MODE COMMAND [ARGUMENT-LIST [ENVIRONMENT-LIST [EXACT-FLAG]]])" (id process-spawn))) (p "Creates and runs a new process with the given " (tt "COMMAND") " filename and the optional " (tt "ARGUMENT-LIST") " and " (tt "ENVIRONMENT-LIST") ". " (tt "MODE") " specifies how exactly the process should be executed and must be one or more of the " (tt "spawn/...") " flags defined above.") (p "The " (tt "EXACT-FLAG") ", default " (tt "#f") ", controls quote-wrapping of argument strings. When " (tt "#t") " quote-wrapping is not performed.") (p "Returns:") (ul (li "the exit status when synchronous") (li "the PID when asynchronous") (li "-1 when failure")))
