(index ("stream?" 0) ("stream-pair?" 67) ("stream-null?" 144) ("stream-occupied?" 221) ("stream-null" 348) ("stream-cons" 431) ("stream-lambda" 509) ("stream-car" 597) ("stream-cdr" 664) ("define-stream" 736) ("stream-of" 821) ("stream-let" 952) ("stream-match" 1034) ("stream" 1118) ("list->stream" 1182) ("port->stream" 1256) ("stream->list" 1353) ("stream-append" 1438) ("stream-concat" 1519) ("stream-drop" 1632) ("stream-drop-while" 1712) ("stream-filter" 1808) ("stream-fold" 1896) ("stream-for-each" 1982) ("stream-map" 2076) ("stream-from" 2160) ("stream-iterate" 2242) ("stream-length" 2329) ("stream-range" 2407) ("stream-ref" 2519) ("stream-reverse" 2592) ("stream-scan" 2672) ("stream-unfold" 2760) ("stream-unfolds" 2863) ("stream-zip" 2951) ("stream-intersperse" 3026) ("stream-permutations" 3121) ("file->stream" 3211) ("stream-split" 3308) ("stream-unique" 3406) ("stream-fold-one" 3487) ("stream-member" 3578) ("stream-merge" 3666) ("stream-partition" 3749) ("stream-finds" 3843) ("stream-find" 3929) ("stream-remove" 4013) ("stream-every" 4101) ("stream-any" 4188) ("stream-and" 4271) ("stream-or" 4344) ("stream-fold-right" 4415) ("stream-fold-right-one" 4510) ("stream-assoc" 4608) ("stream-equal?" 4695) ("stream-quick-sort" 4786) ("stream-insertion-sort" 4875) ("stream-merge-sort" 4972) ("stream-maximum" 5061) ("stream-minimum" 5139) ("binary-tree-same-fringe?" 5217) ("stream-max" 5480) ("stream-min" 5547) ("stream-sum" 5614) ("odd-numbers-stream" 5666) ("even-numbers-stream" 5734) ("cardinal-numbers-stream" 5804) ("natural-numbers-stream" 5882) ("prime-numbers-stream" 5958) ("hamming-sequence-stream" 6030))
(def (sig (procedure "(stream? OBJECT) => boolean" (id stream?))))
(def (sig (procedure "(stream-pair? OBJECT) => boolean" (id stream-pair?))))
(def (sig (procedure "(stream-null? OBJECT) => boolean" (id stream-null?))))
(def (sig (procedure "(stream-occupied? OBJECT) => boolean" (id stream-occupied?))) (p "Inverse of " (tt "stream-null?") "."))
(def (sig (constant "stream-null" (id stream-null))) (p "The null stream value."))
(def (sig (syntax "(stream-cons OBJECT STREAM) => stream" (id stream-cons))))
(def (sig (syntax "(stream-lambda FORMALS BODY ...) => procedure" (id stream-lambda))))
(def (sig (procedure "(stream-car STREAM) => *" (id stream-car))))
(def (sig (procedure "(stream-cdr STREAM) => stream" (id stream-cdr))))
(def (sig (syntax "(define-stream (NAME [FORMAL...]) BODY...)" (id define-stream))))
(def (sig (syntax "(stream-of EXPRESSION (VARIABLE in STREAM)/(VARIABLE is EXPRESSION)/PREDICATE ...) => stream" (id stream-of))))
(def (sig (syntax "(stream-let TAG ((NAME VALUE)...) BODY...)" (id stream-let))))
(def (sig (syntax "(stream-match STREAM-EXPRESSION CLAUSE...)" (id stream-match))))
(def (sig (syntax "(stream OBJECT...) => stream" (id stream))))
(def (sig (procedure "(list->stream LIST) => stream" (id list->stream))))
(def (sig (procedure "(port->stream [PORT (current-input-port)]) => stream" (id port->stream))))
(def (sig (procedure "(stream->list [COUNT #f] STREAM) => list" (id stream->list))))
(def (sig (procedure "(stream-append STREAM...) => stream" (id stream-append))))
(def (sig (procedure "(stream-concat STREAM) => stream" (id stream-concat))) (p "Flatten a stream of streams."))
(def (sig (procedure "(stream-drop COUNT STREAM) => stream" (id stream-drop))))
(def (sig (procedure "(stream-drop-while PREDICATE STREAM) => stream" (id stream-drop-while))))
(def (sig (procedure "(stream-filter PREDICATE STREAM) => stream" (id stream-filter))))
(def (sig (procedure "(stream-fold FUNCTION BASE STREAM...) => *" (id stream-fold))))
(def (sig (procedure "(stream-for-each FUNCTION STREAM...) => stream" (id stream-for-each))))
(def (sig (procedure "(stream-map FUNCTION STREAM...) => stream" (id stream-map))))
(def (sig (procedure "(stream-from FIRST [STEP 1]) => stream" (id stream-from))))
(def (sig (procedure "(stream-iterate FUNCTION BASE) => stream" (id stream-iterate))))
(def (sig (procedure "(stream-length STREAM) => FIXNUM" (id stream-length))))
(def (sig (procedure "(stream-range FIRST PAST [STEP (if (< FIRST PAST) 1 -1)]) => stream" (id stream-range))))
(def (sig (procedure "(stream-ref STREAM INDEX) => *" (id stream-ref))))
(def (sig (procedure "(stream-reverse STREAM) => stream" (id stream-reverse))))
(def (sig (procedure "(stream-scan FUNCTION BASE STREAM) => stream" (id stream-scan))))
(def (sig (procedure "(stream-unfold MAPPER PREDICATE GENERATOR BASE) => stream" (id stream-unfold))))
(def (sig (procedure "(stream-unfolds GENERATOR SEED) => stream" (id stream-unfolds))))
(def (sig (procedure "(stream-zip STREAM...) => stream" (id stream-zip))))
(def (sig (procedure "(stream-intersperse STREAM OBJECT) => stream" (id stream-intersperse))))
(def (sig (procedure "(stream-permutations STREAM) => stream" (id stream-permutations))))
(def (sig (procedure "(file->stream FILENAME [READER read-char]) => stream" (id file->stream))))
(def (sig (procedure "(stream-split COUNT STREAM) => (values STREAM STREAM)" (id stream-split))))
(def (sig (procedure "(stream-unique =? STREAM) => stream" (id stream-unique))))
(def (sig (procedure "(stream-fold-one FUNCTION STREAM) => stream" (id stream-fold-one))))
(def (sig (procedure "(stream-member =? OBJECT STREAM) => stream" (id stream-member))))
(def (sig (procedure "(stream-merge <? STREAM ...) => stream" (id stream-merge))))
(def (sig (procedure "(stream-partition PREDICATE STREAM) => stream" (id stream-partition))))
(def (sig (procedure "(stream-finds =? OBJECT STREAM) => stream" (id stream-finds))))
(def (sig (procedure "(stream-find =? OBJECT STREAM) => stream" (id stream-find))))
(def (sig (procedure "(stream-remove PREDICATE STREAM) => stream" (id stream-remove))))
(def (sig (procedure "(stream-every PREDICATE STREAM) => boolean" (id stream-every))))
(def (sig (procedure "(stream-any PREDICATE STREAM) => boolean" (id stream-any))))
(def (sig (procedure "(stream-and STREAM) => boolean" (id stream-and))))
(def (sig (procedure "(stream-or STREAM) => boolean" (id stream-or))))
(def (sig (procedure "(stream-fold-right FUNCTION BASE STREAM) => *" (id stream-fold-right))))
(def (sig (procedure "(stream-fold-right-one FUNCTION STREAM) => *" (id stream-fold-right-one))))
(def (sig (procedure "(stream-assoc KEY STREAM [=? equal?]) => *" (id stream-assoc))))
(def (sig (procedure "(stream-equal? =? STREAM1 STREAM2) => boolean" (id stream-equal?))))
(def (sig (procedure "(stream-quick-sort <? STREAM) => stream" (id stream-quick-sort))))
(def (sig (procedure "(stream-insertion-sort <? STREAM) => stream" (id stream-insertion-sort))))
(def (sig (procedure "(stream-merge-sort <? STREAM) => stream" (id stream-merge-sort))))
(def (sig (procedure "(stream-maximum <? STREAM) => *" (id stream-maximum))))
(def (sig (procedure "(stream-minimum <? STREAM) => *" (id stream-minimum))))
(def (sig (procedure "(binary-tree-same-fringe? TREE1 TREE2) => boolean" (id binary-tree-same-fringe?))) (p (tt "TREE1") " and " (tt "TREE2") " are binary-tree nodes, so either " (tt "()") " or " (tt "pair") ".") (p "Lazy version of the " (i "same fringe") "."))
(def (sig (procedure "(stream-max STREAM) => *" (id stream-max))))
(def (sig (procedure "(stream-min STREAM) => *" (id stream-min))))
(def (sig (constant "stream-sum" (id stream-sum))))
(def (sig (constant "odd-numbers-stream" (id odd-numbers-stream))))
(def (sig (constant "even-numbers-stream" (id even-numbers-stream))))
(def (sig (constant "cardinal-numbers-stream" (id cardinal-numbers-stream))))
(def (sig (constant "natural-numbers-stream" (id natural-numbers-stream))))
(def (sig (constant "prime-numbers-stream" (id prime-numbers-stream))))
(def (sig (constant "hamming-sequence-stream" (id hamming-sequence-stream))))
