(index ("thread-reap!" 0) ("thread-reaper-stop!" 123) ("thread-reaper-timeout" 270) ("thread-reaper-timeout" 270) ("thread-reaper-retries" 694) ("thread-reaper-retries" 694) ("thread-reaper-greedy" 958) ("thread-reaper-greedy" 958) ("thread-reaper-quantum" 1301) ("thread-reaper-quantum" 1301) ("thread-reaper-shutdown?" 1551) ("print-exception-error" 1678) ("print-exception-warning" 2274) ("thread-warning-message" 2663) ("thread-timeout?" 2832) ("check-timeout" 2832) ("error-timeout" 2832) ("make-thread-timeout" 3271) ("check-thread" 3795) ("error-thread" 3795) ("thread-created?" 4018) ("thread-ready?" 4018) ("thread-running?" 4018) ("thread-blocked?" 4018) ("thread-suspended?" 4018) ("thread-sleeping?" 4018) ("thread-terminated?" 4018) ("thread-dead?" 4018) ("thread-obstructed?" 4655) ("thread-state=?" 4796) ("thread-blocked?/termination" 4972) ("thread-blocked?/io" 4972) ("thread-blocked?/timeout" 4972) ("thread-unblock!" 5307))
(def (sig (procedure "(thread-reap! THREAD)" (id thread-reap!))) (p "Queues the supplied " (tt "THREAD") " for reaping."))
(def (sig (procedure "(thread-reaper-stop!)" (id thread-reaper-stop!))) (p "Processes any threads queued for reaping and terminates the reaper."))
(def (sig (procedure "(thread-reaper-timeout) => (or #f number)" (id thread-reaper-timeout)) (procedure "(thread-reaper-timeout SECONDS)" (id thread-reaper-timeout))) (p "Gets and sets the number of seconds to wait for a thread to quit. The default is " (tt "#f") " or wait till termination. Should threads submitted to the reaper be known to \"run off with the cpu\" then something other than wait forever is warranted."))
(def (sig (procedure "(thread-reaper-retries) => fixnum" (id thread-reaper-retries)) (procedure "(thread-reaper-retries SECONDS)" (id thread-reaper-retries))) (p "Gets and sets the number of attempts to wait for a thread to quit.") (p "Default is " (tt "1") "."))
(def (sig (procedure "(thread-reaper-greedy) => boolean" (id thread-reaper-greedy)) (procedure "(thread-reaper-greedy FLAG)" (id thread-reaper-greedy))) (p "Gets and sets the reaper greedy mode. When greedy the queue is exhausted whenever possible. Otherwise only one queue item is processed per time-slice.") (p "Default is " (tt "#f") "."))
(def (sig (procedure "(thread-reaper-quantum) => number" (id thread-reaper-quantum)) (procedure "(thread-reaper-quantum MILLISECONDS)" (id thread-reaper-quantum))) (p "Gets and sets the time-slice for the reaper.") (p "Default is " (tt "2500") "."))
(def (sig (procedure "(thread-reaper-shutdown?) => boolean" (id thread-reaper-shutdown?))) (p "Is the reaper shutting down?"))
(def (sig (procedure "(print-exception-error EXN [THREAD [PORT]])" (id print-exception-error))) (p "Prints the error " (tt "EXN") " and the current call chain. The message header is supplied by " (tt "thread-warning-message") ". This routine duplicates the uncaught exception in a thread handling behavior of Chicken. Useful for caught exceptions that cannot in fact be handled.") (p "The " (tt "EXN") " is a " (tt "condition") " or any other object. The default for " (tt "THREAD") " is the " (tt "(current-thread)") ". The default for " (tt "PORT") " is the " (tt "(current-error-port)") "."))
(def (sig (procedure "(print-exception-warning EXN [THREAD [PORT]])" (id print-exception-warning))) (p "Invokes " (tt "print-exception-error") " when warnings are enabled.") (p "The " (tt "EXN") " is a " (tt "condition") " or any other object. The default for " (tt "THREAD") " is the " (tt "(current-thread)") ". The default for " (tt "PORT") " is the " (tt "(current-error-port)") "."))
(def (sig (procedure "(thread-warning-message THREAD) => string" (id thread-warning-message))) (p "Returns the " (tt "string") " " (tt "\"Warning (<THREAD>): \"") "."))
(def (sig (procedure "(thread-timeout? OBJECT) => boolean" (id thread-timeout?)) (procedure "(check-timeout LOCATION OBJECT [ARGUMENT-NAME]) => (or #f time number)" (id check-timeout)) (procedure "(error-timeout LOCATION OBJECT [ARGUMENT-NAME])" (id error-timeout))) (p "Is the " (tt "OBJECT") " a " (tt "thread-timeout") " object? A " (tt "thread-timeout") " is " (tt "#f") ", a " (tt "number") ", or a SRFI 18 " (tt "time") " object."))
(def (sig (procedure "(make-thread-timeout OFFSET [BASE]) => (or #f time)" (id make-thread-timeout))) (p "Returns the SRFI 18 " (tt "time") " object representing the " (tt "OFFSET") " + " (tt "BASE") ". The " (tt "BASE") " is a " (tt "thread-timeout") " object with default " (tt "(current-time)") ".") (p "Should " (tt "OFFSET") " be " (tt "#f") " or a " (tt "time") " object the " (tt "BASE") " is ignored and " (tt "OFFSET") " is returned. Assumes an absolute " (tt "OFFSET") " indicates a timeout already calculated."))
(def (sig (procedure "(check-thread LOCATION OBJECT [ARGUMENT-NAME]) => thread" (id check-thread)) (procedure "(error-thread LOCATION OBJECT [ARGUMENT-NAME])" (id error-thread))) (p "Type checking for " (tt "thread") "."))
(def (sig (procedure "(thread-created? THREAD) => boolean" (id thread-created?)) (procedure "(thread-ready? THREAD) => boolean" (id thread-ready?)) (procedure "(thread-running? THREAD) => boolean" (id thread-running?)) (procedure "(thread-blocked? THREAD) => boolean" (id thread-blocked?)) (procedure "(thread-suspended? THREAD) => boolean" (id thread-suspended?)) (procedure "(thread-sleeping? THREAD) => boolean" (id thread-sleeping?)) (procedure "(thread-terminated? THREAD) => boolean" (id thread-terminated?)) (procedure "(thread-dead? THREAD) => boolean" (id thread-dead?))) (p "Is the " (tt "THREAD") " in the indicated state?"))
(def (sig (procedure "(thread-obstructed? THREAD) => boolean" (id thread-obstructed?))) (p "Is the " (tt "THREAD") " blocked or sleeping?"))
(def (sig (procedure "(thread-state=? THREAD TOKEN) => boolean" (id thread-state=?))) (p "Does the state token of the " (tt "THREAD") " equal the supplied " (tt "TOKEN") "."))
(def (sig (procedure "(thread-blocked?/termination THREAD) => boolean" (id thread-blocked?/termination)) (procedure "(thread-blocked?/io THREAD) => boolean" (id thread-blocked?/io)) (procedure "(thread-blocked?/timeout THREAD) => boolean" (id thread-blocked?/timeout))) (p "Is the " (tt "THREAD") " in the indicated blocking state?"))
(def (sig (procedure "(thread-unblock! THREAD)" (id thread-unblock!))) (p "Attempts to " (i "cleanly") " unblock the " (tt "THREAD") ".") (p "Currently only threads blocked for timeout can be unblocked. Threads blocked for any other reason are ignored."))
