(index ("address->pointer" 0) ("allocate" 195) ("free" 474) ("null-pointer" 708) ("null-pointer?" 825) ("object->pointer" 1034) ("pointer->object" 1340) ("pointer?" 1611) ("pointer-like?" 1757) ("pointer=?" 1918) ("pointer->address" 2148) ("pointer+" 2312) ("align-to-word" 2613) ("pointer-u8-ref" 2956) ("pointer-s8-ref" 3108) ("pointer-u16-ref" 3258) ("pointer-s16-ref" 3422) ("pointer-u32-ref" 3584) ("pointer-s32-ref" 3748) ("pointer-f32-ref" 3910) ("pointer-f64-ref" 4063) ("pointer-u8-set!" 4217) ("set!" 4217) ("pointer-s8-set!" 4443) ("set!" 4443) ("pointer-u16-set!" 4667) ("set!" 4667) ("pointer-s16-set!" 4906) ("set!" 4906) ("pointer-u32-set!" 5143) ("set!" 5143) ("pointer-s32-set!" 5382) ("set!" 5382) ("pointer-f32-set!" 5612) ("set!" 5612) ("pointer-f64-set!" 5856) ("set!" 5856) ("tag-pointer" 6100) ("tagged-pointer?" 6403) ("pointer-tag" 6744) ("make-locative" 7019) ("make-weak-locative" 7381) ("locative?" 7677) ("locative-ref" 7819) ("locative-set!" 8101) ("set!" 8101) ("locative->object" 8397) ("extend-procedure" 8690) ("extended-procedure?" 9107) ("procedure-data" 9296) ("set-procedure-data!" 9510) ("vector-like?" 10068) ("block-ref" 10233) ("block-set!" 10404) ("set!" 10404) ("number-of-slots" 10664) ("number-of-bytes" 10828) ("object-copy" 11025) ("move-memory!" 11233) ("object-evict" 12153) ("object-evict-to-location" 13341) ("object-evicted?" 14054) ("object-release" 14233) ("object-unevict" 14541) ("object-size" 14856) ("global-bound?" 15009) ("global-ref" 15231) ("global-set!" 15675) ("set!" 15675) ("make-record-instance" 15876) ("record-instance?" 16651) ("record-instance-type" 16935) ("record-instance-length" 17151) ("record-instance-slot" 17417) ("record-instance-slot-set!" 17745) ("set!" 17745) ("record->vector" 18151) ("object-become!" 18387) ("mutate-procedure" 19147))
(def (sig (procedure "(address->pointer ADDRESS)" (id address->pointer))) (p "Creates a new foreign pointer object initialized to point to the address given in the integer " (tt "ADDRESS") "."))
(def (sig (procedure "(allocate BYTES)" (id allocate))) (p "Returns a foreign pointer object to a freshly allocated region of static memory.") (p "This procedure could be defined as follows:") (highlight scheme "(define allocate (foreign-lambda c-pointer \"malloc\" integer))"))
(def (sig (procedure "(free POINTER)" (id free))) (p "Frees the memory pointed to by " (tt "POINTER") ".") (p "This procedure could be defined as follows:") (highlight scheme "(define free (foreign-lambda void \"free\" c-pointer))"))
(def (sig (procedure "(null-pointer)" (id null-pointer))) (p "Another way to say " (tt "(address->pointer 0)") "."))
(def (sig (procedure "(null-pointer? POINTER*)" (id null-pointer?))) (p "Returns " (tt "#t") " if the pointer-like object " (tt "POINTER*") " contains a " (tt "NULL") " pointer, or " (tt "#f") " otherwise."))
(def (sig (procedure "(object->pointer X)" (id object->pointer))) (p "Returns a foreign pointer object pointing to the Scheme object X, which should be a non-immediate object. (\"foreign\" here is a bit of a misnomer.)") (p "Note that data in the garbage collected heap moves during garbage collection."))
(def (sig (procedure "(pointer->object POINTER)" (id pointer->object))) (p "Returns the Scheme object pointed to by the pointer object " (tt "POINTER") ".") (p "Whether the " (tt "POINTER") " actually points to a Scheme object is not guaranteed. Use at your own risk."))
(def (sig (procedure "(pointer? X)" (id pointer?))) (p "Returns " (tt "#t") " if " (tt "X") " is a pointer object, or " (tt "#f") " otherwise."))
(def (sig (procedure "(pointer-like? X)" (id pointer-like?))) (p "Returns " (tt "#t") " if " (tt "X") " is a pointer-like object, or " (tt "#f") " otherwise."))
(def (sig (procedure "(pointer=? POINTER*1 POINTER*2)" (id pointer=?))) (p "Returns " (tt "#t") " if the pointer-like objects " (tt "POINTER*1") " and " (tt "POINTER*2") " point to the same address, or " (tt "#f") " otherwise."))
(def (sig (procedure "(pointer->address POINTER*)" (id pointer->address))) (p "Returns the address, to which the pointer-like object " (tt "POINTER*") " points."))
(def (sig (procedure "(pointer+ POINTER* N)" (id pointer+))) (p "Returns a new foreign pointer object representing the pointer-like object " (tt "POINTER*") " address value increased by the byte-offset " (tt "N") ".") (p "Use of anything other than a pointer object as an argument is questionable."))
(def (sig (procedure "(align-to-word POINTER*-OR-INT)" (id align-to-word))) (p "Accepts either a pointer-like object or an integer as the argument and returns a new foreign pointer or integer aligned to the native word size of the host platform.") (p "Use of anything other than an integer or pointer object as an argument is questionable."))
(def (sig (procedure "(pointer-u8-ref POINTER)" (id pointer-u8-ref))) (p "Returns the unsigned byte at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-s8-ref POINTER)" (id pointer-s8-ref))) (p "Returns the signed byte at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-u16-ref POINTER)" (id pointer-u16-ref))) (p "Returns the unsigned 16-bit integer at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-s16-ref POINTER)" (id pointer-s16-ref))) (p "Returns the signed 16-bit integer at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-u32-ref POINTER)" (id pointer-u32-ref))) (p "Returns the unsigned 32-bit integer at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-s32-ref POINTER)" (id pointer-s32-ref))) (p "Returns the signed 32-bit integer at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-f32-ref POINTER)" (id pointer-f32-ref))) (p "Returns the 32-bit float at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-f64-ref POINTER)" (id pointer-f64-ref))) (p "Returns the 64-bit double at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-u8-set! POINTER N)" (id pointer-u8-set!)) (procedure "(set! (pointer-u8-ref POINTER) N)" (id set!))) (p "Stores the unsigned byte " (tt "N") " at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-s8-set! POINTER N)" (id pointer-s8-set!)) (procedure "(set! (pointer-s8-ref POINTER) N)" (id set!))) (p "Stores the signed byte " (tt "N") " at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-u16-set! POINTER N)" (id pointer-u16-set!)) (procedure "(set! (pointer-u16-ref POINTER) N)" (id set!))) (p "Stores the unsigned 16-bit integer " (tt "N") " at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-s16-set! POINTER N)" (id pointer-s16-set!)) (procedure "(set! (pointer-s16-ref POINTER) N)" (id set!))) (p "Stores the signed 16-bit integer " (tt "N") " at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-u32-set! POINTER N)" (id pointer-u32-set!)) (procedure "(set! (pointer-u32-ref POINTER) N)" (id set!))) (p "Stores the unsigned 32-bit integer " (tt "N") " at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-s32-set! POINTER N)" (id pointer-s32-set!)) (procedure "(set! (pointer-s32-ref POINTER) N)" (id set!))) (p "Stores the 32-bit integer " (tt "N") " at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-f32-set! POINTER N)" (id pointer-f32-set!)) (procedure "(set! (pointer-f32-ref POINTER) N)" (id set!))) (p "Stores the 32-bit floating-point number " (tt "N") " at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(pointer-f64-set! POINTER N)" (id pointer-f64-set!)) (procedure "(set! (pointer-f64-ref POINTER) N)" (id set!))) (p "Stores the 64-bit floating-point number " (tt "N") " at the address designated by " (tt "POINTER") "."))
(def (sig (procedure "(tag-pointer POINTER* TAG)" (id tag-pointer))) (p "Creates a new tagged foreign pointer object from the pointer-like object " (tt "POINTER*") " with the tag " (tt "TAG") ", which may an arbitrary Scheme object.") (p "Use of anything other than a pointer object is questionable."))
(def (sig (procedure "(tagged-pointer? X [TAG])" (id tagged-pointer?))) (p "Returns " (tt "#t") " if " (tt "X") " is a tagged foreign pointer object, or " (tt "#f") " otherwise.") (p "Further, returns " (tt "#t") " when " (tt "X") " has the optional tag " (tt "TAG") " (using an " (tt "equal?") " comparison), or " (tt "#f") " otherwise."))
(def (sig (procedure "(pointer-tag POINTER*)" (id pointer-tag))) (p "If " (tt "POINTER") " is a tagged foreign pointer object, its tag is returned. If " (tt "POINTER*") " is any other kind of pointer-like object " (tt "#f") " is returned. Otherwise an error is signalled."))
(def (sig (procedure "(make-locative OBJ [INDEX])" (id make-locative))) (p "Creates a locative that refers to the element of the non-immediate object " (tt "OBJ") " at position " (tt "INDEX") ". " (tt "OBJ") " may be a vector, pair, string, blob, SRFI-4 number-vector, or record structure. " (tt "INDEX") " should be a fixnum. " (tt "INDEX") " defaults to 0."))
(def (sig (procedure "(make-weak-locative OBJ [INDEX])" (id make-weak-locative))) (p "Creates a " (i "weak") " locative. Even though the locative refers to an element of a container object, the container object will still be reclaimed by garbage collection if no other references to it exist."))
(def (sig (procedure "(locative? X)" (id locative?))) (p "Returns " (tt "#t") " if " (tt "X") " is a locative, or " (tt "#f") " otherwise."))
(def (sig (procedure "(locative-ref LOC)" (id locative-ref))) (p "Returns the element to which the locative " (tt "LOC") " refers. If the containing object has been reclaimed by garbage collection, an error is signalled.") (pre "(locative-ref (make-locative \"abc\" 1)) ==> #\\b"))
(def (sig (procedure "(locative-set! LOC X)" (id locative-set!)) (procedure "(set! (locative-ref LOC) X)" (id set!))) (p "Changes the element to which the locative " (tt "LOC") " refers to " (tt "X") ". If the containing object has been reclaimed by garbage collection, an error is signalled."))
(def (sig (procedure "(locative->object LOC)" (id locative->object))) (p "Returns the object that contains the element referred to by " (tt "LOC") " or " (tt "#f") " if the container has been reclaimed by garbage collection.") (pre "(locative->object (make-locative \"abc\" 1)) ==> \"abc\""))
(def (sig (procedure "(extend-procedure PROCEDURE X)" (id extend-procedure))) (p "Returns a copy of the procedure " (tt "PROCEDURE") " which contains an additional data slot initialized to " (tt "X") ". If " (tt "PROCEDURE") " is already an extended procedure, then its data slot is changed to contain " (tt "X") " and the same procedure is returned. Signals an error when " (tt "PROCEDURE") " is not a procedure."))
(def (sig (procedure "(extended-procedure? PROCEDURE)" (id extended-procedure?))) (p "Returns " (tt "#t") " if " (tt "PROCEDURE") " is an extended procedure, or " (tt "#f") " otherwise."))
(def (sig (procedure "(procedure-data PROCEDURE)" (id procedure-data))) (p "Returns the data object contained in the extended procedure " (tt "PROCEDURE") ", or " (tt "#f") " if it is not an extended procedure."))
(def (sig (procedure "(set-procedure-data! PROCEDURE X)" (id set-procedure-data!))) (p "Changes the data object contained in the extended procedure " (tt "PROCEDURE") " to " (tt "X") ". Signals an error when " (tt "PROCEDURE") " is not an extended procedure.") (highlight scheme "(define foo\n  (letrec ((f (lambda () (procedure-data x)))\n           (x #f) )\n    (set! x (extend-procedure f 123))\n    x) )\n(foo)                                         ==> 123\n(set-procedure-data! foo 'hello)\n(foo)                                         ==> hello"))
(def (sig (procedure "(vector-like? X)" (id vector-like?))) (p "Returns " (tt "#t") " when " (tt "X") " is a vector-like object, returns " (tt "#f") " otherwise."))
(def (sig (procedure "(block-ref VECTOR* INDEX)" (id block-ref))) (p "Returns the contents of the " (tt "INDEX") "th slot of the vector-like object " (tt "VECTOR*") "."))
(def (sig (procedure "(block-set! VECTOR* INDEX X)" (id block-set!)) (procedure "(set! (block-ref VECTOR* INDEX) X)" (id set!))) (p "Sets the contents of the " (tt "INDEX") "th slot of the vector-like object " (tt "VECTOR*") " to the value of " (tt "X") "."))
(def (sig (procedure "(number-of-slots VECTOR*)" (id number-of-slots))) (p "Returns the number of slots that the vector-like object " (tt "VECTOR*") " contains."))
(def (sig (procedure "(number-of-bytes BLOCK)" (id number-of-bytes))) (p "Returns the number of bytes that the object " (tt "BLOCK") " contains. " (tt "BLOCK") " may be any non-immediate value."))
(def (sig (procedure "(object-copy X)" (id object-copy))) (p "Copies " (tt "X") " recursively and returns the fresh copy. Objects allocated in static memory are copied back into garbage collected storage."))
(def (sig (procedure "(move-memory! FROM TO [BYTES [FROM-OFFSET [TO-OFFSET]]])" (id move-memory!))) (p "Copies " (tt "BYTES") " bytes of memory from " (tt "FROM") " to " (tt "TO") ". " (tt "FROM") " and " (tt "TO") " may be strings, blobs, " (int-link "Unit srfi-4" "SRFI-4 number-vectors") ", memory mapped files, foreign pointers (as obtained from a call to " (tt "foreign-lambda") ", for example), tagged-pointers or locatives. if " (tt "BYTES") " is not given and the size of the source or destination operand is known then the maximal number of bytes will be copied. Moving memory to the storage returned by locatives will cause havoc, if the locative refers to containers of non-immediate data, like vectors or pairs.") (p "The additional fourth and fifth argument specify starting offsets (in bytes) for the source and destination arguments.") (p "Signals an error if any of the above constraints is violated."))
(def (sig (procedure "(object-evict X [ALLOCATOR])" (id object-evict))) (p "Copies the object " (tt "X") " recursively into the memory pointed to by the foreign pointer object returned by " (tt "ALLOCATOR") ", which should be a procedure of a single argument (the number of bytes to allocate). The freshly copied object is returned.") (p "This facility allows moving arbitrary objects into static memory, but care should be taken when mutating evicted data: setting slots in evicted vector-like objects to non-evicted data is not allowed. It " (b "is") " possible to set characters/bytes in evicted strings or byte-vectors, though.  It is advisable " (b "not") " to evict ports, because they might be mutated by certain file-operations.  " (tt "object-evict") " is able to handle circular and shared structures, but evicted symbols are no longer unique: a fresh copy of the symbol is created, so") (highlight scheme "(define x 'foo)\n(define y (object-evict 'foo))\ny                              ==> foo\n(eq? x y)                      ==> #f\n(define z (object-evict '(bar bar)))\n(eq? (car z) (cadr z))         ==> #t") (p "The " (tt "ALLOCATOR") " defaults to " (tt "allocate") "."))
(def (sig (procedure "(object-evict-to-location X POINTER* [LIMIT])" (id object-evict-to-location))) (p "As " (tt "object-evict") " but moves the object at the address pointed to by the pointer-like object " (tt "POINTER*") ". If the number of copied bytes exceeds the optional " (tt "LIMIT") " then an error is signalled (specifically a composite condition of types " (tt "exn") " and " (tt "evict") ". The latter provides a " (tt "limit") " property which holds the exceeded limit. Two values are returned: the evicted object and a new pointer pointing to the first free address after the evicted object.") (p "Use of anything other than a pointer object as the " (tt "POINTER*") " argument is questionable."))
(def (sig (procedure "(object-evicted? X)" (id object-evicted?))) (p "Returns " (tt "#t") " if " (tt "X") " is a non-immediate evicted data object, or " (tt "#f") " otherwise."))
(def (sig (procedure "(object-release X [RELEASER])" (id object-release))) (p "Frees memory occupied by the evicted object " (tt "X") " recursively. " (tt "RELEASER") " should be a procedure of a single argument (a foreign pointer object to the static memory to be freed) and defaults to " (tt "free") "."))
(def (sig (procedure "(object-unevict X [FULL])" (id object-unevict))) (p "Copies the object " (tt "X") " and nested objects back into the normal Scheme heap. Symbols are re-interned into the symbol table. Strings and byte-vectors are " (b "not") " copied, unless " (tt "FULL") " is given and not " (tt "#f") "."))
(def (sig (procedure "(object-size X)" (id object-size))) (p "Returns the number of bytes that would be needed to evict the data object " (tt "X") "."))
(def (sig (procedure "(global-bound? SYMBOL)" (id global-bound?))) (p "Returns " (tt "#t") ", if the global (" (i "toplevel") ") variable with the name " (tt "SYMBOL") " is bound to a value, or " (tt "#f") " otherwise."))
(def (sig (procedure "(global-ref SYMBOL)" (id global-ref))) (p "Returns the value of the global variable " (tt "SYMBOL") ". If no variable under that name is bound, an error is signalled.") (p "Note that it is not possible to access a toplevel binding with " (tt "global-ref") " or " (tt "global-set!") " if it has been hidden in compiled code via " (tt "(declare (hide ...))") ", or if the code has been compiled in " (tt "block") " mode."))
(def (sig (procedure "(global-set! SYMBOL X)" (id global-set!)) (procedure "(set! (global-ref SYMBOL) X)" (id set!))) (p "Sets the global variable named " (tt "SYMBOL") " to the value " (tt "X") "."))
(def (sig (procedure "(make-record-instance SYMBOL ARG1 ...)" (id make-record-instance))) (p "Returns a new instance of the record type " (tt "SYMBOL") ", with its slots initialized to " (tt "ARG1 ...") ".  To illustrate:") (highlight scheme "(define-record-type point (make-point x y) point?\n  (x point-x point-x-set!)\n  (y point-y point-y-set!))") (p "expands into something quite similar to:") (highlight scheme "(begin\n  (define (make-point x y)\n    (make-record-instance 'point x y) )\n  (define (point? x)\n    (and (record-instance? x)\n         (eq? 'point (block-ref x 0)) ) )\n  (define (point-x p) (block-ref p 1))\n  (define (point-x-set! p x) (block-set! p 1 x))\n  (define (point-y p) (block-ref p 2))\n  (define (point-y-set! p y) (block-set! p 1 y)) )"))
(def (sig (procedure "(record-instance? X [SYMBOL])" (id record-instance?))) (p "Returns " (tt "#t") " if " (tt "X") " is a record structure, or " (tt "#f") " otherwise.") (p "Further, returns " (tt "#t") " if " (tt "X") " is of type " (tt "SYMBOL") ", or " (tt "#f") " otherwise."))
(def (sig (procedure "(record-instance-type RECORD)" (id record-instance-type))) (p "Returns type symbol of the record structure " (tt "RECORD") ". Signals an error if " (tt "RECORD") " is not a record structure."))
(def (sig (procedure "(record-instance-length RECORD)" (id record-instance-length))) (p "Returns number of slots for the record structure " (tt "RECORD") ". The record-instance type is not counted. Signals an error if " (tt "RECORD") " is not a record structure."))
(def (sig (procedure "(record-instance-slot RECORD INDEX)" (id record-instance-slot))) (p "Returns the contents of the " (tt "INDEX") "th slot of the record structure " (tt "RECORD") ". The slot index range is the open interval (([0 record-instance-length)}}. Signals an error if " (tt "RECORD") " is not a record structure."))
(def (sig (procedure "(record-instance-slot-set! RECORD INDEX X)" (id record-instance-slot-set!)) (procedure "(set! (record-instance-slot RECORD INDEX) X)" (id set!))) (p "Sets the " (tt "INDEX") "th slot of the record structure " (tt "RECORD") " to " (tt "X") ". The slot index range is the open interval (([0 record-instance-length)}}. Signals an error if " (tt "RECORD") " is not a record structure."))
(def (sig (procedure "(record->vector RECORD)" (id record->vector))) (p "Returns a new vector with the type and the elements of the record structure " (tt "RECORD") ". Signals an error if " (tt "RECORD") " is not a record structure."))
(def (sig (procedure "(object-become! ALIST)" (id object-become!))) (p "Changes the identity of the value of the car of each pair in " (tt "ALIST") " to the value of the cdr. Both values may not be immediate (i.e. exact integers, characters, booleans or the empty list).") (highlight scheme "(define x \"i used to be a string\")\n(define y '#(and now i am a vector))\n(object-become! (list (cons x y)))\nx                                    ==> #(and now i am a vector)\ny                                    ==> #(and now i am a vector)\n(eq? x y)                            ==> #t") (p "Note: this operation invokes a major garbage collection.") (p "The effect of using " (tt "object-become!") " on evicted data (see " (tt "object-evict") ") is undefined."))
(def (sig (procedure "(mutate-procedure OLD PROC)" (id mutate-procedure))) (p "Replaces the procedure " (tt "OLD") " with the result of calling the one-argument procedure " (tt "PROC") ". " (tt "PROC") " will receive a copy of " (tt "OLD") " that will be identical in behaviour to the result of " (tt "PROC") ":") (highlight scheme " ;;; Replace arbitrary procedure with tracing one:\n\n (mutate-procedure my-proc\n   (lambda (new)\n     (lambda args\n       (printf \"~s called with arguments: ~s~%\" new args)\n       (apply new args) ) ) )"))
