((tags "egg") (section 2 "expat" (toc) (section 3 "Description" (p "An interface to James Clarks' " (link "http://www.libexpat.org" "Expat") " XML parser.")) (section 3 "Author" (p (int-link "/users/felix winkelmann" "felix winkelmann") "; ported to Chicken 4 by " (int-link "/users/ecloud" "Shawn Rutledge"))) (section 3 "Requirements" (ul (li (int-link "silex")) (li (int-link "easyffi")))) (section 3 "Download" (p (link "http://www.call-with-current-continuation.org/eggs/expat.egg" "expat.egg"))) (section 3 "Documentation" (p "Expat is a stream-oriented parser. You register callback (or handler) functions with the parser and then start feeding it the document. As the parser recognizes parts of the document, it will call the appropriate handler for that part (if you've registered one.) The document is fed to the parser in pieces, so you can start parsing before you have all the document. This also allows you to parse really huge documents that won't fit into memory.") (p "If you want to parse an entire document into memory or if you need more bells and whistles, you should take a look at Oleg Kiselyov's " (int-link "ssax" "SSAX") " parser.") (section 4 "expat:make-parser" (def (sig (procedure "(expat:make-parser #!key (encoding #f) (namespaces #f) (namespace-separator #\\:))" (id expat:make-parser))) (p "Creates a parser object with the specified attributes. " (tt "encoding") " should be a string designating the encoding of the document and should be one of the following:") (ul (li "UTF-8") (li "UTF-16") (li "ISO-8859-1") (li "US-ASCII ")) (p "If no encoding or " (tt "#f") " is given, then the encoding specified in the document.  Note that the strings passed to the handlers are always UTF-8 encoded.") (p "If " (tt "namespaces") " is true, then namespace declarations are properly recognized and tags belonging to a namespace will be prefixed with the namespace string and the character given in " (tt "namespace-separator") "."))) (section 4 "expat:make-external-entity-parser" (def (sig (procedure "(expat:make-external-entity-parser PARSER CONTEXT #!key (encoding #f))" (id expat:make-external-entity-parser))) (p "Creates a parser to recursively process external entities."))) (section 4 "expat:destroy-parser" (def (sig (procedure "(expat:destroy-parser PARSER)" (id expat:destroy-parser))) (p "Releases the memory resources associated with PARSER."))) (section 4 "expat:parse" (def (sig (procedure "(expat:parse PARSER STRING #!key length (final #t) (external-entities #f))" (id expat:parse))) (p "Parses a piece of XML document given in " (tt "STRING") ". If " (tt "length") " is given, then it specifies the number of bytes to parse.  If " (tt "final") " is true, then the string is the last piece of the document. " (tt "LENGTH") " defaults to " (tt "(string-length STRING)") ".") (p "Returns " (tt "#t") " on success, or triggers and exception of the kinds " (tt "(exn expat)") ".  If " (tt "external-entities") " controls whether parsing of external entities is enabled and can be any of the symbols " (tt "never") ", " (tt "always") " or " (tt "unless-standalone") ". " (tt "#f") " and " (tt "#t") " are synonymous for " (tt "never") " and " (tt "always") "."))) (section 4 "expat:set-start-handler!" (def (sig (procedure "(expat:set-start-handler! PARSER PROCEDURE)" (id expat:set-start-handler!))) (p "Sets the handler to process start (and empty) tags. " (tt "PROCEDURE") " will be called with two arguments: the tag (a string) and a list of pairs, where each pair is of the form " (tt "(ATTRIBUTENAME . ATTRIBUTEVALUE)") " (both strings)."))) (section 4 "expat:set-end-handler!" (def (sig (procedure "(expat:set-end-handler! PARSER PROCEDURE)" (id expat:set-end-handler!))) (p "Sets the handler to process end (and empty) tags. " (tt "PROCEDURE") " will be called with one argumente the tag (a string)."))) (section 4 "expat:set-character-data-handler!" (def (sig (procedure "(expat:set-character-data-handler! PARSER PROCEDURE)" (id expat:set-character-data-handler!))) (p "Sets the handler to process text. " (tt "PROCEDURE") " will be called with one argument: a string containing a piece of text. Note that a single block of contiguous text free of markup may still result in a sequence of calls to this handler."))) (section 4 "expat:set-processing-instruction-handler!" (def (sig (procedure "(expat:set-processing-instruction-handler! PARSER PROCEDURE)" (id expat:set-processing-instruction-handler!))) (p "Sets the handler to for processing insructions. " (tt "PROCEDURE") " will be called with two arguments: target and data (both strings). The target is the first word in the processing instruction.  The data is the rest of the characters in it after skipping all whitespace after the initial word."))) (section 4 "expat:set-comment-handler!" (def (sig (procedure "(expat:set-comment-handler! PARSER PROCEDURE)" (id expat:set-comment-handler!))) (p "Sets the handler to process comments. " (tt "PROCEDURE") " will be called with the all the text inside the comment delimiters."))) (section 4 "expat:set-external-entity-ref-handler!" (def (sig (procedure "(expat:set-external-entity-ref-handler! PARSER PROCEDURE)" (id expat:set-external-entity-ref-handler!))) (p "Sets the handler to references to external entities. PROCEDURE will be called with four arguments: context, URI base, system- and public ID (all strings). To parse the external entity, create a parser with " (tt "expat:make-external-entity-parser") ".")))) (section 3 "Examples" (p "A silly example:") (highlight scheme "(use expat)\n\n(define text #<<EOF\n<?xml version='1.0'?>\n<!-- a comment -->\n<?pi1 yepyepyep?>\n<yo:this yo='abc' xmlns:yo=\"http://www.yo.com\">\n&gt;&;lt;&#x100;\n<yo:test>yes, no, &#33<is/><a/>\n</yo:test>some more text\n</yo:this>\nEOF\n)\n\n(define p (expat:make-parser namespaces: #t))\n(expat:set-start-handler! p (lambda (tag attrs) (print \"Start: \" tag \" - \" attrs)))\n(expat:set-end-handler! p (lambda (tag) (print \"End: \" tag)))\n(expat:set-character-data-handler! p (lambda (text) (pp (string->list text))))\n(expat:set-processing-instruction-handler! p (lambda (target text) (print \"PI: \" target \" - \" text)))\n(expat:set-comment-handler! p (lambda (text) (print \"Comment: \" text)))\n(expat:parse p text)\n(expat:destroy-parser p)") (p "This will output:") (pre " Comment:  a comment \n PI: pi1 - yepyepyep\n Start: http://www.yo.com:this - ((yo . abc))\n (#\\newline)\n (#\\>)\n (#\\<)\n (#\\Ã„ #\\)\n (#\\newline)\n (#\\space)\n Start: http://www.yo.com:test - ()\n (#\\y #\\e #\\s #\\, #\\space #\\n #\\o #\\, #\\space)\n (#\\!)\n Start: is - ()\n End: is\n Start: a - ()\n End: a\n (#\\newline)\n (#\\space)\n End: http://www.yo.com:test\n (#\\s #\\o #\\m #\\e #\\space #\\m #\\o #\\r #\\e #\\space #\\t #\\e #\\x #\\t)\n (#\\newline)\n End: http://www.yo.com:this") (p "Another example that uses DTDs:") (p "Say we have a file foo.xml:") (pre " <?xml version=\"1.0\"?>\n <!DOCTYPE foo SYSTEM \"foo.dtd\">\n <foo>\n &abcdef;\n </foo>") (p "and another one called foo.dtd:") (pre " <!ENTITY abcdef \"this is a test\">") (highlight scheme "(use utils expat)\n\n(define p (expat:make-parser))\n(expat:set-start-handler! p (lambda (tag attrs) (print \"Start: \" tag \" - \" attrs)))\n(expat:set-end-handler! p (lambda (tag) (print \"End: \" tag)))\n(expat:set-character-data-handler! p (lambda (text) (pp (string->list text))))\n\n(expat:set-external-entity-ref-handler!\n p\n (lambda (context base sys pub)\n   (print \"external: \" sys)\n   (let* ([p2 (expat:make-external-entity-parser p context)]\n\t  [s (expat:parse p2 (read-all \"foo.dtd\"))] )\n     (expat:destroy-parser p2) \n     s) ) )\n\n(expat:parse p (read-all \"foo.xml\") external-entities: #t)\n(expat:destroy-parser p)")) (section 3 "Changelog" (ul (li "1.4 Ported to Chicken 4") (li "1.3 Removed use of " (tt "___callback")) (li "1.2 Works withh externalized easyffi extension") (li "1.1 Added support for parsing external entities; optional arguments to " (tt "expat:parse") " are now keyword arguments.") (li "1.0 Initial release"))) (section 3 "License" (pre " Copyright (c) 2005, Felix L. Winkelmann\n All rights reserved.\n \n Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following\n conditions are met:\n \n   Redistributions of source code must retain the above copyright notice, this list of conditions and the following\n     disclaimer. \n   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following\n     disclaimer in the documentation and/or other materials provided with the distribution. \n   Neither the name of the author nor the names of its contributors may be used to endorse or promote\n     products derived from this software without specific prior written permission. \n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\n CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n POSSIBILITY OF SUCH DAMAGE."))))