(index ("client-connect" 0) ("connection-outport" 891) ("connection-inport" 891) ("connection-message-size" 1118) ("client-disconnect" 1455) ("connection?" 1697) ("with-output-to-file" 1844) ("call-with-output-file" 2159) ("open-output-file" 2517) ("with-input-from-file" 3126) ("call-with-input-file" 3443) ("open-input-file" 3797) ("directory?" 4105) ("create-directory" 4300) ("directory" 4610) ("regular-file?" 4900) ("delete-file" 5390) ("file-stat" 5637) ("file-permissions" 6893) ("file-access-time" 7185) ("file-modification-time" 7419) ("file-size" 7671) ("file-owner" 7845) ("file-group" 8037) ("file-last-modified-by" 8236) ("file-open" 8463) ("file-create" 8862) ("file-close" 9440) ("file-read" 9607) ("file-write" 9862) ("set-file-position!" 10162) ("file-position" 10577) ("handle-stat" 10717) ("path-walk" 10898) ("with-handle-to" 11340) ("alloc-handle" 11818) ("handle-connection" 12012) ("handle-fid" 12012) ("handle-position" 12012) ("handle-iounit" 12012) ("release-handle" 12909) ("request" 13105) ("make-message" 13750) ("send-message" 16246) ("receive-message" 16395) ("qid-type" 16568) ("qid-version" 16568) ("qid-path" 16568) ("make-qid" 16783) ("qid?" 16946) ("qtfile" 17166) ("qtdir" 17438) ("qtappend" 17540) ("qtexcl" 17659) ("qtauth" 17847) ("qttmp" 18002) ("perm/irusr" 18443) ("perm/iwusr" 18443) ("perm/ixusr" 18443) ("perm/irgrp" 18694) ("perm/iwgrp" 18694) ("perm/ixgrp" 18694) ("perm/iroth" 18947) ("perm/iwoth" 18947) ("perm/ixoth" 18947) ("dmdir" 19494) ("dmappend" 19619) ("dmexcl" 19707) ("dmauth" 19829) ("dmtmp" 19948) ("open/rdonly" 20108) ("open/wronly" 20211) ("open/rdwr" 20314) ("open/trunc" 20425) ("open/rclose" 20523) ("data->directory-listing" 20653))
(def (sig (procedure "(client-connect inport outport [user] [mountpoint])" (id client-connect))) (p "The " (tt "inport") " and " (tt "outport") " arguments are the ports you use to communicate to the server.  The " (tt "user") " argument is the name of the user that creates the files.  It defaults to the empty string.  There is no support for authentication, so the user name is simply used for newly created files on servers that support usernames (wmii doesn't, for example).  The " (tt "mountpoint") " also defaults to the empty string, which selects the \"default mount point\" on the server.  If the server has multiple mountpoints it exports, you can select with this argument.") (p "The procedure returns a connection object you must keep and use in all subsequent 9p procedure calls.") (p "You can use the following procedures to obtain some more information on the connection:"))
(def (sig (procedure "(connection-outport connection)" (id connection-outport)) (procedure "(connection-inport connection)" (id connection-inport))) (p "Get back the underlying ports you passed to " (tt "client-connect") "."))
(def (sig (procedure "(connection-message-size connection)" (id connection-message-size))) (p "The maximum size of a low-level message as negotiated in the connection handshake.  Not very useful unless you would like to write some custom messages.  This " (i "includes") " the size of the tag (2 bytes) and the message type (1 byte)."))
(def (sig (procedure "(client-disconnect connection)" (id client-disconnect))) (p "Disconnect from the server described by " (tt "connection") ".  This clunks any fids that are still open (in Unix terms: closes any open file descriptors)."))
(def (sig (procedure "(connection? object)" (id connection?))) (p "You can verify an object is a connection to a 9p server with this predicate."))
(def (sig (procedure "(with-output-to-file connection file thunk)" (id with-output-to-file))) (p "Open " (tt "file") " on the 9p connection " (tt "connection") " and call " (tt "thunk") " with the " (tt "current-output-port") " set to a port that writes to the file. When the thunk finishes, the port is closed."))
(def (sig (procedure "(call-with-output-file connection file procedure)" (id call-with-output-file))) (p "Open " (tt "file") " on the 9p connection " (tt "connection") " and call " (tt "procedure") " with an output-port that corresponds to the file. When the procedure finishes, the port is closed.  Procedure should accept one argument, the output-port."))
(def (sig (procedure "(open-output-file connection file [mode])" (id open-output-file))) (p "Create an output port that will write to the given " (tt "file") " on the 9p connection " (tt "connection") ".  If the file exists, it is truncated.  If it does not exist yet it will be created.  If the optional " (tt "mode") " is given, it determines with what permissions the file will be created, if it is a new file.  See " (int-link "#Permission bits" "below") " for the list of file permissions.") (p "Don't forget to close the output port (with " (tt "close-output-port") ") when you finish writing to it!"))
(def (sig (procedure "(with-input-from-file connection file thunk)" (id with-input-from-file))) (p "Open " (tt "file") " on the 9p connection " (tt "connection") " and call " (tt "thunk") " with the " (tt "current-input-port") " set to a port that reads from the file. When the thunk finishes, the port is closed."))
(def (sig (procedure "(call-with-input-file connection file procedure)" (id call-with-input-file))) (p "Open " (tt "file") " on the 9p connection " (tt "connection") " and call " (tt "procedure") " with an input-port that corresponds to the file. When the procedure finishes, the port is closed.  Procedure should accept one argument, the input-port."))
(def (sig (procedure "(open-input-file connection file)" (id open-input-file))) (p "Create an input port that will read from the given " (tt "file") " on the 9p connection " (tt "connection") ".") (p "Don't forget to close the input port (with " (tt "close-input-port") " when you finish reading from it!"))
(def (sig (procedure "(directory? connection path)" (id directory?))) (p "Returns " (tt "#t") " if the given " (tt "path") " on the " (tt "connection") " is a directory, " (tt "#f") " if not."))
(def (sig (procedure "(create-directory connection path permissions)" (id create-directory))) (p "Create a directory on the " (tt "connection") " with the given " (tt "path") ".  It will have the specified " (tt "permissions") ", see " (int-link "#Permission bits" "below") " for the available permissions."))
(def (sig (procedure "(directory connection directory [show-dotfiles?])" (id directory))) (p "Returns a list with the contents of the " (tt "directory") " on the " (tt "connection") ". Files beginning with " (tt ".") " are included only if " (tt "show-dotfiles?") " is given and not #f."))
(def (sig (procedure "(regular-file? connection path)" (id regular-file?))) (p "Returns " (tt "#t") " if the given " (tt "path") " on the " (tt "connection") " is a regular file, " (tt "#f") " if not.  9p does not support symlinks or FIFOs, so this is the same as " (tt "(not (directory? connection path))") ", even if the underlying FS is a Unix FS (the 9p egg currently does not (and probably will never) support " (link "http://v9fs.sourceforge.net/rfc/9p2000.u.html" "9P2000.u") ")."))
(def (sig (procedure "(delete-file connection path)" (id delete-file))) (p "Delete the file indicated by " (tt "path") " on the " (tt "connection") ". If the file does not exist or you do not have permission to delete it, an error is signaled."))
(def (sig (procedure "(file-stat connection path)" (id file-stat))) (p "Returns a 9-element vector which contains information about the file indicated by " (tt "path") " on the " (tt "connection") ".  It has the following contents:") (ul (li "The QID of the file (The qid can be queried with the " (int-link "#QIDs" "QID procedures") " from 9p-lolevel.") (li "The permission mode (See " (int-link "#Permission bits" "the permission bits section") " for a description)") (li "The access time of the file.  This is an integer which indicates the server-time when the file was last accessed.  There is no way to determine what the server's time is using the 9p protocol, so you can only use this for comparing timestamps of files on the same server unless you use an additional protocol to find out about the server's current time and zone.") (li "The modification time of the file.  This is an integer which indicates the server-time when the file was last modified.") (li "The file's size in bytes.") (li "The filename of the file.") (li "The user who owns the file (a string, not a uid, because Plan9 has only user and group names, not numerical ids).") (li "The group who owns the file (a string)") (li "The user who last modified the file (a string)")))
(def (sig (procedure "(file-permissions connection path)" (id file-permissions))) (p "Returns the permissions of the file indicated by " (tt "path") " on the " (tt "connection") ". See " (int-link "#Permission bits" "the permission bits section") " for a description of the possible bits."))
(def (sig (procedure "(file-access-time connection path)" (id file-access-time))) (p "Returns the access time of the file indicated by " (tt "path") " on the " (tt "connection") ".  See the notes under " (int-link "#file-stat") "."))
(def (sig (procedure "(file-modification-time connection path)" (id file-modification-time))) (p "Returns the modification time of the file indicated by " (tt "path") " on the " (tt "connection") ".  See the notes under " (int-link "#file-stat") "."))
(def (sig (procedure "(file-size connection path)" (id file-size))) (p "Returns the size, in bytes, of the file indicated by " (tt "path") " on the " (tt "connection") "."))
(def (sig (procedure "(file-owner connection path)" (id file-owner))) (p "Returns the name of the owner, as a string, of the file indicated by " (tt "path") " on the " (tt "connection") "."))
(def (sig (procedure "(file-group connection path)" (id file-group))) (p "Returns the name of the owning group, as a string, of the file indicated by " (tt "path") " on the " (tt "connection") "."))
(def (sig (procedure "(file-last-modified-by connection path)" (id file-last-modified-by))) (p "Returns the name of the user, as a string, who last changed the file indicated by " (tt "path") " on the " (tt "connection") "."))
(def (sig (procedure "(file-open connection path mode)" (id file-open))) (p "Opens the file indicated by " (tt "path") " on the " (tt "connection") " with the given " (tt "mode") " and returns an opaque handle object which you can use for the other procedures described in this section.  For bit flags that the " (tt "mode") " can take, see " (int-link "#Open flags" "the open flags section") "."))
(def (sig (procedure "(file-create connection path permissions mode)" (id file-create))) (p "Creates and opens the file indicated by " (tt "path") " on the " (tt "connection") " with the given " (tt "permission") " and " (tt "mode") " and returns an opaque handle object which you can use for the other procedures described in this section.  For bit flags that the " (tt "mode") " can take, see " (int-link "#Open flags" "the open flags section") ".  For bit flags that the " (tt "permission") " can take, see " (int-link "#Permission bits" "the permission bits section") "."))
(def (sig (procedure "(file-close handle)" (id file-close))) (p "Close the file indicated by " (tt "handle") ".  It is not an error to close a file more than once."))
(def (sig (procedure "(file-read handle size)" (id file-read))) (p "Read " (tt "size") " bytes from the file with the given " (tt "handle") ".  This procedure returns a list with two values: the buffer containing the data and the number of bytes read."))
(def (sig (procedure "(file-write handle buffer [size])" (id file-write))) (p "Writes the contents of the string or bytevector " (tt "buffer") " into the file with the given " (tt "handle") ". If the optional argument " (tt "size") " is given, then only the specified number of bytes are written."))
(def (sig (procedure "(set-file-position! handle position [whence])" (id set-file-position!))) (p "Sets the current read/write position of " (tt "handle") " to " (tt "position") ", which should be an exact integer. " (tt "whence") " specifies how the position is to interpreted and should be one of the values " (tt "seek/set") ", " (tt "seek/cur") " and " (tt "seek/end") ". It defaults to " (tt "seek/set") "."))
(def (sig (procedure "(file-position handle)" (id file-position))) (p "Returns the current read/write position of the " (tt "handle") "."))
(def (sig (procedure "(handle-stat handle)" (id handle-stat))) (p "Just like " (int-link "#file-stat") ", except it works on a handle instead of on a connection with a filename."))
(def (sig (procedure "(path-walk connection path [starting-point])" (id path-walk))) (p "Obtain a handle for the file identified by " (tt "path") " on the " (tt "connection") " " (i "without opening it") ".  You must not forget to clunk the handle's FID (or just call " (tt "file-close") " on the handle).  " (tt "starting-point") " is an optional handle to a directory from which to start walking.  It defaults to the root directory (/)."))
(def (sig (procedure "(with-handle-to connection path procedure)" (id with-handle-to))) (p "This will call " (tt "procedure") " with one argument: a temporary handle which represents the " (tt "path") " on the " (tt "connection") ".  After the procedure returns, the handle will be deallocated and the FID will no longer be valid.  This returns whatever " (tt "procedure") " returned.  If a condition is signaled, the handle will be deallocated properly and the FID clunked."))
(def (sig (procedure "(alloc-handle connection)" (id alloc-handle))) (p "Allocate a handle on the connection.  This returns a handle object which you can query with the following procedures:"))
(def (sig (procedure "(handle-connection handle)" (id handle-connection)) (procedure "(handle-fid handle)" (id handle-fid)) (procedure "(handle-position handle)" (id handle-position)) (procedure "(handle-iounit handle)" (id handle-iounit))) (p "The fid is allocated from an internal pool of free fids.  The position is initialized to 0, and used as an offset for read/write procedures (the server does not keep track of this for us in the 9p protocol).") (p "The iounit defaults to " (tt "#f") " and you are expected to set it manually (normally, " (int-link "#file-open" "file-open") " and " (int-link "#file-create" "file-create") " do this for you). is returned as part of the Ropen and Rcreate replies and is the maximum size of a data transfer (either read or write).  If the server returns 0, the iounit should default to the size returned by " (tt "connection-message-size") " minus 24."))
(def (sig (procedure "(release-handle handle)" (id release-handle))) (p (b "important") ": be sure to clunk the handle's fid first.  " (tt "release-handle") " does " (i "not") " clunk the fid."))
(def (sig (procedure "(request connection type . args)" (id request))) (p "This creates a new " (tt "message") " object (see below) with a tag and the given " (tt "type") ".  " (tt "args") " are the message-contents.  It then sends this request to the server and awaits a response.  The response should match the request (a " (tt "Twhatever") " should result in a " (tt "Rwhatever") " message), or a condition of type " (tt "(exn 9p-response-error)") " is signaled.  If the server returns an error (via " (tt "Rerror") "), a condition of type " (tt "(exn 9p-server-error)") " is signaled.  The response object (a message object) is returned."))
(def (sig (procedure "(make-message type tag contents)" (id make-message))) (p "The type is a symbol, one of") (pre " Tversion Rversion\n Tauth Rauth\n Tattach Rattach\n Rerror\n Tflush Rflush\n Twalk Rwalk\n Topen Ropen\n Tcreate Rcreate\n Tread Rread\n Twrite Rwrite\n Tclunk Rclunk\n Tremove Rremove\n Tstat Rstat\n Twstat Rwstat") (p "As you can see, all messages (except Rerror) come in pairs: there is a transmit message (that starts with a T) and a response message (that starts with an R).  The client sends transmit messages and the server sends response message in return.  It must either send the matching response message or Rerror.  It is not allowed to return a different message, nor is it allowed for the client to send a response message or the server to send a transmit message.") (p "The tag is a unique identifier that allows the client to keep track of what it sent and what responses belong to what transmissions.  The client sends a message with a given tag and the server will respond with the matching response message bearing the same tag.  This allows a client to send messages " (i "asynchronously") ", as long as they all have a different tag.  Then the responses can come in any order and be handled at any time and still be understood if the client keeps a list of sent tags and what transmissions belonged to them.  The " (int-link "#9p-client" "9p-client") " library always sends messages synchronously, waiting for replies before sending new transmissions.  This allows it to use a constant tag all the time.") (p "The contents are a list whose contents differ per message type.  For instance, a Tversion message's contents consist of an " (tt "msize") " (a maximum message size) and a " (tt "string") " which indicates the protocol version.  Currently the 9p-lolevel implicitly assumes the 9P2000 version of the protocol because of the way it is constructed.  If it turns out to be useful to support different versions, the egg's API will most likely change in order to allow for more flexibility.") (p "You can of course query and modify the message objects with the following procedures: <procedure>(message? object)</procedure> <procedure>(message-type message)</procedure> <procedure>(message-type-set! message new-type)</procedure> <procedure>(message-tag message)</procedure> <procedure>(message-tag-set! message new-tag)</procedure> <procedure>(message-contents message)</procedure> <procedure>(message-contents-set! message new-contents)</procedure>"))
(def (sig (procedure "(send-message outport message)" (id send-message))) (p "Sends the " (tt "message") " on the output-port " (tt "outport") "."))
(def (sig (procedure "(receive-message inport)" (id receive-message))) (p "Waits for a message on input-port " (tt "inport") " and returns a 9p message-object.") (pre " "))
(def (sig (procedure "(qid-type qid)" (id qid-type)) (procedure "(qid-version qid)" (id qid-version)) (procedure "(qid-path qid)" (id qid-path))) (p "You can create a QID using the " (tt "make-qid") " procedure:"))
(def (sig (procedure "(make-qid type version path)" (id make-qid))) (p "Finally, you can check if an object is a QID object with the " (tt "qid?") " predicate:"))
(def (sig (procedure "(qid? object)" (id qid?))) (p "The fields of the QID will be described next.") (p "First, the type of a QID is a bitwise field which consists of several of the following constants ORed together:"))
(def (sig (constant "qtfile" (id qtfile))) (pre "") (p (tt "qtfile") " indicates that the file is, in fact, a file.  Because everything in Plan9 is a file, this is always true, even for directories.  It does " (i "not") " mean that the file is a regular file.") (pre ""))
(def (sig (constant "qtdir" (id qtdir))) (p (tt "qtdir") " indicates that the file is a directory."))
(def (sig (constant "qtappend" (id qtappend))) (p (tt "qtappend") " indicates that the file is an append-only file."))
(def (sig (constant "qtexcl" (id qtexcl))) (p (tt "qtexcl") " indicates that the file is marked for exclusive-use.  This means that only one client can have this file open at any time."))
(def (sig (constant "qtauth" (id qtauth))) (p (tt "qtauth") " indicates that the file is an authentication file established by AUTH messages.") (pre " "))
(def (sig (constant "qttmp" (id qttmp))) (p (tt "qttmp") " indicates that the file is a \"temporary file\".  In practice this means that the file is not included in nightly backups.") (p "The version of a QID is a version number for the file which is incremented every time the file is modified.") (p "The path of a QID is an integer that is unique among all files in the file hierarchy (ie, this uniquely identifies the file in the FS)."))
(def (sig (constant "perm/irusr" (id perm/irusr)) (constant "perm/iwusr" (id perm/iwusr)) (constant "perm/ixusr" (id perm/ixusr))) (p "These constants determine the permissions for the user who owns the file: read, write and execute, respectively."))
(def (sig (constant "perm/irgrp" (id perm/irgrp)) (constant "perm/iwgrp" (id perm/iwgrp)) (constant "perm/ixgrp" (id perm/ixgrp))) (p "These constants determine the permissions for the group that owns the file: read, write and execute, respectively."))
(def (sig (constant "perm/iroth" (id perm/iroth)) (constant "perm/iwoth" (id perm/iwoth)) (constant "perm/ixoth" (id perm/ixoth))) (p "These constants determine the permissions for others: read, write and execute, respectively.") (p "There are some additional \"permissions\" that can be used on " (tt "Tcreate") " messages, which are not really permissions but rather modes that change the way the file behaves (hence the inconsistence of the docs).  These are like the 'special' bits in Unix like sticky/setuid etc.  These are the following:"))
(def (sig (constant "dmdir" (id dmdir))) (p "This is used to create directories instead of files with " (tt "Tcreate") "."))
(def (sig (constant "dmappend" (id dmappend))) (p "The file can only be appended to."))
(def (sig (constant "dmexcl" (id dmexcl))) (p "The file is 'exclusive', it can only be opened by one client at a time."))
(def (sig (constant "dmauth" (id dmauth))) (p "The file is an authentication file, as established by AUTH messages."))
(def (sig (constant "dmtmp" (id dmtmp))) (p "The file is to be considered \"temporary\".  In practice this means that it is not included in nightly backups."))
(def (sig (constant "open/rdonly" (id open/rdonly))) (p "The file is to be opened only for reading."))
(def (sig (constant "open/wronly" (id open/wronly))) (p "The file is to be opened only for writing."))
(def (sig (constant "open/rdwr" (id open/rdwr))) (p "The file is to be opened both for reading and writing."))
(def (sig (constant "open/trunc" (id open/trunc))) (p "The file is to be truncated on opening."))
(def (sig (constant "open/rclose" (id open/rclose))) (p "The file is to be removed upon closing (ie, when the FID is clunked)."))
(def (sig (procedure "(data->directory-listing data show-dotfiles?)" (id data->directory-listing))) (p "Because the 9p protocol requires you to use the " (tt "Tread") "/" (tt "Rread") " messages to read both from files and directories, the " (tt "Rread") " response can be considered to be a polymorphic type.  In case of files, the data is simply a bytestream, but in case of directories, the data will be structured.  This means the data needs to be decoded.") (p "This procedures decodes the " (tt "data") " obtained from the " (tt "Rread") " message and returns a list of filenames which are the directory listing for the directory that was read.  If " (tt "show-dotfiles?") " is " (tt "#f") " files starting with a dot are excluded from the list.") (p "Note: The converse procedure, " (tt "directory-listing->data") ", is currently not implemented."))
