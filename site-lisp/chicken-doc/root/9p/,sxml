((tags "egg") (section 2 "9p" (toc) (section 3 "Description" (p "A pure Scheme implementation of the " (link "http://9p.cat-v.org" "9p networked filesystem protocol") ".")) (section 3 "Author" (p (int-link "/users/peter-bex" "Peter Bex"))) (section 3 "Requirements" (p "Requires the " (int-link "iset") " egg.")) (section 3 "Documentation" (p "9p is an implementation of the networked file system protocol known as 9P, specifically version 9P2000 which is also known as \"Styx\". This protocol is used by the " (link "http://cm.bell-labs.com/plan9" "Plan 9 operating system") " and the " (link "http://wmii.suckless.org" "wmii window manager") ", among others.") (p "This implementation includes a low-level implementation of the protocol that is suitable both for writing clients and servers and a high-level client implementation.  There currently are no concrete plans for a high-level server implementation, but contributions are of course very welcome :)") (p "The low-level implementation is documented below under " (int-link "#9p-lolevel" "9p-lolevel") " and the high-level client implementation under " (int-link "#9p-client" "9p-client") ".  The high-level client is discussed first, because this is the one you will most likely need.")) (section 3 "9p-client" (p "The basic library was modeled after Chicken's " (int-link "/man/4/Unit posix" "Unit posix") " and a few choice other procedures that interact with the filesystem.  Most procedures from Unit posix are available under the same name.  When you include the module together with posix, don't forget to prefix either these procedures or those of posix! Where possible, the procedure's signature has been unmodified, except for an additional leading argument that specifies the connection with the 9p server.") (section 4 "Usage" (pre " (use 9p-client)\n (use utf8)") (p "It is highly recommended you require utf8 in your applications, as 9p is a utf8-aware protocol.  It is not a dependency of this egg because in some situations you might decide it's safe to leave it out, for performance or memory footprint reasons.")) (section 4 "Connection management" (section 5 "client-connect" (p "Before doing anything else, you must establish a connection with the server.  This is done with the " (tt "client-connect") " procedure.") (def (sig (procedure "(client-connect inport outport [user] [mountpoint])" (id client-connect))) (p "The " (tt "inport") " and " (tt "outport") " arguments are the ports you use to communicate to the server.  The " (tt "user") " argument is the name of the user that creates the files.  It defaults to the empty string.  There is no support for authentication, so the user name is simply used for newly created files on servers that support usernames (wmii doesn't, for example).  The " (tt "mountpoint") " also defaults to the empty string, which selects the \"default mount point\" on the server.  If the server has multiple mountpoints it exports, you can select with this argument.") (p "The procedure returns a connection object you must keep and use in all subsequent 9p procedure calls.") (p "You can use the following procedures to obtain some more information on the connection:")) (def (sig (procedure "(connection-outport connection)" (id connection-outport)) (procedure "(connection-inport connection)" (id connection-inport))) (p "Get back the underlying ports you passed to " (tt "client-connect") ".")) (def (sig (procedure "(connection-message-size connection)" (id connection-message-size))) (p "The maximum size of a low-level message as negotiated in the connection handshake.  Not very useful unless you would like to write some custom messages.  This " (i "includes") " the size of the tag (2 bytes) and the message type (1 byte)."))) (section 5 "client-disconnect" (def (sig (procedure "(client-disconnect connection)" (id client-disconnect))) (p "Disconnect from the server described by " (tt "connection") ".  This clunks any fids that are still open (in Unix terms: closes any open file descriptors)."))) (section 5 "connection?" (def (sig (procedure "(connection? object)" (id connection?))) (p "You can verify an object is a connection to a 9p server with this predicate.")))) (section 4 "Files as ports" (section 5 "with-output-to-file" (def (sig (procedure "(with-output-to-file connection file thunk)" (id with-output-to-file))) (p "Open " (tt "file") " on the 9p connection " (tt "connection") " and call " (tt "thunk") " with the " (tt "current-output-port") " set to a port that writes to the file. When the thunk finishes, the port is closed."))) (section 5 "call-with-output-file" (def (sig (procedure "(call-with-output-file connection file procedure)" (id call-with-output-file))) (p "Open " (tt "file") " on the 9p connection " (tt "connection") " and call " (tt "procedure") " with an output-port that corresponds to the file. When the procedure finishes, the port is closed.  Procedure should accept one argument, the output-port."))) (section 5 "open-output-file" (def (sig (procedure "(open-output-file connection file [mode])" (id open-output-file))) (p "Create an output port that will write to the given " (tt "file") " on the 9p connection " (tt "connection") ".  If the file exists, it is truncated.  If it does not exist yet it will be created.  If the optional " (tt "mode") " is given, it determines with what permissions the file will be created, if it is a new file.  See " (int-link "#Permission bits" "below") " for the list of file permissions.") (p "Don't forget to close the output port (with " (tt "close-output-port") ") when you finish writing to it!"))) (section 5 "with-input-from-file" (def (sig (procedure "(with-input-from-file connection file thunk)" (id with-input-from-file))) (p "Open " (tt "file") " on the 9p connection " (tt "connection") " and call " (tt "thunk") " with the " (tt "current-input-port") " set to a port that reads from the file. When the thunk finishes, the port is closed."))) (section 5 "call-with-input-file" (def (sig (procedure "(call-with-input-file connection file procedure)" (id call-with-input-file))) (p "Open " (tt "file") " on the 9p connection " (tt "connection") " and call " (tt "procedure") " with an input-port that corresponds to the file. When the procedure finishes, the port is closed.  Procedure should accept one argument, the input-port."))) (section 5 "open-input-file" (def (sig (procedure "(open-input-file connection file)" (id open-input-file))) (p "Create an input port that will read from the given " (tt "file") " on the 9p connection " (tt "connection") ".") (p "Don't forget to close the input port (with " (tt "close-input-port") " when you finish reading from it!")))) (section 4 "Directories" (section 5 "directory?" (def (sig (procedure "(directory? connection path)" (id directory?))) (p "Returns " (tt "#t") " if the given " (tt "path") " on the " (tt "connection") " is a directory, " (tt "#f") " if not."))) (section 5 "create-directory" (def (sig (procedure "(create-directory connection path permissions)" (id create-directory))) (p "Create a directory on the " (tt "connection") " with the given " (tt "path") ".  It will have the specified " (tt "permissions") ", see " (int-link "#Permission bits" "below") " for the available permissions."))) (section 5 "directory" (def (sig (procedure "(directory connection directory [show-dotfiles?])" (id directory))) (p "Returns a list with the contents of the " (tt "directory") " on the " (tt "connection") ". Files beginning with " (tt ".") " are included only if " (tt "show-dotfiles?") " is given and not #f.")))) (section 4 "Files" (section 5 "regular-file?" (def (sig (procedure "(regular-file? connection path)" (id regular-file?))) (p "Returns " (tt "#t") " if the given " (tt "path") " on the " (tt "connection") " is a regular file, " (tt "#f") " if not.  9p does not support symlinks or FIFOs, so this is the same as " (tt "(not (directory? connection path))") ", even if the underlying FS is a Unix FS (the 9p egg currently does not (and probably will never) support " (link "http://v9fs.sourceforge.net/rfc/9p2000.u.html" "9P2000.u") ")."))) (section 5 "delete-file" (def (sig (procedure "(delete-file connection path)" (id delete-file))) (p "Delete the file indicated by " (tt "path") " on the " (tt "connection") ". If the file does not exist or you do not have permission to delete it, an error is signaled."))) (section 5 "file-stat" (def (sig (procedure "(file-stat connection path)" (id file-stat))) (p "Returns a 9-element vector which contains information about the file indicated by " (tt "path") " on the " (tt "connection") ".  It has the following contents:") (ul (li "The QID of the file (The qid can be queried with the " (int-link "#QIDs" "QID procedures") " from 9p-lolevel.") (li "The permission mode (See " (int-link "#Permission bits" "the permission bits section") " for a description)") (li "The access time of the file.  This is an integer which indicates the server-time when the file was last accessed.  There is no way to determine what the server's time is using the 9p protocol, so you can only use this for comparing timestamps of files on the same server unless you use an additional protocol to find out about the server's current time and zone.") (li "The modification time of the file.  This is an integer which indicates the server-time when the file was last modified.") (li "The file's size in bytes.") (li "The filename of the file.") (li "The user who owns the file (a string, not a uid, because Plan9 has only user and group names, not numerical ids).") (li "The group who owns the file (a string)") (li "The user who last modified the file (a string)")))) (section 5 "file-permissions" (def (sig (procedure "(file-permissions connection path)" (id file-permissions))) (p "Returns the permissions of the file indicated by " (tt "path") " on the " (tt "connection") ". See " (int-link "#Permission bits" "the permission bits section") " for a description of the possible bits."))) (section 5 "file-access-time" (def (sig (procedure "(file-access-time connection path)" (id file-access-time))) (p "Returns the access time of the file indicated by " (tt "path") " on the " (tt "connection") ".  See the notes under " (int-link "#file-stat") "."))) (section 5 "file-modification-time" (def (sig (procedure "(file-modification-time connection path)" (id file-modification-time))) (p "Returns the modification time of the file indicated by " (tt "path") " on the " (tt "connection") ".  See the notes under " (int-link "#file-stat") "."))) (section 5 "file-size" (def (sig (procedure "(file-size connection path)" (id file-size))) (p "Returns the size, in bytes, of the file indicated by " (tt "path") " on the " (tt "connection") "."))) (section 5 "file-owner" (def (sig (procedure "(file-owner connection path)" (id file-owner))) (p "Returns the name of the owner, as a string, of the file indicated by " (tt "path") " on the " (tt "connection") "."))) (section 5 "file-group" (def (sig (procedure "(file-group connection path)" (id file-group))) (p "Returns the name of the owning group, as a string, of the file indicated by " (tt "path") " on the " (tt "connection") "."))) (section 5 "file-last-modified-by" (def (sig (procedure "(file-last-modified-by connection path)" (id file-last-modified-by))) (p "Returns the name of the user, as a string, who last changed the file indicated by " (tt "path") " on the " (tt "connection") ".")))) (section 4 "File handles and low-level calls" (p "These calls are not on the protocol level, as the " (int-link "#9p-lolevel") " library procedures, but they are more low-level than the other procedures in the " (int-link "#9p-client") " library because they allow you to work on the file handle level.") (section 5 "file-open" (def (sig (procedure "(file-open connection path mode)" (id file-open))) (p "Opens the file indicated by " (tt "path") " on the " (tt "connection") " with the given " (tt "mode") " and returns an opaque handle object which you can use for the other procedures described in this section.  For bit flags that the " (tt "mode") " can take, see " (int-link "#Open flags" "the open flags section") "."))) (section 5 "file-create" (def (sig (procedure "(file-create connection path permissions mode)" (id file-create))) (p "Creates and opens the file indicated by " (tt "path") " on the " (tt "connection") " with the given " (tt "permission") " and " (tt "mode") " and returns an opaque handle object which you can use for the other procedures described in this section.  For bit flags that the " (tt "mode") " can take, see " (int-link "#Open flags" "the open flags section") ".  For bit flags that the " (tt "permission") " can take, see " (int-link "#Permission bits" "the permission bits section") "."))) (section 5 "file-close" (def (sig (procedure "(file-close handle)" (id file-close))) (p "Close the file indicated by " (tt "handle") ".  It is not an error to close a file more than once."))) (section 5 "file-read" (def (sig (procedure "(file-read handle size)" (id file-read))) (p "Read " (tt "size") " bytes from the file with the given " (tt "handle") ".  This procedure returns a list with two values: the buffer containing the data and the number of bytes read."))) (section 5 "file-write" (def (sig (procedure "(file-write handle buffer [size])" (id file-write))) (p "Writes the contents of the string or bytevector " (tt "buffer") " into the file with the given " (tt "handle") ". If the optional argument " (tt "size") " is given, then only the specified number of bytes are written."))) (section 5 "set-file-position!" (def (sig (procedure "(set-file-position! handle position [whence])" (id set-file-position!))) (p "Sets the current read/write position of " (tt "handle") " to " (tt "position") ", which should be an exact integer. " (tt "whence") " specifies how the position is to interpreted and should be one of the values " (tt "seek/set") ", " (tt "seek/cur") " and " (tt "seek/end") ". It defaults to " (tt "seek/set") "."))) (section 5 "file-position" (def (sig (procedure "(file-position handle)" (id file-position))) (p "Returns the current read/write position of the " (tt "handle") "."))) (section 5 "handle-stat" (def (sig (procedure "(handle-stat handle)" (id handle-stat))) (p "Just like " (int-link "#file-stat") ", except it works on a handle instead of on a connection with a filename."))) (section 5 "Low-level handle access" (p "If you want to get really dirty and low-level you can modify file handles with the following procedures.  This is not recommended, but sometimes required if you want to do some custom things just above the protocol level and extend the client library instead of writing your own.") (section 6 "path-walk" (def (sig (procedure "(path-walk connection path [starting-point])" (id path-walk))) (p "Obtain a handle for the file identified by " (tt "path") " on the " (tt "connection") " " (i "without opening it") ".  You must not forget to clunk the handle's FID (or just call " (tt "file-close") " on the handle).  " (tt "starting-point") " is an optional handle to a directory from which to start walking.  It defaults to the root directory (/)."))) (section 6 "with-handle-to" (p "If all you need is a temporary handle/FID for a message to the server, you can use this utility procedure:") (def (sig (procedure "(with-handle-to connection path procedure)" (id with-handle-to))) (p "This will call " (tt "procedure") " with one argument: a temporary handle which represents the " (tt "path") " on the " (tt "connection") ".  After the procedure returns, the handle will be deallocated and the FID will no longer be valid.  This returns whatever " (tt "procedure") " returned.  If a condition is signaled, the handle will be deallocated properly and the FID clunked."))) (section 6 "alloc-handle" (p "The 9p-client library keeps track of FIDs for you so you do not have to remember numbers.  If you wish to send low-level messages yourself you should allocate and release FIDs through the library so your FIDs can't clash with the FIDs the library uses:") (def (sig (procedure "(alloc-handle connection)" (id alloc-handle))) (p "Allocate a handle on the connection.  This returns a handle object which you can query with the following procedures:")) (def (sig (procedure "(handle-connection handle)" (id handle-connection)) (procedure "(handle-fid handle)" (id handle-fid)) (procedure "(handle-position handle)" (id handle-position)) (procedure "(handle-iounit handle)" (id handle-iounit))) (p "The fid is allocated from an internal pool of free fids.  The position is initialized to 0, and used as an offset for read/write procedures (the server does not keep track of this for us in the 9p protocol).") (p "The iounit defaults to " (tt "#f") " and you are expected to set it manually (normally, " (int-link "#file-open" "file-open") " and " (int-link "#file-create" "file-create") " do this for you). is returned as part of the Ropen and Rcreate replies and is the maximum size of a data transfer (either read or write).  If the server returns 0, the iounit should default to the size returned by " (tt "connection-message-size") " minus 24."))) (section 6 "release-handle" (p "Once you are done with a handle, you must either pass the handle to " (int-link "#file-close" "file-close") " (or just disconnect with " (int-link "#client-disconnect" "client-disconnect") ") or call " (tt "release-handle") ":") (def (sig (procedure "(release-handle handle)" (id release-handle))) (p (b "important") ": be sure to clunk the handle's fid first.  " (tt "release-handle") " does " (i "not") " clunk the fid.")))) (section 5 "Sending messages" (p "A code using 9p-client normally never needs to send raw messages, but in case it does, there is one convenience procedure that does just a bit more than the raw " (int-link "#9p-lolevel" "9p-lolevel") " procedures do:") (def (sig (procedure "(request connection type . args)" (id request))) (p "This creates a new " (tt "message") " object (see below) with a tag and the given " (tt "type") ".  " (tt "args") " are the message-contents.  It then sends this request to the server and awaits a response.  The response should match the request (a " (tt "Twhatever") " should result in a " (tt "Rwhatever") " message), or a condition of type " (tt "(exn 9p-response-error)") " is signaled.  If the server returns an error (via " (tt "Rerror") "), a condition of type " (tt "(exn 9p-server-error)") " is signaled.  The response object (a message object) is returned."))))) (section 3 "9p-lolevel" (p "This library allows you to build your own client or server abstraction library.  This documentation will not make a lot of sense if you haven't read the " (link "http://9p.cat-v.org/documentation" "9p protocol documentation") ".") (section 4 "Usage" (pre " (use 9p-lolevel)\n (use utf8)") (p "Again, utf8 is highly recommended but not strictly required.")) (section 4 "Messages" (p "Messages are main concept in the 9p protocol.  They can be created as follows:") (def (sig (procedure "(make-message type tag contents)" (id make-message))) (p "The type is a symbol, one of") (pre " Tversion Rversion\n Tauth Rauth\n Tattach Rattach\n Rerror\n Tflush Rflush\n Twalk Rwalk\n Topen Ropen\n Tcreate Rcreate\n Tread Rread\n Twrite Rwrite\n Tclunk Rclunk\n Tremove Rremove\n Tstat Rstat\n Twstat Rwstat") (p "As you can see, all messages (except Rerror) come in pairs: there is a transmit message (that starts with a T) and a response message (that starts with an R).  The client sends transmit messages and the server sends response message in return.  It must either send the matching response message or Rerror.  It is not allowed to return a different message, nor is it allowed for the client to send a response message or the server to send a transmit message.") (p "The tag is a unique identifier that allows the client to keep track of what it sent and what responses belong to what transmissions.  The client sends a message with a given tag and the server will respond with the matching response message bearing the same tag.  This allows a client to send messages " (i "asynchronously") ", as long as they all have a different tag.  Then the responses can come in any order and be handled at any time and still be understood if the client keeps a list of sent tags and what transmissions belonged to them.  The " (int-link "#9p-client" "9p-client") " library always sends messages synchronously, waiting for replies before sending new transmissions.  This allows it to use a constant tag all the time.") (p "The contents are a list whose contents differ per message type.  For instance, a Tversion message's contents consist of an " (tt "msize") " (a maximum message size) and a " (tt "string") " which indicates the protocol version.  Currently the 9p-lolevel implicitly assumes the 9P2000 version of the protocol because of the way it is constructed.  If it turns out to be useful to support different versions, the egg's API will most likely change in order to allow for more flexibility.") (p "You can of course query and modify the message objects with the following procedures: <procedure>(message? object)</procedure> <procedure>(message-type message)</procedure> <procedure>(message-type-set! message new-type)</procedure> <procedure>(message-tag message)</procedure> <procedure>(message-tag-set! message new-tag)</procedure> <procedure>(message-contents message)</procedure> <procedure>(message-contents-set! message new-contents)</procedure>")) (section 5 "send-message" (def (sig (procedure "(send-message outport message)" (id send-message))) (p "Sends the " (tt "message") " on the output-port " (tt "outport") "."))) (section 5 "receive-message" (def (sig (procedure "(receive-message inport)" (id receive-message))) (p "Waits for a message on input-port " (tt "inport") " and returns a 9p message-object.") (pre " ")))) (section 4 "QIDs" (p "A QID is an unique identifier for a file on the server; two QIDs are the same iff they point to the same file.  A QID has three fields which can be queried with the following procedures:") (def (sig (procedure "(qid-type qid)" (id qid-type)) (procedure "(qid-version qid)" (id qid-version)) (procedure "(qid-path qid)" (id qid-path))) (p "You can create a QID using the " (tt "make-qid") " procedure:")) (def (sig (procedure "(make-qid type version path)" (id make-qid))) (p "Finally, you can check if an object is a QID object with the " (tt "qid?") " predicate:")) (def (sig (procedure "(qid? object)" (id qid?))) (p "The fields of the QID will be described next.") (p "First, the type of a QID is a bitwise field which consists of several of the following constants ORed together:")) (def (sig (constant "qtfile" (id qtfile))) (pre "") (p (tt "qtfile") " indicates that the file is, in fact, a file.  Because everything in Plan9 is a file, this is always true, even for directories.  It does " (i "not") " mean that the file is a regular file.") (pre "")) (def (sig (constant "qtdir" (id qtdir))) (p (tt "qtdir") " indicates that the file is a directory.")) (def (sig (constant "qtappend" (id qtappend))) (p (tt "qtappend") " indicates that the file is an append-only file.")) (def (sig (constant "qtexcl" (id qtexcl))) (p (tt "qtexcl") " indicates that the file is marked for exclusive-use.  This means that only one client can have this file open at any time.")) (def (sig (constant "qtauth" (id qtauth))) (p (tt "qtauth") " indicates that the file is an authentication file established by AUTH messages.") (pre " ")) (def (sig (constant "qttmp" (id qttmp))) (p (tt "qttmp") " indicates that the file is a \"temporary file\".  In practice this means that the file is not included in nightly backups.") (p "The version of a QID is a version number for the file which is incremented every time the file is modified.") (p "The path of a QID is an integer that is unique among all files in the file hierarchy (ie, this uniquely identifies the file in the FS)."))) (section 4 "Permission bits" (p "The permissions below can be ORed together bitwise to produce the desired permission mode.  When creating new files, the execute bit is ignored by the server unless you're creating a directory, so it is safe to always include it.") (p (b "Note:") " The 9p protocol documentation is not very consistent in naming these.  Sometimes it refers to permissions as " (i "mode") ", and sometimes as " (i "perm") " or " (i "permission") ".  On other occasions, it refers to the " (int-link "#Open flags" "open flags") " as " (i "mode") ".  Read carefully and check the context!") (def (sig (constant "perm/irusr" (id perm/irusr)) (constant "perm/iwusr" (id perm/iwusr)) (constant "perm/ixusr" (id perm/ixusr))) (p "These constants determine the permissions for the user who owns the file: read, write and execute, respectively.")) (def (sig (constant "perm/irgrp" (id perm/irgrp)) (constant "perm/iwgrp" (id perm/iwgrp)) (constant "perm/ixgrp" (id perm/ixgrp))) (p "These constants determine the permissions for the group that owns the file: read, write and execute, respectively.")) (def (sig (constant "perm/iroth" (id perm/iroth)) (constant "perm/iwoth" (id perm/iwoth)) (constant "perm/ixoth" (id perm/ixoth))) (p "These constants determine the permissions for others: read, write and execute, respectively.") (p "There are some additional \"permissions\" that can be used on " (tt "Tcreate") " messages, which are not really permissions but rather modes that change the way the file behaves (hence the inconsistence of the docs).  These are like the 'special' bits in Unix like sticky/setuid etc.  These are the following:")) (def (sig (constant "dmdir" (id dmdir))) (p "This is used to create directories instead of files with " (tt "Tcreate") ".")) (def (sig (constant "dmappend" (id dmappend))) (p "The file can only be appended to.")) (def (sig (constant "dmexcl" (id dmexcl))) (p "The file is 'exclusive', it can only be opened by one client at a time.")) (def (sig (constant "dmauth" (id dmauth))) (p "The file is an authentication file, as established by AUTH messages.")) (def (sig (constant "dmtmp" (id dmtmp))) (p "The file is to be considered \"temporary\".  In practice this means that it is not included in nightly backups."))) (section 4 "Open flags" (p "These flags are useful when opening a new file (for use in the " (tt "Topen") "/" (tt "Tcreate") " messages).  These can be ORed together bitwise to produce the desired mode.") (def (sig (constant "open/rdonly" (id open/rdonly))) (p "The file is to be opened only for reading.")) (def (sig (constant "open/wronly" (id open/wronly))) (p "The file is to be opened only for writing.")) (def (sig (constant "open/rdwr" (id open/rdwr))) (p "The file is to be opened both for reading and writing.")) (def (sig (constant "open/trunc" (id open/trunc))) (p "The file is to be truncated on opening.")) (def (sig (constant "open/rclose" (id open/rclose))) (p "The file is to be removed upon closing (ie, when the FID is clunked)."))) (section 4 "Utility procedures" (section 5 "data->directory-listing" (def (sig (procedure "(data->directory-listing data show-dotfiles?)" (id data->directory-listing))) (p "Because the 9p protocol requires you to use the " (tt "Tread") "/" (tt "Rread") " messages to read both from files and directories, the " (tt "Rread") " response can be considered to be a polymorphic type.  In case of files, the data is simply a bytestream, but in case of directories, the data will be structured.  This means the data needs to be decoded.") (p "This procedures decodes the " (tt "data") " obtained from the " (tt "Rread") " message and returns a list of filenames which are the directory listing for the directory that was read.  If " (tt "show-dotfiles?") " is " (tt "#f") " files starting with a dot are excluded from the list.") (p "Note: The converse procedure, " (tt "directory-listing->data") ", is currently not implemented."))))) (section 3 "Example" (section 4 "9p-client" (p "Here's a simple example that talks to a wmii server.  Note that if you're really looking for a Scheme library to script your wmiirc files, you probably want the " (int-link "wmiirc") " egg instead of using the raw 9p protocol directly.") (highlight scheme "(require-library 9p-client unix-sockets)\n\n(import (prefix 9p-client 9p:))\n\n(receive (in out)\n    (unix-connect (sprintf \"/tmp/ns.~A.:0/wmii\" (getenv \"USER\")))\n  (let ((con (9p:client-connect in out)))\n    (printf \"Current tabs on left bar: ~A\\n\" (9p:directory con \"/lbar\"))\n    (printf \"Label on first tab on left bar: ~A\\n\"\n            (9p:with-input-from-file con `(\"lbar\" ,(car (9p:directory con \"/lbar\"))) read-string ))\n    ;; Write something to the right bar\n    (9p:with-output-to-file con \"/rbar/status\" (lambda () (printf \"Yo, what's up?\")))\n    (9p:client-disconnect con)))") (p "This prints something like") (pre " Current tabs on left bar: (3 2 1)\n Label on first tab on left bar: #888888 #222222 #333333 3") (p "And it shows the string \"Yo, what's up?\" on your status bar."))) (section 3 "Changelog" (ul (li "0.8 Change to install only one extension \"9p\". This simplifies uninstallation.") (li "0.7 Fix import handling for unit \"files\"") (li "0.6 Port to hygienic Chicken, fix handle auto-closing bug") (li "0.5 Add mutex handling to ensure thread-safety") (li "0.4 When reading files, EOF gets reported only when the file really is at an end (fixes reading from FIFO-like files)") (li "0.3 Don't allow output 9p ports to return values when all other values are (void), allow multiple return values in with-output/with-input thunks") (li "0.2 Fix 9p:open-output-file bug, make path-walk accept handles") (li "0.1 Initial release"))) (section 3 "License" (pre " Copyright (c) 2008, Peter Bex\n All rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n \n Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n \n Redistributions in binary form must reproduce the above copyright\n notice, this list of conditions and the following disclaimer in the\n documentation and/or other materials provided with the distribution.\n \n Neither the name of the author nor the names of its contributors may\n be used to endorse or promote products derived from this software\n without specific prior written permission.\n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n OF THE POSSIBILITY OF SUCH DAMAGE."))))