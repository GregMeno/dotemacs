(index ("object?" 0) ("object-parent" 120) ("object-set!" 242) ("object-get" 433) ("object-get" 680) ("object-apply/noslot-thunk" 1324) ("object-raw-clone/no-slots-copy" 1617) ("object-raw-clone/copy-immed-slots" 1617) ("object-raw-clone/copy-all-slots" 1617) ("current-root-object" 2214) ("^" 2561) ("!" 2631) ("!" 2631) ("?" 2908) ("@" 3106) ("@" 3106) ("%" 3471))
(def (sig (procedure "(object? x)" (id object?))) (p "Predicate for whether or not " (tt "x") " is a Protobj object."))
(def (sig (procedure "(object-parent obj)" (id object-parent))) (p "Yields the parent object of object " (tt "obj") "."))
(def (sig (procedure "(object-set! obj slot-symbol val)" (id object-set!))) (p "Sets the slot identified by symbol " (tt "slot-symbol") " in object " (tt "obj") " to value " (tt "val") "."))
(def (sig (procedure "(object-get obj slot-symbol)" (id object-get))) (p "Yields the value of slot named by symbol " (tt "slot-symbol") " in object " (tt "obj") " (immediate or inherited).  If no slot of that name exists, an error is signaled."))
(def (sig (procedure "(object-get obj slot-symbol noslot-thunk)" (id object-get))) (p "Yields the value of slot named by symbol " (tt "slot-symbol") " in object " (tt "obj") " (immediate or inherited), if any such slot exists.  If no slot of that name exists, then yields the value of applying closure " (tt "noslot-thunk") ".") (p "<procedure>(object-apply obj slot-symbol { arg }*)") (p "Applies the method (closure) in the slot named by " (tt "slot-symbol") " of object " (tt "obj") ".  The first term of the method is " (tt "obj") ", and one or more " (tt "arg") " are the remaining terms.  If no such slot exists, an error is signaled."))
(def (sig (procedure "(object-apply/noslot-thunk obj noslot-thunk slot-symbol { arg }*)" (id object-apply/noslot-thunk))) (p "Like " (tt "object-apply") ", except that, if the slot does not exist, instead of signalling an error, the value is the result of applying " (tt "noslot-thunk") "."))
(def (sig (procedure "(object-raw-clone/no-slots-copy obj)" (id object-raw-clone/no-slots-copy)) (procedure "(object-raw-clone/copy-immed-slots obj)" (id object-raw-clone/copy-immed-slots)) (procedure "(object-raw-clone/copy-all-slots obj)" (id object-raw-clone/copy-all-slots))) (p "These procedures implement different ways of cloning an object, and are generally bound as " (tt "clone") " methods in root objects. " (tt "/no-slots-copy") " does not copy any slots, " (tt "/copy-immed-slots") " copes immediate slots, and " (tt "/copy-all-slots") " copies all slots including inherited ones."))
(def (sig (parameter "(current-root-object)" (id current-root-object))) (p "Parameter for the default root object.  The initial value is a root object that has " (tt "object-raw-clone/no-slots-copy") " in its " (tt "clone") " slot.") (p "Since Protobj's raison d'etre was to play with syntax, here it is. Note that slot names are never quoted."))
(def (sig (syntax "(^ obj)" (id ^))) (p "Parent of " (tt "obj") "."))
(def (sig (syntax "(! obj slot val)" (id !)) (syntax "(! obj)" (id !))) (p "Sets object " (tt "obj") "'s slot " (tt "slot") "'s value to " (tt "val") ".  In the second form of this syntax, multiple slots of " (tt "obj") " may be set at once, and are set in the order given."))
(def (sig (syntax "(? obj { slot }+)" (id ?))) (p "Yields the values of the given " (tt "slot") "s of " (tt "obj") ".  If more than one " (tt "slot") " is given, a multiple-value return is used."))
(def (sig (syntax "(@ obj slot { arg }*)" (id @)) (syntax "(@ obj { (slot { arg }* ) }+)" (id @))) (p "Applies " (tt "obj") "'s " (tt "slot") " method, with " (tt "obj") " as the first term and " (tt "arg") "s as the remaining terms.  In the second form of this syntax, multiple methods may be applied, and the value is the value of the last method application."))
(def (sig (syntax "(% [ obj { (slot val) }* ])" (id %))) (p "Clones object " (tt "obj") ", binding any given " (tt "slot") "s to respective given " (tt "val") "s.") (p "You can override the method " (tt "print") " to customize printing ogf objects:") (highlight scheme "(define x (%))\n(! x print\n   (lambda (self #!optional (port (current-output-port)))\n     (fprintf port \"#<my object>\")))"))
