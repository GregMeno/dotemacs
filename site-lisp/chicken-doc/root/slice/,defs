(index ("slice" 0))
(def (sig (procedure "(slice object #!optional from to)" (id slice))) (p "Slice the given " (tt "object") " returning the slice from " (tt "from") " to " (tt "to") ".") (p "If " (tt "to") " is ommited and " (tt "from") " is positive, return the slice from " (tt "from") " to the last element of the given " (tt "object") ".") (p "If " (tt "to") " is ommited and " (tt "from") " is negative, return the slice from " (tt "from") ", assuming " (tt "from") " is the counted from the end of " (tt "object") ", to the last element of the given " (tt "object") ".") (p "Examples:") (highlight scheme "(define v '#(1 2 3 4 5 6 7))\n\n(slice v 0 0)     => #()\n(slice v 1 0))    => #()\n(slice v 0 1))    => #(1)\n(slice v 1 3))    => #(2 3)\n(slice v 10 10))  => #()\n(slice v 0 10))   => #(1 2 3 4 5 6 7)\n(slice v 10 0))   => #()\n(slice v 0))      => #(1 2 3 4 5 6 7)\n(slice v -1))     => #(7)\n(slice v 10))     => #()\n(slice v -10))    => #(1 2 3 4 5 6 7)\n(slice v -4))     => #(4 5 6 7)\n(slice v -4 -4))  => #()\n(slice v -4 -2))  => #(4 5)\n(slice v -4 -10)) => #()\n(slice v -10 -4)) => #(1 2 3)") (p "If " (tt "from") " and " (tt "to") " are ommited, the " (tt "object") " argument is expected to be a procedure to be added to the set of slicers known by " (tt "slice") ". The given procedure is an one-argument one which should check for the type of the object it is given and return a slicer procedure, which should accept an " (tt "object") ", the " (tt "from") " and " (tt "to") " indexes.") (p "Example:") (highlight scheme "(define s (make-custom-string \"custom string\"))\n\n(slice (lambda (obj)\n         (and (custom-string? obj)\n              (lambda (obj from to)\n                (handle-exceptions\n                 exn\n                 \"\"\n                 (substring (custom-string-text obj) from to))))))\n\n(slice s 0 1) => \"c\""))
