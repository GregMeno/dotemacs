((tags "egg") (section 2 "Intarweb" (toc) (section 3 "Description" (p "Intarweb is an advanced http library.  It parses all headers into more useful Scheme values.")) (section 3 "Author" (p (int-link "/users/peter-bex" "Peter Bex"))) (section 3 "Requirements" (p "Requires the " (int-link "defstruct") ", " (int-link "base64") " and " (int-link "uri-common") " extensions.")) (section 3 "Documentation" (p "The intarweb egg is designed to be used from a variety of situations. For this reason, it does not try to be a full HTTP client or server. If you need that kind of functionality, see eggs like " (int-link "spiffy") " or " (int-link "http-client") ".")) (section 3 "Requests" (def (sig (procedure "(make-request #!key uri port (method 'GET) (major 1) (minor 1) (headers (make-headers '())))" (id make-request))) (p "Create a request object (a " (int-link "defstruct") "-type record). The client will generally write requests, while the server will read them.") (p "The URI defines the entity to retrieve on the server, which should be a " (int-link "uri-common") "-type URI object. The PORT is the scheme I/O port where the request is written to or read from.  The METHOD is a symbol that defines the HTTP method to use (case sensitive). MAJOR and MINOR identify the major and minor version of HTTP to use. Currently, 0.9, 1.0 and 1.1 are supported (but be careful with 0.9, it has some weird consequences and is not widely supported). HEADERS must be a headers object.")) (def (sig (procedure "(request-uri REQUEST) => URI" (id request-uri)) (procedure "(request-port REQUEST) => PORT" (id request-port)) (procedure "(request-method REQUEST) => SYMBOL" (id request-method)) (procedure "(request-major REQUEST) => NUMBER" (id request-major)) (procedure "(request-minor REQUEST) => NUMBER" (id request-minor)) (procedure "(request-headers REQUEST) => HEADERS" (id request-headers))) (p "An existing request can be picked apart with these accessors.")) (def (sig (procedure "(write-request REQUEST) => REQUEST" (id write-request))) (p "Write a request line with headers to the server.  In case it is a request type that has any body data, this should be written to the the request's port. Beware that this port can be modified by write-request, so be sure to write to the port as it is returned by the write-request procedure!")) (def (sig (procedure "(read-request PORT) => REQUEST" (id read-request))) (p "Reads a request object from the given input-port.  An optional request body can be read from the request-port after calling this procedure.")) (def (sig (parameter "(request-parsers [LIST])" (id request-parsers))) (p "Requests are parsed using parse procedures, which can be customized by overriding this parameter.") (p "LIST is a list of procedures which accept a request line string and produce a request object, or " (tt "#f") " if the request is not of the type handled by that procedure.") (p "The predefined request parsers are:") (ul (li (tt "http-0.9-request-parser")) (li (tt "http-1.x-request-parser")))) (def (sig (procedure "(http-0.9-request-parser STRING) => REQUEST" (id http-0.9-request-parser)) (procedure "(http-1.x-request-parser STRING) => REQUEST" (id http-1.x-request-parser))) (p "Predefined request parsers for use with " (tt "request-parsers") ".")) (def (sig (parameter "(request-unparsers [LIST])" (id request-unparsers))) (p "Requests are written using unparse procedures, which can be customized by overriding this parameter.") (p "LIST is list of procedures which accept a request object and write to the request's output port and return the new, possibly updated request object. If the request object is not unparsed by this handler, it returns " (tt "#f") ".") (p "The predefined request unparsers are:") (ul (li (tt "http-0.9-request-unparser")) (li (tt "http-1.x-request-unparser")))) (def (sig (procedure "(http-0.9-request-unparser REQUEST) => REQUEST" (id http-0.9-request-unparser)) (procedure "(http-1.x-request-unparser REQUEST) => REQUEST" (id http-1.x-request-unparser))) (p "Predefined request unparsers for use with " (tt "request-unparsers") ". They return the request, and as a side effect they write the request to the request object's port."))) (section 3 "Responses" (def (sig (procedure "(make-response #!key port (code 200) (reason \"OK\") (major 1) (minor 1) (headers (make-headers '())))" (id make-response))) (p "Create a response, a " (int-link "defstruct") "-type record.  A server will usually write a response with " (tt "write-response") "; a client will read it with " (tt "read-response") ".")) (def (sig (procedure "(response-port RESPONSE) => PORT" (id response-port)) (procedure "(response-code RESPONSE) => NUMBER" (id response-code)) (procedure "(response-reason RESPONSE) => STRING" (id response-reason)) (procedure "(response-class RESPONSE-OR-CODE) => NUMBER" (id response-class)) (procedure "(response-major RESPONSE) => NUMBER" (id response-major)) (procedure "(response-minor RESPONSE) => NUMBER" (id response-minor)) (procedure "(response-headers RESPONSE) => HEADERS" (id response-headers))) (p "An existing response can be picked apart using these accessors.") (p "The PORT, MAJOR, MINOR and HEADERS are the same as for requests. CODE and REASON are an integer status code and the short message that belongs to it, as defined in the spec (examples include: 200 OK, 301 Moved Permanently, etc).  CLASS is the major class of the response code (100, 200, 300, 400 or 500).  " (tt "response-class") " can be called either on a response object or directly on a response code number.")) (def (sig (procedure "(write-response RESPONSE) => RESPONSE" (id write-response))) (p "Write the response object RESPONSE to the " (tt "response-port") ".") (p "If there is a response body, this must be written to the response-port after sending the response headers.")) (def (sig (procedure "(read-response PORT) => RESPONSE" (id read-response))) (p "Reads a response object from the port. An optional response body can be read from the response-port after calling this procedure.")) (def (sig (parameter "(response-parsers [LIST])" (id response-parsers))) (p "Responses are parsed using parse procedures, which can be customized by overriding this parameter.") (p "LIST is a list one of procedures which accept a response line string and produce a response object, or " (tt "#f") " if the response is not of the type handled by that procedure.") (p "The predefined response parsers are:") (ul (li (tt "http-0.9-response-parser")) (li (tt "http-1.x-response-parser")))) (def (sig (procedure "(http-0.9-response-parser REQUEST) => REQUEST" (id http-0.9-response-parser)) (procedure "(http-1.x-response-parser REQUEST) => REQUEST" (id http-1.x-response-parser))) (p "Predefined response parsers for use with " (tt "response-parser") ".")) (def (sig (parameter "(response-unparsers [LIST])" (id response-unparsers))) (p "Responses are written using unparse procedures, which can be customized by overriding this parameter.") (p "LIST is a list of procedures which accept a response object and write to the response's output port and return the new, possibly updated response object. If the response object is not unparsed by this handler, it returns " (tt "#f") ".") (p "The predefined response unparsers are the following:") (ul (li (tt "http-0.9-response-unparser")) (li (tt "http-1.x-response-unparser")))) (def (sig (procedure "(http-0.9-response-unparser REQUEST) => REQUEST" (id http-0.9-response-unparser)) (procedure "(http-1.x-response-unparser REQUEST) => REQUEST" (id http-1.x-response-unparser))) (p "Predefined response unparsers for use with " (tt "response-unparser") "."))) (section 3 "Headers" (def (sig (procedure "(headers ALIST [HEADERS]) => HEADERS" (id headers))) (p "This creates a header object based on an input list.") (p "Requests and responses contain HTTP headers wrapped in a special header-object to ensure they are properly normalized.") (p "The input list has header names (symbols) as keys, and lists of values as values:") (highlight scheme "(headers `((host (\"example.com\" . 8080))\n           (accept #(text/html ((q . 0.5)))\n                   #(text/xml ((q . 0.1)))))\n          old-headers)") (p "This adds the named headers to the existing headers in " (tt "old-headers") ". The host header is a pair of hostname/port. The accept header is a list of allowed mime-type symbols.") (p "As can be seen here, optional parameters or \"attributes\" can be added to a header value by wrapping the value in a vector of length 2. The first entry in the vector is the header value, the second is an alist of attribute name/value pairs.")) (def (sig (procedure "(headers->list HEADERS) => ALIST" (id headers->list))) (p "This converts a header object back to a list.  See " (tt "headers") " for details.")) (def (sig (procedure "(header-values NAME HEADERS) => LIST" (id header-values))) (p "Obtain the value of header NAME in the HEADERS object.") (p "The NAME of the header is a symbol; this procedure will return all the values of the header (for example, the Accept header will have several values that indicate the set of acceptable mime-types).")) (def (sig (procedure "(header-value NAME HEADERS [DEFAULT]) => value" (id header-value))) (p "If you know in advance that a header has only one value, you can use " (tt "header-value") " instead of " (tt "header-values") ".  This will return the first value in the list, or the provided default if there is no value for that header.")) (def (sig (procedure "(header-params NAME HEADERS) => ALIST" (id header-params))) (p "This will return all the params for a given header, assuming there is only one header.  An empty list is returned if the header does not exist.")) (def (sig (procedure "(header-param PARAM NAME HEADERS [DEFAULT]) => value" (id header-param))) (p "This will return a specific parameter for the header, or DEFAULT if the parameter isn't present or the header does not exist.  This also assumes there's only one header.")) (def (sig (procedure "(header-contents NAME HEADERS) => VECTOR" (id header-contents)) (procedure "(get-value VECTOR) => value" (id get-value)) (procedure "(get-params VECTOR) => ALIST" (id get-params)) (procedure "(get-param PARAM VECTOR [DEFAULT]) => value" (id get-param))) (p "Procedures such as " (tt "header-values") " are just shortcuts; these are the underlying procedures to query the raw contents of a header.") (p "Header contents are 2-element vectors; the first value containing the value for the header and the second value containing an alist with \"parameters\" for that header value. Parameters are attribute/value pairs that define further specialization of a header's value. For example, the " (tt "accept") " header consists of a list of mime-types, which optionally can have a quality parameter that defines the preference for that mime-type.  All parameter names are downcased symbols, just like header names.")) (section 4 "Header types" (p "The headers all have their own different types.  Here follows a list of headers with their value types:") (table (tr (th "Header name") (th "Value type") (th "Example value")) "\n" (tr "\n" (td (tt "accept")) "\n" (td "List of mime-types (symbols), with optional " (tt "q") " attribute\nindicating \"quality\" (preference level)") "\n" (td (tt "(text/html #(text/xml ((q . 0.1))))")) "\n") "\n" (tr "\n" (td (tt "accept-charset")) "\n" (td "List of charset-names (symbols), with optional " (tt "q") " attribute") "\n" (td (tt "(utf-8 #(iso-8859-5 ((q . 0.1))))")) "\n") "\n" (tr "\n" (td (tt "accept-encoding")) "\n" (td "List of encoding-names (symbols), with optional " (tt "q") " attribute") "\n" (td (tt "(gzip #(identity ((q . 0))))")) "\n") "\n" (tr "\n" (td (tt "accept-language")) "\n" (td "List of language-names (symbols), with optional " (tt "q") " attribute") "\n" (td (tt "(en-gb #(nl ((q . 0.5))))")) "\n") "\n" (tr "\n" (td (tt "accept-ranges")) "\n" (td "List of range types acceptable (symbols). The spec only defines\n" (tt "bytes") " and " (tt "none") ".") "\n" (td (tt "(bytes)")) "\n") "\n" (tr "\n" (td (tt "age")) "\n" (td "Age in seconds (number)") "\n" (td (tt "(3600)")) "\n") "\n" (tr "\n" (td (tt "allow")) "\n" (td "List of methods that are allowed (symbols).") "\n" (td (tt "(GET POST PUT DELETE)")) "\n") "\n" (tr "\n" (td (tt "authorization")) "\n" (td "Authorization information. This consists of a symbol identifying the\nauthentication scheme, with scheme-specific attributes.\n" (tt "basic") " is handled specially, as if it were a regular symbol with two\nattributes; " (tt "username") " and " (tt "password") ".") "\n" (td (tt "(#(basic ((username . \"foo\") (password . \"bar\"))) #(digest ((qop . auth) (username . \"Mufasa\") (nc . 1))))")) "\n") "\n" (tr "\n" (td (tt "cache-control")) "\n" (td "An alist of key/value pairs. If no value is applicable, it is " (tt "#t")) "\n" (td "((public . #t) (max-stale . 10) (no-cache . (age set-cookie)))") "\n") "\n" (tr "\n" (td (tt "connection")) "\n" (td "A list of connection options (symbols)") "\n" (td (tt "(close)")) "\n") "\n" (tr "\n" (td (tt "content-encoding")) "\n" (td "A list of encodings (symbols) applied to the entity-body.") "\n" (td (tt "(deflate gzip)")) "\n") "\n" (tr "\n" (td (tt "content-language")) "\n" (td "The natural language(s) of the \"intended audience\" (symbols)") "\n" (td (tt "(de nl en-gb)")) "\n") "\n" (tr "\n" (td (tt "content-length")) "\n" (td "The number of bytes (an exact number) in the entity-body") "\n" (td (tt "(10)")) "\n") "\n" (tr "\n" (td (tt "content-location")) "\n" (td "A location that the content can be retrieved from (a uri-common object)") "\n" (td (tt "(<#uri-common# ...>)")) "\n") "\n" (tr "\n" (td (tt "content-md5")) "\n" (td "The MD5 checksum (a string) of the entity-body") "\n" (td (tt "(\"12345ABCDEF\")")) "\n") "\n" (tr "\n" (td (tt "content-range")) "\n" (td "Content range (pair with start- and endpoint) of the entity-body, if partially sent") "\n" (td (tt "((25 . 120))")) "\n") "\n" (tr "\n" (td (tt "content-type")) "\n" (td "The mime type of the entity-body (a symbol)") "\n" (td (tt "(text/html)")) "\n") "\n" (tr "\n" (td (tt "date")) "\n" (td "A timestamp (10-element vector, see " (tt "string->time") ") at which the message originated. " (i "Important") ": Note that you will always need to supply (an empty list of) attributes, because otherwise it is ambiguous whether it's a vector with attribs or a bare timestamp.") "\n" (td (tt "(#(#(42 23 15 20 6 108 0 309 #f 0) ()))")) "\n") "\n" (tr "\n" (td (tt "etag")) "\n" (td "An entity-tag (pair, car being either the symbol weak or strong, cdr being a string) that uniquely identifies the resource contents.") "\n" (td (tt "((strong . \"foo123\"))")) "\n") "\n" (tr "\n" (td (tt "expect")) "\n" (td "Expectations of the server's behaviour (alist of symbol-string pairs), possibly with parameters.") "\n" (td (tt "(#(((100-continue . #t)) ()))")) "\n") "\n" (tr "\n" (td (tt "expires")) "\n" (td "Expiry timestamp (10-element vector, see " (tt "string->time") ") for the entity. Also see the note for " (tt "date")) "\n" (td (tt "(#(#(42 23 15 20 6 108 0 309 #f 0) ()))")) "\n") "\n" (tr "\n" (td (tt "from")) "\n" (td "The e-mail address (a string) of the human user who controls the client") "\n" (td (tt "(\"info@example.com\")")) "\n") "\n" (tr "\n" (td (tt "host")) "\n" (td "The host to use (for virtual hosting). This is a pair of hostname and port. The port will be " (tt "#f") " if the port should be the default one for the requested service.") "\n" (td (tt "((\"example.com\" . 8080))")) "\n") "\n" (tr "\n" (td (tt "if-match")) "\n" (td "Either " (tt "'*") " (a wildcard symbol) or a list of entity-tags (pair, weak/strong symbol and unique entity identifier string).") "\n" (td (tt "((strong . \"foo123\") (strong . \"bar123\"))")) "\n") "\n" (tr "\n" (td (tt "if-modified-since")) "\n" (td "Timestamp (10-element vector, see " (tt "string->time") ") which indicates since when the entity must have been modified.") "\n" (td (tt "(#(#(42 23 15 20 6 108 0 309 #f 0) ()))")) "\n") "\n" (tr "\n" (td (tt "if-none-match")) "\n" (td "Either " (tt "'*") " (a wildcard symbol) or a list of entity-tags (pair, weak/strong symbol and unique entity identifier symbol).") "\n" (td (tt "((strong . foo123) (strong . bar123))")) "\n") "\n" (tr "\n" (td (tt "if-range")) "\n" (td "The range to request, if the entity was unchanged") "\n" (td "TODO") "\n") "\n" (tr "\n" (td (tt "if-unmodified-since")) "\n" (td "A timestamp (10-element vector, see " (tt "string->time") ") since which the entity must not have been modified") "\n" (td (tt "(#(#(42 23 15 20 6 108 0 309 #f 0) ()))")) "\n") "\n" (tr "\n" (td (tt "last-modified")) "\n" (td "A timestamp (10-element vector, see " (tt "string->time") ") when the entity was last modified") "\n" (td (tt "(#(#(42 23 15 20 6 108 0 309 #f 0) ()))")) "\n") "\n" (tr "\n" (td (tt "location")) "\n" (td "A location (an URI object) to which to redirect") "\n" (td (tt "(<#uri-object ...>)")) "\n") "\n" (tr "\n" (td (tt "max-forwards")) "\n" (td "The maximum number of proxies that can forward a request") "\n" (td (tt "(2)")) "\n") "\n" (tr "\n" (td (tt "pragma")) "\n" (td "An alist of symbols containing implementation-specific directives.") "\n" (td (tt "((no-cache . #t) (my-extension . my-value))")) "\n") "\n" (tr "\n" (td (tt "proxy-authenticate")) "\n" (td "Proxy authentication request.  Equivalent to " (tt "www-authenticate") ", for proxies.") "\n" (td (tt "(#(basic ((realm . \"foo\")) ) #(digest ((realm . \"foo\") (domain . (<#uri object> <#uri object>)) (qop . (auth auth-int)) (nonce . \"012345abc\"))))")) "\n") "\n" (tr "\n" (td (tt "proxy-authorization")) "\n" (td "The answer to a " (tt "proxy-authentication") " request. Equivalent to " (tt "authorization") ", for proxies.") "\n" (td (tt "(#(basic ((username . \"foo\") (password . \"bar\"))) #(digest ((qop . auth) (username . \"Mufasa\") (nc . 1))))")) "\n") "\n" (tr "\n" (td (tt "range")) "\n" (td "The range of bytes (a pair of start and end) to request from the server.") "\n" (td (tt "((25 . 120))")) "\n") "\n" (tr "\n" (td (tt "referer")) "\n" (td "The referring URL (uri-common object) that linked to this one.") "\n" (td (tt "(<#uri-object ...>)")) "\n") "\n" (tr "\n" (td (tt "retry-after")) "\n" (td "Timestamp (10-element vector, see " (tt "string->time") ") after which to retry the request if unavailable now.") "\n" (td (tt "(#(#(42 23 15 20 6 108 0 309 #f 0) ()))")) "\n") "\n" (tr "\n" (td (tt "server")) "\n" (td "List of products the server uses (list of 3-tuple lists of strings; product name, product version, comment. Version and/or comment may be " (tt "#f") "). Note that this is a single header, with a list inside it!") "\n" (td (tt "(((\"Apache\" \"2.2.9\" \"Unix\") (\"mod_ssl\" \"2.2.9\" #f) (\"OpenSSL\" \"0.9.8e\" #f) (\"DAV\" \"2\" #f) (\"mod_fastcgi\" \"2.4.2\" #f) (\"mod_apreq2-20051231\" \"2.6.0\" #f)))")) "\n") "\n" (tr "\n" (td (tt "te")) "\n" (td "Allowed transfer-encodings (symbols, with optional q attribute) for the response") "\n" (td (tt "(deflate #(gzip ((q . 0.2))))")) "\n") "\n" (tr "\n" (td (tt "trailer")) "\n" (td "Names of header fields (symbols) available in the trailer/after body") "\n" (td (tt "(range etag)")) "\n") "\n" (tr "\n" (td (tt "transfer-encoding")) "\n" (td "The encodings (symbols) used in the body") "\n" (td (tt "(chunked)")) "\n") "\n" (tr "\n" (td (tt "upgrade")) "\n" (td "Product names to which must be upgraded (strings)") "\n" (td "TODO") "\n") "\n" (tr "\n" (td (tt "user-agent")) "\n" (td "List of products the user agent uses (list of 3-tuple lists of strings; product name, product version, comment. Version and/or comment may be " (tt "#f") "). Note that this is a single header, with a list inside it!") "\n" (td (tt "(((\"Mozilla\" \"5.0\" \"X11; U; NetBSD amd64; en-US; rv:1.9.0.3\") (\"Gecko\" \"2008110501\" #f) (\"Minefield\" \"3.0.3\" #f)))")) "\n") "\n" (tr "\n" (td (tt "vary")) "\n" (td "The names of headers that define variation in the resource body, to determine cachability (symbols)") "\n" (td (tt "(range etag)")) "\n") "\n" (tr "\n" (td (tt "via")) "\n" (td "The intermediate hops through which the message is forwarded (strings)") "\n" (td "TODO") "\n") "\n" (tr "\n" (td (tt "warning")) "\n" (td "Warning code for special status") "\n" (td "TODO") "\n") "\n" (tr "\n" (td (tt "www-authenticate")) "\n" (td "If unauthorized, a challenge to authenticate (symbol, with attributes)") "\n" (td (tt "(#(basic ((realm . \"foo\"))) #(digest ((realm . \"foo\") (domain . (<#uri object> <#uri object>)) (qop . (auth auth-int)) (nonce . \"012345abc\"))))")) "\n") "\n" (tr "\n" (td (tt "set-cookie")) "\n" (td "Cookies to set (name/value pair (both strings), with attributes)") "\n" (td (tt "(#((\"foo\" . \"bar\") ((max-age . 10) (port . '(80 8080))))")) "\n") "\n" (tr "\n" (td (tt "cookie")) "\n" (td "Cookies that were set (name/value string pair, with attributes)") "\n" (td (tt "(#((\"foo\" . \"bar\") ((version . 1) (path . #(uri path: (/ \"\"))) (domain . \"foo.com\"))))")) "\n")) (p "Any unrecognised headers are assumed to be multi-headers, and the entire header lines are put unparsed into a list, one entry per line.")) (section 4 "Header parsers and unparsers" (def (sig (parameter "(header-parsers [ALIST])" (id header-parsers)) (parameter "(header-unparsers [ALIST])" (id header-unparsers))) (p "The parsers and unparsers used to read and write header values can be customized with these parameters.") (p "These (un)parsers are indexed with as key the header name (a symbol) and the value being a procedure.") (p "A header parser accepts the contents of the header (a string, without the leading header name and colon) and returns a " (i "list of vectors") " which represents the values of the header.  For headers that are supposed to only have a single value, the last value in the list will be stored as the value (as determined by " (tt "single-headers") ").") (p "A header unparser accepts one argument: the header's contents (a vector).  It should return a list of strings, each of which represents one line's worth of header contents (without the header name).  For each entry, a header line will automatically be printed with the header name preceding it.") (p "The parser driver will call " (tt "update-header-contents!") " with the parser's result.")) (def (sig (parameter "(header-parse-error-handler [HANDLER])" (id header-parse-error-handler))) (p "When there is an error parsing a given header, this parameter's procedure will be invoked.") (p (tt "HANDLER") " is a procedure accepting four values: the header name, the header contents, the current headers and the exception object.  The procedure must return the new headers.  Defaults to a procedure that simply returns the current headers.  When an error occurs while parsing the header line itself (for example when a colon is missing between the header name and contents), the error will not be caught.") (p "In such a case, Servers should return a 400 Bad Request error and clients should error out.  The reason that malformed error lines are ignored is that there are several servers and clients that send headers content values that are slightly off, even though the rest of the request is OK.  In the interest of the \"robustness principle\", it's best to simply ignore these headers with \"bad\" content values.")) (def (sig (procedure "(replace-header-contents NAME CONTENTS HEADERS) => HEADERS" (id replace-header-contents)) (procedure "(replace-header-contents! NAME CONTENTS HEADERS) => HEADERS" (id replace-header-contents!)) (procedure "(update-header-contents NAME CONTENTS HEADERS) => HEADERS" (id update-header-contents)) (procedure "(update-header-contents! NAME CONTENTS HEADERS) => HEADERS" (id update-header-contents!))) (p "The " (tt "replace") " procedures replace any existing contents of the named header with new ones, the " (tt "update") " procedures add these contents to the existing header. The procedures with a name ending in bang are linear update variants of the ones without the bang. The header contents have to be normalized to be a 2-element vector, with the first element being the actual value and the second element being an alist (possibly empty) of parameters/attributes for that value.") (p "The update procedures append the value to the existing header if it is a multi-header, and act as a simple replace in the case of a single-header.")) (def (sig (parameter "(single-headers [LIST])" (id single-headers))) (p "Whether a header is allowed once or multiple times in a request or response is determined by this parameter.") (p "The value is a list of symbols that define header-names which are allowed to occur only once in a request/response.")) (def (sig (procedure "(http-name->symbol-name STRING) => SYMBOL" (id http-name->symbol-name)) (procedure "(symbol->http-name SYMBOL) => STRING" (id symbol->http-name))) (p "These procedures convert strings containing the name of a header or attribute (parameter name) to symbols representing the same. The symbols are completely downcased.  When converting this symbol back to a string, the initial letters of all the words in the header name or attribute are capitalized.")) (def (sig (procedure "(remove-header name headers) => headers" (id remove-header)) (procedure "(remove-header! name headers) => headers" (id remove-header!))) (p "These two procedures remove all headers with the given name.")))) (section 3 "Other procedures" (def (sig (procedure "(keep-alive? request-or-response)" (id keep-alive?))) (p "Returns " (tt "#t") " when the given request or response object belongs to a connection that should be kept alive, " (tt "#f") " if not.  Remember that both parties must agree on whether the connection is to be kept alive or not; HTTP/1.1 defaults to keep alive unless a " (tt "Connection: close") " header is sent, HTTP/1.0 defaults to closing the connection, unless a " (tt "Connection: Keep-Alive") " header is sent.")) (def (sig (procedure "(safe? request-or-method)" (id safe?))) (p "Returns " (tt "#t") " when the given request object or symbol (method) is a " (i "safe") " method.  A method is defined to be safe when a request of this method will have no side-effects on the server.  In practice this means that you can send this request from anywhere at any time and cause no damage.") (p (b "Important") ": Quite a lot of software does not abide by these rules!  This is not necessarily a reason to treat all methods as unsafe, however.  In the words of the standard \"the user did not request the side-effects, so therefore cannot be held accountable for them\".  If a safe method produces side-effects, that's the server-side script developer's fault and he should fix his code.")) (def (sig (parameter "(safe-methods [symbols])" (id safe-methods))) (p "A list of methods which are to be considered safe.  Defaults to " (tt "'(GET HEAD OPTIONS TRACE)") ".")) (def (sig (procedure "(idempotent? request-or-method)" (id idempotent?))) (p "Returns " (tt "#t") " when the given request object or symbol (method) is a " (i "idempotent") " method.  A method is defined to be idempotent when a series of identical requests of this method in succession causes the exact same side-effect as just one such request.  In practice this means that you can safely retry such a request when an error occurs, for example.") (p (b "Important") ": Just as with the " (i "safe") " methods, there is no guarantee that methods that " (i "should be") " idempotent really are idempotent in any given web application.  Furthermore, a sequence of requests which each are individually idempotent is not necessarily idempotent as a whole.  This means that you cannot replay requests starting anywhere in the chain.  To be on the safe side, only retry the last request in the chain.")) (def (sig (parameter "(idempotent-methods [symbols])" (id idempotent-methods))) (p "A list of methods which are to be considered idempotent.  Defaults to " (tt "'(GET HEAD PUT DELETE OPTIONS TRACE)") ".")) (def (sig (procedure "(etag=? a b)" (id etag=?))) (p "Do the etag values " (tt "a") " and " (tt "b") " strongly match?  That is, their " (tt "car") " and " (tt "cdr") " must be equal, and neither can have a " (tt "car") " of " (tt "weak") " (both must be " (tt "strong") ").")) (def (sig (procedure "(etag=-weakly? a b)" (id etag=-weakly?))) (p "Do the etag values " (tt "a") " and " (tt "b") " weakly match?  That is, their " (tt "car") " and " (tt "cdr") " must be equal.  A " (tt "car") " of " (tt "weak") " is allowed.")) (def (sig (procedure "(etag-matches? etag matches)" (id etag-matches?))) (p "Does the " (tt "etag") " strongly match any of the etags in the list " (tt "matches") "?  " (tt "matches") " is a plain list of etag values, but it can also contain the special symbol " (tt "*") ", which matches any etag.")) (def (sig (procedure "(etag-matches-weakly? etag matches)" (id etag-matches-weakly?))) (p "Does the " (tt "etag") " weakly match any of the etags in the list " (tt "matches") "?  " (tt "matches") " is a plain list of etag values, but it can also contain the special symbol " (tt "*") ", which matches any etag."))) (section 3 "Changelog" (ul (li "0.6 Change path parameters on cookies to be uri-common objects") (li "0.5 Add regex requirement to make it work with Chicken 4.6.2+") (li "0.4 Don't unparse \"attributes\" (aka \"params\") by titlecasing their names. Don't default Host header's port to 80, but use #f") (li "0.3 Add rfc1123 to default unparser list for the 'date' header. Add etag procedures and if-match unparser. Change procedure signature for header unparsers") (li "0.2 Make cookie header parsers/unparsers preserve cookie name case. Change header unparse procedure semantics slightly.") (li "0.1 Initial version"))) (section 3 "License" (pre " Copyright (c) 2008-2010, Peter Bex\n All rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n \n Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n \n Redistributions in binary form must reproduce the above copyright\n notice, this list of conditions and the following disclaimer in the\n documentation and/or other materials provided with the distribution.\n \n Neither the name of the author nor the names of its contributors may\n be used to endorse or promote products derived from this software\n without specific prior written permission.\n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n OF THE POSSIBILITY OF SUCH DAMAGE."))))