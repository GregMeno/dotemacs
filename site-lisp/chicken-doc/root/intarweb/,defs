(index ("make-request" 0) ("request-uri" 797) ("request-port" 797) ("request-method" 797) ("request-major" 797) ("request-minor" 797) ("request-headers" 797) ("write-request" 1275) ("read-request" 1652) ("request-parsers" 1873) ("http-0.9-request-parser" 2346) ("http-1.x-request-parser" 2346) ("request-unparsers" 2606) ("http-0.9-request-unparser" 3150) ("http-1.x-request-unparser" 3150) ("make-response" 3523) ("response-port" 3863) ("response-code" 3863) ("response-reason" 3863) ("response-class" 3863) ("response-major" 3863) ("response-minor" 3863) ("response-headers" 3863) ("write-response" 4863) ("read-response" 5134) ("response-parsers" 5348) ("http-0.9-response-parser" 5834) ("http-1.x-response-parser" 5834) ("response-unparsers" 6101) ("http-0.9-response-unparser" 6671) ("http-1.x-response-unparser" 6671) ("headers" 6950) ("headers->list" 7912) ("header-values" 8079) ("header-value" 8426) ("header-params" 8762) ("header-param" 8995) ("header-contents" 9268) ("get-value" 9268) ("get-params" 9268) ("get-param" 9268) ("header-parsers" 10202) ("header-unparsers" 10202) ("header-parse-error-handler" 11305) ("replace-header-contents" 12332) ("replace-header-contents!" 12332) ("update-header-contents" 12332) ("update-header-contents!" 12332) ("single-headers" 13395) ("http-name->symbol-name" 13702) ("symbol->http-name" 13702) ("remove-header" 14178) ("remove-header!" 14178) ("keep-alive?" 14405) ("safe?" 14908) ("safe-methods" 15679) ("idempotent?" 15856) ("idempotent-methods" 16754) ("etag=?" 16960) ("etag=-weakly?" 17238) ("etag-matches?" 17486) ("etag-matches-weakly?" 17788))
(def (sig (procedure "(make-request #!key uri port (method 'GET) (major 1) (minor 1) (headers (make-headers '())))" (id make-request))) (p "Create a request object (a " (int-link "defstruct") "-type record). The client will generally write requests, while the server will read them.") (p "The URI defines the entity to retrieve on the server, which should be a " (int-link "uri-common") "-type URI object. The PORT is the scheme I/O port where the request is written to or read from.  The METHOD is a symbol that defines the HTTP method to use (case sensitive). MAJOR and MINOR identify the major and minor version of HTTP to use. Currently, 0.9, 1.0 and 1.1 are supported (but be careful with 0.9, it has some weird consequences and is not widely supported). HEADERS must be a headers object."))
(def (sig (procedure "(request-uri REQUEST) => URI" (id request-uri)) (procedure "(request-port REQUEST) => PORT" (id request-port)) (procedure "(request-method REQUEST) => SYMBOL" (id request-method)) (procedure "(request-major REQUEST) => NUMBER" (id request-major)) (procedure "(request-minor REQUEST) => NUMBER" (id request-minor)) (procedure "(request-headers REQUEST) => HEADERS" (id request-headers))) (p "An existing request can be picked apart with these accessors."))
(def (sig (procedure "(write-request REQUEST) => REQUEST" (id write-request))) (p "Write a request line with headers to the server.  In case it is a request type that has any body data, this should be written to the the request's port. Beware that this port can be modified by write-request, so be sure to write to the port as it is returned by the write-request procedure!"))
(def (sig (procedure "(read-request PORT) => REQUEST" (id read-request))) (p "Reads a request object from the given input-port.  An optional request body can be read from the request-port after calling this procedure."))
(def (sig (parameter "(request-parsers [LIST])" (id request-parsers))) (p "Requests are parsed using parse procedures, which can be customized by overriding this parameter.") (p "LIST is a list of procedures which accept a request line string and produce a request object, or " (tt "#f") " if the request is not of the type handled by that procedure.") (p "The predefined request parsers are:") (ul (li (tt "http-0.9-request-parser")) (li (tt "http-1.x-request-parser"))))
(def (sig (procedure "(http-0.9-request-parser STRING) => REQUEST" (id http-0.9-request-parser)) (procedure "(http-1.x-request-parser STRING) => REQUEST" (id http-1.x-request-parser))) (p "Predefined request parsers for use with " (tt "request-parsers") "."))
(def (sig (parameter "(request-unparsers [LIST])" (id request-unparsers))) (p "Requests are written using unparse procedures, which can be customized by overriding this parameter.") (p "LIST is list of procedures which accept a request object and write to the request's output port and return the new, possibly updated request object. If the request object is not unparsed by this handler, it returns " (tt "#f") ".") (p "The predefined request unparsers are:") (ul (li (tt "http-0.9-request-unparser")) (li (tt "http-1.x-request-unparser"))))
(def (sig (procedure "(http-0.9-request-unparser REQUEST) => REQUEST" (id http-0.9-request-unparser)) (procedure "(http-1.x-request-unparser REQUEST) => REQUEST" (id http-1.x-request-unparser))) (p "Predefined request unparsers for use with " (tt "request-unparsers") ". They return the request, and as a side effect they write the request to the request object's port."))
(def (sig (procedure "(make-response #!key port (code 200) (reason \"OK\") (major 1) (minor 1) (headers (make-headers '())))" (id make-response))) (p "Create a response, a " (int-link "defstruct") "-type record.  A server will usually write a response with " (tt "write-response") "; a client will read it with " (tt "read-response") "."))
(def (sig (procedure "(response-port RESPONSE) => PORT" (id response-port)) (procedure "(response-code RESPONSE) => NUMBER" (id response-code)) (procedure "(response-reason RESPONSE) => STRING" (id response-reason)) (procedure "(response-class RESPONSE-OR-CODE) => NUMBER" (id response-class)) (procedure "(response-major RESPONSE) => NUMBER" (id response-major)) (procedure "(response-minor RESPONSE) => NUMBER" (id response-minor)) (procedure "(response-headers RESPONSE) => HEADERS" (id response-headers))) (p "An existing response can be picked apart using these accessors.") (p "The PORT, MAJOR, MINOR and HEADERS are the same as for requests. CODE and REASON are an integer status code and the short message that belongs to it, as defined in the spec (examples include: 200 OK, 301 Moved Permanently, etc).  CLASS is the major class of the response code (100, 200, 300, 400 or 500).  " (tt "response-class") " can be called either on a response object or directly on a response code number."))
(def (sig (procedure "(write-response RESPONSE) => RESPONSE" (id write-response))) (p "Write the response object RESPONSE to the " (tt "response-port") ".") (p "If there is a response body, this must be written to the response-port after sending the response headers."))
(def (sig (procedure "(read-response PORT) => RESPONSE" (id read-response))) (p "Reads a response object from the port. An optional response body can be read from the response-port after calling this procedure."))
(def (sig (parameter "(response-parsers [LIST])" (id response-parsers))) (p "Responses are parsed using parse procedures, which can be customized by overriding this parameter.") (p "LIST is a list one of procedures which accept a response line string and produce a response object, or " (tt "#f") " if the response is not of the type handled by that procedure.") (p "The predefined response parsers are:") (ul (li (tt "http-0.9-response-parser")) (li (tt "http-1.x-response-parser"))))
(def (sig (procedure "(http-0.9-response-parser REQUEST) => REQUEST" (id http-0.9-response-parser)) (procedure "(http-1.x-response-parser REQUEST) => REQUEST" (id http-1.x-response-parser))) (p "Predefined response parsers for use with " (tt "response-parser") "."))
(def (sig (parameter "(response-unparsers [LIST])" (id response-unparsers))) (p "Responses are written using unparse procedures, which can be customized by overriding this parameter.") (p "LIST is a list of procedures which accept a response object and write to the response's output port and return the new, possibly updated response object. If the response object is not unparsed by this handler, it returns " (tt "#f") ".") (p "The predefined response unparsers are the following:") (ul (li (tt "http-0.9-response-unparser")) (li (tt "http-1.x-response-unparser"))))
(def (sig (procedure "(http-0.9-response-unparser REQUEST) => REQUEST" (id http-0.9-response-unparser)) (procedure "(http-1.x-response-unparser REQUEST) => REQUEST" (id http-1.x-response-unparser))) (p "Predefined response unparsers for use with " (tt "response-unparser") "."))
(def (sig (procedure "(headers ALIST [HEADERS]) => HEADERS" (id headers))) (p "This creates a header object based on an input list.") (p "Requests and responses contain HTTP headers wrapped in a special header-object to ensure they are properly normalized.") (p "The input list has header names (symbols) as keys, and lists of values as values:") (highlight scheme "(headers `((host (\"example.com\" . 8080))\n           (accept #(text/html ((q . 0.5)))\n                   #(text/xml ((q . 0.1)))))\n          old-headers)") (p "This adds the named headers to the existing headers in " (tt "old-headers") ". The host header is a pair of hostname/port. The accept header is a list of allowed mime-type symbols.") (p "As can be seen here, optional parameters or \"attributes\" can be added to a header value by wrapping the value in a vector of length 2. The first entry in the vector is the header value, the second is an alist of attribute name/value pairs."))
(def (sig (procedure "(headers->list HEADERS) => ALIST" (id headers->list))) (p "This converts a header object back to a list.  See " (tt "headers") " for details."))
(def (sig (procedure "(header-values NAME HEADERS) => LIST" (id header-values))) (p "Obtain the value of header NAME in the HEADERS object.") (p "The NAME of the header is a symbol; this procedure will return all the values of the header (for example, the Accept header will have several values that indicate the set of acceptable mime-types)."))
(def (sig (procedure "(header-value NAME HEADERS [DEFAULT]) => value" (id header-value))) (p "If you know in advance that a header has only one value, you can use " (tt "header-value") " instead of " (tt "header-values") ".  This will return the first value in the list, or the provided default if there is no value for that header."))
(def (sig (procedure "(header-params NAME HEADERS) => ALIST" (id header-params))) (p "This will return all the params for a given header, assuming there is only one header.  An empty list is returned if the header does not exist."))
(def (sig (procedure "(header-param PARAM NAME HEADERS [DEFAULT]) => value" (id header-param))) (p "This will return a specific parameter for the header, or DEFAULT if the parameter isn't present or the header does not exist.  This also assumes there's only one header."))
(def (sig (procedure "(header-contents NAME HEADERS) => VECTOR" (id header-contents)) (procedure "(get-value VECTOR) => value" (id get-value)) (procedure "(get-params VECTOR) => ALIST" (id get-params)) (procedure "(get-param PARAM VECTOR [DEFAULT]) => value" (id get-param))) (p "Procedures such as " (tt "header-values") " are just shortcuts; these are the underlying procedures to query the raw contents of a header.") (p "Header contents are 2-element vectors; the first value containing the value for the header and the second value containing an alist with \"parameters\" for that header value. Parameters are attribute/value pairs that define further specialization of a header's value. For example, the " (tt "accept") " header consists of a list of mime-types, which optionally can have a quality parameter that defines the preference for that mime-type.  All parameter names are downcased symbols, just like header names."))
(def (sig (parameter "(header-parsers [ALIST])" (id header-parsers)) (parameter "(header-unparsers [ALIST])" (id header-unparsers))) (p "The parsers and unparsers used to read and write header values can be customized with these parameters.") (p "These (un)parsers are indexed with as key the header name (a symbol) and the value being a procedure.") (p "A header parser accepts the contents of the header (a string, without the leading header name and colon) and returns a " (i "list of vectors") " which represents the values of the header.  For headers that are supposed to only have a single value, the last value in the list will be stored as the value (as determined by " (tt "single-headers") ").") (p "A header unparser accepts one argument: the header's contents (a vector).  It should return a list of strings, each of which represents one line's worth of header contents (without the header name).  For each entry, a header line will automatically be printed with the header name preceding it.") (p "The parser driver will call " (tt "update-header-contents!") " with the parser's result."))
(def (sig (parameter "(header-parse-error-handler [HANDLER])" (id header-parse-error-handler))) (p "When there is an error parsing a given header, this parameter's procedure will be invoked.") (p (tt "HANDLER") " is a procedure accepting four values: the header name, the header contents, the current headers and the exception object.  The procedure must return the new headers.  Defaults to a procedure that simply returns the current headers.  When an error occurs while parsing the header line itself (for example when a colon is missing between the header name and contents), the error will not be caught.") (p "In such a case, Servers should return a 400 Bad Request error and clients should error out.  The reason that malformed error lines are ignored is that there are several servers and clients that send headers content values that are slightly off, even though the rest of the request is OK.  In the interest of the \"robustness principle\", it's best to simply ignore these headers with \"bad\" content values."))
(def (sig (procedure "(replace-header-contents NAME CONTENTS HEADERS) => HEADERS" (id replace-header-contents)) (procedure "(replace-header-contents! NAME CONTENTS HEADERS) => HEADERS" (id replace-header-contents!)) (procedure "(update-header-contents NAME CONTENTS HEADERS) => HEADERS" (id update-header-contents)) (procedure "(update-header-contents! NAME CONTENTS HEADERS) => HEADERS" (id update-header-contents!))) (p "The " (tt "replace") " procedures replace any existing contents of the named header with new ones, the " (tt "update") " procedures add these contents to the existing header. The procedures with a name ending in bang are linear update variants of the ones without the bang. The header contents have to be normalized to be a 2-element vector, with the first element being the actual value and the second element being an alist (possibly empty) of parameters/attributes for that value.") (p "The update procedures append the value to the existing header if it is a multi-header, and act as a simple replace in the case of a single-header."))
(def (sig (parameter "(single-headers [LIST])" (id single-headers))) (p "Whether a header is allowed once or multiple times in a request or response is determined by this parameter.") (p "The value is a list of symbols that define header-names which are allowed to occur only once in a request/response."))
(def (sig (procedure "(http-name->symbol-name STRING) => SYMBOL" (id http-name->symbol-name)) (procedure "(symbol->http-name SYMBOL) => STRING" (id symbol->http-name))) (p "These procedures convert strings containing the name of a header or attribute (parameter name) to symbols representing the same. The symbols are completely downcased.  When converting this symbol back to a string, the initial letters of all the words in the header name or attribute are capitalized."))
(def (sig (procedure "(remove-header name headers) => headers" (id remove-header)) (procedure "(remove-header! name headers) => headers" (id remove-header!))) (p "These two procedures remove all headers with the given name."))
(def (sig (procedure "(keep-alive? request-or-response)" (id keep-alive?))) (p "Returns " (tt "#t") " when the given request or response object belongs to a connection that should be kept alive, " (tt "#f") " if not.  Remember that both parties must agree on whether the connection is to be kept alive or not; HTTP/1.1 defaults to keep alive unless a " (tt "Connection: close") " header is sent, HTTP/1.0 defaults to closing the connection, unless a " (tt "Connection: Keep-Alive") " header is sent."))
(def (sig (procedure "(safe? request-or-method)" (id safe?))) (p "Returns " (tt "#t") " when the given request object or symbol (method) is a " (i "safe") " method.  A method is defined to be safe when a request of this method will have no side-effects on the server.  In practice this means that you can send this request from anywhere at any time and cause no damage.") (p (b "Important") ": Quite a lot of software does not abide by these rules!  This is not necessarily a reason to treat all methods as unsafe, however.  In the words of the standard \"the user did not request the side-effects, so therefore cannot be held accountable for them\".  If a safe method produces side-effects, that's the server-side script developer's fault and he should fix his code."))
(def (sig (parameter "(safe-methods [symbols])" (id safe-methods))) (p "A list of methods which are to be considered safe.  Defaults to " (tt "'(GET HEAD OPTIONS TRACE)") "."))
(def (sig (procedure "(idempotent? request-or-method)" (id idempotent?))) (p "Returns " (tt "#t") " when the given request object or symbol (method) is a " (i "idempotent") " method.  A method is defined to be idempotent when a series of identical requests of this method in succession causes the exact same side-effect as just one such request.  In practice this means that you can safely retry such a request when an error occurs, for example.") (p (b "Important") ": Just as with the " (i "safe") " methods, there is no guarantee that methods that " (i "should be") " idempotent really are idempotent in any given web application.  Furthermore, a sequence of requests which each are individually idempotent is not necessarily idempotent as a whole.  This means that you cannot replay requests starting anywhere in the chain.  To be on the safe side, only retry the last request in the chain."))
(def (sig (parameter "(idempotent-methods [symbols])" (id idempotent-methods))) (p "A list of methods which are to be considered idempotent.  Defaults to " (tt "'(GET HEAD PUT DELETE OPTIONS TRACE)") "."))
(def (sig (procedure "(etag=? a b)" (id etag=?))) (p "Do the etag values " (tt "a") " and " (tt "b") " strongly match?  That is, their " (tt "car") " and " (tt "cdr") " must be equal, and neither can have a " (tt "car") " of " (tt "weak") " (both must be " (tt "strong") ")."))
(def (sig (procedure "(etag=-weakly? a b)" (id etag=-weakly?))) (p "Do the etag values " (tt "a") " and " (tt "b") " weakly match?  That is, their " (tt "car") " and " (tt "cdr") " must be equal.  A " (tt "car") " of " (tt "weak") " is allowed."))
(def (sig (procedure "(etag-matches? etag matches)" (id etag-matches?))) (p "Does the " (tt "etag") " strongly match any of the etags in the list " (tt "matches") "?  " (tt "matches") " is a plain list of etag values, but it can also contain the special symbol " (tt "*") ", which matches any etag."))
(def (sig (procedure "(etag-matches-weakly? etag matches)" (id etag-matches-weakly?))) (p "Does the " (tt "etag") " weakly match any of the etags in the list " (tt "matches") "?  " (tt "matches") " is a plain list of etag values, but it can also contain the special symbol " (tt "*") ", which matches any etag."))
