((tags "manual") (toc) (section 2 "Unit data-structures" (p "This unit contains a collection of procedures related to data structures.  This unit is used by default, unless the program is compiled with the " (tt "-explicit-use") " option.") (section 3 "Lists" (section 4 "alist-ref" (def (sig (procedure "(alist-ref KEY ALIST [TEST [DEFAULT]])" (id alist-ref))) (p "Looks up " (tt "KEY") " in " (tt "ALIST") " using " (tt "TEST") " as the comparison function (or " (tt "eqv?") " if no test was given) and returns the cdr of the found pair, or " (tt "DEFAULT") " (which defaults to " (tt "#f") ")."))) (section 4 "alist-update!" (def (sig (procedure "(alist-update! KEY VALUE ALIST [TEST])" (id alist-update!))) (p "If the list " (tt "ALIST") " contains a pair of the form " (tt "(KEY . X)") ", then this procedure replaces " (tt "X") " with " (tt "VALUE") " and returns " (tt "ALIST") ". If " (tt "ALIST") " contains no such item, then " (tt "alist-update!") " returns " (tt "((KEY . VALUE) . ALIST)") ". The optional argument " (tt "TEST") " specifies the comparison procedure to search a matching pair in " (tt "ALIST") " and defaults to " (tt "eqv?") "."))) (section 4 "atom?" (def (sig (procedure "(atom? X)" (id atom?))) (p "Returns " (tt "#t") " if " (tt "X") " is not a pair. This is identical to " (tt "not-pair?") " from " (int-link "Unit srfi-1") " but kept for historical reasons."))) (section 4 "rassoc" (def (sig (procedure "(rassoc KEY LIST [TEST])" (id rassoc))) (p "Similar to " (tt "assoc") ", but compares " (tt "KEY") " with the " (tt "cdr") " of each pair in " (tt "LIST") " using " (tt "TEST") " as the comparison procedures (which defaults to " (tt "eqv?") "."))) (section 4 "butlast" (def (sig (procedure "(butlast LIST)" (id butlast))) (p "Returns a fresh list with all elements but the last of " (tt "LIST") "."))) (section 4 "chop" (def (sig (procedure "(chop LIST N)" (id chop))) (p "Returns a new list of sublists, where each sublist contains " (tt "N") " elements of " (tt "LIST") ". If " (tt "LIST") " has a length that is not a multiple of " (tt "N") ", then the last sublist contains the remaining elements.") (highlight scheme "(chop '(1 2 3 4 5 6) 2) ==> ((1 2) (3 4) (5 6))\n(chop '(a b c d) 3)     ==> ((a b c) (d))"))) (section 4 "compress" (def (sig (procedure "(compress BLIST LIST)" (id compress))) (p "Returns a new list with elements taken from " (tt "LIST") " with corresponding true values in the list " (tt "BLIST") ".") (highlight scheme "(define nums '(99 100 110 401 1234))\n(compress (map odd? nums) nums)      ==> (99 401)"))) (section 4 "flatten" (def (sig (procedure "(flatten LIST1 ...)" (id flatten))) (p "Returns " (tt "LIST1 ...") " concatenated together, with nested lists removed (flattened)."))) (section 4 "intersperse" (def (sig (procedure "(intersperse LIST X)" (id intersperse))) (p "Returns a new list with " (tt "X") " placed between each element."))) (section 4 "join" (def (sig (procedure "(join LISTOFLISTS [LIST])" (id join))) (p "Concatenates the lists in " (tt "LISTOFLISTS") " with " (tt "LIST") " placed between each sublist. " (tt "LIST") " defaults to the empty list.") (highlight scheme "(join '((a b) (c d) (e)) '(x y)) ==> (a b x y c d x y e)\n(join '((p q) () (r (s) t)) '(-))  ==> (p q - - r (s) t)") (p (tt "join") " could be implemented as follows:") (highlight scheme "(define (join lstoflsts #!optional (lst '()))\n  (apply append (intersperse lstoflists lst)) )"))) (section 4 "shuffle" (def (sig (procedure "(shuffle LIST RANDOM)" (id shuffle))) (p "Returns " (tt "LIST") " with its elements sorted in a random order given by procedure " (tt "RANDOM") "."))) (section 4 "tail?" (def (sig (procedure "(tail? X LIST)" (id tail?))) (p "Returns true if " (tt "X") " is one of the tails (cdr's) of " (tt "LIST") ".")))) (section 3 "Queues" (section 4 "list->queue" (def (sig (procedure "(list->queue LIST)" (id list->queue))) (p "Returns " (tt "LIST") " converted into a queue, where the first element of the list is the same as the first element of the queue. The resulting queue may share memory with the list and the list should not be modified after this operation."))) (section 4 "make-queue" (def (sig (procedure "(make-queue)" (id make-queue))) (p "Returns a newly created queue."))) (section 4 "queue?" (def (sig (procedure "(queue? X)" (id queue?))) (p "Returns " (tt "#t") " if " (tt "X") " is a queue, or " (tt "#f") " otherwise."))) (section 4 "queue->list" (def (sig (procedure "(queue->list QUEUE)" (id queue->list))) (p "Returns " (tt "QUEUE") " converted into a list, where the first element of the list is the same as the first element of the queue. The resulting list may share memory with the queue object and should not be modified."))) (section 4 "queue-add!" (def (sig (procedure "(queue-add! QUEUE X)" (id queue-add!))) (p "Adds " (tt "X") " to the rear of " (tt "QUEUE") "."))) (section 4 "queue-empty?" (def (sig (procedure "(queue-empty? QUEUE)" (id queue-empty?))) (p "Returns " (tt "#t") " if " (tt "QUEUE") " is empty, or " (tt "#f") " otherwise."))) (section 4 "queue-first" (def (sig (procedure "(queue-first QUEUE)" (id queue-first))) (p "Returns the first element of " (tt "QUEUE") ". If " (tt "QUEUE") " is empty an error is signaled"))) (section 4 "queue-last" (def (sig (procedure "(queue-last QUEUE)" (id queue-last))) (p "Returns the last element of " (tt "QUEUE") ". If " (tt "QUEUE") " is empty an error is signaled"))) (section 4 "queue-remove!" (def (sig (procedure "(queue-remove! QUEUE)" (id queue-remove!))) (p "Removes and returns the first element of " (tt "QUEUE") ". If " (tt "QUEUE") " is empty an error is signaled"))) (section 4 "queue-push-back!" (def (sig (procedure "(queue-push-back! QUEUE ITEM)" (id queue-push-back!))) (p "Pushes an item into the first position of a queue, i.e. the next " (tt "queue-remove!") " will return " (tt "ITEM") "."))) (section 4 "queue-push-back-list!" (def (sig (procedure "(queue-push-back-list! QUEUE LIST)" (id queue-push-back-list!))) (p "Pushes the items in item-list back onto the queue, so that " (tt "(car LIST)") " becomes the next removable item.")))) (section 3 "Sorting" (section 4 "merge" (def (sig (procedure "(merge LIST1 LIST2 LESS?)" (id merge)) (procedure "(merge! LIST1 LIST2 LESS?)" (id merge!))) (p "Joins two lists in sorted order. " (tt "merge!") " is the destructive version of merge. " (tt "LESS?  ") " should be a procedure of two arguments, that returns true if the first argument is to be ordered before the second argument."))) (section 4 "sort" (def (sig (procedure "(sort SEQUENCE LESS?)" (id sort)) (procedure "(sort! SEQUENCE LESS?)" (id sort!))) (p "Sort " (tt "SEQUENCE") ", which should be a list or a vector. " (tt "sort!") " is the destructive version of sort."))) (section 4 "sorted?" (def (sig (procedure "(sorted? SEQUENCE LESS?)" (id sorted?))) (p "Returns true if the list or vector " (tt "SEQUENCE") " is already sorted."))) (section 4 "topological-sort" (def (sig (procedure "(topological-sort DAG PRED)" (id topological-sort))) (p "Sorts the directed acyclic graph dag " (tt "DAG") " so that for every edge from vertex u to v, u will come before v in the resulting list of vertices.") (p (tt "DAG") " is a list of sublists. The car of each sublist is a vertex. The cdr is the adjacency list of that vertex, i.e. a list of all vertices to which there exists an edge from the car vertex. " (tt "pred") " is procedure of two arguments that should compare vertices for equality.") (p "Time complexity: O (|V| + |E|)") (highlight scheme "(require 'tsort)\n(topological-sort\n       '((shirt tie belt)\n         (tie jacket)\n         (belt jacket)\n         (watch)\n         (pants shoes belt)\n         (undershorts pants shoes)\n         (socks shoes))\n       eq?)\n\n=>\n\n(socks undershorts pants shoes watch shirt belt tie jacket)")))) (section 3 "Random numbers" (section 4 "random-seed" (def (sig (procedure "(random-seed [SEED])" (id random-seed))) (p "Seeds the random number generator with " (tt "SEED") " (an exact integer) or " (tt "(current-seconds)") " if " (tt "SEED") " is not given.")))) (section 3 "Strings" (section 4 "conc" (def (sig (procedure "(conc X ...)" (id conc))) (p "Returns a string with the string-represenation of all arguments concatenated together. " (tt "conc") " could be implemented as") (highlight scheme "(define (conc . args)\n  (apply string-append (map ->string args)) )"))) (section 4 "->string" (def (sig (procedure "(->string X)" (id ->string))) (p "Returns a string-representation of " (tt "X") "."))) (section 4 "string-chop" (def (sig (procedure "(string-chop STRING LENGTH)" (id string-chop))) (p "Returns a list of substrings taken by " (i "chopping") " " (tt "STRING") " every " (tt "LENGTH") " characters:") (highlight scheme "(string-chop \"one two three\" 4)  ==>  (\"one \" \"two \" \"thre\" \"e\")"))) (section 4 "string-chomp" (def (sig (procedure "(string-chomp STRING [SUFFIX])" (id string-chomp))) (p "If " (tt "STRING") " ends with " (tt "SUFFIX") ", then this procedure returns a copy of its first argument with the suffix removed, otherwise returns " (tt "STRING") " unchanged. " (tt "SUFFIX") " defaults to " (tt "\"\\n\"") "."))) (section 4 "string-compare3" (def (sig (procedure "(string-compare3 STRING1 STRING2)" (id string-compare3)) (procedure "(string-compare3-ci STRING1 STRING2)" (id string-compare3-ci))) (p "Perform a three-way comparison between the " (tt "STRING1") " and " (tt "STRING2") ", returning either " (tt "-1") " if " (tt "STRING1") " is lexicographically less than " (tt "STRING2") ", " (tt "0") " if it is equal, or " (tt "1") " if it s greater. " (tt "string-compare3-ci") " performs a case-insensitive comparison."))) (section 4 "string-intersperse" (def (sig (procedure "(string-intersperse LIST [STRING])" (id string-intersperse))) (p "Returns a string that contains all strings in " (tt "LIST") " concatenated together.  " (tt "STRING") " is placed between each concatenated string and defaults to " (tt "\" \"") ".") (highlight scheme "(string-intersperse '(\"one\" \"two\") \"three\")") (p "is equivalent to") (highlight scheme "(apply string-append (intersperse '(\"one\" \"two\") \"three\"))"))) (section 4 "string-split" (def (sig (procedure "(string-split STRING [DELIMITER-STRING [KEEPEMPTY]])" (id string-split))) (p "Split string into substrings delimited by any of the characters given in the delimiter string. If no delimiters are specified, a string comprising the tab, newline and space characters is assumed. If the parameter " (tt "KEEPEMPTY") " is given and not " (tt "#f") ", then empty substrings are retained:") (highlight scheme "(string-split \"one  two  three\") ==> (\"one\" \"two\" \"three\")\n(string-split \"foo:bar::baz:\" \":\" #t) ==> (\"foo\" \"bar\" \"\" \"baz\" \"\")\n(string-split \"foo:bar:baz,quux,zot\" \":,\" ) ==> (\"foo\" \"bar\" \"baz\" \"quux\" \"zot\")"))) (section 4 "string-translate" (def (sig (procedure "(string-translate STRING FROM [TO])" (id string-translate))) (p "Returns a fresh copy of " (tt "STRING") " with characters matching " (tt "FROM") " translated to " (tt "TO") ".  If " (tt "TO") " is omitted, then matching characters are removed. " (tt "FROM") " and " (tt "TO") " may be a character, a string or a list. If both " (tt "FROM") " and " (tt "TO") " are strings, then the character at the same position in " (tt "TO") " as the matching character in " (tt "FROM") " is substituted."))) (section 4 "string-translate*" (def (sig (procedure "(string-translate* STRING SMAP)" (id string-translate*))) (p "Substitutes elements of " (tt "STRING") " according to " (tt "SMAP") ". " (tt "SMAP") " should be an association-list where each element of the list is a pair of the form " (tt "(MATCH \\. REPLACEMENT)") ". Every occurrence of the string " (tt "MATCH") " in " (tt "STRING") " will be replaced by the string " (tt "REPLACEMENT") ":") (highlight scheme "(string-translate*\n  \"<h1>this is a \\\"string\\\"</h1>\"\n  '((\"<\" . \"&lt;\") (\">\" . \"&gt;\") (\"\\\"\" . \"&quot;\")) )\n=>  \"&lt;h1&gt;this is a &quot;string&quot;&lt;/h1&gt;\""))) (section 4 "substring=?" (def (sig (procedure "(substring=? STRING1 STRING2 [START1 [START2 [LENGTH]]])" (id substring=?)) (procedure "(substring-ci=? STRING1 STRING2 [START1 [START2 [LENGTH]]])" (id substring-ci=?))) (p "Returns " (tt "#t") " if the strings " (tt "STRING1") " and " (tt "STRING2") " are equal, or " (tt "#f") " otherwise. The comparison starts at the positions " (tt "START1") " and " (tt "START2") " (which default to 0), comparing " (tt "LENGTH") " characters (which defaults to the minimum of the remaining length of both strings)."))) (section 4 "substring-index" (def (sig (procedure "(substring-index WHICH WHERE [START])" (id substring-index)) (procedure "(substring-index-ci WHICH WHERE [START])" (id substring-index-ci))) (p "Searches for first index in string " (tt "WHERE") " where string " (tt "WHICH") " occurs.  If the optional argument " (tt "START") " is given, then the search starts at that index.  " (tt "substring-index-ci") " is a case-insensitive version of " (tt "substring-index") "."))) (section 4 "reverse-string-append" (def (sig (procedure "(reverse-string-append LIST)" (id reverse-string-append))) (p (tt "(apply string-append (reverse LIST))"))))) (section 3 "Combinators" (section 4 "any?" (def (sig (procedure "(any? X)" (id any?))) (p "Ignores its argument and always returns " (tt "#t") ". This is actually useful sometimes."))) (section 4 "none?" (def (sig (procedure "(none? X)" (id none?))) (p "Ignores its argument and always returns " (tt "#f") ". This is actually useful sometimes."))) (section 4 "always?" (def (sig (procedure "(always? X)" (id always?))) (p "Ignores its arguments and always returns " (tt "#t") ". This is actually useful sometimes."))) (section 4 "never?" (def (sig (procedure "(never? X)" (id never?))) (p "Ignores its arguments and always returns " (tt "#f") ". This is actually useful sometimes."))) (section 4 "constantly" (def (sig (procedure "(constantly X ...)" (id constantly))) (p "Returns a procedure that always returns the values " (tt "X ...") " regardless of the number and value of its arguments.") (highlight scheme "(constantly X) <=> (lambda args X)"))) (section 4 "complement" (def (sig (procedure "(complement PROC)" (id complement))) (p "Returns a procedure that returns the boolean inverse of " (tt "PROC") ".") (highlight scheme "(complement PROC) <=> (lambda (x) (not (PROC x)))"))) (section 4 "compose" (def (sig (procedure "(compose PROC1 PROC2 ...)" (id compose))) (p "Returns a procedure that represents the composition of the argument-procedures " (tt "PROC1 PROC2 ...") ".") (highlight scheme "(compose F G) <=> (lambda args\n                      (call-with-values\n                         (lambda () (apply G args))\n                         F))") (p (tt "(compose)") " is equivalent to " (tt "values") "."))) (section 4 "conjoin" (def (sig (procedure "(conjoin PRED ...)" (id conjoin))) (p "Returns a procedure that returns " (tt "#t") " if its argument satisfies the predicates " (tt "PRED ...") ".") (highlight scheme "((conjoin odd? positive?) 33)   ==>  #t\n((conjoin odd? positive?) -33)  ==>  #f"))) (section 4 "disjoin" (def (sig (procedure "(disjoin PRED ...)" (id disjoin))) (p "Returns a procedure that returns " (tt "#t") " if its argument satisfies any predicate " (tt "PRED ...") ".") (highlight scheme "((disjoin odd? positive?) 32)    ==>  #t\n((disjoin odd? positive?) -32)   ==>  #f"))) (section 4 "each" (def (sig (procedure "(each PROC ...)" (id each))) (p "Returns a procedure that applies " (tt "PROC ...") " to its arguments, and returns the result(s) of the last procedure application. For example") (highlight scheme "(each pp eval)") (p "is equivalent to") (highlight scheme "(lambda args \n  (apply pp args)\n  (apply eval args) )") (p (tt "(each PROC)") " is equivalent to " (tt "PROC") " and " (tt "(each)") " is equivalent to " (tt "void") "."))) (section 4 "flip" (def (sig (procedure "(flip PROC)" (id flip))) (p "Returns a two-argument procedure that calls " (tt "PROC") " with its arguments swapped:") (highlight scheme "(flip PROC) <=> (lambda (x y) (PROC y x))"))) (section 4 "identity" (def (sig (procedure "(identity X)" (id identity))) (p "Returns its sole argument " (tt "X") "."))) (section 4 "list-of?" (def (sig (procedure "(list-of? PRED)" (id list-of?))) (p "Returns a procedure of one argument that returns " (tt "#t") " when applied to a list of elements that all satisfy the predicate procedure " (tt "PRED") ", or " (tt "#f") " otherwise.") (highlight scheme "((list-of? even?) '(1 2 3))   ==> #f\n((list-of? number?) '(1 2 3)) ==> #t"))) (section 4 "o" (def (sig (procedure "(o PROC ...)" (id o))) (p "A single value version of " (tt "compose") " (slightly faster). " (tt "(o)") " is equivalent to " (tt "identity") ".")))) (section 3 "Binary searching" (section 4 "binary-search" (def (sig (procedure "(binary-search SEQUENCE PROC)" (id binary-search))) (p "Performs a binary search in " (tt "SEQUENCE") ", which should be a sorted list or vector.  " (tt "PROC") " is called to compare items in the sequence, should accept a single argument and return an exact integer: zero if the searched value is equal to the current item, negative if the searched value is " (i "less") " than the current item, and positive otherwise. Returns the index of the found value or " (tt "#f") " otherwise.")) (hr) (p "Previous: " (int-link "Unit expand")) (p "Next: " (int-link "Unit ports"))))))