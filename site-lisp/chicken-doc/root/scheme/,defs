(index ("<variable>" 0) ("quote" 331) ("quote" 331) ("<constant>" 331) ("<operator>" 1653) ("lambda" 3438) ("if" 5972) ("if" 5972) ("set!" 6733) ("cond" 7208) ("case" 8947) ("and" 10394) ("or" 11010) ("let" 11627) ("let*" 12534) ("letrec" 13186) ("begin" 14724) ("do" 15239) ("let" 17145) ("delay" 18078) ("quasiquote" 18594) ("quasiquote" 18594) ("let-syntax" 21296) ("letrec-syntax" 22455) ("eqv?" 23449) ("eq?" 28745) ("equal?" 30585) ("number?" 31373) ("complex?" 31373) ("real?" 31373) ("rational?" 31373) ("integer?" 31373) ("exact?" 33066) ("inexact?" 33066) ("=" 33302) ("<" 33302) (">" 33302) ("<=" 33302) (">=" 33302) ("zero?" 34147) ("positive?" 34147) ("negative?" 34147) ("odd?" 34147) ("even?" 34147) ("max" 34458) ("min" 34458) ("+" 35209) ("*" 35209) ("-" 35570) ("-" 35570) ("-" 35570) ("/" 35570) ("/" 35570) ("/" 35570) ("abs" 36232) ("quotient" 36377) ("remainder" 36377) ("modulo" 36377) ("gcd" 37929) ("lcm" 37929) ("numerator" 38384) ("denominator" 38384) ("floor" 38872) ("ceiling" 38872) ("truncate" 38872) ("round" 38872) ("rationalize" 40162) ("exp" 40935) ("log" 40935) ("sin" 40935) ("cos" 40935) ("tan" 40935) ("asin" 40935) ("acos" 40935) ("atan" 40935) ("atan" 40935) ("sqrt" 42486) ("expt" 42676) ("make-rectangular" 42865) ("make-polar" 42865) ("real-part" 42865) ("imag-part" 42865) ("magnitude" 42865) ("angle" 42865) ("exact->inexact" 43993) ("inexact->exact" 43993) ("number->string" 44836) ("number->string" 44836) ("string->number" 46342) ("string->number" 46342) ("not" 47859) ("boolean?" 48178) ("pair?" 48438) ("cons" 48729) ("car" 49210) ("cdr" 49546) ("set-car!" 49845) ("set-cdr!" 50181) ("caar" 50331) ("cadr" 50331) ("cdddar" 50331) ("cddddr" 50331) ("null?" 50764) ("list?" 50878) ("list" 51269) ("length" 51487) ("append" 51727) ("reverse" 52412) ("list-tail" 52693) ("list-ref" 53023) ("memq" 53367) ("memv" 53367) ("member" 53367) ("assq" 54274) ("assv" 54274) ("assoc" 54274) ("symbol?" 55467) ("symbol->string" 55840) ("string->symbol" 56945) ("char?" 57893) ("char=?" 58004) ("char<?" 58004) ("char>?" 58004) ("char<=?" 58004) ("char>=?" 58004) ("char-ci=?" 58956) ("char-ci<?" 58956) ("char-ci>?" 58956) ("char-ci<=?" 58956) ("char-ci>=?" 58956) ("char-alphabetic?" 59557) ("char-numeric?" 59557) ("char-whitespace?" 59557) ("char-upper-case?" 59557) ("char-lower-case?" 59557) ("char->integer" 60337) ("integer->char" 60337) ("char-upcase" 61119) ("char-downcase" 61119) ("string?" 61449) ("make-string" 61561) ("make-string" 61561) ("string" 61865) ("string-length" 61987) ("string-ref" 62115) ("string-set!" 62289) ("string=?" 62745) ("string-ci=?" 62745) ("string<?" 63167) ("string>?" 63167) ("string<=?" 63167) ("string>=?" 63167) ("string-ci<?" 63167) ("string-ci>?" 63167) ("string-ci<=?" 63167) ("string-ci>=?" 63167) ("substring" 64248) ("string-append" 64614) ("string->list" 64787) ("list->string" 64787) ("string-copy" 65205) ("string-fill!" 65327) ("vector?" 65487) ("make-vector" 65599) ("make-vector" 65599) ("vector" 65900) ("vector-length" 66120) ("vector-ref" 66256) ("vector-set!" 66705) ("vector->list" 67163) ("list->vector" 67163) ("vector-fill!" 67627) ("procedure?" 67795) ("apply" 68274) ("map" 68693) ("for-each" 69558) ("force" 70140) ("call-with-current-continuation" 73568) ("values" 77865) ("call-with-values" 78236) ("dynamic-wind" 78803) ("eval" 81547) ("scheme-report-environment" 82450) ("null-environment" 82450) ("interaction-environment" 83647) ("call-with-input-file" 84036) ("call-with-output-file" 84036) ("input-port?" 85293) ("output-port?" 85293) ("current-input-port" 85497) ("current-output-port" 85497) ("with-input-from-file" 85685) ("with-output-to-file" 85685) ("open-input-file" 86628) ("open-output-file" 86874) ("close-input-port" 87218) ("close-output-port" 87218) ("read" 87566) ("read" 87566) ("read-char" 88577) ("read-char" 88577) ("peek-char" 88959) ("peek-char" 88959) ("eof-object?" 89788) ("char-ready?" 90086) ("char-ready?" 90086) ("write" 90987) ("write" 90987) ("display" 91508) ("display" 91508) ("newline" 92309) ("newline" 92309) ("write-char" 92644) ("write-char" 92644) ("load" 92997) ("transcript-on" 93596) ("transcript-off" 93596))
(def (sig (syntax "<variable>" (id <variable>))) (p "An expression consisting of a variable (section 3.1) is a variable reference. The value of the variable reference is the value stored in the location to which the variable is bound. It is an error to reference an unbound variable.") (pre "(define x 28)\nx           ===>  28"))
(def (sig (syntax "(quote <datum>)" (id quote)) (syntax "'<datum>" (id quote)) (syntax "<constant>" (id <constant>))) (p "(quote <datum>) evaluates to <datum>. <Datum> may be any external representation of a Scheme object (see section 3.3). This notation is used to include literal constants in Scheme code.") (pre "(quote a)                    ===>  a\n(quote #(a b c))             ===>  #(a b c)\n(quote (+ 1 2))              ===>  (+ 1 2)") (p "(quote <datum>) may be abbreviated as '<datum>. The two notations are equivalent in all respects.") (pre "'a                           ===>  a\n'#(a b c)                    ===>  #(a b c)\n'()                          ===>  ()\n'(+ 1 2)                     ===>  (+ 1 2)\n'(quote a)                   ===>  (quote a)\n''a                          ===>  (quote a)") (p "Numerical constants, string constants, character constants, and boolean constants evaluate \"to themselves\"; they need not be quoted.") (pre "'\"abc\"             ===>  \"abc\"\n\"abc\"              ===>  \"abc\"\n'145932            ===>  145932\n145932             ===>  145932\n'#t                ===>  #t\n#t                 ===>  #t") (p "As noted in section 3.4, it is an error to alter a constant (i.e. the value of a literal expression) using a mutation procedure like set-car! or string-set!."))
(def (sig (syntax "(<operator> <operand[1]> ...)" (id <operator>))) (p "A procedure call is written by simply enclosing in parentheses expressions for the procedure to be called and the arguments to be passed to it. The operator and operand expressions are evaluated (in an unspecified order) and the resulting procedure is passed the resulting arguments.") (pre "(+ 3 4)                           ===>  7\n((if #f + *) 3 4)                 ===>  12") (p "A number of procedures are available as the values of variables in the initial environment; for example, the addition and multiplication procedures in the above examples are the values of the variables + and *. New procedures are created by evaluating lambda expressions (see section 4.1.4). Procedure calls may return any number of values (see values in section 6.4). With the exception of values the procedures available in the initial environment return one value or, for procedures such as apply, pass on the values returned by a call to one of their arguments.") (p "Procedure calls are also called combinations.") (p "Note:   In contrast to other dialects of Lisp, the order of evaluation is unspecified, and the operator expression and the operand expressions are always evaluated with the same evaluation rules.") (p "Note:   Although the order of evaluation is otherwise unspecified, the effect of any concurrent evaluation of the operator and operand expressions is constrained to be consistent with some sequential order of evaluation. The order of evaluation may be chosen differently for each procedure call.") (p "Note:   In many dialects of Lisp, the empty combination, (), is a legitimate expression. In Scheme, combinations must have at least one subexpression, so () is not a syntactically valid expression."))
(def (sig (syntax "(lambda <formals> <body>)" (id lambda))) (p "Syntax: <Formals> should be a formal arguments list as described below, and <body> should be a sequence of one or more expressions.") (p "Semantics: A lambda expression evaluates to a procedure. The environment in effect when the lambda expression was evaluated is remembered as part of the procedure. When the procedure is later called with some actual arguments, the environment in which the lambda expression was evaluated will be extended by binding the variables in the formal argument list to fresh locations, the corresponding actual argument values will be stored in those locations, and the expressions in the body of the lambda expression will be evaluated sequentially in the extended environment. The result(s) of the last expression in the body will be returned as the result(s) of the procedure call.") (pre "(lambda (x) (+ x x))              ===>  a procedure\n((lambda (x) (+ x x)) 4)          ===>  8\n\n(define reverse-subtract\n  (lambda (x y) (- y x)))\n(reverse-subtract 7 10)           ===>  3\n\n(define add4\n  (let ((x 4))\n    (lambda (y) (+ x y))))\n(add4 6)                          ===>  10") (p "<Formals> should have one of the following forms:") (ul (li "(<variable[1]> ...): The procedure takes a fixed number of arguments; when the procedure is called, the arguments will be stored in the bindings of the corresponding variables.") (li "<variable>: The procedure takes any number of arguments; when the procedure is called, the sequence of actual arguments is converted into a newly allocated list, and the list is stored in the binding of the <variable>.") (li "(<variable[1]> ... <variable[n]> . <variable[n+1]>): If a space-delimited period precedes the last variable, then the procedure takes n or more arguments, where n is the number of formal arguments before the period (there must be at least one). The value stored in the binding of the last variable will be a newly allocated list of the actual arguments left over after all the other actual arguments have been matched up against the other formal arguments.")) (p "It is an error for a <variable> to appear more than once in <formals>.") (pre "((lambda x x) 3 4 5 6)                  ===>  (3 4 5 6)\n((lambda (x y . z) z)\n 3 4 5 6)                               ===>  (5 6)") (p "Each procedure created as the result of evaluating a lambda expression is (conceptually) tagged with a storage location, in order to make eqv? and eq? work on procedures (see section 6.1)."))
(def (sig (syntax "(if <test> <consequent> <alternate>)" (id if)) (syntax "(if <test> <consequent>)" (id if))) (p "Syntax: <Test>, <consequent>, and <alternate> may be arbitrary expressions.") (p "Semantics: An if expression is evaluated as follows: first, <test> is evaluated. If it yields a true value (see section 6.3.1), then <consequent> is evaluated and its value(s) is(are) returned. Otherwise <alternate> is evaluated and its value(s) is(are) returned. If <test> yields a false value and no <alternate> is specified, then the result of the expression is unspecified.") (pre "(if (> 3 2) 'yes 'no)                   ===>  yes\n(if (> 2 3) 'yes 'no)                   ===>  no\n(if (> 3 2)\n    (- 3 2)\n    (+ 3 2))                            ===>  1"))
(def (sig (syntax "(set! <variable> <expression>)" (id set!))) (p "<Expression> is evaluated, and the resulting value is stored in the location to which <variable> is bound. <Variable> must be bound either in some region enclosing the set! expression or at top level. The result of the set! expression is unspecified.") (pre "(define x 2)\n(+ x 1)                         ===>  3\n(set! x 4)                      ===>  unspecified\n(+ x 1)                         ===>  5"))
(def (sig (syntax "(cond <clause[1]> <clause[2]> ...)" (id cond))) (p "Syntax: Each <clause> should be of the form") (pre "(<test> <expression[1]> ...)") (p "where <test> is any expression. Alternatively, a <clause> may be of the form") (pre "(<test> => <expression>)") (p "The last <clause> may be an \"else clause,\" which has the form") (pre "(else <expression[1]> <expression[2]> ...).") (p "Semantics: A cond expression is evaluated by evaluating the <test> expressions of successive <clause>s in order until one of them evaluates to a true value (see section 6.3.1). When a <test> evaluates to a true value, then the remaining <expression>s in its <clause> are evaluated in order, and the result(s) of the last <expression> in the <clause> is(are) returned as the result(s) of the entire cond expression. If the selected <clause> contains only the <test> and no <expression>s, then the value of the <test> is returned as the result. If the selected <clause> uses the => alternate form, then the <expression> is evaluated. Its value must be a procedure that accepts one argument; this procedure is then called on the value of the <test> and the value(s) returned by this procedure is(are) returned by the cond expression. If all <test>s evaluate to false values, and there is no else clause, then the result of the conditional expression is unspecified; if there is an else clause, then its <expression>s are evaluated, and the value(s) of the last one is(are) returned.") (pre "(cond ((> 3 2) 'greater)\n      ((< 3 2) 'less))           ===>  greater\n(cond ((> 3 3) 'greater)\n      ((< 3 3) 'less)\n      (else 'equal))             ===>  equal\n(cond ((assv 'b '((a 1) (b 2))) => cadr)\n      (else #f))                 ===>  2"))
(def (sig (syntax "(case <key> <clause[1]> <clause[2]> ...)" (id case))) (p "Syntax: <Key> may be any expression. Each <clause> should have the form") (pre "((<datum[1]> ...) <expression[1]> <expression[2]> ...),") (p "where each <datum> is an external representation of some object. All the <datum>s must be distinct. The last <clause> may be an \"else clause,\" which has the form") (pre "(else <expression[1]> <expression[2]> ...).") (p "Semantics: A case expression is evaluated as follows. <Key> is evaluated and its result is compared against each <datum>. If the result of evaluating <key> is equivalent (in the sense of eqv?; see section 6.1) to a <datum>, then the expressions in the corresponding <clause> are evaluated from left to right and the result(s) of the last expression in the <clause> is(are) returned as the result(s) of the case expression. If the result of evaluating <key> is different from every <datum>, then if there is an else clause its expressions are evaluated and the result(s) of the last is(are) the result(s) of the case expression; otherwise the result of the case expression is unspecified.") (pre "(case (* 2 3)\n  ((2 3 5 7) 'prime)\n  ((1 4 6 8 9) 'composite))             ===>  composite\n(case (car '(c d))\n  ((a) 'a)\n  ((b) 'b))                             ===>  unspecified\n(case (car '(c d))\n  ((a e i o u) 'vowel)\n  ((w y) 'semivowel)\n  (else 'consonant))                    ===>  consonant"))
(def (sig (syntax "(and <test[1]> ...)" (id and))) (p "The <test> expressions are evaluated from left to right, and the value of the first expression that evaluates to a false value (see section 6.3.1) is returned. Any remaining expressions are not evaluated. If all the expressions evaluate to true values, the value of the last expression is returned. If there are no expressions then #t is returned.") (pre "(and (= 2 2) (> 2 1))                   ===>  #t\n(and (= 2 2) (< 2 1))                   ===>  #f\n(and 1 2 'c '(f g))                     ===>  (f g)\n(and)                                   ===>  #t"))
(def (sig (syntax "(or <test[1]> ...)" (id or))) (p "The <test> expressions are evaluated from left to right, and the value of the first expression that evaluates to a true value (see section 6.3.1) is returned. Any remaining expressions are not evaluated. If all expressions evaluate to false values, the value of the last expression is returned. If there are no expressions then #f is returned.") (pre "(or (= 2 2) (> 2 1))                    ===>  #t\n(or (= 2 2) (< 2 1))                    ===>  #t\n(or #f #f #f)         ===>  #f\n(or (memq 'b '(a b c)) \n    (/ 3 0))                            ===>  (b c)"))
(def (sig (syntax "(let <bindings> <body>)" (id let))) (p "Syntax: <Bindings> should have the form") (pre "((<variable[1]> <init[1]>) ...),") (p "where each <init> is an expression, and <body> should be a sequence of one or more expressions. It is an error for a <variable> to appear more than once in the list of variables being bound.") (p "Semantics: The <init>s are evaluated in the current environment (in some unspecified order), the <variable>s are bound to fresh locations holding the results, the <body> is evaluated in the extended environment, and the value(s) of the last expression of <body> is(are) returned. Each binding of a <variable> has <body> as its region.") (pre "(let ((x 2) (y 3))\n  (* x y))                              ===>  6\n\n(let ((x 2) (y 3))\n  (let ((x 7)\n        (z (+ x y)))\n    (* z x)))                           ===>  35") (p "See also named let, section 4.2.4."))
(def (sig (syntax "(let* <bindings> <body>)" (id let*))) (p "Syntax: <Bindings> should have the form") (pre "((<variable[1]> <init[1]>) ...),") (p "and <body> should be a sequence of one or more expressions.") (p "Semantics: Let* is similar to let, but the bindings are performed sequentially from left to right, and the region of a binding indicated by (<variable> <init>) is that part of the let* expression to the right of the binding. Thus the second binding is done in an environment in which the first binding is visible, and so on.") (pre "(let ((x 2) (y 3))\n  (let* ((x 7)\n         (z (+ x y)))\n    (* z x)))                     ===>  70"))
(def (sig (syntax "(letrec <bindings> <body>)" (id letrec))) (p "Syntax: <Bindings> should have the form") (pre "((<variable[1]> <init[1]>) ...),") (p "and <body> should be a sequence of one or more expressions. It is an error for a <variable> to appear more than once in the list of variables being bound.") (p "Semantics: The <variable>s are bound to fresh locations holding undefined values, the <init>s are evaluated in the resulting environment (in some unspecified order), each <variable> is assigned to the result of the corresponding <init>, the <body> is evaluated in the resulting environment, and the value(s) of the last expression in <body> is(are) returned. Each binding of a <variable> has the entire letrec expression as its region, making it possible to define mutually recursive procedures.") (pre "(letrec ((even?\n          (lambda (n)\n            (if (zero? n)\n                #t\n                (odd? (- n 1)))))\n         (odd?\n          (lambda (n)\n            (if (zero? n)\n                #f\n                (even? (- n 1))))))\n  (even? 88))\n                        ===>  #t") (p "One restriction on letrec is very important: it must be possible to evaluate each <init> without assigning or referring to the value of any <variable>. If this restriction is violated, then it is an error. The restriction is necessary because Scheme passes arguments by value rather than by name. In the most common uses of letrec, all the <init>s are lambda expressions and the restriction is satisfied automatically."))
(def (sig (syntax "(begin <expression[1]> <expression[2]> ...)" (id begin))) (p "The <expression>s are evaluated sequentially from left to right, and the value(s) of the last <expression> is(are) returned. This expression type is used to sequence side effects such as input and output.") (pre "(define x 0)\n\n(begin (set! x 5)\n       (+ x 1))                          ===>  6\n\n(begin (display \"4 plus 1 equals \")\n       (display (+ 4 1)))                ===>  unspecified\n  and prints  4 plus 1 equals 5"))
(def (sig (syntax "(do ((<variable[1]> <init[1]> <step[1]>) ...) (<test> <expression> ...) <command> ...)" (id do))) (p "Do is an iteration construct. It specifies a set of variables to be bound, how they are to be initialized at the start, and how they are to be updated on each iteration. When a termination condition is met, the loop exits after evaluating the <expression>s.") (p "Do expressions are evaluated as follows: The <init> expressions are evaluated (in some unspecified order), the <variable>s are bound to fresh locations, the results of the <init> expressions are stored in the bindings of the <variable>s, and then the iteration phase begins.") (p "Each iteration begins by evaluating <test>; if the result is false (see section 6.3.1), then the <command> expressions are evaluated in order for effect, the <step> expressions are evaluated in some unspecified order, the <variable>s are bound to fresh locations, the results of the <step>s are stored in the bindings of the <variable>s, and the next iteration begins.") (p "If <test> evaluates to a true value, then the <expression>s are evaluated from left to right and the value(s) of the last <expression> is(are) returned. If no <expression>s are present, then the value of the do expression is unspecified.") (p "The region of the binding of a <variable> consists of the entire do expression except for the <init>s. It is an error for a <variable> to appear more than once in the list of do variables.") (p "A <step> may be omitted, in which case the effect is the same as if (<variable> <init> <variable>) had been written instead of (<variable> <init>).") (pre "(do ((vec (make-vector 5))\n     (i 0 (+ i 1)))\n    ((= i 5) vec)\n  (vector-set! vec i i))                    ===>  #(0 1 2 3 4)\n\n(let ((x '(1 3 5 7 9)))\n  (do ((x x (cdr x))\n       (sum 0 (+ sum (car x))))\n      ((null? x) sum)))                     ===>  25"))
(def (sig (syntax "(let <variable> <bindings> <body>)" (id let))) (p "\"Named let\" is a variant on the syntax of let which provides a more general looping construct than do and may also be used to express recursions. It has the same syntax and semantics as ordinary let except that <variable> is bound within <body> to a procedure whose formal arguments are the bound variables and whose body is <body>. Thus the execution of <body> may be repeated by invoking the procedure named by <variable>.") (pre "(let loop ((numbers '(3 -2 1 6 -5))\n           (nonneg '())\n           (neg '()))\n  (cond ((null? numbers) (list nonneg neg))\n        ((>= (car numbers) 0)\n         (loop (cdr numbers)\n               (cons (car numbers) nonneg)\n               neg))\n        ((< (car numbers) 0)\n         (loop (cdr numbers)\n               nonneg\n               (cons (car numbers) neg)))))\n                ===>  ((6 1 3) (-5 -2))"))
(def (sig (syntax "(delay <expression>)" (id delay))) (p "The delay construct is used together with the procedure force to implement lazy evaluation or call by need. (delay <expression>) returns an object called a promise which at some point in the future may be asked (by the force procedure) to evaluate <expression>, and deliver the resulting value. The effect of <expression> returning multiple values is unspecified.") (p "See the description of force (section 6.4) for a more complete description of delay."))
(def (sig (syntax "(quasiquote <qq template>)" (id quasiquote)) (syntax "`<qq template>" (id quasiquote))) (p "\"Backquote\" or \"quasiquote\" expressions are useful for constructing a list or vector structure when most but not all of the desired structure is known in advance. If no commas appear within the <qq template>, the result of evaluating `<qq template> is equivalent to the result of evaluating '<qq template>. If a comma appears within the <qq template>, however, the expression following the comma is evaluated (\"unquoted\") and its result is inserted into the structure instead of the comma and the expression. If a comma appears followed immediately by an at-sign (@), then the following expression must evaluate to a list; the opening and closing parentheses of the list are then \"stripped away\" and the elements of the list are inserted in place of the comma at-sign expression sequence. A comma at-sign should only appear within a list or vector <qq template>.") (pre "`(list ,(+ 1 2) 4)          ===>  (list 3 4)\n(let ((name 'a)) `(list ,name ',name))           \n                ===>  (list a (quote a))\n`(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b)           \n                ===>  (a 3 4 5 6 b)\n`(( foo ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons)))           \n                ===>  ((foo 7) . cons)\n`#(10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8)           \n                ===>  #(10 5 2 4 3 8)") (p "Quasiquote forms may be nested. Substitutions are made only for unquoted components appearing at the same nesting level as the outermost backquote. The nesting level increases by one inside each successive quasiquotation, and decreases by one inside each unquotation.") (pre "`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)           \n                ===>  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)\n(let ((name1 'x)\n      (name2 'y))\n  `(a `(b ,,name1 ,',name2 d) e))           \n                ===>  (a `(b ,x ,'y d) e)") (p "The two notations `<qq template> and (quasiquote <qq template>) are identical in all respects. ,<expression> is identical to (unquote <expression>), and ,@<expression> is identical to (unquote-splicing <expression>). The external syntax generated by write for two-element lists whose car is one of these symbols may vary between implementations.") (pre "(quasiquote (list (unquote (+ 1 2)) 4))           \n                ===>  (list 3 4)\n'(quasiquote (list (unquote (+ 1 2)) 4))           \n                ===>  `(list ,(+ 1 2) 4)\n     i.e., (quasiquote (list (unquote (+ 1 2)) 4))") (p "Unpredictable behavior can result if any of the symbols quasiquote, unquote, or unquote-splicing appear in positions within a <qq template> otherwise than as described above."))
(def (sig (syntax "(let-syntax <bindings> <body>)" (id let-syntax))) (p "Syntax: <Bindings> should have the form") (pre "((<keyword> <transformer spec>) ...)") (p "Each <keyword> is an identifier, each <transformer spec> is an instance of syntax-rules, and <body> should be a sequence of one or more expressions. It is an error for a <keyword> to appear more than once in the list of keywords being bound.") (p "Semantics: The <body> is expanded in the syntactic environment obtained by extending the syntactic environment of the let-syntax expression with macros whose keywords are the <keyword>s, bound to the specified transformers. Each binding of a <keyword> has <body> as its region.") (pre "(let-syntax ((when (syntax-rules ()\n                     ((when test stmt1 stmt2 ...)\n                      (if test\n                          (begin stmt1\n                                 stmt2 ...))))))\n  (let ((if #t))\n    (when if (set! if 'now))\n    if))                                   ===>  now\n\n(let ((x 'outer))\n  (let-syntax ((m (syntax-rules () ((m) x))))\n    (let ((x 'inner))\n      (m))))                               ===>  outer"))
(def (sig (syntax "(letrec-syntax <bindings> <body>)" (id letrec-syntax))) (p "Syntax: Same as for let-syntax.") (p "Semantics: The <body> is expanded in the syntactic environment obtained by extending the syntactic environment of the letrec-syntax expression with macros whose keywords are the <keyword>s, bound to the specified transformers. Each binding of a <keyword> has the <bindings> as well as the <body> within its region, so the transformers can transcribe expressions into uses of the macros introduced by the letrec-syntax expression.") (pre "(letrec-syntax\n  ((my-or (syntax-rules ()\n            ((my-or) #f)\n            ((my-or e) e)\n            ((my-or e1 e2 ...)\n             (let ((temp e1))\n               (if temp\n                   temp\n                   (my-or e2 ...)))))))\n  (let ((x #f)\n        (y 7)\n        (temp 8)\n        (let odd?)\n        (if even?))\n    (my-or x\n           (let temp)\n           (if y)\n           y)))                ===>  7"))
(def (sig (procedure "(eqv? obj[1] obj[2])" (id eqv?))) (p "The eqv? procedure defines a useful equivalence relation on objects. Briefly, it returns #t if obj[1] and obj[2] should normally be regarded as the same object. This relation is left slightly open to interpretation, but the following partial specification of eqv? holds for all implementations of Scheme.") (p "The eqv? procedure returns #t if:") (ul (li "obj[1] and obj[2] are both #t or both #f.") (li "obj[1] and obj[2] are both symbols and")) (pre "   (string=? (symbol->string obj1)\n             (symbol->string obj2))\n               ===>  #t") (p "Note:  This assumes that neither obj[1] nor obj[2] is an \"uninterned symbol\" as alluded to in section 6.3.3. This report does not presume to specify the behavior of eqv? on implementation-dependent extensions.") (ul (li "obj[1] and obj[2] are both numbers, are numerically equal (see =, section 6.2), and are either both exact or both inexact.") (li "obj[1] and obj[2] are both characters and are the same character according to the char=? procedure (section 6.3.4).") (li "both obj[1] and obj[2] are the empty list.") (li "obj[1] and obj[2] are pairs, vectors, or strings that denote the same locations in the store (section 3.4).") (li "obj[1] and obj[2] are procedures whose location tags are equal (section 4.1.4).")) (p "The eqv? procedure returns #f if:") (ul (li "obj[1] and obj[2] are of different types (section 3.2).") (li "one of obj[1] and obj[2] is #t but the other is #f.") (li "obj[1] and obj[2] are symbols but")) (pre "   (string=? (symbol->string obj[1])\n             (symbol->string obj[2]))\n               ===>  #f") (ul (li "one of obj[1] and obj[2] is an exact number but the other is an inexact number.") (li "obj[1] and obj[2] are numbers for which the = procedure returns #f.") (li "obj[1] and obj[2] are characters for which the char=? procedure returns #f.") (li "one of obj[1] and obj[2] is the empty list but the other is not.") (li "obj[1] and obj[2] are pairs, vectors, or strings that denote distinct locations.") (li "obj[1] and obj[2] are procedures that would behave differently (return different value(s) or have different side effects) for some arguments.")) (pre "(eqv? 'a 'a)                             ===>  #t\n(eqv? 'a 'b)                             ===>  #f\n(eqv? 2 2)                               ===>  #t\n(eqv? '() '())                           ===>  #t\n(eqv? 100000000 100000000)               ===>  #t\n(eqv? (cons 1 2) (cons 1 2))             ===>  #f\n(eqv? (lambda () 1)\n      (lambda () 2))                     ===>  #f\n(eqv? #f 'nil)                           ===>  #f\n(let ((p (lambda (x) x)))\n  (eqv? p p))                            ===>  #t") (p "The following examples illustrate cases in which the above rules do not fully specify the behavior of eqv?. All that can be said about such cases is that the value returned by eqv? must be a boolean.") (pre "(eqv? \"\" \"\")                     ===>  unspecified\n(eqv? '#() '#())                 ===>  unspecified\n(eqv? (lambda (x) x)\n      (lambda (x) x))            ===>  unspecified\n(eqv? (lambda (x) x)\n      (lambda (y) y))            ===>  unspecified") (p "The next set of examples shows the use of eqv? with procedures that have local state. Gen-counter must return a distinct procedure every time, since each procedure has its own internal counter. Gen-loser, however, returns equivalent procedures each time, since the local state does not affect the value or side effects of the procedures.") (pre "(define gen-counter\n  (lambda ()\n    (let ((n 0))\n      (lambda () (set! n (+ n 1)) n))))\n(let ((g (gen-counter)))\n  (eqv? g g))                   ===>  #t\n(eqv? (gen-counter) (gen-counter))\n                                ===>  #f\n(define gen-loser\n  (lambda ()\n    (let ((n 0))\n      (lambda () (set! n (+ n 1)) 27))))\n(let ((g (gen-loser)))\n  (eqv? g g))                   ===>  #t\n(eqv? (gen-loser) (gen-loser))\n                                ===>  unspecified\n\n(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))\n         (g (lambda () (if (eqv? f g) 'both 'g))))\n  (eqv? f g))\n                                ===>  unspecified\n\n(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))\n         (g (lambda () (if (eqv? f g) 'g 'both))))\n  (eqv? f g))\n                                ===>  #f") (p "Since it is an error to modify constant objects (those returned by literal expressions), implementations are permitted, though not required, to share structure between constants where appropriate. Thus the value of eqv? on constants is sometimes implementation-dependent.") (pre "(eqv? '(a) '(a))                         ===>  unspecified\n(eqv? \"a\" \"a\")                           ===>  unspecified\n(eqv? '(b) (cdr '(a b)))                 ===>  unspecified\n(let ((x '(a)))\n  (eqv? x x))                            ===>  #t") (p "Rationale:   The above definition of eqv? allows implementations latitude in their treatment of procedures and literals: implementations are free either to detect or to fail to detect that two procedures or two literals are equivalent to each other, and can decide whether or not to merge representations of equivalent objects by using the same pointer or bit pattern to represent both."))
(def (sig (procedure "(eq? obj[1] obj[2])" (id eq?))) (p "Eq? is similar to eqv? except that in some cases it is capable of discerning distinctions finer than those detectable by eqv?.") (p "Eq? and eqv? are guaranteed to have the same behavior on symbols, booleans, the empty list, pairs, procedures, and non-empty strings and vectors. Eq?'s behavior on numbers and characters is implementation-dependent, but it will always return either true or false, and will return true only when eqv? would also return true. Eq? may also behave differently from eqv? on empty vectors and empty strings.") (pre "(eq? 'a 'a)                             ===>  #t\n(eq? '(a) '(a))                         ===>  unspecified\n(eq? (list 'a) (list 'a))               ===>  #f\n(eq? \"a\" \"a\")                           ===>  unspecified\n(eq? \"\" \"\")                             ===>  unspecified\n(eq? '() '())                           ===>  #t\n(eq? 2 2)                               ===>  unspecified\n(eq? #\\A #\\A)                           ===>  unspecified\n(eq? car car)                           ===>  #t\n(let ((n (+ 2 3)))\n  (eq? n n))              ===>  unspecified\n(let ((x '(a)))\n  (eq? x x))              ===>  #t\n(let ((x '#()))\n  (eq? x x))              ===>  #t\n(let ((p (lambda (x) x)))\n  (eq? p p))              ===>  #t") (p "Rationale:   It will usually be possible to implement eq? much more efficiently than eqv?, for example, as a simple pointer comparison instead of as some more complicated operation. One reason is that it may not be possible to compute eqv? of two numbers in constant time, whereas eq? implemented as pointer comparison will always finish in constant time. Eq? may be used like eqv? in applications using procedures to implement objects with state since it obeys the same constraints as eqv?."))
(def (sig (procedure "(equal? obj[1] obj[2])" (id equal?))) (p "Equal? recursively compares the contents of pairs, vectors, and strings, applying eqv? on other objects such as numbers and symbols. A rule of thumb is that objects are generally equal? if they print the same. Equal? may fail to terminate if its arguments are circular data structures.") (pre "(equal? 'a 'a)                          ===>  #t\n(equal? '(a) '(a))                      ===>  #t\n(equal? '(a (b) c)\n        '(a (b) c))                     ===>  #t\n(equal? \"abc\" \"abc\")                    ===>  #t\n(equal? 2 2)                            ===>  #t\n(equal? (make-vector 5 'a)\n        (make-vector 5 'a))             ===>  #t\n(equal? (lambda (x) x)\n        (lambda (y) y))          ===>  unspecified"))
(def (sig (procedure "(number? obj)" (id number?)) (procedure "(complex? obj)" (id complex?)) (procedure "(real? obj)" (id real?)) (procedure "(rational? obj)" (id rational?)) (procedure "(integer? obj)" (id integer?))) (p "These numerical type predicates can be applied to any kind of argument, including non-numbers. They return #t if the object is of the named type, and otherwise they return #f. In general, if a type predicate is true of a number then all higher type predicates are also true of that number. Consequently, if a type predicate is false of a number, then all lower type predicates are also false of that number. If z is an inexact complex number, then (real? z) is true if and only if (zero? (imag-part z)) is true. If x is an inexact real number, then (integer? x) is true if and only if (= x (round x)).") (pre "(complex? 3+4i)                 ===>  #t\n(complex? 3)                    ===>  #t\n(real? 3)                       ===>  #t\n(real? -2.5+0.0i)               ===>  #t\n(real? #e1e10)                  ===>  #t\n(rational? 6/10)                ===>  #t\n(rational? 6/3)                 ===>  #t\n(integer? 3+0i)                 ===>  #t\n(integer? 3.0)                  ===>  #t\n(integer? 8/4)                  ===>  #t") (p "Note:   The behavior of these type predicates on inexact numbers is unreliable, since any inaccuracy may affect the result.") (p "Note:   In many implementations the rational? procedure will be the same as real?, and the complex? procedure will be the same as number?, but unusual implementations may be able to represent some irrational numbers exactly or may extend the number system to support some kind of non-complex numbers."))
(def (sig (procedure "(exact? z)" (id exact?)) (procedure "(inexact? z)" (id inexact?))) (p "These numerical predicates provide tests for the exactness of a quantity. For any Scheme number, precisely one of these predicates is true."))
(def (sig (procedure "(= z[1] z[2] z[3] ...)" (id =)) (procedure "(< x[1] x[2] x[3] ...)" (id <)) (procedure "(> x[1] x[2] x[3] ...)" (id >)) (procedure "(<= x[1] x[2] x[3] ...)" (id <=)) (procedure "(>= x[1] x[2] x[3] ...)" (id >=))) (p "These procedures return #t if their arguments are (respectively): equal, monotonically increasing, monotonically decreasing, monotonically nondecreasing, or monotonically nonincreasing.") (p "These predicates are required to be transitive.") (p "Note:   The traditional implementations of these predicates in Lisp-like languages are not transitive.") (p "Note:   While it is not an error to compare inexact numbers using these predicates, the results may be unreliable because a small inaccuracy may affect the result; this is especially true of = and zero?. When in doubt, consult a numerical analyst."))
(def (sig (procedure "(zero? z)" (id zero?)) (procedure "(positive? x)" (id positive?)) (procedure "(negative? x)" (id negative?)) (procedure "(odd? n)" (id odd?)) (procedure "(even? n)" (id even?))) (p "These numerical predicates test a number for a particular property, returning #t or #f. See note above."))
(def (sig (procedure "(max x[1] x[2] ...)" (id max)) (procedure "(min x[1] x[2] ...)" (id min))) (p "These procedures return the maximum or minimum of their arguments.") (pre "(max 3 4)                      ===>  4    ; exact\n(max 3.9 4)                    ===>  4.0  ; inexact") (p "Note:   If any argument is inexact, then the result will also be inexact (unless the procedure can prove that the inaccuracy is not large enough to affect the result, which is possible only in unusual implementations). If min or max is used to compare numbers of mixed exactness, and the numerical value of the result cannot be represented as an inexact number without loss of accuracy, then the procedure may report a violation of an implementation restriction."))
(def (sig (procedure "(+ z[1] ...)" (id +)) (procedure "(* z[1] ...)" (id *))) (p "These procedures return the sum or product of their arguments.") (pre "(+ 3 4)                         ===>  7\n(+ 3)                           ===>  3\n(+)                             ===>  0\n(* 4)                           ===>  4\n(*)                             ===>  1"))
(def (sig (procedure "(- z[1] z[2])" (id -)) (procedure "(- z)" (id -)) (procedure "(- z[1] z[2] ...)" (id -)) (procedure "(/ z[1] z[2])" (id /)) (procedure "(/ z)" (id /)) (procedure "(/ z[1] z[2] ...)" (id /))) (p "With two or more arguments, these procedures return the difference or quotient of their arguments, associating to the left. With one argument, however, they return the additive or multiplicative inverse of their argument.") (pre "(- 3 4)                         ===>  -1\n(- 3 4 5)                       ===>  -6\n(- 3)                           ===>  -3\n(/ 3 4 5)                       ===>  3/20\n(/ 3)                           ===>  1/3"))
(def (sig (procedure "(abs x)" (id abs))) (p "Abs returns the absolute value of its argument.") (pre "(abs -7)                        ===>  7"))
(def (sig (procedure "(quotient n[1] n[2])" (id quotient)) (procedure "(remainder n[1] n[2])" (id remainder)) (procedure "(modulo n[1] n[2])" (id modulo))) (p "These procedures implement number-theoretic (integer) division. n[2] should be non-zero. All three procedures return integers. If n[1]/n[2] is an integer:") (pre "   (quotient n[1] n[2])           ===> n[1]/n[2]\n   (remainder n[1] n[2])          ===> 0\n   (modulo n[1] n[2])             ===> 0") (p "If n[1]/n[2] is not an integer:") (pre "   (quotient n[1] n[2])           ===> n[q]\n   (remainder n[1] n[2])          ===> n[r]\n   (modulo n[1] n[2])             ===> n[m]") (p "where n[q] is n[1]/n[2] rounded towards zero, 0 < |n[r]| < |n[2]|, 0 < |n[m]| < |n[2]|, n[r] and n[m] differ from n[1] by a multiple of n[2], n[r] has the same sign as n[1], and n[m] has the same sign as n[2].") (p "From this we can conclude that for integers n[1] and n[2] with n[2] not equal to 0,") (pre "    (= n[1] (+ (* n[2] (quotient n[1] n[2]))\n          (remainder n[1] n[2])))\n                                        ===>  #t") (p "provided all numbers involved in that computation are exact.") (pre "(modulo 13 4)                   ===>  1\n(remainder 13 4)                ===>  1\n\n(modulo -13 4)                  ===>  3\n(remainder -13 4)               ===>  -1\n\n(modulo 13 -4)                  ===>  -3\n(remainder 13 -4)               ===>  1\n\n(modulo -13 -4)                 ===>  -1\n(remainder -13 -4)              ===>  -1\n\n(remainder -13 -4.0)            ===>  -1.0  ; inexact"))
(def (sig (procedure "(gcd n[1] ...)" (id gcd)) (procedure "(lcm n[1] ...)" (id lcm))) (p "These procedures return the greatest common divisor or least common multiple of their arguments. The result is always non-negative.") (pre "(gcd 32 -36)                    ===>  4\n(gcd)                           ===>  0\n(lcm 32 -36)                    ===>  288\n(lcm 32.0 -36)                  ===>  288.0  ; inexact\n(lcm)                           ===>  1"))
(def (sig (procedure "(numerator q)" (id numerator)) (procedure "(denominator q)" (id denominator))) (p "These procedures return the numerator or denominator of their argument; the result is computed as if the argument was represented as a fraction in lowest terms. The denominator is always positive. The denominator of 0 is defined to be 1.") (pre "(numerator (/ 6 4))            ===>  3\n(denominator (/ 6 4))          ===>  2\n(denominator\n  (exact->inexact (/ 6 4)))    ===> 2.0"))
(def (sig (procedure "(floor x)" (id floor)) (procedure "(ceiling x)" (id ceiling)) (procedure "(truncate x)" (id truncate)) (procedure "(round x)" (id round))) (p "These procedures return integers. Floor returns the largest integer not larger than x. Ceiling returns the smallest integer not smaller than x. Truncate returns the integer closest to x whose absolute value is not larger than the absolute value of x. Round returns the closest integer to x, rounding to even when x is halfway between two integers.") (p "Rationale:   Round rounds to even for consistency with the default rounding mode specified by the IEEE floating point standard.") (p "Note:   If the argument to one of these procedures is inexact, then the result will also be inexact. If an exact value is needed, the result should be passed to the inexact->exact procedure.") (pre "(floor -4.3)                  ===>  -5.0\n(ceiling -4.3)                ===>  -4.0\n(truncate -4.3)               ===>  -4.0\n(round -4.3)                  ===>  -4.0\n\n(floor 3.5)                   ===>  3.0\n(ceiling 3.5)                 ===>  4.0\n(truncate 3.5)                ===>  3.0\n(round 3.5)                   ===>  4.0  ; inexact\n\n(round 7/2)                   ===>  4    ; exact\n(round 7)                     ===>  7"))
(def (sig (procedure "(rationalize x y)" (id rationalize))) (p "Rationalize returns the simplest rational number differing from x by no more than y. A rational number r[1] is simpler than another rational number r[2] if r[1] = p[1]/q[1] and r[2] = p[2]/q[2] (in lowest terms) and |p[1]| < |p[2]| and |q[1]| < |q[2]|. Thus 3/5 is simpler than 4/7. Although not all rationals are comparable in this ordering (consider 2/ 7 and 3/5) any interval contains a rational number that is simpler than every other rational number in that interval (the simpler 2/5 lies between 2/7 and 3/5). Note that 0 = 0/1 is the simplest rational of all.") (pre "(rationalize\n  (inexact->exact .3) 1/10)          ===> 1/3    ; exact\n(rationalize .3 1/10)                ===> #i1/3  ; inexact"))
(def (sig (procedure "(exp z)" (id exp)) (procedure "(log z)" (id log)) (procedure "(sin z)" (id sin)) (procedure "(cos z)" (id cos)) (procedure "(tan z)" (id tan)) (procedure "(asin z)" (id asin)) (procedure "(acos z)" (id acos)) (procedure "(atan z)" (id atan)) (procedure "(atan y x)" (id atan))) (p "These procedures are part of every implementation that supports general real numbers; they compute the usual transcendental functions. Log computes the natural logarithm of z (not the base ten logarithm). Asin, acos, and atan compute arcsine (sin^-1), arccosine (cos^-1), and arctangent (tan^-1), respectively. The two-argument variant of atan computes (angle (make-rectangular x y)) (see below), even in implementations that don't support general complex numbers.") (p "In general, the mathematical functions log, arcsine, arccosine, and arctangent are multiply defined. The value of log z is defined to be the one whose imaginary part lies in the range from -pi (exclusive) to pi (inclusive). log 0 is undefined. With log defined this way, the values of sin^-1 z, cos^-1 z, and tan^-1 z are according to the following formulae:") (pre "sin^-1 z = - i log (i z + (1 - z^2)^1/2)\n\ncos^-1 z = pi / 2 - sin^-1 z\n\ntan^-1 z = (log (1 + i z) - log (1 - i z)) / (2 i)") (p "The above specification follows [27], which in turn cites [19]; refer to these sources for more detailed discussion of branch cuts, boundary conditions, and implementation of these functions. When it is possible these procedures produce a real result from a real argument."))
(def (sig (procedure "(sqrt z)" (id sqrt))) (p "Returns the principal square root of z. The result will have either positive real part, or zero real part and non-negative imaginary part."))
(def (sig (procedure "(expt z[1] z[2])" (id expt))) (p "Returns z[1] raised to the power z[2]. For z[1] != 0") (pre "z[1]^z[2] = e^z[2] log z[1]") (p "0^z is 1 if z = 0 and 0 otherwise."))
(def (sig (procedure "(make-rectangular x[1] x[2])" (id make-rectangular)) (procedure "(make-polar x[3] x[4])" (id make-polar)) (procedure "(real-part z)" (id real-part)) (procedure "(imag-part z)" (id imag-part)) (procedure "(magnitude z)" (id magnitude)) (procedure "(angle z)" (id angle))) (p "These procedures are part of every implementation that supports general complex numbers. Suppose x[1], x[2], x[3], and x[4] are real numbers and z is a complex number such that") (pre "z = x[1] + x[2]i = x[3] . e^i x[4]") (p "Then") (pre "(make-rectangular x[1] x[2])         ===> z\n(make-polar x[3] x[4])             ===> z\n(real-part z)                          ===> x[1]\n(imag-part z)                          ===> x[2]\n(magnitude z)                          ===> |x[3]|\n(angle z)                              ===> x[angle]") (p "where - pi < x[angle] < pi with x[angle] = x[4] + 2 pi n for some integer n.") (p "Rationale:   Magnitude is the same as abs for a real argument, but abs must be present in all implementations, whereas magnitude need only be present in implementations that support general complex numbers."))
(def (sig (procedure "(exact->inexact z)" (id exact->inexact)) (procedure "(inexact->exact z)" (id inexact->exact))) (p "Exact->inexact returns an inexact representation of z. The value returned is the inexact number that is numerically closest to the argument. If an exact argument has no reasonably close inexact equivalent, then a violation of an implementation restriction may be reported.") (p "Inexact->exact returns an exact representation of z. The value returned is the exact number that is numerically closest to the argument. If an inexact argument has no reasonably close exact equivalent, then a violation of an implementation restriction may be reported.") (p "These procedures implement the natural one-to-one correspondence between exact and inexact integers throughout an implementation-dependent range. See section 6.2.3."))
(def (sig (procedure "(number->string z)" (id number->string)) (procedure "(number->string z radix)" (id number->string))) (p "Radix must be an exact integer, either 2, 8, 10, or 16. If omitted, radix defaults to 10. The procedure number->string takes a number and a radix and returns as a string an external representation of the given number in the given radix such that") (pre "(let ((number number)\n      (radix radix))\n  (eqv? number\n        (string->number (number->string number\n                                        radix)\n                        radix)))") (p "is true. It is an error if no possible result makes this expression true.") (p "If z is inexact, the radix is 10, and the above expression can be satisfied by a result that contains a decimal point, then the result contains a decimal point and is expressed using the minimum number of digits (exclusive of exponent and trailing zeroes) needed to make the above expression true [3, 5]; otherwise the format of the result is unspecified.") (p "The result returned by number->string never contains an explicit radix prefix.") (p "Note:   The error case can occur only when z is not a complex number or is a complex number with a non-rational real or imaginary part.") (p "Rationale:   If z is an inexact number represented using flonums, and the radix is 10, then the above expression is normally satisfied by a result containing a decimal point. The unspecified case allows for infinities, NaNs, and non-flonum representations."))
(def (sig (procedure "(string->number string)" (id string->number)) (procedure "(string->number string radix)" (id string->number))) (p "Returns a number of the maximally precise representation expressed by the given string. Radix must be an exact integer, either 2, 8, 10, or 16. If supplied, radix is a default radix that may be overridden by an explicit radix prefix in string (e.g. \"#o177\"). If radix is not supplied, then the default radix is 10. If string is not a syntactically valid notation for a number, then string->number returns #f.") (pre "(string->number \"100\")                ===>  100\n(string->number \"100\" 16)             ===>  256\n(string->number \"1e2\")                ===>  100.0\n(string->number \"15##\")               ===>  1500.0") (p "Note:   The domain of string->number may be restricted by implementations in the following ways. String->number is permitted to return #f whenever string contains an explicit radix prefix. If all numbers supported by an implementation are real, then string-> number is permitted to return #f whenever string uses the polar or rectangular notations for complex numbers. If all numbers are integers, then string->number may return #f whenever the fractional notation is used. If all numbers are exact, then string->number may return #f whenever an exponent marker or explicit exactness prefix is used, or if a # appears in place of a digit. If all inexact numbers are integers, then string->number may return #f whenever a decimal point is used."))
(def (sig (procedure "(not obj)" (id not))) (p "Not returns #t if obj is false, and returns #f otherwise.") (pre "(not #t)           ===>  #f\n(not 3)            ===>  #f\n(not (list 3))     ===>  #f\n(not #f)           ===>  #t\n(not '())          ===>  #f\n(not (list))       ===>  #f\n(not 'nil)         ===>  #f"))
(def (sig (procedure "(boolean? obj)" (id boolean?))) (p "Boolean? returns #t if obj is either #t or #f and returns #f otherwise.") (pre "(boolean? #f)                 ===>  #t\n(boolean? 0)                  ===>  #f\n(boolean? '())                ===>  #f"))
(def (sig (procedure "(pair? obj)" (id pair?))) (p "Pair? returns #t if obj is a pair, and otherwise returns #f.") (pre "(pair? '(a . b))                ===>  #t\n(pair? '(a b c))                ===>  #t\n(pair? '())                     ===>  #f\n(pair? '#(a b))                 ===>  #f"))
(def (sig (procedure "(cons obj[1] obj[2])" (id cons))) (p "Returns a newly allocated pair whose car is obj[1] and whose cdr is obj[2]. The pair is guaranteed to be different (in the sense of eqv?) from every existing object.") (pre "(cons 'a '())                   ===>  (a)\n(cons '(a) '(b c d))            ===>  ((a) b c d)\n(cons \"a\" '(b c))               ===>  (\"a\" b c)\n(cons 'a 3)                     ===>  (a . 3)\n(cons '(a b) 'c)                ===>  ((a b) . c)"))
(def (sig (procedure "(car pair)" (id car))) (p "Returns the contents of the car field of pair. Note that it is an error to take the car of the empty list.") (pre "(car '(a b c))                  ===>  a\n(car '((a) b c d))              ===>  (a)\n(car '(1 . 2))                  ===>  1\n(car '())                       ===>  error"))
(def (sig (procedure "(cdr pair)" (id cdr))) (p "Returns the contents of the cdr field of pair. Note that it is an error to take the cdr of the empty list.") (pre "(cdr '((a) b c d))              ===>  (b c d)\n(cdr '(1 . 2))                  ===>  2\n(cdr '())                       ===>  error"))
(def (sig (procedure "(set-car! pair obj)" (id set-car!))) (p "Stores obj in the car field of pair. The value returned by set-car! is unspecified.") (pre "(define (f) (list 'not-a-constant-list))\n(define (g) '(constant-list))\n(set-car! (f) 3)                     ===>  unspecified\n(set-car! (g) 3)                     ===>  error"))
(def (sig (procedure "(set-cdr! pair obj)" (id set-cdr!))) (p "Stores obj in the cdr field of pair. The value returned by set-cdr! is unspecified."))
(def (sig (procedure "(caar pair)" (id caar)) (procedure "(cadr pair)" (id cadr)) (procedure "(cdddar pair)" (id cdddar)) (procedure "(cddddr pair)" (id cddddr))) (p "These procedures are compositions of car and cdr, where for example caddr could be defined by") (pre "(define caddr (lambda (x) (car (cdr (cdr x))))).") (p "Arbitrary compositions, up to four deep, are provided. There are twenty-eight of these procedures in all."))
(def (sig (procedure "(null? obj)" (id null?))) (p "Returns #t if obj is the empty list, otherwise returns #f."))
(def (sig (procedure "(list? obj)" (id list?))) (p "Returns #t if obj is a list, otherwise returns #f. By definition, all lists have finite length and are terminated by the empty list.") (pre "(list? '(a b c))             ===>  #t\n(list? '())                  ===>  #t\n(list? '(a . b))             ===>  #f\n(let ((x (list 'a)))\n  (set-cdr! x x)\n  (list? x))                 ===>  #f"))
(def (sig (procedure "(list obj ...)" (id list))) (p "Returns a newly allocated list of its arguments.") (pre "(list 'a (+ 3 4) 'c)                    ===>  (a 7 c)\n(list)                                  ===>  ()"))
(def (sig (procedure "(length list)" (id length))) (p "Returns the length of list.") (pre "(length '(a b c))                       ===>  3\n(length '(a (b) (c d e)))               ===>  3\n(length '())                            ===>  0"))
(def (sig (procedure "(append list ...)" (id append))) (p "Returns a list consisting of the elements of the first list followed by the elements of the other lists.") (pre "(append '(x) '(y))                      ===>  (x y)\n(append '(a) '(b c d))                  ===>  (a b c d)\n(append '(a (b)) '((c)))                ===>  (a (b) (c))") (p "The resulting list is always newly allocated, except that it shares structure with the last list argument. The last argument may actually be any object; an improper list results if the last argument is not a proper list.") (pre "(append '(a b) '(c . d))                ===>  (a b c . d)\n(append '() 'a)                         ===>  a"))
(def (sig (procedure "(reverse list)" (id reverse))) (p "Returns a newly allocated list consisting of the elements of list in reverse order.") (pre "(reverse '(a b c))                      ===>  (c b a)\n(reverse '(a (b c) d (e (f))))\n                ===>  ((e (f)) d (b c) a)"))
(def (sig (procedure "(list-tail list k)" (id list-tail))) (p "Returns the sublist of list obtained by omitting the first k elements. It is an error if list has fewer than k elements. List-tail could be defined by") (pre "(define list-tail\n  (lambda (x k)\n    (if (zero? k)\n        x\n        (list-tail (cdr x) (- k 1)))))"))
(def (sig (procedure "(list-ref list k)" (id list-ref))) (p "Returns the kth element of list. (This is the same as the car of (list-tail list k).) It is an error if list has fewer than k elements.") (pre "(list-ref '(a b c d) 2)                ===>  c\n(list-ref '(a b c d)\n          (inexact->exact (round 1.8))) \n                ===>  c"))
(def (sig (procedure "(memq obj list)" (id memq)) (procedure "(memv obj list)" (id memv)) (procedure "(member obj list)" (id member))) (p "These procedures return the first sublist of list whose car is obj, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If obj does not occur in list, then #f (not the empty list) is returned. Memq uses eq? to compare obj with the elements of list, while memv uses eqv? and member uses equal?.") (pre "(memq 'a '(a b c))                      ===>  (a b c)\n(memq 'b '(a b c))                      ===>  (b c)\n(memq 'a '(b c d))                      ===>  #f\n(memq (list 'a) '(b (a) c))             ===>  #f\n(member (list 'a)\n        '(b (a) c))                     ===>  ((a) c)\n(memq 101 '(100 101 102))               ===>  unspecified\n(memv 101 '(100 101 102))               ===>  (101 102)"))
(def (sig (procedure "(assq obj alist)" (id assq)) (procedure "(assv obj alist)" (id assv)) (procedure "(assoc obj alist)" (id assoc))) (p "Alist (for \"association list\") must be a list of pairs. These procedures find the first pair in alist whose car field is obj, and returns that pair. If no pair in alist has obj as its car, then #f (not the empty list) is returned. Assq uses eq? to compare obj with the car fields of the pairs in alist, while assv uses eqv? and assoc uses equal?.") (pre "(define e '((a 1) (b 2) (c 3)))\n(assq 'a e)             ===>  (a 1)\n(assq 'b e)             ===>  (b 2)\n(assq 'd e)             ===>  #f\n(assq (list 'a) '(((a)) ((b)) ((c))))\n                        ===>  #f\n(assoc (list 'a) '(((a)) ((b)) ((c))))   \n                                   ===>  ((a))\n(assq 5 '((2 3) (5 7) (11 13)))    \n                                   ===>  unspecified\n(assv 5 '((2 3) (5 7) (11 13)))    \n                                   ===>  (5 7)") (p "Rationale:   Although they are ordinarily used as predicates, memq, memv, member, assq, assv, and assoc do not have question marks in their names because they return useful values rather than just #t or #f."))
(def (sig (procedure "(symbol? obj)" (id symbol?))) (p "Returns #t if obj is a symbol, otherwise returns #f.") (pre "(symbol? 'foo)                  ===>  #t\n(symbol? (car '(a b)))          ===>  #t\n(symbol? \"bar\")                 ===>  #f\n(symbol? 'nil)                  ===>  #t\n(symbol? '())                   ===>  #f\n(symbol? #f)                    ===>  #f"))
(def (sig (procedure "(symbol->string symbol)" (id symbol->string))) (p "Returns the name of symbol as a string. If the symbol was part of an object returned as the value of a literal expression (section 4.1.2) or by a call to the read procedure, and its name contains alphabetic characters, then the string returned will contain characters in the implementation's preferred standard case -- some implementations will prefer upper case, others lower case. If the symbol was returned by string->symbol, the case of characters in the string returned will be the same as the case in the string that was passed to string->symbol. It is an error to apply mutation procedures like string-set! to strings returned by this procedure.") (p "The following examples assume that the implementation's standard case is lower case:") (pre "(symbol->string 'flying-fish)     \n                                          ===>  \"flying-fish\"\n(symbol->string 'Martin)                  ===>  \"martin\"\n(symbol->string\n   (string->symbol \"Malvina\"))     \n                                          ===>  \"Malvina\""))
(def (sig (procedure "(string->symbol string)" (id string->symbol))) (p "Returns the symbol whose name is string. This procedure can create symbols with names containing special characters or letters in the non-standard case, but it is usually a bad idea to create such symbols because in some implementations of Scheme they cannot be read as themselves. See symbol->string.") (p "The following examples assume that the implementation's standard case is lower case:") (pre "(eq? 'mISSISSIppi 'mississippi)  \n                ===>  #t\n(string->symbol \"mISSISSIppi\")  \n                ===>  the symbol with name \"mISSISSIppi\"\n(eq? 'bitBlt (string->symbol \"bitBlt\"))     \n                ===>  #f\n(eq? 'JollyWog\n     (string->symbol\n       (symbol->string 'JollyWog)))  \n                ===>  #t\n(string=? \"K. Harper, M.D.\"\n          (symbol->string\n            (string->symbol \"K. Harper, M.D.\")))  \n                ===>  #t"))
(def (sig (procedure "(char? obj)" (id char?))) (p "Returns #t if obj is a character, otherwise returns #f."))
(def (sig (procedure "(char=? char[1] char[2])" (id char=?)) (procedure "(char<? char[1] char[2])" (id char<?)) (procedure "(char>? char[1] char[2])" (id char>?)) (procedure "(char<=? char[1] char[2])" (id char<=?)) (procedure "(char>=? char[1] char[2])" (id char>=?))) (p "These procedures impose a total ordering on the set of characters. It is guaranteed that under this ordering:") (ul (li "The upper case characters are in order. For example, (char<? #\\A #\\ B) returns #t.") (li "The lower case characters are in order. For example, (char<? #\\a #\\ b) returns #t.") (li "The digits are in order. For example, (char<? #\\0 #\\9) returns #t.") (li "Either all the digits precede all the upper case letters, or vice versa.") (li "Either all the digits precede all the lower case letters, or vice versa.")) (p "Some implementations may generalize these procedures to take more than two arguments, as with the corresponding numerical predicates."))
(def (sig (procedure "(char-ci=? char[1] char[2])" (id char-ci=?)) (procedure "(char-ci<? char[1] char[2])" (id char-ci<?)) (procedure "(char-ci>? char[1] char[2])" (id char-ci>?)) (procedure "(char-ci<=? char[1] char[2])" (id char-ci<=?)) (procedure "(char-ci>=? char[1] char[2])" (id char-ci>=?))) (p "These procedures are similar to char=? et cetera, but they treat upper case and lower case letters as the same. For example, (char-ci=? #\\A #\\ a) returns #t. Some implementations may generalize these procedures to take more than two arguments, as with the corresponding numerical predicates."))
(def (sig (procedure "(char-alphabetic? char)" (id char-alphabetic?)) (procedure "(char-numeric? char)" (id char-numeric?)) (procedure "(char-whitespace? char)" (id char-whitespace?)) (procedure "(char-upper-case? letter)" (id char-upper-case?)) (procedure "(char-lower-case? letter)" (id char-lower-case?))) (p "These procedures return #t if their arguments are alphabetic, numeric, whitespace, upper case, or lower case characters, respectively, otherwise they return #f. The following remarks, which are specific to the ASCII character set, are intended only as a guide: The alphabetic characters are the 52 upper and lower case letters. The numeric characters are the ten decimal digits. The whitespace characters are space, tab, line feed, form feed, and carriage return."))
(def (sig (procedure "(char->integer char)" (id char->integer)) (procedure "(integer->char n)" (id integer->char))) (p "Given a character, char->integer returns an exact integer representation of the character. Given an exact integer that is the image of a character under char->integer, integer->char returns that character. These procedures implement order-preserving isomorphisms between the set of characters under the char<=? ordering and some subset of the integers under the <= ordering. That is, if") (pre "(char<=? a b) ===> #t  and  (<= x y) ===> #t") (p "and x and y are in the domain of integer->char, then") (pre "(<= (char->integer a)\n    (char->integer b))                  ===>  #t\n\n(char<=? (integer->char x)\n         (integer->char y))             ===>  #t"))
(def (sig (procedure "(char-upcase char)" (id char-upcase)) (procedure "(char-downcase char)" (id char-downcase))) (p "These procedures return a character char[2] such that (char-ci=? char char[2]). In addition, if char is alphabetic, then the result of char-upcase is upper case and the result of char-downcase is lower case."))
(def (sig (procedure "(string? obj)" (id string?))) (p "Returns #t if obj is a string, otherwise returns #f."))
(def (sig (procedure "(make-string k)" (id make-string)) (procedure "(make-string k char)" (id make-string))) (p "Make-string returns a newly allocated string of length k. If char is given, then all elements of the string are initialized to char, otherwise the contents of the string are unspecified."))
(def (sig (procedure "(string char ...)" (id string))) (p "Returns a newly allocated string composed of the arguments."))
(def (sig (procedure "(string-length string)" (id string-length))) (p "Returns the number of characters in the given string."))
(def (sig (procedure "(string-ref string k)" (id string-ref))) (p "k must be a valid index of string. String-ref returns character k of string using zero-origin indexing."))
(def (sig (procedure "(string-set! string k char)" (id string-set!))) (p "k must be a valid index of string. String-set! stores char in element k of string and returns an unspecified value.") (pre "(define (f) (make-string 3 #\\*))\n(define (g) \"***\")\n(string-set! (f) 0 #\\?)          ===>  unspecified\n(string-set! (g) 0 #\\?)          ===>  error\n(string-set! (symbol->string 'immutable)\n             0\n             #\\?)          ===>  error"))
(def (sig (procedure "(string=? string[1] string[2])" (id string=?)) (procedure "(string-ci=? string[1] string[2])" (id string-ci=?))) (p "Returns #t if the two strings are the same length and contain the same characters in the same positions, otherwise returns #f. String-ci=? treats upper and lower case letters as though they were the same character, but string=? treats upper and lower case as distinct characters."))
(def (sig (procedure "(string<? string[1] string[2])" (id string<?)) (procedure "(string>? string[1] string[2])" (id string>?)) (procedure "(string<=? string[1] string[2])" (id string<=?)) (procedure "(string>=? string[1] string[2])" (id string>=?)) (procedure "(string-ci<? string[1] string[2])" (id string-ci<?)) (procedure "(string-ci>? string[1] string[2])" (id string-ci>?)) (procedure "(string-ci<=? string[1] string[2])" (id string-ci<=?)) (procedure "(string-ci>=? string[1] string[2])" (id string-ci>=?))) (p "These procedures are the lexicographic extensions to strings of the corresponding orderings on characters. For example, string<? is the lexicographic ordering on strings induced by the ordering char<? on characters. If two strings differ in length but are the same up to the length of the shorter string, the shorter string is considered to be lexicographically less than the longer string.") (p "Implementations may generalize these and the string=? and string-ci=? procedures to take more than two arguments, as with the corresponding numerical predicates."))
(def (sig (procedure "(substring string start end)" (id substring))) (p "String must be a string, and start and end must be exact integers satisfying") (pre "0 < start < end < (string-length string)") (p "Substring returns a newly allocated string formed from the characters of string beginning with index start (inclusive) and ending with index end (exclusive)."))
(def (sig (procedure "(string-append string ...)" (id string-append))) (p "Returns a newly allocated string whose characters form the concatenation of the given strings."))
(def (sig (procedure "(string->list string)" (id string->list)) (procedure "(list->string list)" (id list->string))) (p "String->list returns a newly allocated list of the characters that make up the given string. List->string returns a newly allocated string formed from the characters in the list list, which must be a list of characters. String->list and list->string are inverses so far as equal? is concerned."))
(def (sig (procedure "(string-copy string)" (id string-copy))) (p "Returns a newly allocated copy of the given string."))
(def (sig (procedure "(string-fill! string char)" (id string-fill!))) (p "Stores char in every element of the given string and returns an unspecified value."))
(def (sig (procedure "(vector? obj)" (id vector?))) (p "Returns #t if obj is a vector, otherwise returns #f."))
(def (sig (procedure "(make-vector k)" (id make-vector)) (procedure "(make-vector k fill)" (id make-vector))) (p "Returns a newly allocated vector of k elements. If a second argument is given, then each element is initialized to fill. Otherwise the initial contents of each element is unspecified."))
(def (sig (procedure "(vector obj ...)" (id vector))) (p "Returns a newly allocated vector whose elements contain the given arguments. Analogous to list.") (pre "(vector 'a 'b 'c)                       ===>  #(a b c)"))
(def (sig (procedure "(vector-length vector)" (id vector-length))) (p "Returns the number of elements in vector as an exact integer."))
(def (sig (procedure "(vector-ref vector k)" (id vector-ref))) (p "k must be a valid index of vector. Vector-ref returns the contents of element k of vector.") (pre "(vector-ref '#(1 1 2 3 5 8 13 21)\n            5)  \n                ===>  8\n(vector-ref '#(1 1 2 3 5 8 13 21)\n            (let ((i (round (* 2 (acos -1)))))\n              (if (inexact? i)\n                  (inexact->exact i)\n                  i))) \n                ===> 13"))
(def (sig (procedure "(vector-set! vector k obj)" (id vector-set!))) (p "k must be a valid index of vector. Vector-set! stores obj in element k of vector. The value returned by vector-set! is unspecified.") (pre "(let ((vec (vector 0 '(2 2 2 2) \"Anna\")))\n  (vector-set! vec 1 '(\"Sue\" \"Sue\"))\n  vec)      \n                ===>  #(0 (\"Sue\" \"Sue\") \"Anna\")\n\n(vector-set! '#(0 1 2) 1 \"doe\")  \n                ===>  error  ; constant vector"))
(def (sig (procedure "(vector->list vector)" (id vector->list)) (procedure "(list->vector list)" (id list->vector))) (p "Vector->list returns a newly allocated list of the objects contained in the elements of vector. List->vector returns a newly created vector initialized to the elements of the list list.") (pre "(vector->list '#(dah dah didah))  \n                ===>  (dah dah didah)\n(list->vector '(dididit dah))   \n                ===>  #(dididit dah)"))
(def (sig (procedure "(vector-fill! vector fill)" (id vector-fill!))) (p "Stores fill in every element of vector. The value returned by vector-fill! is unspecified."))
(def (sig (procedure "(procedure? obj)" (id procedure?))) (p "Returns #t if obj is a procedure, otherwise returns #f.") (pre "(procedure? car)                    ===>  #t\n(procedure? 'car)                   ===>  #f\n(procedure? (lambda (x) (* x x)))   \n                                    ===>  #t\n(procedure? '(lambda (x) (* x x)))  \n                                    ===>  #f\n(call-with-current-continuation procedure?)\n                                    ===>  #t"))
(def (sig (procedure "(apply proc arg[1] ... args)" (id apply))) (p "Proc must be a procedure and args must be a list. Calls proc with the elements of the list (append (list arg[1] ...) args) as the actual arguments.") (pre "(apply + (list 3 4))                      ===>  7\n\n(define compose\n  (lambda (f g)\n    (lambda args\n      (f (apply g args)))))\n\n((compose sqrt *) 12 75)                      ===>  30"))
(def (sig (procedure "(map proc list[1] list[2] ...)" (id map))) (p "The lists must be lists, and proc must be a procedure taking as many arguments as there are lists and returning a single value. If more than one list is given, then they must all be the same length. Map applies proc element-wise to the elements of the lists and returns a list of the results, in order. The dynamic order in which proc is applied to the elements of the lists is unspecified.") (pre "(map cadr '((a b) (d e) (g h)))   \n                ===>  (b e h)\n\n(map (lambda (n) (expt n n))\n     '(1 2 3 4 5))                \n                ===>  (1 4 27 256 3125)\n\n(map + '(1 2 3) '(4 5 6))                 ===>  (5 7 9)\n\n(let ((count 0))\n  (map (lambda (ignored)\n         (set! count (+ count 1))\n         count)\n       '(a b)))                         ===>  (1 2) or (2 1)"))
(def (sig (procedure "(for-each proc list[1] list[2] ...)" (id for-each))) (p "The arguments to for-each are like the arguments to map, but for-each calls proc for its side effects rather than for its values. Unlike map, for-each is guaranteed to call proc on the elements of the lists in order from the first element(s) to the last, and the value returned by for-each is unspecified.") (pre "(let ((v (make-vector 5)))\n  (for-each (lambda (i)\n              (vector-set! v i (* i i)))\n            '(0 1 2 3 4))\n  v)                                        ===>  #(0 1 4 9 16)"))
(def (sig (procedure "(force promise)" (id force))) (p "Forces the value of promise (see delay, section 4.2.5). If no value has been computed for the promise, then a value is computed and returned. The value of the promise is cached (or \"memoized\") so that if it is forced a second time, the previously computed value is returned.") (pre "(force (delay (+ 1 2)))           ===>  3\n(let ((p (delay (+ 1 2))))\n  (list (force p) (force p)))  \n                                       ===>  (3 3)\n\n(define a-stream\n  (letrec ((next\n            (lambda (n)\n              (cons n (delay (next (+ n 1)))))))\n    (next 0)))\n(define head car)\n(define tail\n  (lambda (stream) (force (cdr stream))))\n\n(head (tail (tail a-stream)))  \n                                       ===>  2") (p "Force and delay are mainly intended for programs written in functional style. The following examples should not be considered to illustrate good programming style, but they illustrate the property that only one value is computed for a promise, no matter how many times it is forced.") (pre "(define count 0)\n(define p\n  (delay (begin (set! count (+ count 1))\n                (if (> count x)\n                    count\n                    (force p)))))\n(define x 5)\np                             ===>  a promise\n(force p)                     ===>  6\np                             ===>  a promise, still\n(begin (set! x 10)\n       (force p))             ===>  6") (p "Here is a possible implementation of delay and force. Promises are implemented here as procedures of no arguments, and force simply calls its argument:") (pre "(define force\n  (lambda (object)\n    (object)))") (p "We define the expression") (pre "(delay <expression>)") (p "to have the same meaning as the procedure call") (pre "(make-promise (lambda () <expression>))") (p "as follows") (pre "(define-syntax delay\n  (syntax-rules ()\n    ((delay expression)\n     (make-promise (lambda () expression))))),") (p "where make-promise is defined as follows:") (pre "(define make-promise\n  (lambda (proc)\n    (let ((result-ready? #f)\n          (result #f))\n      (lambda ()\n        (if result-ready?\n            result\n            (let ((x (proc)))\n              (if result-ready?\n                  result\n                  (begin (set! result-ready? #t)\n                         (set! result x)\n                         result))))))))") (p "Rationale:   A promise may refer to its own value, as in the last example above. Forcing such a promise may cause the promise to be forced a second time before the value of the first force has been computed. This complicates the definition of make-promise.") (p "Various extensions to this semantics of delay and force are supported in some implementations:") (ul (li "Calling force on an object that is not a promise may simply return the object.") (li "It may be the case that there is no means by which a promise can be operationally distinguished from its forced value. That is, expressions like the following may evaluate to either #t or to #f, depending on the implementation:")) (pre "   (eqv? (delay 1) 1)                  ===>  unspecified\n   (pair? (delay (cons 1 2)))          ===>  unspecified") (ul (li "Some implementations may implement \"implicit forcing,\" where the value of a promise is forced by primitive procedures like cdr and +:")) (pre "   (+ (delay (* 3 7)) 13)          ===>  34"))
(def (sig (procedure "(call-with-current-continuation proc)" (id call-with-current-continuation))) (p "Proc must be a procedure of one argument. The procedure call-with-current-continuation packages up the current continuation (see the rationale below) as an \"escape procedure\" and passes it as an argument to proc. The escape procedure is a Scheme procedure that, if it is later called, will abandon whatever continuation is in effect at that later time and will instead use the continuation that was in effect when the escape procedure was created. Calling the escape procedure may cause the invocation of before and after thunks installed using dynamic-wind.") (p "The escape procedure accepts the same number of arguments as the continuation to the original call to call-with-current-continuation. Except for continuations created by the call-with-values procedure, all continuations take exactly one value. The effect of passing no value or more than one value to continuations that were not created by call-with-values is unspecified.") (p "The escape procedure that is passed to proc has unlimited extent just like any other procedure in Scheme. It may be stored in variables or data structures and may be called as many times as desired.") (p "The following examples show only the most common ways in which call-with-current-continuation is used. If all real uses were as simple as these examples, there would be no need for a procedure with the power of call-with-current-continuation.") (pre "(call-with-current-continuation\n  (lambda (exit)\n    (for-each (lambda (x)\n                (if (negative? x)\n                    (exit x)))\n              '(54 0 37 -3 245 19))\n    #t))                                ===>  -3\n\n(define list-length\n  (lambda (obj)\n    (call-with-current-continuation\n      (lambda (return)\n        (letrec ((r\n                  (lambda (obj)\n                    (cond ((null? obj) 0)\n                          ((pair? obj)\n                           (+ (r (cdr obj)) 1))\n                          (else (return #f))))))\n          (r obj))))))\n\n(list-length '(1 2 3 4))                    ===>  4\n\n(list-length '(a b . c))                    ===>  #f") (p "Rationale:") (p "A common use of call-with-current-continuation is for structured, non-local exits from loops or procedure bodies, but in fact call-with-current-continuation is extremely useful for implementing a wide variety of advanced control structures.") (p "Whenever a Scheme expression is evaluated there is a continuation wanting the result of the expression. The continuation represents an entire (default) future for the computation. If the expression is evaluated at top level, for example, then the continuation might take the result, print it on the screen, prompt for the next input, evaluate it, and so on forever. Most of the time the continuation includes actions specified by user code, as in a continuation that will take the result, multiply it by the value stored in a local variable, add seven, and give the answer to the top level continuation to be printed. Normally these ubiquitous continuations are hidden behind the scenes and programmers do not think much about them. On rare occasions, however, a programmer may need to deal with continuations explicitly. Call-with-current-continuation allows Scheme programmers to do that by creating a procedure that acts just like the current continuation.") (p "Most programming languages incorporate one or more special-purpose escape constructs with names like exit, return, or even goto. In 1965, however, Peter Landin [16] invented a general purpose escape operator called the J-operator. John Reynolds [24] described a simpler but equally powerful construct in 1972. The catch special form described by Sussman and Steele in the 1975 report on Scheme is exactly the same as Reynolds's construct, though its name came from a less general construct in MacLisp. Several Scheme implementors noticed that the full power of the catch construct could be provided by a procedure instead of by a special syntactic construct, and the name call-with-current-continuation was coined in 1982. This name is descriptive, but opinions differ on the merits of such a long name, and some people use the name call/cc instead."))
(def (sig (procedure "(values obj ...)" (id values))) (p "Delivers all of its arguments to its continuation. Except for continuations created by the call-with-values procedure, all continuations take exactly one value. Values might be defined as follows:") (pre "(define (values . things)\n  (call-with-current-continuation \n    (lambda (cont) (apply cont things))))"))
(def (sig (procedure "(call-with-values producer consumer)" (id call-with-values))) (p "Calls its producer argument with no values and a continuation that, when passed some values, calls the consumer procedure with those values as arguments. The continuation for the call to consumer is the continuation of the call to call-with-values.") (pre "(call-with-values (lambda () (values 4 5))\n                  (lambda (a b) b))\n                                                           ===>  5\n\n(call-with-values * -)                                     ===>  -1"))
(def (sig (procedure "(dynamic-wind before thunk after)" (id dynamic-wind))) (p "Calls thunk without arguments, returning the result(s) of this call. Before and after are called, also without arguments, as required by the following rules (note that in the absence of calls to continuations captured using call-with-current-continuation the three arguments are called once each, in order). Before is called whenever execution enters the dynamic extent of the call to thunk and after is called whenever it exits that dynamic extent. The dynamic extent of a procedure call is the period between when the call is initiated and when it returns. In Scheme, because of call-with-current-continuation, the dynamic extent of a call may not be a single, connected time period. It is defined as follows:") (ul (li "The dynamic extent is entered when execution of the body of the called procedure begins.") (li "The dynamic extent is also entered when execution is not within the dynamic extent and a continuation is invoked that was captured (using call-with-current-continuation) during the dynamic extent.") (li "It is exited when the called procedure returns.") (li "It is also exited when execution is within the dynamic extent and a continuation is invoked that was captured while not within the dynamic extent.")) (p "If a second call to dynamic-wind occurs within the dynamic extent of the call to thunk and then a continuation is invoked in such a way that the afters from these two invocations of dynamic-wind are both to be called, then the after associated with the second (inner) call to dynamic-wind is called first.") (p "If a second call to dynamic-wind occurs within the dynamic extent of the call to thunk and then a continuation is invoked in such a way that the befores from these two invocations of dynamic-wind are both to be called, then the before associated with the first (outer) call to dynamic-wind is called first.") (p "If invoking a continuation requires calling the before from one call to dynamic-wind and the after from another, then the after is called first.") (p "The effect of using a captured continuation to enter or exit the dynamic extent of a call to before or after is undefined.") (pre "(let ((path '())\n      (c #f))\n  (let ((add (lambda (s)\n               (set! path (cons s path)))))\n    (dynamic-wind\n      (lambda () (add 'connect))\n      (lambda ()\n        (add (call-with-current-continuation\n               (lambda (c0)\n                 (set! c c0)\n                 'talk1))))\n      (lambda () (add 'disconnect)))\n    (if (< (length path) 4)\n        (c 'talk2)\n        (reverse path))))\n\n                ===> (connect talk1 disconnect\n                      connect talk2 disconnect)"))
(def (sig (procedure "(eval expression environment-specifier)" (id eval))) (p "Evaluates expression in the specified environment and returns its value. Expression must be a valid Scheme expression represented as data, and environment-specifier must be a value returned by one of the three procedures described below. Implementations may extend eval to allow non-expression programs (definitions) as the first argument and to allow other values as environments, with the restriction that eval is not allowed to create new bindings in the environments associated with null-environment or scheme-report-environment.") (pre "(eval '(* 7 3) (scheme-report-environment 5))\n                                                           ===>  21\n\n(let ((f (eval '(lambda (f x) (f x x))\n               (null-environment 5))))\n  (f + 10))\n                                                           ===>  20"))
(def (sig (procedure "(scheme-report-environment version)" (id scheme-report-environment)) (procedure "(null-environment version)" (id null-environment))) (p "Version must be the exact integer 5, corresponding to this revision of the Scheme report (the Revised^5 Report on Scheme). Scheme-report-environment returns a specifier for an environment that is empty except for all bindings defined in this report that are either required or both optional and supported by the implementation. Null-environment returns a specifier for an environment that is empty except for the (syntactic) bindings for all syntactic keywords defined in this report that are either required or both optional and supported by the implementation.") (p "Other values of version can be used to specify environments matching past revisions of this report, but their support is not required. An implementation will signal an error if version is neither 5 nor another value supported by the implementation.") (p "The effect of assigning (through the use of eval) a variable bound in a scheme-report-environment (for example car) is unspecified. Thus the environments specified by scheme-report-environment may be immutable."))
(def (sig (procedure "(interaction-environment)" (id interaction-environment))) (p "This procedure returns a specifier for the environment that contains implementation-defined bindings, typically a superset of those listed in the report. The intent is that this procedure will return the environment in which the implementation would evaluate expressions dynamically typed by the user."))
(def (sig (procedure "(call-with-input-file string proc)" (id call-with-input-file)) (procedure "(call-with-output-file string proc)" (id call-with-output-file))) (p "String should be a string naming a file, and proc should be a procedure that accepts one argument. For call-with-input-file, the file should already exist; for call-with-output-file, the effect is unspecified if the file already exists. These procedures call proc with one argument: the port obtained by opening the named file for input or output. If the file cannot be opened, an error is signalled. If proc returns, then the port is closed automatically and the value(s) yielded by the proc is (are) returned. If proc does not return, then the port will not be closed automatically unless it is possible to prove that the port will never again be used for a read or write operation.") (p "Rationale:   Because Scheme's escape procedures have unlimited extent, it is possible to escape from the current continuation but later to escape back in. If implementations were permitted to close the port on any escape from the current continuation, then it would be impossible to write portable code using both call-with-current-continuation and call-with-input-file or call-with-output-file."))
(def (sig (procedure "(input-port? obj)" (id input-port?)) (procedure "(output-port? obj)" (id output-port?))) (p "Returns #t if obj is an input port or output port respectively, otherwise returns #f."))
(def (sig (procedure "(current-input-port)" (id current-input-port)) (procedure "(current-output-port)" (id current-output-port))) (p "Returns the current default input or output port."))
(def (sig (procedure "(with-input-from-file string thunk)" (id with-input-from-file)) (procedure "(with-output-to-file string thunk)" (id with-output-to-file))) (p "String should be a string naming a file, and proc should be a procedure of no arguments. For with-input-from-file, the file should already exist; for with-output-to-file, the effect is unspecified if the file already exists. The file is opened for input or output, an input or output port connected to it is made the default value returned by current-input-port or current-output-port (and is used by (read), (write obj), and so forth), and the thunk is called with no arguments. When the thunk returns, the port is closed and the previous default is restored. With-input-from-file and with-output-to-file return(s) the value(s) yielded by thunk. If an escape procedure is used to escape from the continuation of these procedures, their behavior is implementation dependent."))
(def (sig (procedure "(open-input-file filename)" (id open-input-file))) (p "Takes a string naming an existing file and returns an input port capable of delivering characters from the file. If the file cannot be opened, an error is signalled."))
(def (sig (procedure "(open-output-file filename)" (id open-output-file))) (p "Takes a string naming an output file to be created and returns an output port capable of writing characters to a new file by that name. If the file cannot be opened, an error is signalled. If a file with the given name already exists, the effect is unspecified."))
(def (sig (procedure "(close-input-port port)" (id close-input-port)) (procedure "(close-output-port port)" (id close-output-port))) (p "Closes the file associated with port, rendering the port incapable of delivering or accepting characters. These routines have no effect if the file has already been closed. The value returned is unspecified."))
(def (sig (procedure "(read)" (id read)) (procedure "(read port)" (id read))) (p "Read converts external representations of Scheme objects into the objects themselves. That is, it is a parser for the nonterminal <datum> (see sections 7.1.2 and 6.3.2). Read returns the next object parsable from the given input port, updating port to point to the first character past the end of the external representation of the object.") (p "If an end of file is encountered in the input before any characters are found that can begin an object, then an end of file object is returned. The port remains open, and further attempts to read will also return an end of file object. If an end of file is encountered after the beginning of an object's external representation, but the external representation is incomplete and therefore not parsable, an error is signalled.") (p "The port argument may be omitted, in which case it defaults to the value returned by current-input-port. It is an error to read from a closed port."))
(def (sig (procedure "(read-char)" (id read-char)) (procedure "(read-char port)" (id read-char))) (p "Returns the next character available from the input port, updating the port to point to the following character. If no more characters are available, an end of file object is returned. Port may be omitted, in which case it defaults to the value returned by current-input-port."))
(def (sig (procedure "(peek-char)" (id peek-char)) (procedure "(peek-char port)" (id peek-char))) (p "Returns the next character available from the input port, without updating the port to point to the following character. If no more characters are available, an end of file object is returned. Port may be omitted, in which case it defaults to the value returned by current-input-port.") (p "Note:   The value returned by a call to peek-char is the same as the value that would have been returned by a call to read-char with the same port. The only difference is that the very next call to read-char or peek-char on that port will return the value returned by the preceding call to peek-char. In particular, a call to peek-char on an interactive port will hang waiting for input whenever a call to read-char would have hung."))
(def (sig (procedure "(eof-object? obj)" (id eof-object?))) (p "Returns #t if obj is an end of file object, otherwise returns #f. The precise set of end of file objects will vary among implementations, but in any case no end of file object will ever be an object that can be read in using read."))
(def (sig (procedure "(char-ready?)" (id char-ready?)) (procedure "(char-ready? port)" (id char-ready?))) (p "Returns #t if a character is ready on the input port and returns #f otherwise. If char-ready returns #t then the next read-char operation on the given port is guaranteed not to hang. If the port is at end of file then char-ready? returns #t. Port may be omitted, in which case it defaults to the value returned by current-input-port.") (p "Rationale:   Char-ready? exists to make it possible for a program to accept characters from interactive ports without getting stuck waiting for input. Any input editors associated with such ports must ensure that characters whose existence has been asserted by char-ready? cannot be rubbed out. If char-ready? were to return #f at end of file, a port at end of file would be indistinguishable from an interactive port that has no ready characters."))
(def (sig (procedure "(write obj)" (id write)) (procedure "(write obj port)" (id write))) (p "Writes a written representation of obj to the given port. Strings that appear in the written representation are enclosed in doublequotes, and within those strings backslash and doublequote characters are escaped by backslashes. Character objects are written using the #\\ notation. Write returns an unspecified value. The port argument may be omitted, in which case it defaults to the value returned by current-output-port."))
(def (sig (procedure "(display obj)" (id display)) (procedure "(display obj port)" (id display))) (p "Writes a representation of obj to the given port. Strings that appear in the written representation are not enclosed in doublequotes, and no characters are escaped within those strings. Character objects appear in the representation as if written by write-char instead of by write. Display returns an unspecified value. The port argument may be omitted, in which case it defaults to the value returned by current-output-port.") (p "Rationale:   Write is intended for producing machine-readable output and display is for producing human-readable output. Implementations that allow \"slashification\" within symbols will probably want write but not display to slashify funny characters in symbols."))
(def (sig (procedure "(newline)" (id newline)) (procedure "(newline port)" (id newline))) (p "Writes an end of line to port. Exactly how this is done differs from one operating system to another. Returns an unspecified value. The port argument may be omitted, in which case it defaults to the value returned by current-output-port."))
(def (sig (procedure "(write-char char)" (id write-char)) (procedure "(write-char char port)" (id write-char))) (p "Writes the character char (not an external representation of the character) to the given port and returns an unspecified value. The port argument may be omitted, in which case it defaults to the value returned by current-output-port."))
(def (sig (procedure "(load filename)" (id load))) (p "Filename should be a string naming an existing file containing Scheme source code. The load procedure reads expressions and definitions from the file and evaluates them sequentially. It is unspecified whether the results of the expressions are printed. The load procedure does not affect the values returned by current-input-port and current-output-port. Load returns an unspecified value.") (p "Rationale:   For portability, load must operate on source files. Its operation on other kinds of files necessarily varies among implementations."))
(def (sig (procedure "(transcript-on filename)" (id transcript-on)) (procedure "(transcript-off)" (id transcript-off))) (p "(These procedures are not implemented in Chicken.)") (p "Filename must be a string naming an output file to be created. The effect of transcript-on is to open the named file for output, and to cause a transcript of subsequent interaction between the user and the Scheme system to be written to the file. The transcript is ended by a call to transcript-off, which closes the transcript file. Only one transcript may be in progress at any time, though some implementations may relax this restriction. The values returned by these procedures are unspecified."))
