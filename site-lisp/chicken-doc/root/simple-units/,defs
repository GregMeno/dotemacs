(index ("make-units" 0) ("make-units*" 787) ("units?" 1086) ("check-units" 1148) ("error-units" 1148) ("units-name" 1289) ("units-base-name" 1360) ("units-unit-names" 1441) ("units-unit-factor" 1534) ("units-units-system" 1710) ("quantity" 1864) ("quantity" 1864) ("quantity" 1864) ("make-quantity" 2098) ("make-units-system" 2182) ("units-system?" 2272) ("check-units-system" 2348) ("error-units-system" 2348) ("units-system-name" 2517) ("units-system-catalog" 2611) ("units-system-units" 2720) ("units-system-units/unit" 2906) ("units-system-add-units!" 3123) ("default-units-system" 3347) ("default-units-system" 3347) ("factor?" 3571) ("check-factor" 3733) ("error-factor" 3733) ("units-factor-scale" 3878) ("units-factor-scale" 3878) ("units-number-predicate" 4246) ("units-number-predicate" 4246) ("units-number-system" 4642) ("units-number-system" 4642))
(def (sig (syntax "(make-units NAME BASE-NAME [system: UNITS-SYSTEM] UNIT-SPEC...) => units" (id make-units))) (p "Returns a new " (tt "units") ".") (p "Also pollutes the " (tt "UNITS-SYSTEM") " with the new " (tt "units") ", unless it already exists by-name. In which case the new " (tt "units") " is said to be " (i "standalone") ".") (p (tt "NAME") " is a " (tt "symbol") ", the name of the units.") (p (tt "BASE-NAME") " is a " (tt "symbol") ", the name of the unit with factor " (tt "1") ".") (p (tt "UNIT-SPEC") " is the form " (tt "<unit-spec>") ".") (p "<unit-spec>   := <unit-name> <unit-value>") (p "<unit-value>  ::= <unit-factor> <unit-value>  ::= <unit-name> <unit-value>  ::= (<unit-factor> <unit-name>)") (p "<unit-name>   ::= <symbol>") (p "<unit-factor> ::= <number>"))
(def (sig (syntax "(make-units* NAME BASE-NAME [system: UNITS-SYSTEM] UNIT-SPEC...) => units" (id make-units*))) (p "Like " (tt "make-units") " but always creates an " (i "standalone") " " (tt "units") " instance, i.e. the " (tt "UNITS-SYSTEM") " is not polluted by the created " (tt "units") "."))
(def (sig (procedure "(units? OBJ) => boolean" (id units?))))
(def (sig (procedure "(check-units LOC OBJ [ARGNAM]) => *" (id check-units)) (procedure "(error-units LOC OBJ [ARGNAM])" (id error-units))))
(def (sig (procedure "(units-name UNITS) => symbol" (id units-name))))
(def (sig (procedure "(units-base-name UNITS) => symbol" (id units-base-name))))
(def (sig (procedure "(units-unit-names UNITS) => (list-of symbol)" (id units-unit-names))))
(def (sig (procedure "(units-unit-factor UNITS NAME) => number" (id units-unit-factor))) (p "Returns the value for the " (tt "unit") " with " (tt "NAME") " in " (tt "UNITS")))
(def (sig (procedure "(units-units-system UNITS) => units-system" (id units-units-system))) (p "The " (tt "units-system") " defining " (tt "UNITS") "."))
(def (sig (syntax "(quantity N NAME [UNITS]) => number" (id quantity)) (syntax "(quantity N NAME [system: UNITS-SYSTEM]) => number" (id quantity)) (syntax "(quantity N NAME UNITS-NAME system: UNITS-SYSTEM) => number" (id quantity))))
(def (sig (procedure "(make-quantity N NAME UNITS) => number" (id make-quantity))))
(def (sig (procedure "(make-units-system NAME) => units-system" (id make-units-system))))
(def (sig (procedure "(units-system? OBJ) => boolean" (id units-system?))))
(def (sig (procedure "(check-units-system LOC OBJ [ARGNAM]) => *" (id check-units-system)) (procedure "(error-units-system LOC OBJ [ARGNAM])" (id error-units-system))))
(def (sig (procedure "(units-system-name [UNITS-SYSTEM]) => symbol" (id units-system-name))))
(def (sig (procedure "(units-system-catalog [UNITS-SYSTEM]) => (list-of units)" (id units-system-catalog))))
(def (sig (procedure "(units-system-units NAME [UNITS-SYSTEM]) => units" (id units-system-units))) (p "Returns the " (tt "units") " of " (tt "NAME") " in the " (tt "UNITS-SYSTEM") "."))
(def (sig (procedure "(units-system-units/unit NAME [UNITS-SYSTEM]) => units" (id units-system-units/unit))) (p "Returns the " (tt "units") " with " (tt "unit") " of " (tt "NAME") " in the " (tt "UNITS-SYSTEM") "."))
(def (sig (procedure "(units-system-add-units! UNITS [UNITS-SYSTEM])" (id units-system-add-units!))) (p "Adds " (tt "UNITS") " to " (tt "UNITS-SYSTEM") " catalog, replacing any existing " (tt "units") " of the same name."))
(def (sig (procedure "(default-units-system) => units-system" (id default-units-system)) (procedure "(default-units-system UNITS-SYSTEM)" (id default-units-system))) (p "Gets and sets the default " (tt "units-system") "."))
(def (sig (procedure "(factor? OBJ) => boolean" (id factor?))) (p "Is " (tt "OBJ") " a " (i "factor") ", as determined by " (tt "(units-number-predicate)") "?"))
(def (sig (procedure "(check-factor LOC OBJ [ARGNAM]) => *" (id check-factor)) (procedure "(error-factor LOC OBJ [ARGNAM])" (id error-factor))))
(def (sig (procedure "(units-factor-scale) => procedure" (id units-factor-scale)) (procedure "(units-factor-scale MULTIPLY)" (id units-factor-scale))) (p "Gets and sets the " (tt "procedure") " used to scale factors.") (p (tt "MULTIPLY") " is a " (tt "(procedure (number number) number)") ".") (p "Override when using the " (tt "numbers") " extension, for example."))
(def (sig (procedure "(units-number-predicate) => procedure" (id units-number-predicate)) (procedure "(units-number-predicate PREDICATE)" (id units-number-predicate))) (p "Gets and sets the " (tt "procedure") " used determine what is a " (tt "number") ".") (p (tt "PREDICATE") " is a " (tt "(procedure (*) boolean)") ".") (p "Override when using the " (tt "numbers") " extension, for example."))
(def (sig (procedure "(units-number-system MULTIPLY PREDICATE)" (id units-number-system)) (procedure "(units-number-system) => (values procedure procedure)" (id units-number-system))) (p "Convenience for " (tt "units-factor-scale") " & " (tt "units-number-predicate?") ". When no arguments returns 2 values, the " (tt "(units-factor-scale)") " and " (tt "(units-number-predicate?)") "."))
