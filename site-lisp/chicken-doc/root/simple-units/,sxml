((tags "egg") (section 2 "simple-units" (p "Simple Units") (toc)) (section 2 "Documentation" (p "Rudimentary support for the concept of " (i "quantity") ".") (section 3 "Argument Conventions" (p (tt "OBJ") " is a Scheme " (tt "object")) (p (tt "NAME") " is a " (tt "symbol")) (p (tt "BASE-NAME") " is a " (tt "symbol") ", the name of unit with the " (i "unit value") " of " (tt "1") ".") (p (tt "UNITS-NAME") " is a " (tt "symbol")) (p (tt "UNITS") " is an instance of " (tt "units") " (Read as " (i "unit-set") ".)") (p (tt "UNITS-SYSTEM") " is an instance of " (tt "units-system") ", the default is " (tt "(default-units-system)") ".")) (section 3 "Units (Unit-Set)" (section 4 "make-units" (def (sig (syntax "(make-units NAME BASE-NAME [system: UNITS-SYSTEM] UNIT-SPEC...) => units" (id make-units))) (p "Returns a new " (tt "units") ".") (p "Also pollutes the " (tt "UNITS-SYSTEM") " with the new " (tt "units") ", unless it already exists by-name. In which case the new " (tt "units") " is said to be " (i "standalone") ".") (p (tt "NAME") " is a " (tt "symbol") ", the name of the units.") (p (tt "BASE-NAME") " is a " (tt "symbol") ", the name of the unit with factor " (tt "1") ".") (p (tt "UNIT-SPEC") " is the form " (tt "<unit-spec>") ".") (p "<unit-spec>   := <unit-name> <unit-value>") (p "<unit-value>  ::= <unit-factor> <unit-value>  ::= <unit-name> <unit-value>  ::= (<unit-factor> <unit-name>)") (p "<unit-name>   ::= <symbol>") (p "<unit-factor> ::= <number>"))) (section 4 "make-units*" (def (sig (syntax "(make-units* NAME BASE-NAME [system: UNITS-SYSTEM] UNIT-SPEC...) => units" (id make-units*))) (p "Like " (tt "make-units") " but always creates an " (i "standalone") " " (tt "units") " instance, i.e. the " (tt "UNITS-SYSTEM") " is not polluted by the created " (tt "units") "."))) (section 4 "units?" (def (sig (procedure "(units? OBJ) => boolean" (id units?)))) (def (sig (procedure "(check-units LOC OBJ [ARGNAM]) => *" (id check-units)) (procedure "(error-units LOC OBJ [ARGNAM])" (id error-units))))) (section 4 "units-name" (def (sig (procedure "(units-name UNITS) => symbol" (id units-name))))) (section 4 "units-base-name" (def (sig (procedure "(units-base-name UNITS) => symbol" (id units-base-name))))) (section 4 "units-unit-names" (def (sig (procedure "(units-unit-names UNITS) => (list-of symbol)" (id units-unit-names))))) (section 4 "units-unit-factor" (def (sig (procedure "(units-unit-factor UNITS NAME) => number" (id units-unit-factor))) (p "Returns the value for the " (tt "unit") " with " (tt "NAME") " in " (tt "UNITS")))) (section 4 "units-units-system" (def (sig (procedure "(units-units-system UNITS) => units-system" (id units-units-system))) (p "The " (tt "units-system") " defining " (tt "UNITS") ".")))) (section 3 "Quantity" (section 4 "quantity" (def (sig (syntax "(quantity N NAME [UNITS]) => number" (id quantity)) (syntax "(quantity N NAME [system: UNITS-SYSTEM]) => number" (id quantity)) (syntax "(quantity N NAME UNITS-NAME system: UNITS-SYSTEM) => number" (id quantity))))) (section 4 "make-quantity" (def (sig (procedure "(make-quantity N NAME UNITS) => number" (id make-quantity)))))) (section 3 "Units System" (section 4 "make-units-system" (def (sig (procedure "(make-units-system NAME) => units-system" (id make-units-system))))) (section 4 "units-system?" (def (sig (procedure "(units-system? OBJ) => boolean" (id units-system?)))) (def (sig (procedure "(check-units-system LOC OBJ [ARGNAM]) => *" (id check-units-system)) (procedure "(error-units-system LOC OBJ [ARGNAM])" (id error-units-system))))) (section 4 "units-system-name" (def (sig (procedure "(units-system-name [UNITS-SYSTEM]) => symbol" (id units-system-name))))) (section 4 "units-system-catalog" (def (sig (procedure "(units-system-catalog [UNITS-SYSTEM]) => (list-of units)" (id units-system-catalog))))) (section 4 "units-system-units" (def (sig (procedure "(units-system-units NAME [UNITS-SYSTEM]) => units" (id units-system-units))) (p "Returns the " (tt "units") " of " (tt "NAME") " in the " (tt "UNITS-SYSTEM") "."))) (section 4 "units-system-units/unit" (def (sig (procedure "(units-system-units/unit NAME [UNITS-SYSTEM]) => units" (id units-system-units/unit))) (p "Returns the " (tt "units") " with " (tt "unit") " of " (tt "NAME") " in the " (tt "UNITS-SYSTEM") "."))) (section 4 "units-system-add-units!" (def (sig (procedure "(units-system-add-units! UNITS [UNITS-SYSTEM])" (id units-system-add-units!))) (p "Adds " (tt "UNITS") " to " (tt "UNITS-SYSTEM") " catalog, replacing any existing " (tt "units") " of the same name."))) (section 4 "default-units-system" (def (sig (procedure "(default-units-system) => units-system" (id default-units-system)) (procedure "(default-units-system UNITS-SYSTEM)" (id default-units-system))) (p "Gets and sets the default " (tt "units-system") ".")))) (section 3 "Unit" (section 4 "factor?" (def (sig (procedure "(factor? OBJ) => boolean" (id factor?))) (p "Is " (tt "OBJ") " a " (i "factor") ", as determined by " (tt "(units-number-predicate)") "?")) (def (sig (procedure "(check-factor LOC OBJ [ARGNAM]) => *" (id check-factor)) (procedure "(error-factor LOC OBJ [ARGNAM])" (id error-factor))))) (section 4 "units-factor-scale" (def (sig (procedure "(units-factor-scale) => procedure" (id units-factor-scale)) (procedure "(units-factor-scale MULTIPLY)" (id units-factor-scale))) (p "Gets and sets the " (tt "procedure") " used to scale factors.") (p (tt "MULTIPLY") " is a " (tt "(procedure (number number) number)") ".") (p "Override when using the " (tt "numbers") " extension, for example."))) (section 4 "units-number-predicate" (def (sig (procedure "(units-number-predicate) => procedure" (id units-number-predicate)) (procedure "(units-number-predicate PREDICATE)" (id units-number-predicate))) (p "Gets and sets the " (tt "procedure") " used determine what is a " (tt "number") ".") (p (tt "PREDICATE") " is a " (tt "(procedure (*) boolean)") ".") (p "Override when using the " (tt "numbers") " extension, for example."))) (section 4 "units-number-system" (def (sig (procedure "(units-number-system MULTIPLY PREDICATE)" (id units-number-system)) (procedure "(units-number-system) => (values procedure procedure)" (id units-number-system))) (p "Convenience for " (tt "units-factor-scale") " & " (tt "units-number-predicate?") ". When no arguments returns 2 values, the " (tt "(units-factor-scale)") " and " (tt "(units-number-predicate?)") "."))))) (section 2 "Usage" (highlight scheme "(require-extension simple-units)")) (section 2 "Examples" (ul (li "Using a registerd units")) (highlight scheme "(make-units time s\n  m 60\n  h (60 m)\n  d (24 h)\n  ms (0.0001 s)\n  us (0.0001 ms))\n\n(define 23h23m23s\n  (+ (quantity 23 h)\n     (quantity 23 m)\n     (quantity 23 s)))") (ul (li "Using a " (i "standalone") " units")) (highlight scheme "(define time-units\n  (make-units* time s\n    m 60\n    h (60 m)\n    d (24 h)\n    ms (0.0001 s)\n    us (0.0001 ms)))\n\n(define 23h23m23s\n  (+ (quantity 23 h time-units)\n     (quantity 23 m time-units)\n     (quantity 23 s time-units)))") (ul (li "Using " (tt "numbers") ".")) (highlight scheme "(use numbers)\n\n(units-number-system * number?) ;must override\n\n(make-units time s\n  m 60\n  h (60 m)\n  d (24 h)\n  ms (1/1000 s)\n  us (1/1000 ms))\n\n(make-units distance m\n  km 1000\n  cm 1/100\n  mm (1/10 cm)\n  nm (1/1000 mm)\n\n  ; Defined in 1956\n  yard 9144/10000\n  foot (1/3 yard)\n  inch (1/12 foot)\n  mile (1760 yard)\n  furlong (1/8 mile)\n\n  ; Defined in 1929\n  nautical-mile 1852\n  cable (1/10 nautical-mile)\n  fathom (2 yard)\n\n  ; Dropped in 1970\n  old-british-nautical-mile\n    (6080/3 yard)\n  old-british-cable\n    (1/10 old-british-nautical-mile)\n  old-british-fathom\n    (1/100 old-british-cable))")) (section 2 "Notes" (ul (li "This is best viewed as a toy."))) (section 2 "Requirements" (p (int-link "record-variants") " " (int-link "list-utils") " " (int-link "symbol-utils") " " (int-link "lookup-table") " " (int-link "moremacros") " " (int-link "type-checks")) (p (int-link "setup-helper"))) (section 2 "Bugs and Limitations" (ul (li "A " (tt "unit") " is not 1st-class.") (li "A " (tt "quantity") " is not 1st-class. Requires extending the numeric tower!") (li "No " (i "dimension") " concept.") (li "Cannot remove a " (tt "units") " from a " (tt "units-system") ".") (li "Cannot extend a " (tt "units") ", only re-define.") (li "The " (tt "units-factor-scale") " & " (tt "units-number-predicate") " variables are a kludge.") (li "Cannot create derived " (tt "units") "."))) (section 2 "Author" (p (int-link "/users/kon-lovett" "Kon Lovett"))) (section 2 "Version history" (dl (dt "1.2.0") (dd "Removed dependency on \"format-compiler-base\".") (dt "1.1.0") (dt "1.0.0") (dd "Hello."))) (section 2 "License" (p "Copyright (C) 2010 Kon Lovett.  All rights reserved.") (p "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:") (p "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.") (p "THE SOFTWARE IS PROVIDED ASIS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.")))