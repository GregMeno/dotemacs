((tags "egg") (section 2 "sql-null " (section 3 "Description" (p "An extension for providing a portable SQL NULL object.")) (section 3 "Author" (p "Ivan Shmakov")) (section 3 "Documentation" (p "The sql-null extension implements the following interface.") (def (sig (procedure "(sql-null)" (id sql-null))) (p "Return an object, corresponding to a SQL NULL value.  The object is guaranteed to be of a type disjoint from all of the R5RS' standard types. It's unspecified whether the values returned by this function will be " (tt "eq?") " to each other:") (highlight scheme "(eq? (sql-null) (sql-null)) => ; unspecified.")) (def (sig (procedure "(sql-null? OBJECT)" (id sql-null?))) (p "Return #t if OBJECT is a SQL NULL object.  Return #f otherwise.")) (def (sig (syntax "(sql-not OBJECT)" (id sql-not))) (p "Return " (tt "OBJECT") " if " (tt "OBJECT") " is a SQL NULL object.  Return the value of " (tt "(not OBJECT)") " otherwise.") (highlight scheme "(sql-not (sql-null)) => SQL-NULL\n(sql-not 'a) => #f\n(sql-not #f) => #t\n\n(let ((null (sql-null)))\n  (eq? null (sql-not null))) => #t")) (def (sig (syntax "(sql-and TEST-1 ...)" (id sql-and))) (p "The " (tt "TEST") " expressions are evaluated from left to right, and the value of the first expression that evaluates to a false value is returned, and any remaining " (tt "TEST") "s are not evaluated. If there were no expressions to evaluate to a false value, the value of any of the expressions to evaluate to a SQL NULL is returned.  If there were no such expressions as well, " (tt "#t") " is returned.") (highlight scheme "(sql-and 1) => 1\n(sql-and 1 (sql-null) 2) => SQL-NULL\n(sql-and #f (sql-null)) => #f") (p "In the absence of the expressions that evaluate to SQL NULL values, the semantics is the same as for " (tt "(and test-1 ...)") ".  One could think of the SQL NULL as \"sticky\"; as soon as it is encountered, it will be the result of the entire expression (unless " (tt "#f") " is also encountered).")) (def (sig (syntax "(sql-or test-1 ...)" (id sql-or))) (p "The TEST expressions are evaluated from left to right, and the value of the first expression that evaluates to a value, other than SQL NULL and a false value (a ``SQL true'' value), is returned, and any remaining TESTs are not evaluated. If there were no expressions to evaluate to a SQL true value, the value of any of the expressions to evaluate to a SQL NULL is returned.  If there were no such expressions as well, " (tt "#f") " is returned.") (highlight scheme "(sql-or 1) => 1\n(sql-or #t (sql-null) 2) => #t\n(sql-or #f (sql-null)) => SQL-NULL\n(sql-or #f (sql-null) 1) => 1") (p "In the absence of the expressions that evaluate to SQL NULL values, the semantics is the same as for " (tt "(or test-1 ...)") ".")) (def (sig (syntax "(sql-coalesce test-1 ...)" (id sql-coalesce))) (p "The TEST expressions are evaluated from left to right, and the value of the first expression that is not SQL NULL is returned, and any remaining TESTs are not evaluated. If no such value is found, SQL NULL is returned, similar to the SQL `" (tt "COALESCE") "' function.") (highlight scheme "(sql-coalesce 1) => 1\n(sql-coalesce (sql-null)) => SQL NULL\n(sql-coalesce (sql-null) 2) => 2\n(sql-coalesce #f (sql-null) 1) => #f") (p "This is like Scheme's " (tt "or") " macro, instead of treating " (tt "#f") " as the only false value, it treats SQL NULL as false and everything else as true."))) (section 3 "License" (p "Public Domain"))))