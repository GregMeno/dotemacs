((section 2 "Leptonica" (p "In progress.") (p "An interface to the " (link "http://www.leptonica.com/" "leptonica") " library of routines for image analysis and processing.") (section 3 "Memory Management" (p "Most of the library's operations are based around manipulating images, which are stored in a structure known as a " (tt "pix") ".  You should manually manage the references to the images.  If you want a copy of an existing " (tt "pix") ", use " (tt "pix-clone") "; this updates the reference count for an image.  Use " (tt "pix-destroy") " when you are finished with a reference to a " (tt "pix") "; this decrements the reference count, and finally deletes the image when the count is 0.")) (section 3 "Implemented Procedures" (section 4 "Creating and managing images" (def (sig (procedure "(pix-clone pix)" (id pix-clone))) (p "Return a reference to given " (tt "pix") ".")) (def (sig (procedure "(pix-copy pix-d pix-s)" (id pix-copy))) (p "Makes a copy of " (tt "pix-s") ": if " (tt "pix-d") " is " (tt "#f") " then returns a pointer to a copy of " (tt "pix-s") ", else makes " (tt "pix-d") " a copy of " (tt "pix-s") ".")) (def (sig (procedure "(pix-create width height depth)" (id pix-create))) (p "Returns a pointer to a new " (tt "pix") ", an image of given " (tt "width") " and " (tt "height") " in pixels, and colour " (tt "depth") ".")) (def (sig (procedure "(pix-destroy pix)" (id pix-destroy))) (p "Reduces reference count to " (tt "pix") ", and destroys picture if count is 0.")) (def (sig (procedure "(pix-read filename)" (id pix-read))) (p "Returns a pointer to a new " (tt "pix") " created by reading image from " (tt "filename") ".  Returns " (tt "#f") " if there is an error.")) (def (sig (procedure "(pix-write filename pix image-type)" (id pix-write))) (p "Writes " (tt "pix") " to an image file called " (tt "filename") ".  The " (tt "image-type") " is taken from the list of constants, below."))) (section 4 "Image attributes" (def (sig (procedure "(pix-get-width pix)" (id pix-get-width))) (p "Returns the width in pixels of given " (tt "pix") ".")) (def (sig (procedure "(pix-set-width pix integer)" (id pix-set-width))) (p "Sets the width in pixels of given " (tt "pix") ".  Returns 0 if ok, or 1 if error.")) (def (sig (procedure "(pix-get-height pix)" (id pix-get-height))) (p "Returns the height in pixels of given " (tt "pix") ".")) (def (sig (procedure "(pix-set-height pix integer)" (id pix-set-height))) (p "Sets the height in pixels of given " (tt "pix") ".  Returns 0 if ok, or 1 if error.")) (def (sig (procedure "(pix-get-depth pix)" (id pix-get-depth))) (p "Returns the colour depth of given " (tt "pix") ".")) (def (sig (procedure "(pix-set-depth pix integer)" (id pix-set-depth))) (p "Sets colour depth of given " (tt "pix") ".  Returns 0 if ok, or 1 if error.")) (def (sig (procedure "(pix-set-dimensions pix width height depth)" (id pix-set-dimensions))) (p "Sets all three properties of given " (tt "pix") ".  Returns 0 if ok, or 1 if error.")) (def (sig (procedure "(pix-get-x-res pix)" (id pix-get-x-res))) (p "Returns the x resolution of given " (tt "pix") ".")) (def (sig (procedure "(pix-set-x-res pix integer)" (id pix-set-x-res))) (p "Sets the x resolution of given " (tt "pix") ".  Returns 0 if ok, or 1 if error.")) (def (sig (procedure "(pix-get-y-res pix)" (id pix-get-y-res))) (p "Returns the y resolution of given " (tt "pix") ".")) (def (sig (procedure "(pix-set-y-res pix integer)" (id pix-set-y-res))) (p "Sets the y resolution of given " (tt "pix") ".  Returns 0 if ok, or 1 if error.")) (def (sig (procedure "(pix-set-resolution pix x-res y-res)" (id pix-set-resolution))) (p "Sets the x and y resolution of given " (tt "pix") ".  Returns 0 if ok, or 1 if error.")) (def (sig (procedure "(pix-scale-resolution pix x-scale y-scale)" (id pix-scale-resolution))) (p "Rescales the image in the x and y directions.  Returns 0 if ok, or 1 if error.")) (def (sig (procedure "(pix-get-input-format pix)" (id pix-get-input-format))) (p "Returns the input format of " (tt "pix") ".")) (def (sig (procedure "(pix-set-input-format pix integer)" (id pix-set-input-format))) (p "Sets the input format of " (tt "pix") "."))) (section 4 "Manipulating images" (def (sig (procedure "(pix-abs-difference pix-1 pix-2)" (id pix-abs-difference))) (p "Returns pointer to new image which is formed by taking the pixel-wise absolute difference between " (tt "pix-1") " and " (tt "pix-2") ".  The two source images must have identical dimensions and colour depth.  " (tt "#f") " is returned on an error.")) (def (sig (procedure "(pix-add-gray pix-d pix-1 pix-2)" (id pix-add-gray))) (p "Returns pointer to image which is pixel sum of " (tt "pix-1") " and " (tt "pix-2") ".  Unless " (tt "#f") ", " (tt "pix-d") " may specify the destination image, and " (tt "pix-d") " may be equal to " (tt "pix-1") " for an in-place change.")) (def (sig (procedure "(pix-add-constant-gray pix-s value)" (id pix-add-constant-gray))) (p "In-place modification of " (tt "pix-s") " by adding " (tt "value") " to each pixel.  Returns 0 if OK or 1 if error.")) (def (sig (procedure "(pix-close-gray pix h-size v-size)" (id pix-close-gray))) (p (tt "h-size") " and " (tt "v-size") " must be odd values: they denote the size of gray block to find. Returns a pointer to a new " (tt "pix") ", based on the given " (tt "pix") ", removing parts that do not fit a h-size x v-size block.")) (def (sig (procedure "(pix-combine-masked pix-d pix-s pix-m)" (id pix-combine-masked))) (p "Modifies " (tt "pix-d") " in place.  Each pixel in " (tt "pix-d") " corresponding to a set pixel in the mask " (tt "pix-m") " is set to that pixel's value from " (tt "pix-s") ".  " (tt "pix-d") " and " (tt "pix-s") " must be equivalent in pixel depth.  The three images are aligned to the top-left corner, stopping when outside the intersection of three images.  Returns 0 if OK or 1 if error.")) (def (sig (procedure "(pix-dilate-gray pix h-size v-size)" (id pix-dilate-gray))) (p (tt "h-size") " and " (tt "v-size") " must be odd values. Returns a pointer to a new " (tt "pix") ", based on the given " (tt "pix") ".")) (def (sig (procedure "(pix-dither-to-binary pix)" (id pix-dither-to-binary))) (p "Uses Floyd-Steinberg error diffusion dithering algorithm to convert given " (tt "pix") " to a new " (tt "pix") ".  Returns " (tt "#f") " on error.")) (def (sig (procedure "(pix-dither-to-binary-spec pix lowerclip upperclip)" (id pix-dither-to-binary-spec))) (p "Similar to " (tt "pix-dither-to-binary") ", but the integers " (tt "lowerclip") " and " (tt "upperclip") " specific the distance to 0 or 255 respectively beyond which the routine stops propagating excess.")) (def (sig (procedure "(pix-erode-gray pix h-size v-size)" (id pix-erode-gray))) (p (tt "h-size") " and " (tt "v-size") " must be odd values. Returns a pointer to a new " (tt "pix") ", based on the given " (tt "pix") ".")) (def (sig (procedure "(pix-find-skew pix)" (id pix-find-skew))) (p "Returns two values: the angle (in radians) and confidence level of skew in the given " (tt "pix") ".")) (def (sig (procedure "(pix-invert pix-d pix-s)" (id pix-invert))) (p "Inverts the image " (tt "pix-s") ".  If " (tt "pix-d") " is " (tt "#f") ", then a pointer to a new " (tt "pix") " is returned; otherwise, " (tt "pix-d") " holds the inverted image.")) (def (sig (procedure "(pix-max-dynamic-range pix scale-type)" (id pix-max-dynamic-range))) (p "Returns a new pointer to an image which stretches the colour values in " (tt "pix") " to the full available range.  Returns " (tt "#f") " if error.  " (tt "scale-type") " is constant given below.")) (def (sig (procedure "(pix-min-or-max pix-d pix-1 pix-2 choose-type)" (id pix-min-or-max))) (p "Returns a pointer to an image which is formed either from the pixel-wise min or max of the two source images (the type determined by " (tt "choose-type") ", defined below).  If " (tt "pix-d") " is " (tt "#f") " then a new image is created and returned.  If " (tt "pix-d") " is an image, then that image is updated.  If " (tt "pix-d") " is the same as " (tt "pix-1") " then an in-place change is made.")) (def (sig (procedure "(pix-mult-constant-gray pix-s value)" (id pix-mult-constant-gray))) (p "In-place modification of " (tt "pix-s") " by multiplying each pixel value by " (tt "value") ".  Returns 0 if OK, or 1 if error.")) (def (sig (procedure "(pix-open-gray pix h-size v-size)" (id pix-open-gray))) (p (tt "h-size") " and " (tt "v-size") " must be odd values. Returns a pointer to a new " (tt "pix") ", based on the given " (tt "pix"))) (def (sig (procedure "(pix-rotate-am-gray pix angle filler)" (id pix-rotate-am-gray))) (p "Returns a pointer to a new 8bpp " (tt "pix") " created by rotating the given 8 bpp " (tt "pix") " through the given " (tt "angle") "; " (tt "filler") " specifies the gray value to be brought in to fill blanks, 0 for black, 255 for white.")) (def (sig (procedure "(pix-subtract-gray pix-d pix-1 pix-2)" (id pix-subtract-gray))) (p "Returns pointer to image which is pixel difference of " (tt "pix-1") " and " (tt "pix-2") ".  Unless " (tt "#f") ", " (tt "pix-d") " may specify the destination image, and " (tt "pix-d") " may be equal to " (tt "pix-1") " for an in-place change.")) (def (sig (procedure "(pix-threshold-to-binary pix threshold)" (id pix-threshold-to-binary))) (p "Returns a pointer to a new " (tt "pix") " created from the given " (tt "pix") ".  The given " (tt "pix") " should be a 4 or 8 bpp colour image; the given threshold value is used to convert the image to binary.")) (def (sig (procedure "(pix-threshold-to-value pix-d pix-s threshold set-value)" (id pix-threshold-to-value))) (p "If " (tt "pix-d") " is " (tt "#f") ", returns a pointer to a new " (tt "pix") ".  Else, " (tt "pix-d") " must be equal to " (tt "pix-s") " and thresholding is done in place.  If set-value > threshold, then all pixels with a value >= threshold are set to set-value; else, if set-value < threshold, then all pixels with value <= threshold are set to set-value.")) (def (sig (procedure "(pix-var-threshold-to-binary pix-s pix-g)" (id pix-var-threshold-to-binary))) (p "Returns a pointer to a new " (tt "pix") " created from the given 8 bpp " (tt "pix-s") " by thresholding each corresponding pixel according to the value in " (tt "pix-g") ".")) (def (sig (procedure "(rotate pix angle rotation-type in-colour width height)" (id rotate))) (p "Returns a pointer to a new " (tt "pix") " created by rotating given " (tt "pix") ".") (ul (li "angle: in radians, with positive value indicating clockwise.") (li "rotation-type: from list of constants below.") (li "in-colour: from list of constants below, determines if white or black pixels complete missing spaces.") (li "width: of final image") (li "height: of final image"))) (def (sig (procedure "(scale pix scale-x scale-y)" (id scale))) (p "Returns a pointer to a new " (tt "pix") " created by rescaling given " (tt "pix") " along x and y dimensions."))) (section 4 "Finding Components in Images" (p "In each of the following, the {{connectivity} must be 4 or 8 depending on whether pixels are connected to their 4 neighbours in the up/down/left/right directions or with all 8 of their neighbours.") (def (sig (procedure "(pix-conn-comp-bb pix connectivity)" (id pix-conn-comp-bb))) (p "Returns an array of bounding boxes corresponding to the components within " (tt "pix") ".  " (tt "pix") " must be a 1 bpp image.")) (def (sig (procedure "(pix-conn-comp-pixa pix connectivity)" (id pix-conn-comp-pixa))) (p "Returns two values: an array of bounding boxes (type " (tt "BOXA") ") and an array of pix images (type " (tt "PIXA") ").  The bounding boxes and images are the components within the given " (tt "pix") ".  " (tt "pix") " must be a 1 bpp image.")) (def (sig (procedure "(pix-count-conn-comp pix connectivity)" (id pix-count-conn-comp))) (p "Returns the number of connected components, or " (tt "#f") " if there was an error.  " (tt "pix") " must be a 1 bpp image."))) (section 4 "Boxes" (p "Boxes are used within Leptonica to hold information about regions of an image.  These boxes can be stored as arrays.  The following procedures let you work with boxes and box arrays, extracting information from them and subobjects.") (p (tt "box") " stands for an instance of the " (tt "BOX") " structure within the C-code.") (p (tt "boxa") " stands for an instance of the " (tt "BOXA") " structure, an array of boxes.") (def (sig (procedure "(box-get-geometry box)" (id box-get-geometry))) (p "Returns four values: the x, y, width, height of the box in pixel coordinates.  Returns " (tt "#f") " on error.")) (def (sig (procedure "(box-set-geometry box x y w h)" (id box-set-geometry))) (p "Sets the values of x, y, width and height of the given " (tt "box") " in pixels.  Returns 0 if OK, or 1 if error.")) (def (sig (procedure "(boxa-get-box boxa index copy-type)" (id boxa-get-box))) (p "Return a pointer to the indexed box in the box array: " (tt "copy-type") " is a constant, as defined below, and determines if the box is returned as a copy or a clone.  Returns " (tt "#f") " on error.")) (def (sig (procedure "(boxa-get-count boxa)" (id boxa-get-count))) (p "Returns a count of the number of boxes within the box array."))) (section 4 "Pix arrays" (p "The " (tt "PIXA") " structure can be explored using the following procedures:") (def (sig (procedure "(pixa-get-count pixa)" (id pixa-get-count))) (p "Returns the number of pix images in the pix array.")) (def (sig (procedure "(pixa-get-pix pixa index copy-type)" (id pixa-get-pix))) (p "Returns a pointer to the indexed pix in the pix array: " (tt "copy-type") " is a constant, as defined below, and determines if the pix is returned as a copy or a clone.  Returns " (tt "#f") " on error."))) (section 4 "Constants" (dl (dt "choose-type") (dd "L-CHOOSE-MAX, L-CHOOSE-MIN") (dt "copy-type") (dd "L-COPY L-CLONE") (dt "image-type") (dd "IFF-UNKNOWN, IFF-BMP, IFF-JFIF-JPEG, IFF-PNG, IFF-TIFF, IFF-TIFF-PACKBITS, IFF-TIFF-RLE, IFF-TIFF-G3, IFF-TIFF-G4, IFF-TIFF-LZW, IFF-TIFF-ZIP, IFF-PNM, IFF-PS, IFF-GIF, IFF-JP2, IFF-DEFAULT, IFF-SPIX.") (dt "in-colour") (dd "L-BRING-IN-WHITE, L-BRING-IN-BLACK.") (dt "rotation-type") (dd "L-ROTATE-AREA-MAP, L-ROTATE-SHEAR, L-ROTATE-SAMPLING.") (dt "scale-type") (dd "L-LINEAR-SCALE, L-LOG-SCALE")))) (section 3 "Examples" (p "See the examples folder in the " (link "http://anonymous@code.call-cc.org/svn/chicken-eggs/release/4/leptonica/examples/" "repository") ".") (p "The more useful examples include:") (ul (li "component extraction (identifies all the letter-like components of a scanned image)") (li "lineremoval (after the version provided with leptonica)"))) (section 3 "Author" (p (link "http://wiki.call-cc.org/users/peter-lane" "Peter Lane"))) (section 3 "License" (p "GPL version 3.0.")) (section 3 "Requirements" (p "You will need libraries for handling images: libjpeg, libpng, libtiff are currently assumed in the setup file.") (p "Also, you must download and compile the " (link "http://www.leptonica.com/download.html" "source code") " for the leptonica library.") (p "Note: this egg has only been tested under Linux.")) (section 3 "Version History" (ul (li "0.2: includes component analysis") (li "0.1: initial release")))))