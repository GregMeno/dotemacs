((tags "egg") (section 2 "message-digest" (toc)) (section 2 "Documentation" (p "Message Digest provides support for message digest primitives. A message-digest is a function taking some input source and returning a fixed-length hash.") (p "For best results the source object(s) to be accumulated into the digest should be something easily treated as a " (tt "byteblock") " or, even better, a " (tt "bytevector") ".") (section 3 "Message Digest Primitive" (section 4 "Common Argument Definitions" (p (tt "PRIMITIVE") " is a " (tt "message-digest-primitive"))) (section 4 "message-digest-primitive?" (def (sig (procedure "(message-digest-primitive? OBJ) => boolean" (id message-digest-primitive?)) (procedure "(check-message-digest-primitive LOC OBJ [NAM])" (id check-message-digest-primitive)) (procedure "(error-message-digest-primitive LOC OBJ [NAM])" (id error-message-digest-primitive))))) (section 4 "message-digest-primitive Accessors" (def (sig (procedure "(message-digest-primitive-context-info PRIMITIVE)" (id message-digest-primitive-context-info)) (procedure "(message-digest-primitive-digest-length PRIMITIVE)" (id message-digest-primitive-digest-length)) (procedure "(message-digest-primitive-init PRIMITIVE)" (id message-digest-primitive-init)) (procedure "(message-digest-primitive-update PRIMITIVE)" (id message-digest-primitive-update)) (procedure "(message-digest-primitive-final PRIMITIVE)" (id message-digest-primitive-final)) (procedure "(message-digest-primitive-name PRIMITIVE)" (id message-digest-primitive-name))))) (section 4 "make-message-digest-primitive" (def (sig (procedure "(make-message-digest-primitive CONTEXT-INFO DIGEST-LENGTH INIT UPDATE FINAL [NAME]) => message-digest-primitive" (id make-message-digest-primitive))) (p "Create a " (tt "message-digest-primitive") " object. The reification of a message digest algorithm.") (p (tt "CONTEXT-INFO") " is either a " (tt "(procedure () <context>)") ", or an " (tt "integer") ". When an " (tt "integer") " a memory-block of length " (tt "CONTEXT-INFO") " is allocated (and automatically free'ed).") (p (tt "<context>") " is an opaque object, except when the " (tt "CONTEXT-INFO") " is an integer. In which case it is known that the object is a " (tt "pointer") " to a block of non-garbage collected memory.") (p "The " (tt "<context>") " must always be a " (b "new") " object.") (p (tt "DIGEST-LENGTH") " is the count of bytes in the result " (tt "string") ".") (p "The processing of a message digest is split into three phases: initialization, update & finalization. These are represented by three procedures: " (tt "INIT") ", " (tt "UPDATE") " & " (tt "FINAL") ", respectively.") (p (tt "INIT") " is a " (tt "(procedure (<context>))") ". Sets up the " (tt "<context>") ". (Technically the creation of a new " (tt "<context>") " is part of the initialization phase but this detail is hidden from the user.)") (p (tt "UPDATE") " is a " (tt "(procedure (<context> <bytevector> <count>))") ". Must accumulate the " (tt "<bytevector>") ", where " (tt "<bytevector>") " is a " (tt "string") " or " (tt "blob") ". Will be called one or more times.") (p "The foreign type specifier " (tt "scheme-pointer") " is suitable as a foreign-lambda argument type for the " (tt "<bytevector>") " argument since the data-region of both is a bytevector.") (p (tt "<count>") " is the actual number of bytes in the " (tt "<bytevector>") ". Since this value is supplied it means only the first " (tt "<count>") " bytes in the " (tt "<bytevector>") " are valid.") (p (tt "FINAL") " is a " (tt "(procedure (<context> <bytevector>))") ". Must build the message-digest result in the supplied result " (tt "<bytevector>") " of length at least " (tt "DIGEST-LENGTH") ".") (p "Currently the result " (tt "<bytevector>") " will " (b "only") " be a " (tt "string") " but developers should accept a " (tt "string") " or " (tt "blob") ".") (p "(" (b "Note") " that " (tt "INIT") ", " (tt "UPDATE") " & " (tt "FINAL") " are side-effecting procedures!)") (p (tt "NAME") " must be a " (tt "symbol") " or a " (tt "string") " and identifies the message digest algorithm. The suggested form is " (tt "<algorithm name>-primitive") ". Example: " (tt "'md5-primitive") ". The default is a nearly useless generated, uninterned " (tt "symbol") ".")))) (section 3 "Message Digest" (section 4 "Common Argument Definitions" (p (tt "RESULT-FORM") " is one of:") (dl (dt (tt "'string")) (dd "the result bytes as a string; these are raw bytes, not characters!") (dt (tt "'hex")) (dd "the result bytes encoded as a string of hexadecimal digits.") (dt (tt "'blob")) (dd "the result bytes as a blob.") (dt (tt "'u8vector")) (dd "the result bytes as a u8vector.")) (p (tt "DIGEST") " is a " (tt "message-digest") ".") (p (tt "ENDIAN") " is one of " (tt "'big-endian") ", " (tt "'little-endian") ".") (p (tt "SOURCE") " is a Scheme object.") (p "The " (tt "<buffer>") " argument for the update phase is translated as:") (dl (dt (tt "string")) (dd (tt "<buffer>") " = " (tt "SOURCE") ".") (dt (tt "blob")) (dd (tt "<buffer>") " = " (tt "SOURCE") ".") (dt (tt "packed-vector")) (dd (tt "<buffer>") " = " (tt "(...vector->blob/shared SOURCE)") ".") (dt (tt "procedure")) (dd "updates with " (tt "<buffer>") " = " (tt "(procedure)") " until " (tt "#f = (procedure)") ".") (dt (tt "input-port")) (dd "like " (tt "procedure") " above but from " (tt "((message-digest-chunk-read-maker) SOURCE)") ".") (dt (tt "*")) (dd (tt "<buffer>") " = " (tt "(message-digest-chunk-converter SOURCE)") ".")) (p "Should none of the above interpretations be available then an error is signaled.") (p "A " (tt "<byte-source>") " is one of " (tt "string") ", " (tt "blob") ", or " (tt "packed-vector") ".")) (section 4 "message-digest-chunk-read-maker" (def (sig (procedure "(message-digest-chunk-read-maker) => (procedure (input-port) (procedure () <byte-source>))" (id message-digest-chunk-read-maker)) (procedure "(message-digest-chunk-read-maker CONSTRUCTOR)" (id message-digest-chunk-read-maker))) (p "Supplies the procedure used to create an input procedure.") (p (tt "CONSTRUCTOR") " is a " (tt "(procedure (input-port #!optional positive-integer) (procedure () <byte-source>))") ". The first argument is the chunk source port and the second argument is the size of chunks.") (p "The default " (tt "CONSTRUCTOR") " will return a procedure that reads from " (tt "INPUT-PORT") " in " (tt "(message-digest-chunk-size)") " bytes."))) (section 4 "message-digest-chunk-size" (def (sig (procedure "(message-digest-chunk-size) => positive-integer" (id message-digest-chunk-size)) (procedure "(message-digest-chunk-size [SIZE])" (id message-digest-chunk-size))) (p "The number of bytes to read from a binary-stream during the message-digest update phase. Used by the default " (tt "message-digest-chunk-read-maker") ".") (p (tt "SIZE") " is a " (tt "positive integer") ", with default " (tt "1024") "."))) (section 4 "message-digest-chunk-converter" (def (sig (procedure "(message-digest-chunk-converter) => (procedure (*) <byte-source>)" (id message-digest-chunk-converter)) (procedure "(message-digest-chunk-converter [CONVERTER])" (id message-digest-chunk-converter))) (p "The procedure used to translate an arbitrary object into something suitable for an " (tt "UPDATE") " procedure. See " (tt "make-message-digest-primitive") ".") (p (tt "CONVERTER") " is a " (tt "(procedure (*) <byte-source>)") ".") (p "Should the " (tt "CONVERTER") " be " (tt "#f") " or return " (tt "#f") " then no translation is attempted.") (p "The default is " (tt "#f") "."))) (section 4 "initialize-message-digest" (def (sig (procedure "(initialize-message-digest PRIMITIVE) => message-digest" (id initialize-message-digest))) (p "Returns a new, initialized " (tt "message-digest") " for the supplied algorithm " (tt "PRIMITIVE") ".") (p "Initialized here means the intialization phase is completed."))) (section 4 "message-digest?" (def (sig (procedure "(message-digest? OBJ) => boolean" (id message-digest?)))) (def (sig (procedure "(check-message-digest LOC OBJ [NAM])" (id check-message-digest)) (procedure "(error-message-digest LOC OBJ [NAM])" (id error-message-digest))))) (section 4 "message-digest-algorithm" (def (sig (procedure "(message-digest-algorithm DIGEST) => message-digest-primitive" (id message-digest-algorithm))) (p "Returns the message digest algorithm used by this " (tt "DIGEST") ".") (p "Mostly for use when developing an update operation.") (p "Do not mess with this object!"))) (section 4 "finalize-message-digest" (def (sig (procedure "(finalize-message-digest DIGEST [RESULT-FORM]) => <result>" (id finalize-message-digest))) (p "Finalize the " (tt "DIGEST") " and return the " (tt "<result>") " in the " (tt "RESULT-FORM") ".") (p (tt "RESULT-FORM") " default is " (tt "'hex") ".") (p "Finalize here means the finalization phase is completed. The " (tt "DIGEST") " is not in a useful state."))) (section 4 "message-digest-update-object" (def (sig (procedure "(message-digest-update-object DIGEST SOURCE)" (id message-digest-update-object))) (p "Update the " (tt "DIGEST") " with some " (tt "SOURCE") "."))) (section 4 "message-digest-update-bytevector" (def (sig (procedure "(message-digest-update-bytevector DIGEST BYTEVECTOR [LENGTH])" (id message-digest-update-bytevector))) (p "Update the " (tt "DIGEST") " with the " (tt "BYTEVECTOR") ", a " (tt "blob") " or " (tt "string") ".") (p "The " (tt "LENGTH") " is the byte count. Default is the size in bytes of the " (tt "BYTEVECTOR") ".") (p "Using some other " (i "vector-like") " object for the " (tt "BYTEVECTOR") " than the documented is performed at your own risk."))) (section 4 "message-digest-update-blob" (def (sig (procedure "(message-digest-update-blob DIGEST BLOB)" (id message-digest-update-blob))) (p "Update the " (tt "DIGEST") " with a " (tt "BLOB") "."))) (section 4 "message-digest-update-string" (def (sig (procedure "(message-digest-update-string DIGEST STRING)" (id message-digest-update-string))) (p "Update the " (tt "DIGEST") " with a " (tt "STRING") "."))) (section 4 "message-digest-update-substring" (def (sig (procedure "(message-digest-update-substring DIGEST STRING START END)" (id message-digest-update-substring))) (p "Update the " (tt "DIGEST") " with a substring " (tt "STRING START END") "."))) (section 4 "message-digest-update-u8vector" (def (sig (procedure "(message-digest-update-u8vector DIGEST U8VECTOR)" (id message-digest-update-u8vector))) (p "Update the " (tt "DIGEST") " with a " (tt "U8VECTOR") "."))) (section 4 "message-digest-update-subu8vector" (def (sig (procedure "(message-digest-update-subu8vector DIGEST U8VECTOR START END)" (id message-digest-update-subu8vector))) (p "Update the " (tt "DIGEST") " with a subvector " (tt "U8VECTOR START END") "."))) (section 4 "message-digest-update-char-u8" (def (sig (procedure "(message-digest-update-char-u8 DIGEST CHAR)" (id message-digest-update-char-u8))) (p "Update the " (tt "DIGEST") " with a character " (tt "CHAR") "."))) (section 4 "message-digest-update-char" (def (sig (procedure "(message-digest-update-char DIGEST CHAR [ENDIAN])" (id message-digest-update-char))) (p "Update the " (tt "DIGEST") " with a the character " (tt "CHAR") " 32-bit integer value treated as " (tt "ENDIAN") ".") (p (tt "ENDIAN") " default is " (tt "(machine-byte-order)") "."))) (section 4 "message-digest-update-char-be" (def (sig (procedure "(message-digest-update-char-be DIGEST CHAR)" (id message-digest-update-char-be))) (p "Update the " (tt "DIGEST") " with a the character " (tt "CHAR") " 32-bit integer value treated as big-endian."))) (section 4 "message-digest-update-char-le" (def (sig (procedure "(message-digest-update-char-le DIGEST CHAR)" (id message-digest-update-char-le))) (p "Update the " (tt "DIGEST") " with a the character " (tt "CHAR") " 32-bit integer value treated as little-endian."))) (section 4 "message-digest-update-u8" (def (sig (procedure "(message-digest-update-u8 DIGEST U8)" (id message-digest-update-u8))) (p "Update the " (tt "DIGEST") " with an 8-bit integer " (tt "U8") "."))) (section 4 "message-digest-update-u16" (def (sig (procedure "(message-digest-update-u16 DIGEST U16 [ENDIAN])" (id message-digest-update-u16))) (p "Update the " (tt "DIGEST") " with a 16-bit integer " (tt "U16") " treated as " (tt "ENDIAN") ".") (p (tt "ENDIAN") " default is " (tt "(machine-byte-order)") "."))) (section 4 "message-digest-update-u16-be" (def (sig (procedure "(message-digest-update-u16-be DIGEST U16)" (id message-digest-update-u16-be))) (p "Update the " (tt "DIGEST") " with a 16-bit integer " (tt "U16") " treated as big-endian."))) (section 4 "message-digest-update-u16-le" (def (sig (procedure "(message-digest-update-u16-le DIGEST U16)" (id message-digest-update-u16-le))) (p "Update the " (tt "DIGEST") " with a 16-bit integer " (tt "U16") " treated as little-endian."))) (section 4 "message-digest-update-u32" (def (sig (procedure "(message-digest-update-u32 DIGEST U32 [ENDIAN])" (id message-digest-update-u32))) (p "Update the " (tt "DIGEST") " with a 32-bit integer " (tt "U32") " treated as " (tt "ENDIAN") ".") (p (tt "ENDIAN") " default is " (tt "(machine-byte-order)") "."))) (section 4 "message-digest-update-u32-be" (def (sig (procedure "(message-digest-update-u32-be DIGEST U32)" (id message-digest-update-u32-be))) (p "Update the " (tt "DIGEST") " with a 32-bit integer " (tt "U32") " treated as big-endian."))) (section 4 "message-digest-update-u32-le" (def (sig (procedure "(message-digest-update-u32-le DIGEST U32)" (id message-digest-update-u32-le))) (p "Update the " (tt "DIGEST") " with a 32-bit integer " (tt "U32") " treated as little-endian."))) (section 4 "message-digest-update-u64" (def (sig (procedure "(message-digest-update-u64 DIGEST U64 [ENDIAN])" (id message-digest-update-u64))) (p "Update the " (tt "DIGEST") " with a 64-bit integer " (tt "U64") " treated as " (tt "ENDIAN") ".") (p (tt "ENDIAN") " default is " (tt "(machine-byte-order)") "."))) (section 4 "message-digest-update-u64-be" (def (sig (procedure "(message-digest-update-u64-be DIGEST U64)" (id message-digest-update-u64-be))) (p "Update the " (tt "DIGEST") " with a 64-bit integer " (tt "U64") " treated as big-endian."))) (section 4 "message-digest-update-u64-le" (def (sig (procedure "(message-digest-update-u64-le DIGEST U64)" (id message-digest-update-u64-le))) (p "Update the " (tt "DIGEST") " with a 64-bit integer " (tt "U64") " treated as little-endian."))) (section 4 "message-digest-update-procedure" (def (sig (procedure "(message-digest-update-procedure DIGEST THUNK)" (id message-digest-update-procedure))) (p "Update the " (tt "DIGEST") " with a " (tt "THUNK") " until it returns " (tt "#f") ".") (p (tt "THUNK") " is a " (tt "(procedure () <byte-source>)") "."))) (section 4 "message-digest-update-port" (def (sig (procedure "(message-digest-update-port DIGEST INPUT-PORT)" (id message-digest-update-port))) (p "Update the " (tt "DIGEST") " with " (tt "<byte-source>") " from an " (tt "INPUT-PORT") " until " (tt "#!eof") " encountered.") (p "Uses the " (tt "message-digest-chunk-read-maker") " to create a reader for the port."))) (section 4 "message-digest-update-file" (def (sig (procedure "(message-digest-update-file DIGEST FILENAME)" (id message-digest-update-file))) (p "Update the " (tt "DIGEST") " with the contents of file " (tt "FILENAME") "."))) (section 4 "message-digest-object" (def (sig (procedure "(message-digest-object PRIMITIVE SOURCE [RESULT-FORM]) => <result>" (id message-digest-object))) (p "Returns the " (tt "RESULT") " for the digest algorithm " (tt "PRIMITIVE") " applied to " (tt "SOURCE") " in the " (tt "RESULT-FORM") ".") (p (tt "RESULT-FORM") " default is " (tt "'hex") ".") (p "Performs all three phases."))) (section 4 "message-digest-string" (def (sig (procedure "(message-digest-string PRIMITIVE STRING [RESULT-FORM]) => <result>" (id message-digest-string))) (p "Returns the " (tt "RESULT") " for the digest algorithm " (tt "PRIMITIVE") " applied to " (tt "STRING") " in the " (tt "RESULT-FORM") ".") (p (tt "RESULT-FORM") " default is " (tt "'hex") ".") (p "Performs all three phases."))) (section 4 "message-digest-blob" (def (sig (procedure "(message-digest-blob PRIMITIVE BLOB [RESULT-FORM]) => <result>" (id message-digest-blob))) (p "Returns the " (tt "<result>") " for the digest algorithm " (tt "PRIMITIVE") " applied to " (tt "BLOB") " in the " (tt "RESULT-FORM") ".") (p (tt "RESULT-FORM") " default is " (tt "'hex") ".") (p "Performs all three phases."))) (section 4 "message-digest-u8vector" (def (sig (procedure "(message-digest-u8vector PRIMITIVE U8VECTOR [RESULT-FORM]) => <result>" (id message-digest-u8vector))) (p "Returns the " (tt "<result>") " for the digest algorithm " (tt "PRIMITIVE") " applied to " (tt "U8VECTOR") " in the " (tt "RESULT-FORM") ".") (p (tt "RESULT-FORM") " default is " (tt "'hex") ".") (p "Performs all three phases."))) (section 4 "message-digest-file" (def (sig (procedure "(message-digest-file PRIMITIVE FILENAME [RESULT-FORM]) => <result>" (id message-digest-file))) (p "Returns the " (tt "<result>") " for the digest algorithm " (tt "PRIMITIVE") " applied to the file " (tt "FILENAME") " in the " (tt "RESULT-FORM") ".") (p (tt "RESULT-FORM") " default is " (tt "'hex") ".") (p "Performs all three phases.")))) (section 3 "Utility Procedures" (section 4 "Byte Packing" (p (tt "BUFFER") " is either a " (tt "symbol") " in " (tt "{string blob u8vector") "}, a " (tt "string") ", a " (tt "blob") ", or a " (tt "u8vector}. The {{BUFFER") " is interpreted as:") (dl (dt (tt "symbol")) (dd "Construct a new instance of the specified type with necessary space.") (dt (tt "...")) (dd "Use the supplied object, ensuring enough space available.")) (p "The packing routines are either functional or side-effecting, depending on the supplied " (tt "BUFFER") " object. The default is " (tt "'string") ".") (p (tt "START") " is the byte-offset (index) in the " (tt "BUFFER") " to begin packing. The default is " (tt "0") ".") (p (tt "ORDER") " is a " (tt "symbol") " in " (tt "{big-endian little-endian") "}. The default is " (tt "(machine-byte-order)") ".") (p (tt "SIZE") " is an " (tt "integer") " in " (tt "{1 2 4 8") "}. The default is " (tt "4") ".") (p (tt "<byte-buffer>") " is either a " (tt "string") ", a " (tt "blob") ", or a " (tt "u8vector") ".") (section 5 "pack-u8" (def (sig (procedure "(pack-u8 N (#:buffer BUFFER) (#:start START))) => <byte-buffer>" (id pack-u8))) (p "Returns the " (tt "BUFFER") " with the low-order 8 bits of the integer " (tt "N") " packed at index " (tt "START") ". " (tt "SIZE") " is assumed " (tt "1") "."))) (section 5 "pack-u16" (def (sig (procedure "(pack-u16 N (#:buffer BUFFER) (#:start START) (#:order ORDER))) => <byte-buffer>" (id pack-u16))) (p "Returns the " (tt "BUFFER") " with the low-order 16 bits of the integer " (tt "N") " packed at index " (tt "START") " in the byte " (tt "ORDER") ". " (tt "SIZE") " is assumed " (tt "2") "."))) (section 5 "pack-u32" (def (sig (procedure "(pack-u32 N (#:buffer BUFFER) (#:start START) (#:order ORDER))) => <byte-buffer>" (id pack-u32))) (p "Returns the " (tt "BUFFER") " with the low-order 32 bits of the integer " (tt "N") " packed at index " (tt "START") " in the byte " (tt "ORDER") ". " (tt "SIZE") " is assumed " (tt "4") "."))) (section 5 "pack-u64" (def (sig (procedure "(pack-u64 N (#:buffer BUFFER) (#:start START) (#:order ORDER))) => <byte-buffer>" (id pack-u64))) (p "Returns the " (tt "BUFFER") " with the low-order 64 bits of the integer " (tt "N") " packed at index " (tt "START") " in the byte " (tt "ORDER") ". " (tt "SIZE") " is assumed " (tt "8") "."))) (section 5 "pack-integer" (def (sig (procedure "(pack-integer N (#:buffer BUFFER) (#:start START) (#:order ORDER) (#:size SIZE))) => <byte-buffer>" (id pack-integer))) (p "Returns the " (tt "BUFFER") " with the low-order " (tt "SIZE") " bits of the integer " (tt "N") " packed at index " (tt "START") " in the byte " (tt "ORDER") "."))))) (section 3 "Old API" (section 4 "make-binary-message-digest (DEPRECATED)" (def (sig (procedure "(make-binary-message-digest SOURCE CONTEXT-INFO DIGEST-LENGTH INIT UPDATE FINAL [CALLER]) => string" (id make-binary-message-digest))) (p "Returns the message-digest for " (tt "SOURCE") " as a string of bytes.") (p (tt "SOURCE") " is a Scheme-object.") (p "The meaning of the other fields are as for " (tt "make-message-digest-primitive") ".") (p "The optional " (tt "CALLER") " is for identification.") (p "See " (tt "message-digest-chunk-size") " to set the number of bytes read from a port.") (p "See " (tt "message-digest-chunk-read-maker") " to set the chunk reader procedure creator.") (p "See " (tt "message-digest-chunk-converter") " to set the chunk representation translation procedure."))) (section 4 "make-message-digest (DEPRECATED)" (def (sig (procedure "(make-message-digest SOURCE CONTEXT-INFO DIGEST-LENGTH INIT UPDATE FINAL [CALLER]) => string" (id make-message-digest))) (p "Exactly as " (tt "make-binary-message-digest") " but returns the message-digest for " (tt "SOURCE") " using " (tt "byte-string->hexadecimal") "."))) (section 4 "message-digest-primitive-apply (DEPRECATED)" (def (sig (procedure "(message-digest-primitive-apply PRIMITIVE SOURCE [CALLER])" (id message-digest-primitive-apply))) (p "Returns a binary-message-digest of " (tt "SOURCE") " using " (tt "PRIMITIVE") ".")))) (section 3 "Message Digest Port" (p "Provides a " (tt "port") " abstraction for a " (tt "message-digest-primitive") ".") (section 4 "Usage" (highlight scheme "(use message-digest-port)")) (section 4 "Common Argument Definitions" (p (tt "PORT") " is a " (tt "digest-output-port") ".")) (section 4 "digest-output-port" (def (sig (procedure "(digest-output-port? OBJ) => boolean" (id digest-output-port?)) (procedure "(check-digest-output-port LOC OBJ [NAM])" (id check-digest-output-port)) (procedure "(error-digest-output-port LOC OBJ [NAM])" (id error-digest-output-port)) (procedure "(digest-output-port-name PORT) => string" (id digest-output-port-name))))) (section 4 "open-output-digest" (def (sig (procedure "(open-output-digest PRIMITIVE) => digest-output-port" (id open-output-digest))) (p "Returns a message digest output port for the supplied algorithm " (tt "PRIMITIVE") ".") (p "The initialization phase."))) (section 4 "close-output-digest" (def (sig (procedure "(close-output-digest PORT [RESULT-FORM]) => <result>" (id close-output-digest))) (p "Closes the " (tt "PORT") " and returns the " (tt "<result>") " in the " (tt "RESULT-FORM") ".") (p (tt "RESULT-FORM") " default is " (tt "'hex") ".") (p "The finalization phase."))) (section 4 "get-output-digest-string" (def (sig (procedure "(get-output-digest-string PORT) => string" (id get-output-digest-string)) (procedure "(get-output-digest-byte-string PORT) => string" (id get-output-digest-byte-string))) (p "Closes the " (tt "PORT") " and returns the result " (tt "string") ".") (p "The finalization phase."))) (section 4 "get-output-digest-hexstring" (def (sig (procedure "(get-output-digest-hexstring PORT) => string" (id get-output-digest-hexstring))) (p "Closes the " (tt "PORT") " and returns the result as a " (tt "string") " of hexadecimal digits.") (p "The finalization phase."))) (section 4 "get-output-digest-blob" (def (sig (procedure "(get-output-digest-blob PORT) => blob" (id get-output-digest-blob))) (p "Closes the " (tt "PORT") " and returns the result " (tt "blob") ".") (p "The finalization phase."))) (section 4 "get-output-digest-u8vector" (def (sig (procedure "(get-output-digest-u8vector PORT) => u8vector" (id get-output-digest-u8vector))) (p "Closes the " (tt "PORT") " and returns the result " (tt "u8vector") ".") (p "The finalization phase."))) (section 4 "call-with-output-digest" (def (sig (procedure "(call-with-output-digest PRIMITIVE PROCEDURE/1 [RESULT-FORM]) => <result>" (id call-with-output-digest))) (p "Invoke the procedure " (tt "PROCEDURE PORT") " with " (tt "digest-output-port") " and return " (tt "<result>") " in the " (tt "RESULT-FORM") ".") (p (tt "RESULT-FORM") " default is " (tt "'hex") ".") (p "Performs all three phases."))) (section 4 "with-output-to-digest" (def (sig (procedure "(with-output-to-digest PRIMITIVE THUNK [RESULT-FORM]) => <result>" (id with-output-to-digest))) (p "Invoke the procedure " (tt "THUNK") " with " (tt "(current-output-port)") " bound to a " (tt "digest-output-port") " and return " (tt "<result>") " in the " (tt "RESULT-FORM") ".") (p (tt "RESULT-FORM") " default is " (tt "'hex") ".") (p "Performs all three phases."))))) (section 2 "Usage" (highlight scheme "(use message-digest)")) (section 2 "Examples" (p "Uses the message-digest port abstraction to get an MD5 digest of a string:") (highlight scheme "(use message-digest-port)\n(use md5)    ; Or sha1, or sha2, ...\n\n(call-with-output-digest (md5-primitive) (cut display \"foo\" <>))\n;=> \"acbd18db4cc2f85cedef654fccc4a4d8\"\n\n(use message-digest)\n\n; Uses a string as the buffer so the packed buffer is interpreted properly.\n; A blob or u8vector would be converted to a string by the port i/o machinary\n; with loose of information; like all of it.\n(call-with-output-digest (md5-primitive) (pack-u32 #xabcdef012345 #:order 'big-endian))\n;=> \"\"")) (section 2 "Notes" (ul (li "If someone needs to construct a " (tt "message-digest") " phase procedure that cannot be built upon the existing public API please contact the maintainer. There are some routines that can be exported to aid in such a project.")) (p "It must be pointed out, though, that the message-digest port API is implemented using only the existing public API.") (ul (li "Should the default message-digest result-form be held by a " (i "\"parameter\"") " object?"))) (section 2 "Requirements" (p (int-link "miscmacros") " " (int-link "check-errors"))) (section 2 "Bugs and Limitations" (ul (li "The " (int-link "Utility Procedures") " do not belong here.") (li "Uses a " (tt "string") " for the message-digest " (tt "<result>") " in the finalization phase. Should use a " (tt "blob") " since the " (tt "<result>") " is actually a " (tt "bytevector") ".") (li "The chunk-converter and port-reader interface is clumsy.") (li "Since Chicken does not really have a binary port concept the " (tt "digest-output-port") " will only accumulate strings. Should a more nuanced set of sources be necessary use the " (int-link "Byte Packing") " API above.")) (p "For example, writing a 16-bit integer is actually writing the result of " (tt "number->string") " and not the 16-bit value itself! To get this effect the value must first be packed into a " (tt "string") " and then written.") (p "However, the " (tt "extras#write-byte") " routine should function as expected with a " (tt "digest-output-port") ".")) (section 2 "Author" (p (int-link "/users/kon-lovett" "Kon Lovett"))) (section 2 "Version history" (dl (dt "2.3.2") (dd "Deprecated " (tt "byte-string->hexadecimal") ". Deprecated " (tt "string->hex") ", use " (int-link "string-utils") " " (tt "string-hexadecimal#string->hex") ". Fix for the default " (tt "message-digest-chunk-read-maker") ", blob was always chunk-size.") (dt "2.3.1") (dt "2.3.0") (dd "Added " (tt "message-digest-update-char-u8") ", " (tt "message-digest-update-char-be") ", and " (tt "message-digest-update-char-le") ". " (tt "message-digest-update-char") " now treats the actual bit-width of char correctly.") (dt "2.2.0") (dd "Added " (int-link "Byte Packing") " API. Downgraded " (tt "message-digest-chunk-read-maker") ", " (tt "message-digest-chunk-size") " & " (tt "message-digest-chunk-converter") " from " (tt "parameter") ".") (dt "2.1.1") (dd "Bug fix for hexstring: must use lowercase.") (dt "2.1.0") (dd "Added message digest \"phase\" and port APIs. Deprecated old API.") (dt "2.0.1") (dd "Bug fix for " (tt "(message-digest-chunk-converter)") " use by " (tt "make-binary-message-digest") ".") (dt "2.0.0") (dd "Release for Chicken 4 [From a diff provided by Christian Kellermann]"))) (section 2 "License" (pre " Copyright (C) 2006-2010 Kon Lovett.  All rights reserved.") (pre " Permission is hereby granted, free of charge, to any person obtaining a\n copy of this software and associated documentation files (the Software),\n to deal in the Software without restriction, including without limitation\n the rights to use, copy, modify, merge, publish, distribute, sublicense,\n and/or sell copies of the Software, and to permit persons to whom the\n Software is furnished to do so, subject to the following conditions:") (pre " The above copyright notice and this permission notice shall be included\n in all copies or substantial portions of the Software.") (pre " THE SOFTWARE IS PROVIDED ASIS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n OTHER DEALINGS IN THE SOFTWARE.")))