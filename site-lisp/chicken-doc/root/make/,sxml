((tags "egg") (section 2 "make" (toc) (section 3 "Description" (p "A control structure that provides basic " (tt "makefile") " operations in Scheme.")) (section 3 "Author" (p "This implementation has been taken from " (link "http://www.plt-scheme.org" "PLT") " and minimally modified by " (int-link "/users/felix winkelmann" "felix winkelmann") " to work with Chicken.")) (section 3 "Requirements" (p "None")) (section 3 "Documentation" (p "This library provides a Scheme version of the standard unix " (tt "make") " utility. Its syntax is intended to simulate regular unix make in Scheme.") (p "The idea is to explain how to generate some project you have from a collection of source files that go through several stages of processing.") (p "For example, let's say that you are writing soem project that has three input files (that you create and maintain) called " (tt "a.input") ", " (tt "b.input") ", and " (tt "c.input") ". Further, there are two stages of processing -- first you run a particular tool " (tt "make-output") " that takes an input file and produces and output file, and second you combine the input files into a single file using " (tt "output") ". Using " (tt "make") ", you might write this:") (pre " a.output: a.input\n \tmake-output a.input a.output\n b.output: b.input\n \tmake-output b.input b.output\n c.output: c.input\n \tmake-output c.input c.output \n total: a.output b.output c.output\n \tcombine a.output b.output c.output ") (p "Once you've put those above lines in a file called " (tt "Makefile") ", you can issue the command:") (pre " make total ") (p "that builds your entire project. The Makefile consists of several lines that tell `make' how to create each piece. The first two lines say that a.output depends on a.input and the command for making " (tt "a.output") " from " (tt "a.input") " is") (pre " make-output a.input a.ouput") (p "The point of this exercise is that the " (tt "make") " utility looks at the file creation dates of the various files and only re-builds what is necessary.  Make is based on building things with shell programs. If, on the other hand, you want to build similar things with various Scheme programs, you can use the make collection.") (p "Here's the equivalent Scheme program:") (highlight scheme "(require-for-syntax 'make)\n\n(define (make-output in out)\n   ...)\n\n(define (combine-total . args)\n  ...)\n\n(make\n  ((\"a.output\" (\"a.input\") (make-output \"a.output\" \"a.input\"))\n   (\"b.output\" (\"b.input\") (make-output \"b.output\" \"b.input\"))\n   (\"c.output\" (\"c.input\") (make-output \"c.output\" \"c.input\"))\n   (\"total\" (\"a.output\" \"b.output\" \"c.output\")\n            (combine-total \"a.output\" \"b.output\" \"c.output\")) )\n  \"total\")") (p "If you were to fill in the ellipses above with calls to " (tt "system") ", you'd have the exact same thing as the original Makefile. In addition, if you use " (tt "make/proc") ", you can abstract over the various make lines (for example, the " (tt "a.output") ", " (tt "b.output") ", and " (tt "c.output") " lines are very similar and it would be good to write a program to generate those lines).") (pre "\t\t      ") (def (sig (syntax "(make ((TARGET (DEPEND ...) COMMAND ...) ...) ARGV)" (id make))) (p "Expands to") (pre " (make/proc\n   (list (list TARGET (list DEPEND ...) (lambda () COMMAND ...)) ...)\n   ARGV)")) (def (sig (procedure "(make/proc SPEC ARGV)" (id make/proc))) (p "Performs a make according to " (tt "SPEC") " and using " (tt "ARGV") " selecting one or more targets.  " (tt "ARGV") " can either be a string or a vector or list of strings.") (p (tt "SPEC") " is a " (tt "MAKE-SPEC") ":") (pre " MAKE-SPEC = (list-of MAKE-LINE)\n MAKE-LINE = (list TARGET (list-of DEPEND-STRING) COMMAND-THUNK)\n TARGET = (union string (list-of string)) ; either a string or a list of strings\n DEPEND-STRING = string\n COMMAND-THUNK = (-> void)") (p "To make a target, " (tt "MAKE/PROC") " is first called on each of the target's dependencies. If a target is not in the spec and it exists, then the target is considered made. If a target is older than any of its dependencies, the corresponding " (tt "COMMAND-THUNK") " is invoked. The " (tt "COMMAND-THUNK") " is optional; a " (tt "MAKE-LINE") " without a " (tt "COMMAND-THUNK") " is useful as a target for making a number of other targets (the dependencies).")) (def (sig (parameter "make-print-checking" (id make-print-checking))) (p "If " (tt "#f") ", make only prints when it is making a target. Otherwise, it prints when it is checking the dependancies of a target. Defaultly " (tt "#f") ".")) (def (sig (parameter "make-print-dep-no-line" (id make-print-dep-no-line))) (p "If " (tt "#f") ", make only prints " (tt "\"checking...\"") "  lines for dependancies that have a corresponding make line.  Defaultly " (tt "#f") ".")) (def (sig (parameter "make-print-reasons" (id make-print-reasons))) (p "If " (tt "#t") ", make prints the reason for each dependancy that fires. Defaultly " (tt "#f") "."))) (section 3 "Changelog" (ul (li "1.6 added missing exports for parameters") (li "1.5 exported " (tt "make/proc")) (li "1.4 ported to chicken 4") (li "1.3 Accepts lists in addition to vectors for target list") (li "1.2 Adapted to new setup scheme") (li "1.1 Removed unused reference to " (tt "directory-exists?") ". The file " (tt "make/syntax.scm") " wasn't needed.") (li "1.0 Initial release"))) (section 3 "License" (pre " PLT Software\n Copyright (c) 1995-2002 PLT\n \n PLT software is distributed under the GNU Lesser General Public\n License (LGPL). "))))