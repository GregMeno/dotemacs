(index ("skip+" 0) ("split-at+" 408) ("section" 1457) ("length=0?" 2396) ("length=1?" 2514) ("length>1?" 2606) ("length=2?" 2711) ("ensure-list" 2803) ("not-null?" 2957) ("alist-delete-first" 3131) ("alist-delete-first!" 3284) ("assoc-def" 3432) ("assv-def" 3578) ("assq-def" 3695) ("alist-inverse-ref" 3812) ("alist-delete/count" 4145) ("alist-delete!/count" 4983) ("unzip-alist" 5244) ("zip-alist" 5400) ("plist->alist" 5779) ("alist->plist" 5913) ("shift!" 6044) ("unshift!" 6398) ("shift!/set" 6690) ("andmap" 7008) ("ormap" 7239))
(def (sig (procedure "(skip+ LIST COUNT) => (list integer)" (id skip+))) (p "Returns 2 values, the " (tt "COUNT") " " (tt "pair") " from " (tt "LIST") ", and the remaining count. The remaining count will be non-zero when end-of-list reached.") (p (tt "COUNT") " is a " (tt "natural fixnum") ".") (highlight scheme "(skip+ '(1 2) 3) ;=> '() 1\n(skip+ '(1 2 3) 3) ;=> '() 0\n(skip+ '(1 2 3 4) 3) ;=> '(4) 0"))
(def (sig (procedure "(split-at+ LIST COUNT [PADS]) => (list list)" (id split-at+))) (p "Returns 2 values, the leading " (tt "COUNT") " elements from " (tt "LIST") " as a new " (tt "list") ", and the remaining elements from " (tt "LIST") ". Should there be fewer than " (tt "COUNT") " elements available padding is attempted.") (p "Padding is performed by trying to complete the remaining elements from the " (tt "list") " " (tt "PADS") ".") (p (tt "COUNT") " is a " (tt "natural fixnum") ". " (tt "PADS") " is a " (tt "list") " or " (tt "#f") ". Default is " (tt "'()") ".") (p "A negative " (tt "COUNT") " is treated as " (tt "0") ".") (p "When " (tt "PADS") " is " (tt "#f") " then an incomplete leading sublist is treated as " (tt "'()") ". The very odd treatment of " (tt "PADS") " = " (tt "#f") " can safely be ignored since this is not the default behavior.") (highlight scheme "(split-at+ '(1 2 3) 3) ;=> '(1 2 3) '()\n(split-at+ '(1 2 3) 2) ;=> '(1 2) '(3)\n(split-at+ '(1 2 3) 4) ;=> '(1 2 3) '()\n(split-at+ '(1 2 3) 4 #f) ;=> '() '()"))
(def (sig (procedure "(section LIST SIZE [[STEP] PADS]) => list" (id section))) (p "Returns a " (tt "list") " of " (tt "list") ", built by taking " (tt "SIZE") " elements from " (tt "LIST") " every " (tt "STEP") " elements. When too few elements remain to complete a " (i "section") " padding is performed.") (p (tt "SIZE") " is a " (tt "positive fixnum") ". " (tt "STEP") " is a " (tt "positive fixnum") ". Default is " (tt "SIZE") ". " (tt "PADS") " is a " (tt "list") " or " (tt "#f") ". Default is " (tt "'()") ".") (p "When " (tt "PADS") " is " (tt "#f") " then any incomplete trailing section is dropped. The very odd treatment of " (tt "PADS") " = " (tt "#f") " can safely be ignored since this is not the default behavior.") (highlight scheme "(section '(1 2) 3 3 '(3 4 5)) ;=> ((1 2 3))\n(section '(1 2 3) 2 1 '(3 4 5)) ;=> ((1 2) (2 3))\n(section '(1 2 3) 2 2 '(4 5)) ;=> ((1 2) (3 4))\n(section '(1 2 3) 2 2) ;=> ((1 2) (3))"))
(def (sig (syntax "(length=0? LIST) => boolean" (id length=0?))) (p "List of length zero? (Just " (tt "null?") ".)"))
(def (sig (syntax "(length=1? LIST) => boolean" (id length=1?))) (p "List of length one?"))
(def (sig (syntax "(length>1? LIST) => boolean" (id length>1?))) (p "List of length greater than one?"))
(def (sig (syntax "(length=2? LIST) => boolean" (id length=2?))) (p "List of length two?"))
(def (sig (syntax "(ensure-list OBJECT) => list" (id ensure-list))) (p "Returns a list, either the list " (tt "OBJECT") " or " (tt "(list OBJECT)") "."))
(def (sig (syntax "(not-null? LIST) => (or list boolean)" (id not-null?))) (p "Returns " (tt "#f") " if the given " (tt "LIST") " is empty, and " (tt "LIST") " otherwise."))
(def (sig (syntax "(alist-delete-first KEY ALIST [TEST?])" (id alist-delete-first))) (p "Returns " (tt "(alist-delete/count KEY ALIST [TEST?] 1)") "."))
(def (sig (syntax "(alist-delete-first! KEY ALIST [TEST?])" (id alist-delete-first!))) (p "Destructive version of " (tt "alist-delete-first") "."))
(def (sig (syntax "(assoc-def KEY ALIST [TEST] [NOT-FOUND])" (id assoc-def))) (p "The assoc procedure with an optional test and default value."))
(def (sig (syntax "(assv-def KEY ALIST [NOT-FOUND])" (id assv-def))) (p "The assv procedure with a default value."))
(def (sig (syntax "(assq-def KEY ALIST [NOT-FOUND])" (id assq-def))) (p "The assq procedure with a default value."))
(def (sig (procedure "(alist-inverse-ref VALUE ALIST [TEST? [NOT-FOUND]])" (id alist-inverse-ref))) (p "Returns the first key associated with " (tt "VALUE") " in the " (tt "ALIST") " using the " (tt "TEST?") " predicate, else " (tt "NOT-FOUND") ".") (p (tt "TEST?") " is " (tt "eqv?") " and " (tt "NOT-FOUND") " is " (tt "#f") "."))
(def (sig (procedure "(alist-delete/count KEY ALIST [TEST? [COUNT]])" (id alist-delete/count))) (p "Deletes the first " (tt "COUNT") " associations from alist " (tt "ALIST") " with the given key " (tt "KEY") ", using key-comparison procedure " (tt "TEST?") ". The dynamic order in which the various applications of equality are made is from the alist head to the tail.") (p "Returns a new alist. The alist is not disordered - elements that appear in the result alist occur in the same order as they occur in the argument alist.") (p "The equality procedure is used to compare the element keys, " (tt "key[i: 0 <= i < (length ALIST)") "', of the alist's entries to the key parameter in this way: " (tt "(TEST? KEY key[i])") ".") (p (tt "COUNT") " defaults to essentially, infinity, and " (tt "EQUALITY?") " defaults to " (tt "eqv?") "."))
(def (sig (procedure "(alist-delete!/count KEY ALIST [TEST? [COUNT]])" (id alist-delete!/count))) (p "Destructive version of " (tt "alist-delete/count") ".") (p (tt "alist-delete-first") " and " (tt "alist-delete-first!") " are also available as procedures."))
(def (sig (procedure "(unzip-alist ALIST)" (id unzip-alist))) (p "Returns 2 values, a list of the keys & a list of the values from the " (tt "ALIST") "."))
(def (sig (procedure "(zip-alist KEYS VALUES)" (id zip-alist))) (p "Returns an association list with elements from the corresponding items of " (tt "KEYS") " and " (tt "VALUES") ".") (p "Error signaling versions of the standard association lookup functions. When the " (tt "KEY") " is not found and a " (tt "NOT-FOUND") " value is not supplied an " (tt "error") " is invoked."))
(def (sig (procedure "(plist->alist PLIST) => list" (id plist->alist))) (p "Returns the association-list form of " (tt "PLIST") "."))
(def (sig (procedure "(alist->plist ALIST) => list" (id alist->plist))) (p "Returns the property-list form of " (tt "ALIST") "."))
(def (sig (procedure "(shift! LIST [DEFAULT]) => *" (id shift!))) (p "Retrns the first element of " (tt "LIST") ", or " (tt "DEFAULT") " when " (tt "LIST") " is null.") (p "The " (tt "car") " and " (tt "cdr") " of the first " (tt "pair") " of " (tt "LIST") " are set to the corresponding element of the second " (tt "pair") ".") (p "Like a stack-pop."))
(def (sig (procedure "(unshift! OBJECT LIST) => list" (id unshift!))) (p "The " (tt "car") " of the first " (tt "pair") " of " (tt "LIST") " is set to " (tt "OBJECT") ". The " (tt "cdr") " of the first " (tt "pair") " of " (tt "LIST") " is set to " (tt "LIST") ".") (p "Like a stack-push."))
(def (sig (syntax "(shift!/set VARIABLE [WHEN-EMPTY])" (id shift!/set))) (p "Like " (tt "shift!") " but assigns the " (tt "VARIABLE") " " (tt "'()") " after shifting from a list of length 1.") (p (tt "WHEN-EMPTY") ", which defaults to " (tt "#f") ", is returned when the list bound to " (tt "VARIABLE") " is empty."))
(def (sig (procedure "(andmap FUNC LIST...) => boolean" (id andmap))) (p "The arity of the function " (tt "FUNC") " must be the length of " (tt "LIST...") ".") (p (tt "(and (FUNC (car LIST)...) (andmap FUNC (cdr LIST)...))") "."))
(def (sig (procedure "(ormap FUNC LIST...) => boolean" (id ormap))) (p "The arity of the function " (tt "FUNC") " must be the length of " (tt "LIST...") ".") (p (tt "(or (FUNC (car LIST)...) (ormap FUNC (cdr LIST)...))") "."))
