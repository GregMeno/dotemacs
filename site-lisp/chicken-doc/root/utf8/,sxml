((tags "egg") (section 2 "utf8" (toc) (section 3 "Description" (p "Unicode support")) (section 3 "Author" (p "Alex Shinn")) (section 3 "Requirements" (p (int-link "iset"))) (section 3 "Download" (p (link "http://www.call-with-current-continuation.org/eggs/utf8.egg" "utf8.egg"))) (section 3 "Documentation" (p "To make your code Unicode aware, just do the following:") (pre " (require-extension utf8)") (p "then all core, extra and regex string operations will be Unicode aware. " (tt "string-length") " will return the number of codepoints, not the number of bytes, " (tt "string-ref") " will index by codepoints and return a char with an integer value up to 2^21, regular expressions will match single codepoints rather than bytes and understand Unicode character classes, etc.") (p "Strings are still native strings and may be passed to external libraries (either Scheme or foreign) perfectly safely. Libraries that do parsing invariably do so on ASCII character boundaries and are thus guaranteed to be compatible. Libraries that reference strings by index would need to be modified with a UTF-8 version. Currently all existing eggs are UTF-8 safe to my knowledge.") (p "This extension does not load into the toplevel, it is composed of modules. So it must be imported. Since exported identifiers match those of common Chicken imports the conflicts must be excluded. Use the examples below to stop such conflicts:") (pre " (import\n   (except scheme\n     string-length string-ref string-set! make-string string substring\n     string->list list->string string-fill! write-char read-char display)\n   (except chicken\n     reverse-list->string print print*)\n   (except data-structures\n     ->string conc string-chop string-split string-translate\n     substring=? substring-ci=? substring-index substring-index-ci)\n   (except extras\n     read-string write-string read-token)\n   (except regexp\n     grep regexp string-substitute string-substitute* string-split-fields\n     string-match string-match-positions string-match-offsets\n     string-search string-search-positions string-search-offsets) )") (p (i "Note") " that not all Chicken string routines have a utf8 version yet:") (dl (dt "Unit data-structures") (dd (tt "string-chomp") ", " (tt "string-compare3") ", " (tt "reverse-string-append")) (dt "Unit extras") (dd (tt "pretty-print") ", " (tt "printf") ", " (tt "sprintf") ", " (tt "fprintf") ", " (tt "read-line") ", " (tt "write-line") ", " (tt "read-lines")) (dt "Unit irregex") (dd "(already utf8 aware, unless disabled)") (dt "Unit utils") (dd (tt "scan-input-lines"))) (p "To use Unicode-aware SRFI-13 and SRFI-14 using UTF-8 semantics:") (pre " (require-extension utf8-srfi-13)\n (require-extension utf8-srfi-14)") (p "The SRFI-14 module provides an alternative to the standard Chicken SRFI-14. As a pure superset which handles arbitrary-sized characters it should be usable as a drop-in replacement. The only aspect related to UTF-8 is STRING->CHAR-SET assumes the string is UTF-8 encoded.") (section 4 "Unicode char-sets" (p "The default SRFI-14 char-sets are defined using ASCII-only characters, since this is both useful and lighter-weight. To obtain full Unicode char-set definitions, use the unicode-char-sets unit:") (pre " (require-extension unicode-char-sets)") (p "[Note this is the only extension in this egg with a " (tt "unicode-") " prefix, because the char-set handling only depends on individual characters and is independent of the character encoding used in strings.]") (p "The following char-sets are provided based on the Unicode properties:") (pre " char-set:alphabetic\n char-set:arabic\n char-set:armenian\n char-set:ascii-hex-digit\n char-set:bengali\n char-set:bidi-control\n char-set:bopomofo\n char-set:braille\n char-set:buhid\n char-set:canadian-aboriginal\n char-set:cherokee\n char-set:common\n char-set:cypriot\n char-set:cyrillic\n char-set:dash\n char-set:default-ignorable-code-point\n char-set:deprecated\n char-set:deseret\n char-set:devanagari\n char-set:diacritic\n char-set:ethiopic\n char-set:extender\n char-set:georgian\n char-set:gothic\n char-set:grapheme-base\n char-set:grapheme-extend\n char-set:grapheme-link\n char-set:greek\n char-set:gujarati\n char-set:gurmukhi\n char-set:han\n char-set:hangul\n char-set:hanunoo\n char-set:hebrew\n char-set:hex-digit\n char-set:hiragana\n char-set:hyphen\n char-set:id-continue\n char-set:id-start\n char-set:ideographic\n char-set:ids-binary-operator\n char-set:ids-trinary-operator\n char-set:inherited\n char-set:join-control\n char-set:kannada\n char-set:katakana\n char-set:katakana-or-hiragana\n char-set:khmer\n char-set:lao\n char-set:latin\n char-set:limbu\n char-set:linear-b\n char-set:logical-order-exception\n char-set:lowercase\n char-set:malayalam\n char-set:math\n char-set:mongolian\n char-set:myanmar\n char-set:noncharacter-code-point\n char-set:ogham\n char-set:old-italic\n char-set:oriya\n char-set:osmanya\n char-set:quotation-mark\n char-set:radical\n char-set:runic\n char-set:shavian\n char-set:sinhala\n char-set:soft-dotted\n char-set:sterm\n char-set:syriac\n char-set:tagalog\n char-set:tagbanwa\n char-set:tai-le\n char-set:tamil\n char-set:telugu\n char-set:terminal-punctuation\n char-set:thaana\n char-set:thai\n char-set:tibetan\n char-set:ugaritic\n char-set:unified-ideograph\n char-set:uppercase\n char-set:variation-selector\n char-set:white-space\n char-set:xid-continue\n char-set:xid-start\n char-set:yi")) (section 4 "Unicode case-mappings" (p "The SRFI-13 case-mapping procedures (" (tt "string-upcase") ", etc.) are defined using only ASCII case-mappings, since this is both useful and lighter-weight. To get full Unicode aware case-mappings, do") (pre " (require-extension utf8-case-map)") (p "which provides the upcase, downcase, and titlecase procedures. These take a first argument of either a string or port, and an optional second argument of locale (as a string), returning the appropriate locale-aware case-mapped string.")) (section 4 "Byte-strings" (p "Sometimes you may need access to the original string primitives so you can directly access bytes, such as if you were implementing your own regex library or text buffer and wanted optimal performance. For these cases we have renamed the original primitives by replacing " (tt "string") " with " (tt "byte-string") ". Thus " (tt "byte-string-length") " is the length in bytes, not characters, of the strings (the equivalent of Gauche's " (tt "string-size") "). " (tt "byte-string-set!") " can corrupt the UTF-8 encoding and should be used sparingly if at all.")) (section 4 "Low-level API" (p "Direct manipulation of the utf8 encoding is factored away in the " (tt "utf8-lolevel") " unit. This includes an abstract string-pointer API, and an analogous string-pointer implementation for ASCII strings in the string-pointer unit, however as the API is not fixed you use these at your own risk.")) (section 4 "Limitations" (p (tt "peek-char") " currently does not have Unicode semantics (i.e. it peeks only a single byte) to avoid problems with port buffering.") (p "char-sets are not interchangeable between the existing srfi-14 code and Unicode code (i.e. do not pass a Unicode char-set to an external library that directly uses the old srfi-14).") (p "Attempting to mutate literal strings will result in an error if the mutated size does not occupy the same number of bytes as the original. This is standards compliant, since the programmer is not supposed to attempt to mutate literal values, but it may be a little confusing since the error is inconsistent.")) (section 4 "Performance" (p (tt "string-length") ", " (tt "string-ref") " and " (tt "string-set!") " are all O(n) operations as opposed to the usual O(1) since UTF-8 is a variable width encoding. Use of these should be discouraged - it is much cleaner to use the high-level SRFI-13 procedures and string ports. For examples of how to do common idioms without these procedures look at any string-based code in Gauche.") (p "Furthermore, " (tt "string-set!") " and other procedures that modify strings in place may invoke gc if the mutated result does not fit within the same UTF-8 encoding size as the original string. If only mutating 7-bit ASCII strings (or only mutating within fixed encoding sizes such as Cyrillic->Cyrillic) then no gc will occur.") (p (tt "string?") ", " (tt "string=?") ", " (tt "string-append") ", all R5RS string comparisons, and " (tt "read-line") " are unmodified.") (p "Regular expression matching will be just as fast except in the case of Unicode character classes (which were not possible before anyway).") (p "All other procedures incur zero to minor overhead, but keep the same asymptotic performance.")) (section 4 "Discussion" (p "There are two ways to add Unicode string support to an existing language: redefine the strings themselves (i.e. add a new string type), or redefine the operations on the strings. The former causes a schism in your string libraries, dividing them between Unicode-aware and not, either doubling your library implementations or limiting them to one type or the other. You can't freely pass strings to other libraries without keeping track of their types and converting when needed. It becomes slow and unwieldy. C and Perl are the only language I know of who seriously tried this. In Perl the modules which worked with Unicode strings were minimal, frequent type conversions were needed, a general mess ensued, and Perl very quickly switched to the latter approach. In C as well, the libraries supporting wchar are still minimal, while most libraries still only support char.") (p "UTF-8 is ideal for the in-place sort of extension because it is backwards compatible with ASCII. Any ASCII (7-bit) byte found within a UTF-8 string is guaranteed to be that character, not part of a multibyte character, so parsing libraries that work on ASCII characters work unmodified. This includes most existing text formats and network protocols. The EUC (Extended Unix Code) encodings also have this feature so a similar module could be implemented allowing users to " (tt "(require 'euc-jp)") " for example and work in Japanese EUC rather than Unicode. Other encodings such as Shift_JIS satisfy the requirement that an ASCII string has the same meaning in the encoding, but multibyte characters in the encoding may include ASCII bytes, breaking the rule we need for safe ASCII parsing. A few encodings like UTF-16 and UTF-32 are completely incompatible. UTF-16 is primarily only used these days by Java, a victim of the unfortunate fact that at first UTF-16 was fixed with but is no longer with the advent of surrogate pairs. Note that even without this module you can write source code in Chicken in any ASCII compatible encoding like ISO-8859-* or UTF-8 and define symbols with that encoding (letting you replace lambda with syntax for a real greek lambda, for example).") (p "Other languages that use UTF-8 include Perl, Python, TCL. XML and increasingly more and more network standards are using UTF-8 by default, and major databases all support UTF-8. Libraries with UTF-8 support include Gtk, SDL, and freetype."))) (section 3 "Changelog" (dl (dt "3.3.0 ;") (dt "3.2.0 ;") (dt "3.1.0 ;") (dt "3.0.0 ; Hello"))) (section 3 "License" (p "Copyright (c) 2004-2008, Alex Shinn All rights reserved.") (p "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:") (pre " Redistributions of source code must retain the above copyright notice, this list of conditions and the following") (p ".  disclaimer.") (pre " Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following") (p ".  disclaimer in the documentation and/or other materials provided with the distribution.") (pre " Neither the name of the author nor the names of its contributors may be used to endorse or promote") (p ".  products derived from this software without specific prior written permission.") (p "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."))))