((tags "egg") (section 2 "charconv" (toc) (section 3 "Description" (p "Character encoding utilities")) (section 3 "Author" (p (int-link "Alex Shinn"))) (section 3 "Requirements" (ul (li (int-link "iconv")) (li (int-link "autoload")))) (section 3 "Documentation" (p "This module provides a convenience layer over top of the iconv module, as well as automatic detection of character encoding schemes.  It implicitly assumes you are using UTF8 internally for your strings (you can use the " (int-link "utf8") " module to change string semantics to use UTF8 as well).  Given that, all you need to do is specify the external encoding you are working with.") (section 4 "Input/output procedures" (p "The following are direct analogs of the equivalent R5RS procedures:") (def (sig (procedure "(open-encoded-input-file FILE ENC)" (id open-encoded-input-file)) (procedure "(call-with-encoded-input-file FILE ENC PROC)" (id call-with-encoded-input-file)) (procedure "(with-input-from-encoded-file FILE ENC THUNK)" (id with-input-from-encoded-file)) (procedure "(open-encoded-output-file FILE ENC)" (id open-encoded-output-file)) (procedure "(call-with-encoded-output-file FILE ENC PROC)" (id call-with-encoded-output-file)) (procedure "(with-output-to-encoded-file FILE ENC THUNK)" (id with-output-to-encoded-file))) (p "Example:") (highlight scheme "(use charconv)\n(with-input-from-encoded-file \"/usr/share/edict/edict\" \"EUC-JP\" read-line)")) (def (sig (procedure "(read-encoded-string ENC [N [PORT]])" (id read-encoded-string))) (p "An analog of " (tt "string") " using byte-count (not character count). May read additional bytes to ensure you read along a character boundary.  If you really want exactly N bytes regardless of character boundaries, you should combine " (tt "read-string") " with " (tt "ces-convert") " below."))) (section 4 "Utility procedures" (p "The following are copied from the Gauche API.  CES stands for Character Encoding Scheme.") (def (sig (procedure "(ces-equivalent? CES-A CES-B)" (id ces-equivalent?))) (p "Returns #t if CES-A and CES-B are equivalent (aliases), #f otherwise.")) (def (sig (procedure "(ces-upper-compatible? CES-A CES-B)" (id ces-upper-compatible?))) (p "Returns #t if a string encoded in CES-B can be considered a string in CES-A without conversion.")) (def (sig (procedure "(ces-convert STR FROM [TO])" (id ces-convert))) (p "Return a new string of STR converted from encoding FROM to encoding TO."))) (section 4 "Detection procedures" (def (sig (procedure "(detect-file-encoding FILE [LOCALE])" (id detect-file-encoding)) (procedure "(detect-encoding STRING [LOCALE])" (id detect-encoding))) (p "The detection procedures can correctly identify most common 'types' of encodings, such as UTF-8/16/32, EUC-*, ISO-2022-*, Shift_JIS or single-byte, without any need for specifying the locale.  However, currently it doesn't include any statistical or linguistic routines, without which it can't distinguish between EUC-JP and EUC-KR, or between any of the single-byte encodings (including ISO-8859-*).  In these cases you can specify a locale, such that in the event of a single-byte encoding a \"de\" locale would result in the default German single-byte encoding, ISO-8859-1.") (p "The detect-file-encoding procedure also recognizes the Emacs-style") (pre " -*- coding: foo -*-") (p "signature in either of the first two lines."))) (section 4 "Automatic detection" (p "You can also use the automatic detection implicitly in the input procedures by specifying an encoding of \"*\" or \"*<LOCALE>\".  For example,") (highlight scheme "(open-encoded-input-file file \"*\")    ; guess with no locale\n(open-encoded-input-file file \"*DE\")  ; guess with a German locale") (p "For compatibility with the Gauche convention, the encoding \"*JP\" is equivalent to \"*JA\", the Japanese locale."))) (section 3 "Changelog" (ul (li "1.3.3 fixed missing " (tt "(require-library srfi-69)") " (reported by Hugo Arregui)") (li "1.2 Fixing bug in pad-euc-input.  Signalling errors when trying to wrap a port with an unknown encoding.") (li "1.1 Adapted to SRFI-69-compatible hash-tables") (li "1.0 Initial release"))) (section 3 "License" (pre " Copyright (c) 2004-2005, Alex Shinn\n All rights reserved.\n \n Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following\n conditions are met:\n \n   Redistributions of source code must retain the above copyright notice, this list of conditions and the following\n     disclaimer. \n   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following\n     disclaimer in the documentation and/or other materials provided with the distribution. \n   Neither the name of the author nor the names of its contributors may be used to endorse or promote\n     products derived from this software without specific prior written permission. \n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\n CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n POSSIBILITY OF SUCH DAMAGE."))))