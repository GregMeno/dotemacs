(index ("open-encoded-input-file" 0) ("call-with-encoded-input-file" 0) ("with-input-from-encoded-file" 0) ("open-encoded-output-file" 0) ("call-with-encoded-output-file" 0) ("with-output-to-encoded-file" 0) ("read-encoded-string" 675) ("ces-equivalent?" 1062) ("ces-upper-compatible?" 1215) ("ces-convert" 1406) ("detect-file-encoding" 1555) ("detect-encoding" 1555))
(def (sig (procedure "(open-encoded-input-file FILE ENC)" (id open-encoded-input-file)) (procedure "(call-with-encoded-input-file FILE ENC PROC)" (id call-with-encoded-input-file)) (procedure "(with-input-from-encoded-file FILE ENC THUNK)" (id with-input-from-encoded-file)) (procedure "(open-encoded-output-file FILE ENC)" (id open-encoded-output-file)) (procedure "(call-with-encoded-output-file FILE ENC PROC)" (id call-with-encoded-output-file)) (procedure "(with-output-to-encoded-file FILE ENC THUNK)" (id with-output-to-encoded-file))) (p "Example:") (highlight scheme "(use charconv)\n(with-input-from-encoded-file \"/usr/share/edict/edict\" \"EUC-JP\" read-line)"))
(def (sig (procedure "(read-encoded-string ENC [N [PORT]])" (id read-encoded-string))) (p "An analog of " (tt "string") " using byte-count (not character count). May read additional bytes to ensure you read along a character boundary.  If you really want exactly N bytes regardless of character boundaries, you should combine " (tt "read-string") " with " (tt "ces-convert") " below."))
(def (sig (procedure "(ces-equivalent? CES-A CES-B)" (id ces-equivalent?))) (p "Returns #t if CES-A and CES-B are equivalent (aliases), #f otherwise."))
(def (sig (procedure "(ces-upper-compatible? CES-A CES-B)" (id ces-upper-compatible?))) (p "Returns #t if a string encoded in CES-B can be considered a string in CES-A without conversion."))
(def (sig (procedure "(ces-convert STR FROM [TO])" (id ces-convert))) (p "Return a new string of STR converted from encoding FROM to encoding TO."))
(def (sig (procedure "(detect-file-encoding FILE [LOCALE])" (id detect-file-encoding)) (procedure "(detect-encoding STRING [LOCALE])" (id detect-encoding))) (p "The detection procedures can correctly identify most common 'types' of encodings, such as UTF-8/16/32, EUC-*, ISO-2022-*, Shift_JIS or single-byte, without any need for specifying the locale.  However, currently it doesn't include any statistical or linguistic routines, without which it can't distinguish between EUC-JP and EUC-KR, or between any of the single-byte encodings (including ISO-8859-*).  In these cases you can specify a locale, such that in the event of a single-byte encoding a \"de\" locale would result in the default German single-byte encoding, ISO-8859-1.") (p "The detect-file-encoding procedure also recognizes the Emacs-style") (pre " -*- coding: foo -*-") (p "signature in either of the first two lines."))
