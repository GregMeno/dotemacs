(index ("match" 0) ("match-lambda" 888) ("match-lambda*" 888) ("match-let" 1727) ("match-let*" 1727) ("match-letrec" 1727))
(def (sig (syntax "(match exp (pat body ...) ...)" (id match))) (p "The basic form of pattern matching expression, where " (tt "exp") " is an expression, " (tt "pat") " is a pattern, and " (tt "body") " is one or more expressions (like the body of a lambda-expression). The " (tt "match") " form matches its first subexpression against a sequence of patterns, and branches to the " (tt "body") " corresponding to the first pattern successfully matched.") (p "For example, the following code defines the usual " (tt "map") " function:") (highlight scheme "(define map\n  (lambda (f l)\n    (match l\n      [() '()]\n      [(x . y) (cons (f x) (map f y))] )))") (p "The first pattern " (tt "()") " matches the empty list.  The second pattern " (tt "(x . y)") " matches a pair, binding " (tt "x") " to the first component of the pair and " (tt "y") " to the second component of the pair."))
(def (sig (syntax "(match-lambda  (pat body ...) ...)" (id match-lambda)) (syntax "(match-lambda* (pat body ...) ...)" (id match-lambda*))) (p "The " (tt "match-lambda") " and " (tt "match-lambda*") " forms are convenient combinations of " (tt "match") " and " (tt "lambda") ", and can be explained as follows:") (highlight scheme "(match-lambda  (pat body ...) ...)\n  --> (lambda (x) (match x (pat body ...) ...))\n\n(match-lambda* (pat body ...) ...)\n  --> (lambda x   (match x (pat body) ...))") (p "where " (tt "x") " is a unique variable.") (p "The " (tt "match-lambda") " form is convenient when defining a single argument function that immediately destructures its argument. The " (tt "match-lambda*") " form constructs a function that accepts any number of arguments; the patterns of " (tt "match-lambda*") " should be lists."))
(def (sig (syntax "(match-let [var] ((pat exp) ...) body ...)" (id match-let)) (syntax "(match-let*      ((pat exp) ...) body ...)" (id match-let*)) (syntax "(match-letrec    ((pat exp) ...) body ...)" (id match-letrec))) (p "The " (tt "match-let") ", " (tt "match-let*") " and " (tt "match-letrec") " forms generalize Scheme's " (tt "let") ", " (tt "let*") ", " (tt "letrec") ", and " (tt "define") " expressions to allow patterns in the binding position rather than just variables. For example, the following expression:") (highlight scheme "(match-let (((x y z) (list 1 2 3)))\n            ((a b c) (list 4 5 6)))\n  body ...)") (p "binds " (tt "x") " to 1, " (tt "y") " to 2, " (tt "z") " to 3, " (tt "a") " to 4, " (tt "b") " to 5, and " (tt "c") " to 6 in " (tt "body ...") ".  These forms are convenient for destructuring the result of a function that returns multiple values as a list or vector.  As usual for " (tt "letrec") ", pattern variables bound by " (tt "match-letrec") " should not be used in computing the bound value.") (p "Analogously to named " (tt "let") ", " (tt "match-let") " accepts an optional loop variable " (tt "var") " before the binding list, turning " (tt "match-let") " into a general looping construct."))
