(index ("start-server" 0) ("accept-loop" 1312) ("switch-user/group" 2486) ("server-software" 2908) ("root-path" 3429) ("server-port" 3583) ("server-bind-address" 3714) ("max-connections" 3900) ("spiffy-user" 4179) ("spiffy-group" 4485) ("index-files" 4894) ("mime-type-map" 5136) ("default-mime-type" 5855) ("default-host" 6071) ("vhost-map" 6268) ("file-extension-handlers" 6560) ("access-log" 6897) ("error-log" 7070) ("debug-log" 7274) ("access-file" 7445) ("handle-directory" 7914) ("handle-file" 8261) ("handle-not-found" 8692) ("handle-exception" 9147) ("handle-access-logging" 9598) ("current-request" 10069) ("current-response" 10500) ("current-file" 10826) ("current-pathinfo" 11133) ("remote-address" 11470) ("local-address" 11625) ("secure-connection?" 11766) ("with-headers" 12130) ("write-logged-response" 12460) ("log-to" 12765) ("send-response" 13171) ("send-status" 13547) ("send-static-file" 14031) ("file-extension->mime-type" 14314) ("restart-request" 14802) ("htmlize" 15087) ("build-error-message" 15273) ("ssp-short-open-tag" 15543) ("ssp-long-open-tag" 15690) ("ssp-close-tag" 15840) ("ssp-eval-environment" 16003) ("ssp-cache-dir" 16240) ("current-workdir" 16915) ("ssp-exit-handler" 17194) ("ssp-handler" 17435) ("ssp-include" 17606) ("ssp-stringize" 17880) ("web-scheme-eval-environment" 18069) ("web-scheme-handler" 18319) ("cgi-default-environment" 18504) ("cgi-handler" 18861) ("cgi-handler*" 19196) ("simple-directory-dotfiles?" 19483) ("simple-directory-display-file" 19673) ("simple-directory-handler" 20074))
(def (sig (procedure "(start-server [port: port-number] [bind-address: address] [listen: listen-procedure] [accept: accept-procedure])" (id start-server))) (p "Starts the server, to listen on the given port. Other configuration can be tweaked through SRFI-39 parameters. These are listed below. Once the server is started, server behaviour can be controlled through these parameters as well.  After the listener is started, when " (tt "spiffy-user") " and/or " (tt "spiffy-group") " are provided, this procedure will drop privileges before starting the accept loop.") (p "By default, Spiffy will only serve static files. On directories, it will give a \"403 forbidden\", unless there is an index-file. If there is, that file's contents will be shown.") (p "All arguments directly supplied to " (tt "start-server") " override the configuration parameter values and will be parameterized to reflect this new setting.") (p (tt "port-number") " defaults to the value of " (tt "server-port") " (see below). " (tt "bind-address") " defaults to the value of " (tt "server-bind-address") " (see below). " (tt "listen") " defaults to " (tt "tcp-listen") " and should accept a port number, backlog and bind address. " (tt "accept") " defaults to " (tt "tcp-accept") ", and is passed on as-is to " (tt "accept-loop") "."))
(def (sig (procedure "(accept-loop listener accept)" (id accept-loop))) (p "This procedure starts the loop which accepts incoming connections and fires off threads to handle requests on those connections.  You can use it if you need more control over the startup process than " (tt "start-server") " offers.  For example, you can set up an SSL context and drop privileges, and possibly load extra code before starting the accept loop (Spiffy contains the required code to detect SSL ports, and will handle those more-or-less transparently):") (highlight scheme "(use spiffy openssl)\n\n(server-port 443)\n(spiffy-user \"www\")\n(spiffy-group \"www\")\n\n;; Bind the port as root, before we drop privileges\n(define listener (ssl-listen (server-port)))\n\n;; Load the certificate files as root so we can secure their permissions\n(ssl-load-certificate-chain! listener \"server.pem\")\n(ssl-load-private-key! listener \"server.key\")\n\n;; Drop root privileges\n(switch-user/group (spiffy-user) (spiffy-group))\n  \n;; We don't want to load this extra code as root!\n(load \"extra-code.scm\")\n\n;; Done! Start listening for connections.\n(accept-loop listener ssl-accept)"))
(def (sig (procedure "(switch-user/group user group)" (id switch-user/group))) (p "This is a helper procedure which allows you to easily drop privileges before running the accept loop.  The user and group must be either strings or UID/GID numbers which indicate the username and groupname to which you want to switch.  Either is also allowed to be " (tt "#f") ", if you don't want to switch that aspect of the process."))
(def (sig (parameter "(server-software [product])" (id server-software))) (p "The server software product description. This should be a valid product value as used in the server and user-agent headers by intarweb; this is a list of lists. The inner lists contain the product name, the product version and a comment, all either a string or " (tt "#f") ". Default: " (tt "((\"Spiffy\" \"a.b\" \"Running on Chicken x.y\"))") ", with " (tt "a.b") " being the Spiffy major/minor version and " (tt "x.y") " being Chicken's."))
(def (sig (parameter "(root-path [path])" (id root-path))) (p "The path to the document root, for the current vhost. Defaults to " (tt "\"./web\"") "."))
(def (sig (parameter "(server-port [port-number])" (id server-port))) (p "The port number on which to listen. Defaults to 8080."))
(def (sig (parameter "(server-bind-address [address])" (id server-bind-address))) (p "The IP address on which to listen, or all addresses if " (tt "#f") ". Defaults to " (tt "#f") "."))
(def (sig (parameter "(max-connections [number])" (id max-connections))) (p "The maximum number of simultaneously active connections. Defaults to 1024.") (p "Any new connection that comes in when this number is reached must wait until one of the active connections is closed."))
(def (sig (parameter "(spiffy-user [name-or-uid])" (id spiffy-user))) (p "The name or UID of a user to switch to just after binding the port. This only works if you start Spiffy as root, so it can bind port 80 and then drop privileges. If " (tt "#f") ", no switch will occur. Defaults to " (tt "#f") "."))
(def (sig (parameter "(spiffy-group [name-or-gid])" (id spiffy-group))) (p "The name or GID of a group to switch to just after binding the port. This only works if you start Spiffy as root, so it can bind port 80 and then drop privileges. If " (tt "#f") ", it will be set to the primary group of " (tt "spiffy-user") " if the user was selected. Otherwise, no change will occur.  Defaults to " (tt "#f") "."))
(def (sig (parameter "(index-files [file-list])" (id index-files))) (p "A list of filenames which are to be used as index files to serve when the requested URL identifies a directory.  Defaults to " (tt "'(\"index.html\" \"index.xhtml\")")))
(def (sig (parameter "(mime-type-map [extension->mimetype-list])" (id mime-type-map))) (p "An alist of extensions (strings) to mime-types (symbols), to use for the content-type header when serving up a static file. Defaults to") (pre " '((\"html\" . text/html)\n   (\"xhtml\" . application/xhtml+xml)\n   (\"js\"  . application/javascript)\n   (\"css\" . text/css)\n   (\"png\" . image/png)\n   (\"xml\" . application/xml)\n   (\"pdf\" . application/pdf)\n   (\"jpeg\" . image/jpeg)\n   (\"jpg\" . image/jpeg)\n   (\"gif\" . image/gif)\n   (\"ico\" . image/vnd.microsoft.icon)\n   (\"txt\" . text/plain))") (p "See also " (tt "file-extension->mime-type") " for a procedure which can look up file extensions for you."))
(def (sig (parameter "(default-mime-type [mime-type])" (id default-mime-type))) (p "The mime-type (a symbol) to use if none was found in the " (tt "mime-type-map") ". Defaults to " (tt "'application/octet-stream")))
(def (sig (parameter "(default-host [hostname])" (id default-host))) (p "The host name to use when no virtual host could be determined from the request.  See the section on virtual hosts below."))
(def (sig (parameter "(vhost-map [host-regex->vhost-handler])" (id vhost-map))) (p "A mapping of virtual hosts (regex) to handlers (procedures of one argument; a continuation thunk). See the section on virtual hosts below. Defaults to " (tt "`((\".*\" . ,(lambda (continue) (continue))))")))
(def (sig (parameter "(file-extension-handlers [extension->handler-list])" (id file-extension-handlers))) (p "An alist mapping file extensions (strings) to handler procedures (lambdas of one argument; the file name relative to the webroot). Defaults to " (tt "'()") ". If no handler was found, defaults to just sending a static file."))
(def (sig (parameter "(access-log [log-file-or-port])" (id access-log))) (p "Filename (string) or port to append access log output to.  Default: " (tt "#f") " (disabled)"))
(def (sig (parameter "(error-log [log-file-or-port])" (id error-log))) (p "Filename (string) or port to which error messages from evaluated code should be output. Default: " (tt "(current-error-port)")))
(def (sig (parameter "(debug-log [log-file-or-port])" (id debug-log))) (p "Filename (string) or port to write debugging messages to.  Default: " (tt "#f") " (disabled)"))
(def (sig (parameter "(access-file [string])" (id access-file))) (p "The name of an access file, or " (tt "#f") " if not applicable.  This file is read when the directory is entered by the directory traversal system, and allows you to write dynamic handlers that can assign new values for parameters only for resources below that directory, very much like adding parameters in code before calling a procedure.  See the section \"Access files\" for more information."))
(def (sig (parameter "(handle-directory [proc])" (id handle-directory))) (p "The handler for directory entries. If the requested URL points to a directory which has no index file, this handler is invoked. It is a procedure of one argument, the path (a string) relative to the webroot. Defaults to a procedure which returns a \"403 forbidden\"."))
(def (sig (parameter "(handle-file [proc])" (id handle-file))) (p "The handler for files. If the requested URL points to a file, this handler is invoked to serve the file. It is a procedure of one argument, the path (a string) relative to the webroot. Defaults to a procedure which sets the content-type and determines a handler based on the " (tt "file-extension-handlers") ", or " (tt "send-static-file") " if none was found."))
(def (sig (parameter "(handle-not-found [proc])" (id handle-not-found))) (p "The handler for nonexisting files. If the requested URL does not point to an existing file or directory, this procedure is called. It is a procedure of one argument, the path (a string) that was requested. This path should be interpreted as being relative to the webroot (even though it points to no existing file). Defaults to a procedure which returns a \"404 Not found\"."))
(def (sig (parameter "(handle-exception [proc])" (id handle-exception))) (p "The handler for when an exception occurs. This defaults to a procedure that logs the error to the error log. While debugging or developing, it may be more convenient to use a procedure that sends the error back to the client:") (highlight scheme "(handle-exception\n  (lambda (exn chain)\n    (send-status 500 \"Internal server error\" (build-error-message exn chain))))"))
(def (sig (parameter "(handle-access-logging [proc])" (id handle-access-logging))) (p "The handler for access logging. This is a procedure of zero arguments which should write a line to the access log. Defaults to a procedure which writes a line to " (tt "access-log") " which looks like this:") (pre "  127.0.0.1 [Sun Nov 16 15:16:01 2008] \"GET http://localhost:8080/foo?bar HTTP/1.1\" 200 \"http://localhost:8080/referer\" \"Links (2.2; NetBSD 5.99.01 macppc; x)\""))
(def (sig (parameter "(current-request [request])" (id current-request))) (p "An intarweb request-object that defines the current request. Available from the moment the request comes in and is parsed. Contains, among other things, the query parameters and the request-headers, in fully parsed form (as intarweb returns them).") (p "The URI is automatically augmented with the host, scheme and port if it is not an absolute URI."))
(def (sig (parameter "(current-response [response])" (id current-response))) (p "An intarweb response-object that defines the current response. Available from the same time current-request is available. This keeps getting updated along the way, while the response data is being refined (like when headers are being added)."))
(def (sig (parameter "(current-file [path])" (id current-file))) (p "The path to the requested file (a string). Available from the moment Spiffy determined the requested URL points to a file (just before the " (tt "handle-file") " procedure is called). This file is relative to the " (tt "root-path") "."))
(def (sig (parameter "(current-pathinfo [path])" (id current-pathinfo))) (p "The trailing path " (i "fragments") " (a list of strings) that were passed in the URL after the requested filename. Available from the moment Spiffy determined the requested URL points to a file (just before the " (tt "handle-file") " procedure is called)."))
(def (sig (parameter "(remote-address [address])" (id remote-address))) (p "The IP address (a string) of the user-agent performing the current request."))
(def (sig (parameter "(local-address [address])" (id local-address))) (p "The IP address (a string) on which the current request came in."))
(def (sig (parameter "(secure-connection? [boolean])" (id secure-connection?))) (p (tt "#t") " when the current connection is a secure one (SSL), " (tt "#f") " if it isn't (regular HTTP).  This pertains only to the direct connection itself, so if Spiffy is behind a proxy this will be " (tt "#f") " even if the proxy itself is connected to the client over SSL."))
(def (sig (procedure "(with-headers new-headers thunk)" (id with-headers))) (p "Call " (tt "thunk") " with the header list " (tt "new-headers") ". This parameterizes the current response to contain the new headers.  The existing headers are extended with " (tt "new-headers") " through intarweb's " (tt "headers") " procedure."))
(def (sig (procedure "(write-logged-response)" (id write-logged-response))) (p "This procedure simply writes " (tt "current-response") " after calling " (tt "handle-access-logging") ". Responses should always go through this procedure instead of directly using " (tt "write-response") " from intarweb."))
(def (sig (procedure "(log-to log format . rest)" (id log-to))) (p "Write a printf-style format string to the specified log (one of " (tt "access-log") ", " (tt "error-log") " or " (tt "debug-log") "). " (tt "format") " is a " (tt "printf") "-style format string, and rest arguments should match the arguments one would pass to printf. A newline is appended to the end of the log message automatically."))
(def (sig (procedure "(send-response #!key (code 200) (reason \"OK\") body (headers '()))" (id send-response))) (p "Easy way to send string data to the client, with additional headers. It will add appropriate headers and will automatically detect " (tt "HEAD") " requests.  If BODY is " (tt "#f") ", no body is sent and the " (tt "content-length") " header is set to zero."))
(def (sig (procedure "(send-status code reason [message])" (id send-status))) (p "Easy way to send a page and a status code to the client.  The optional message is a string containing HTML to add in the body of the response. Some structure will be added around the message, so message should only be the actual message you want to send.  Example:") (highlight scheme "(send-status 404 \"Not found\"\n \"Sorry, page not found! Please try <a href='/search.ws'>our search page</a>\")"))
(def (sig (procedure "(send-static-file filename)" (id send-static-file))) (p "Send a file to the client. This sets the " (tt "content-length") " header and tries to send the file as quickly as possible to the client. The filename is interpreted relative to " (tt "root-path") "."))
(def (sig (procedure "(file-extension->mime-type EXT)" (id file-extension->mime-type))) (p "Looks up the file extension " (tt "EXT") " (without a trailing dot) in " (tt "mime-type-map") ", or uses " (tt "default-mime-type") " when the extension can't be found.") (p "If " (tt "EXT") " is " (tt "#f") ", it'll look up the extension that is the empty string.") (p "This returns a symbol which indicates the mime-type which is matched to the extension (for example " (tt "text/html") ")."))
(def (sig (procedure "(restart-request request)" (id restart-request))) (p "Restart the entire request-handling starting at the point where the request was just parsed. The argument is the new request to use. Be careful, this makes it very easy to introduce unwanted endless loops!"))
(def (sig (procedure "(htmlize string) => string" (id htmlize))) (p "Encode \"special\" html symbols like tag and attribute characters so they will not be interpreted by the browser."))
(def (sig (procedure "(build-error-message exn chain [raw-output])" (id build-error-message))) (p "Build an error message for the exception " (tt "exn") ", with call chain " (tt "chain") ". Defaults to HTML output, unless " (tt "raw-output") " is given and nonfalse."))
(def (sig (parameter "(ssp-short-open-tag [tag-regexp])" (id ssp-short-open-tag))) (p "The opening tag for short fragments. Default: " (tt "<?")))
(def (sig (parameter "(ssp-long-open-tag [tag-regexp])" (id ssp-long-open-tag))) (p "The opening tag for long fragments. Default: " (tt "<?scheme")))
(def (sig (parameter "(ssp-close-tag [tag-regexp])" (id ssp-close-tag))) (p "The closing tag for Scheme fragments in " (tt ".ssp") " files. Default: " (tt "?>")))
(def (sig (parameter "(ssp-eval-environment [environment])" (id ssp-eval-environment))) (p "The environment passed to " (tt "eval") " when evaluating Scheme code inside " (tt ".ssp") "-pages.  Default: " (tt "interaction-environment")))
(def (sig (parameter "(ssp-cache-dir [directory-name])" (id ssp-cache-dir))) (p "The directory under which to store cached .ssp files (these end in .sspx and are pure Scheme files).  Useful if you want to block write access to the webserver under your docroot.  Default: " (tt "\".\"")) (p "If it's a relative path, it is relative to " (tt "root-path") ", if absolute it's taken to be relative to the filesystem root.  A directory structure similar to the docroot will be created underneath this path, so for example if the file " (tt "/foo/bar/qux.ssp") " exists, and the cache dir is set to " (tt "/cache") ", it will create the file " (tt "/cache/foo/bar/qux.sspx") "."))
(def (sig (parameter "(current-workdir [path])" (id current-workdir))) (p "During execution, the current working directory of the SSP handler. Any of the \"include\" procedures (ssp-include, ssp-stringize) will interpret their file arguments to be relative to this directory."))
(def (sig (parameter "(ssp-exit-handler [handler])" (id ssp-exit-handler))) (p "During execution of an ssp page, " (tt "ssp-exit-handler") " is bound to a procedure that will finish the current page, ignoring any further content or code."))
(def (sig (procedure "(ssp-handler filename)" (id ssp-handler))) (p "The handler itself, which should be used in the " (tt "file-extension-handlers") " parameter list."))
(def (sig (procedure "(ssp-include filename)" (id ssp-include))) (p "Translates the file " (tt "filename") " into Scheme by replacing " (tt "<?scheme ... ?>") " and " (tt "<? ... ?>") " sequences (if needed) and writes the translated contents to the current output-port."))
(def (sig (procedure "(ssp-stringize FILENAME)" (id ssp-stringize))) (p "Similar to " (tt "ssp-include") ", but instead of writing the translated text, the text is returned as a string."))
(def (sig (parameter "(web-scheme-eval-environment [environment])" (id web-scheme-eval-environment))) (p "The environment passed to " (tt "eval") " when evaluating Scheme code inside " (tt ".ws") "-pages.  Default: " (tt "interaction-environment")))
(def (sig (procedure "(web-scheme-handler filename)" (id web-scheme-handler))) (p "The handler itself, which should be used in the " (tt "file-extension-handlers") " parameter list."))
(def (sig (procedure "(cgi-default-environment [env-alist])" (id cgi-default-environment))) (p "The environment variables that should be in the default environnment of every CGI program.  Variables like " (tt "SCRIPT_NAME") " will be added dynamically to the end of this alist.") (p "Default:") (highlight scheme "((\"GATEWAY_INTERFACE\" . \"CGI/1.1\"))"))
(def (sig (procedure "(cgi-handler filename [interpreter])" (id cgi-handler))) (p "The cgi handler simply calls CGI scripts. It is assumed the requested file is executable if no interpreter is given. (If used as a regular handler, it will only receive the filename).  The filename is taken to be relative to " (tt "(root-path)") "."))
(def (sig (procedure "(cgi-handler* [interpreter])" (id cgi-handler*))) (p "The " (tt "cgi-handler*") " procedure is usually more useful.  It allows you to define an interpreter to use for files and returns a new handler. See the example above for " (tt "file-extension-handlers") "."))
(def (sig (procedure "(simple-directory-dotfiles? [dotfiles?])" (id simple-directory-dotfiles?))) (p "Determines if dotfiles should show up in the directory listings. Default: " (tt "#f")))
(def (sig (procedure "(simple-directory-display-file [displayer])" (id simple-directory-display-file))) (p "A lambda that accepts three arguments: the remote filename, the local filename and a boolean that says if the file is a directory.  This lambda should output a table row with the desired information. Defaults to a lambda that prints the name, size and date when the file was last modified."))
(def (sig (procedure "(simple-directory-handler pathname)" (id simple-directory-handler))) (p "The handler itself, which should be used in the " (tt "handle-directory") " parameter."))
