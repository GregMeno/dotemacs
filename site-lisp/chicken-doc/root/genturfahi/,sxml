((tags "egg") (section 2 "genturfa'i" (p ".i lo la .ckim. ke pe'a jajgau ratcu ke'e genturfa'i") (toc) (section 3 "Description" (p "genturfa'i is a Scheme packrat parser.") (p "Packrat parsing is a " (link "http://en.wikipedia.org/wiki/Memoization" "memoizing") ", " (link "http://en.wikipedia.org/wiki/Backtracking" "backtracking") ", " (link "http://en.wikipedia.org/wiki/Recursive_descent_parser" "recursive descent") " parsing technique that runs in " (link "http://en.wikipedia.org/wiki/Big_O_notation" "time and space linear to the size of the input text") " O(n).") (p "Packrat parsers require more memory than traditional LL(k) parsers, but are more expressive.  Unlike traditional LL(k) parsers, which have a separate " (link "http://en.wikipedia.org/wiki/Tokenization" "tokenization") " step, Packrat parsers combine lexical analysis and grammar parsing into a single step, using the same language for both.") (p "The word genturfa'i is a " (link "http://lojban.org/" "Lojban") " lujvo, consisting of the gismu gerna, stura, and facki.  It translates to  \"grammar structure discover.\"")) (section 3 "Authors" (p (int-link "/users/alyn.post" ".alyn.post.") ".  Inspired by the " (int-link "packrat") " parser authored by Tony Garnock-Jones.")) (section 3 "Requirements" (p "Requires srfi-1 (list library), srfi-6 (string ports), srfi-9 (records), srfi-13 (string libraries), srfi-28 (basic string formatting), srfi-37 (args-fold), srfi-39 (parameter objects) srfi-61 (more general cond clause), regex (regular expressions), and utf8.") (p "The filter procedure from srfi-1 is used.") (p "srfi-6 (with Chicken Scheme's extensions) is used for reading parse input from a port.  It can be removed if you do not need to parse input from a port.") (p "srfi-9 is used to construct records with no more than two elements. These calls could be replaced by " (tt "cons") " if you wish to remove this dependency.") (p "srfi-13 is required only to return the remaining characters in the input buffer after a successful parse.  If your grammar manually checks for the end of the input, this dependency could be removed.") (p "srfi-28 is used to format the module version number and for debugging support.  It could be excluded with minor modification to the code.") (p "srfi-37 is used to process command-line arguments.") (p "srfi-39 is used to process command-line arguments and to dynamically configure the parser.") (p "srfi-61 is used in the memoization code and regular expression token matching code.") (p "regex is used to match input for certain terminal rules.") (p "utf8 is used for utf8 character support.") (p "srfi-1, srfi-6, srfi-9, srfi-13, srfi-28, srfi-39, and srfi-61 are built into Chicken Scheme.") (p "The srfi-37, regex and utf8 eggs must be installed.") (p "genturfa'i uses DSSSL style lambda lists, which are not standard R5RS Scheme.  DSSSL style lambda lists are build into Chicken.")) (section 3 "Documentation" (section 4 "Usage" (p "With genturfa'i, A parser is expressed using a parsing expression grammar, or PEG.  This language describes the grammar that genturfa'i is parsing.  It is also possible to construct a grammar directly in Scheme.") (p "This module implements two methods for writing parsers.  The recommended method is to write your grammar in " (link "http://en.wikipedia.org/wiki/Parsing_expression_grammar" "PEG") " and compile the grammar to Scheme code.") (p "'" (b "This method of writing parsers has not yet been written.") "'") (p "Your grammar can also be written directly in Scheme, using the primitive grammar construction operators provided by " (tt "genturfahi") ". As this is the only mode that currently exists, it will be covered in this documentation.")) (section 4 "A Note About Lojban" (p (link "http://lojban.org/" "Lojban") " is a carefully constructed spoken language with an " (i "unambiguous grammar") ".") (p "I've written this parser with the intention of parsing " (link "http://www.teddyb.org/~rlpowell/hobbies/lojban/grammar/" "Lojban's PEG grammar") "., as expressed in the " (link "http://www.teddyb.org/~rlpowell/hobbies/lojban/grammar/lojban.peg.txt" "main grammar") ", " (link "http://www.lojban.org/tiki/tiki-index.php?page=BPFK+Section%3A+PEG+Morphology+Algorithm" "morphology") ", and " (link "http://www.teddyb.org/~rlpowell/hobbies/lojban/grammar/morph_header.peg.txt" "morphology header") " files.") (p "Just like the name of this module, the routines in this module are named with Lojban words.  If you are unfamiliar with Lojban, a translation of the words that appear in the API is provided below.")) (section 4 "English translation of Lojban words" (p "This table provides an english glass for each Lojban word that appears in the API documentation.  This table is not intended to have any truth value outside of this document.  For formal English glosses of these words, please consult the " (link "http://jbovlaste.lojban.org/" "Lojban to English Translation Dictionary") ".") (table (tr (th "Lojban word") (th "English gloss")) "\n" (tr (td "cfari") (td "begin")) "\n" (tr (td "cmene, cme") (td "name")) "\n" (tr (td "fanmo") (td "end")) "\n" (tr (td "genturfa'i") (td "parse")) "\n" (tr (td "jalge") (td "result")) "\n" (tr (td "javni") (td "rule")) "\n" (tr (td "je") (td "logical and")) "\n" (tr (td "jonai") (td "logical exclusive or")) "\n" (tr (td "lerfu") (td "character")) "\n" (tr (td "mapti") (td "match")) "\n" (tr (td "midju") (td "middle")) "\n" (tr (td "morji") (td "memoize")) "\n" (tr (td "namapti") (td "nonmatch")) "\n" (tr (td "naselci") (td "nonterminal")) "\n" (tr (td "nilcla") (td "length")) "\n" (tr (td "nunjavni") (td "rule generator")) "\n" (tr (td "nunvalsi") (td "token generator")) "\n" (tr (td "pabalvi") (td "next")) "\n" (tr (td "porsi, poi") (td "ordered sequence")) "\n" (tr (td "rodacmene") (td "names")) "\n" (tr (td "rodajavni") (td "rules")) "\n" (tr (td "rodajalga") (td "results")) "\n" (tr (td "rodanunjavni") (td "rules generator")) "\n" (tr (td "rodanunjalga") (td "results generator")) "\n" (tr (td "rodavalsi") (td "tokens")) "\n" (tr (td "secuxna") (td "option")) "\n" (tr (td "sezvati, zva") (td "location")) "\n" (tr (td "samselpla") (td "code")) "\n" (tr (td "sumti") (td "function argument")) "\n" (tr (td "tolmohi") (td "clear memoization")) "\n" (tr (td "valsi, val") (td "token")))) (section 4 "Writing A Parser" (p "'" (b "This section describes features that are not yet implemented.") "'") (p "This section will eventually document how to write a parser in PEG.  As that code is not yet written, please refer to the API documents.")) (section 4 "Configuration" (p "'" (b "This section describes features that are not yet implemented.") "'") (section 5 "Debugging" (p "'" (b "Debugging is not yet implemented.") "'") (p "Debugging is used to see what rules are being called as the parser tries to parse the input.") (highlight scheme ";;\n;; enable debug output\n;;\n(secuxna debug #t)")) (section 5 "Profiling" (p "'" (b "Profiling is not yet implemented.") "'") (p "Profiling is used to determine how much time is being spent in each grammar rule.") (highlight scheme ";;\n;; enable profiling\n;;\n(secuxna profile #t)")) (section 5 "Memoization" (p "'" (b "This option is not yet implemented.") "'") (p "By default, memoization is enabled to ensure that the parser runs in linear space and time.  For some grammars, memoization does not provide any performance benefit, while the extra cache lookup slows the parser down.") (p "Memoization can be turned completely off:") (highlight scheme ";;\n;; turn memoization completely off.\n;;\n(secuxna memoize #f)") (p "Or it can be turned off for specific non-terminal rules:") (highlight scheme ";;\n;; turn memoization off for non-terminal rule\n;; 'javnipa' and 'javnire'.\n;;\n(secuxna memoize ((javnipa #f) (javnire #f)))")) (section 5 "Changing the sentinel character" (p "'" (b "This option is not yet implemented.") "'") (p "A sentinel character is placed at the end of the parse input to indicate the end of input.  This character cannot be a valid terminal character in the grammar.  Placing a sentinal character at the end of the parse input is an optimization that allows the terminal matching rules to avoid checking for the end of the parse input when they try to match the parse input.  As these rules are called frequently, removing this check can speed up parsing.") (p "This is also the character that is returned when the end of input is explicitely matched.") (p "By default, " (tt "#\\nul") " is used as a sentinal character in the parse input to indicate an end of input.  If this character appears in your grammar, you'll need to change the sentinal character to something else:") (highlight scheme ";;\n;; change the sentinal character used to\n;; detect the end of the parse input.\n;;\n(secuxna sentinal #\\nul) ; default")) (section 5 "Changing the empty string" (p "'" (b "This option is not yet implemented.") "'") (p "The empty string is a parse rule matching zero characters.  By default, the token generated by this rule is the zero length string " (tt "\"\"") ".  To change the token produced by the empty string:") (highlight scheme ";;\n;; change the token returned when we\n;; match against the empty string.\n;;\n(secuxna empty-string \"\") ; default")) (section 5 "Changing non-matching parse result" (p "'" (b "This option is not yet implemented.") "'") (p "When parse input does not match the grammar, a token is returned indicated non-match.  By default, the non-matching token is " (tt "#f") ". To change the token returned when the parse input does not match the grammar:") (highlight scheme ";;\n;; change the token returned when the parse\n;; input does not match the grammar.\n;;\n(secuxna nonmatch-token #f) ; default")))) (section 3 "API Documentation" (p "This is the low-level interface for writing parsers directly in Scheme.  This code is used by the compiler to generate your parser. It is not designed to be used directly.") (p "As this interface is written specifically to support the PEG parser generator, it is expressive but not concise.  A more concise syntax could be written on top of this API.  I do not plan on developing this syntax, but  if you would like to write parsers directly in Scheme, please feel free to add support for a more concise syntax.  See the History section of this document for a starting idea.") (p "This API defines the following components:") (dl (dt "lerfu-porsi") (dd "The parse input with an associated position.") (dt "nunjavni") (dd "A generator that creates grammar rules.") (dt "javni") (dd "A grammar rule that creates a token from the parse input and advances the input position.") (dt "mapti") (dd "A match continuation for a grammar rule.") (dt "namapti") (dd "A non-match continuation for a grammar rule.") (dt "nunvalsi") (dd "A generator that returns parse results.") (dt "javni-valsi") (dd "The token generated by a grammar rule.") (dt "samselpla") (dd "Code that modifies the syntax tree generated by the parser.") (dt "genturfahi") (dd "The parser, containing all of the grammar rules.")) (p "The parser runs as follows:") (p "A " (tt "lerfu-porsi") " encapsulates the input to parse.  It tracks the current position of the input based on the parse.") (p "A " (tt "nunjavni") " expects zero or more " (tt "javni") " and generates a new " (tt "javni") ". The parser is constructed by linking together " (tt "javni") " through " (tt "nunjavni") " generators.") (p "A " (tt "javni") " expects a " (tt "lerfu-porsi") ", " (tt "mapti") ", and " (tt "namapti") ". " (tt "mapti") " and " (tt "namapti") " are continuations representing the next rule in the grammar.  The set of all " (tt "javni") " describe the grammar to parse.") (p "Both " (tt "mapti") " and " (tt "namapti") " expect a " (tt "lerfu-porsi") " (possibly advanced by the previous " (tt "javni") ").  " (tt "mapti") " also expects a " (tt "nunvalsi") ", the generator for the parse tree.  " (tt "mapti") " and " (tt "namapti") " are used for backtracking and general control flow during the parse.") (p "A " (tt "nunvalsi") " generates either a " (tt "javni-valsi") " or a list of " (tt "javni-valsi") ".  " (tt "javni-valsi") " are not immediately generated, as future backtracking could invalidate a currently matched result. " (tt "nunvalsi") " generate the parse tree resulting from the input when called.") (p "A " (tt "javni-valsi") " is a name and associated token.  The token can be a single character or the entire syntax tree.  names must be symbols, and are used to associate a piece of the abstract syntax tree with a variable name when executing " (tt "samselpla") ".  The parser converts the input in " (tt "lerfu-porsi") " to " (tt "javni-valsi") ".") (p (tt "samselpa") " is code embedded in the grammar.  It is executed after a successful parse, modifying the syntax tree before it is returned from the parser.  Often it is easier to work with the syntax tree \"in place\" rather than working on the entire syntax tree at once. " (tt "samselpla") " is the mechanism for working with the syntax tree \"in place.\"") (p (tt "genturfahi") " expects a " (tt "lerfu-porsi") " and " (tt "javni") " containing the starting grammar rule.  It provides the terminal " (tt "mapti") " and " (tt "namapti") " continuations that generate the parse results by generating a " (tt "javni-valsi") " from the " (tt "nunvalsi") " and returning the parsed syntax tree.") (p "Details on each component are below.") (section 4 "lerfu-porsi" (def (sig (record "lerfu-porsi" (id lerfu-porsi))) (p "The string to parse and the current parse position of that string. This structure is used by the parser to store the input to the parser.") (p "It contains the following members:") (dl (dt (tt "zva")) (dd "An integer which is the current index of " (tt "poi") ".") (dt (tt "poi")) (dd "The string which will be parsed."))) (def (sig (procedure "(make-lerfu-porsi zva poi) => lerfu-porsi" (id make-lerfu-porsi))) (dl (dt (tt "zva")) (dd "An integer describing the current position of the parse input.") (dt (tt "poi")) (dd "The parse input, as a specially formatted string.  (See " (tt "make-lerfu-porsi-string") " and " (tt "make-lerfu-porsi-port") ".)")) (p "Create a " (tt "lerfu-porsi") " from the integer index " (tt "zva") " and the parse input " (tt "poi") ".  " (tt "poi") " is specially formatted, and must come from calling " (tt "make-lerfu-porsi-string") " or " (tt "make-lerfu-porsi-port") ".  It has an appended character acting as a \"sentinel\" for purposes of detecting the end of the input buffer.") (p (tt "zva") " must be less than or equal to the " (tt "string-length") " of " (tt "poi") ".")) (def (sig (procedure "(make-lerfu-porsi-pabalvi-lerfu porsi) => lerfu-porsi" (id make-lerfu-porsi-pabalvi-lerfu))) (dl (dt (tt "porsi")) (dd "the parse position to advance.")) (p "Create a " (tt "lerfu-porsi") " from an existing " (tt "lerfu-porsi") " by advancing the index " (tt "zva") " by a single character.") (p "It is an error if " (tt "porsi") " is not of type " (tt "lerfu-porsi") ".") (p "Behavior is undefined if this procedure is called when " (tt "lerfu-porsi-fanmo?") " returns " (tt "#t") " for this " (tt "porsi") ".")) (def (sig (procedure "(make-lerfu-porsi-pabalvi-valsi porsi nilcla) => lerfu-porsi" (id make-lerfu-porsi-pabalvi-valsi))) (dl (dt (tt "porsi")) (dd "the parse position to advance.") (dt (tt "nilcla")) (dd "The number of characters the position will be advanced by.")) (p "Create a " (tt "lerfu-porsi") " from an existing " (tt "lerfu-porsi") " by advancing the index " (tt "zva") " by the length of " (tt "lefpoi") ".") (p "It is an error if " (tt "porsi") " is not of type " (tt "lerfu-porsi") ".") (p "Behavior is undefined if this procedure is called with a " (tt "lefpoi") " whose length is greater than the number of characters in remaining in the parse input.")) (def (sig (procedure "(lerfu-porsi? porsi) => boolean" (id lerfu-porsi?))) (dl (dt (tt "porsi")) (dd "the object to test.")) (p "Return " (tt "#t") " if " (tt "porsi") " is of type " (tt "lerfu-porsi") " and " (tt "#f") " otherwise.")) (def (sig (procedure "(lerfu-porsi-zva porsi) => zva" (id lerfu-porsi-zva))) (dl (dt (tt "porsi")) (dd "A " (tt "lerfu-porsi") ".")) (p "Return the " (tt "zva") " member from " (tt "porsi") ".") (p "It is an error if " (tt "porsi") " is not of type " (tt "lerfu-porsi") ".")) (def (sig (procedure "(lerfu-porsi-poi porsi) => poi" (id lerfu-porsi-poi))) (dl (dt (tt "porsi")) (dd "A " (tt "lerfu-porsi") ".")) (p "Return the " (tt "poi") " member from " (tt "porsi") ".") (p "It is an error if " (tt "porsi") " is not of type " (tt "lerfu-porsi") ".")) (def (sig (procedure "(lerfu-porsi->string porsi) => string" (id lerfu-porsi->string))) (dl (dt (tt "porsi")) (dd "A " (tt "lerfu-porsi") ".")) (p "Return A string representation of " (tt "porsi") ".  This string representation is for debug use only, and cannot be converted back to a " (tt "lerfu-porsi") ".") (p "It is an error if " (tt "porsi") " is not of type " (tt "lerfu-porsi") ".")) (def (sig (procedure "(make-lerfu-porsi-string string) => porsi" (id make-lerfu-porsi-string))) (dl (dt (tt "string")) (dd "The input string to parse.")) (p "Return a " (tt "lerfu-porsi") " with " (tt "string") " as the parse input. " (tt "string") " is copied into the " (tt "lerfu-porsi") ".")) (def (sig (procedure "(make-lerfu-porsi-port port) => porsi" (id make-lerfu-porsi-port))) (dl (dt (tt "port")) (dd "The input port to parse.")) (p "Return a " (tt "lerfu-porsi") " with " (tt "port") " as the parse input. " (tt "port") " is read into a string before being copied into the " (tt "lerfu-porsi") ", as the parser may need to backtrack to any previous location in the string.")) (def (sig (procedure "(lerfu-porsi-string porsi) => string" (id lerfu-porsi-string))) (dl (dt (tt "porsi")) (dd "A " (tt "lerfu-porsi") ".")) (p "Return the characters that have not been parsed from " (tt "porsi") ". This routine copies the characters from the buffer into a new string.") (p "If all of the characters were parsed from " (tt "lerfu-porsi") ", return " (tt "\"\"") ".")) (def (sig (procedure "(lerfu-porsi-lerfu porsi) => character" (id lerfu-porsi-lerfu))) (dl (dt (tt "porsi")) (dd "A " (tt "lerfu-porsi") ".")) (p "Return the character at the current parse position " (tt "zva") " in the parse input " (tt "poi") ".") (p "It is an error if " (tt "porsi") " is not of type " (tt "lerfu-porsi") ".")) (def (sig (procedure "(lerfu-porsi-fanmo? porsi) => boolean" (id lerfu-porsi-fanmo?))) (dl (dt (tt "porsi")) (dd "A " (tt "lerfu-porsi") ".")) (p "Return " (tt "#t") " if this " (tt "porsi") " has no more input to parse, " (tt "#f") " otherwise.") (p "It is an error if " (tt "porsi") " is not of type " (tt "lerfu-porsi") "."))) (section 4 "javni-valsi" (def (sig (record "javni-valsi" (id javni-valsi))) (p "A " (tt "javni-valsi") " is a token with an (optionally) associated name generated from a " (tt "javni") ", indicating a match of that " (tt "javni") ".") (p "It contains the following members:") (dl (dt (tt "cme")) (dd "The name associated with this token, or " (tt "#f") " if there is no associated name.") (dt (tt "val")) (dd "The token generated from matching a rule."))) (def (sig (procedure "(make-javni-valsi cme val) => javni-valsi" (id make-javni-valsi))) (dl (dt (tt "cme")) (dd "The name associated with this token, or " (tt "#f") " if there is no associated name.") (dt (tt "val")) (dd "The token generated from matching a rule.")) (p "Create a " (tt "javni-valsi") " from the name " (tt "cme") " and the token " (tt "val") ".  If this " (tt "javni-valsi") " has no associated " (tt "cmene") ", " (tt "cme") " can be " (tt "#f") ".") (p (tt "val") " may be an object of any type, and is the current abstract syntax tree generated from this parse, as modified by " (tt "samselpla") " executed after the parse succeeds.")) (def (sig (procedure "(javni-valsi? valsi) => boolean" (id javni-valsi?))) (dl (dt (tt "valsi")) (dd "the object to test.")) (p "Return " (tt "#t") " if " (tt "valsi") " is of type " (tt "javni-valsi") " and " (tt "#f") " otherwise.")) (def (sig (procedure "(javni-valsi-cme valsi) => cmene" (id javni-valsi-cme))) (dl (dt (tt "valsi")) (dd "A " (tt "javni-valsi") ".")) (p "Return the " (tt "cmene") " member from " (tt "valsi") ".") (p "It is an error if " (tt "valsi") " is not of type " (tt "javni-valsi") ".")) (def (sig (procedure "(javni-valsi-val valsi) => val" (id javni-valsi-val))) (dl (dt (tt "valsi")) (dd "A " (tt "javni-valsi") ".")) (p "Return the " (tt "val") " member from " (tt "valsi") ".") (p "It is an error if " (tt "valsi") " is not of type " (tt "javni-valsi") ".")) (def (sig (procedure "(javni-nunvalsi-val nunvalsi) => val / (val ...)" (id javni-nunvalsi-val))) (dl (dt (tt "nunvalsi")) (dd "A " (tt "javni-valsi") " generator.")) (p "Generate the " (tt "javni-valsi") " from " (tt "nunvalsi") ".  If the result is a single " (tt "javni-valsi") ", return the " (tt "val") " member of that result.  Otherwise, treat the result as a tree containing " (tt "javnli-valsi") " and recursively retrieve the " (tt "val") " member from each " (tt "javni-valsi") " node in the tree.") (p "It is an error if " (tt "valsi") " is not (lists of) of type " (tt "javni-valsi") ".")) (def (sig (procedure "(javni-rodavalsi-val rodavalsi) => val / (val ...)" (id javni-rodavalsi-val))) (dl (dt (tt "rodavalsi")) (dd "A " (tt "javni-valsi") ".")) (p "This helper routine for " (tt "javni-nunvalsi-val") " returns the " (tt "val") " member of " (tt "rodavalsi") " if " (tt "rodavalsi") " is a " (tt "javni-valsi") ", calling itself recursively every time " (tt "rodavalsi") " is a list.") (p "It is an error if " (tt "valsi") " is not of type " (tt "javni-valsi") ".")) (def (sig (procedure "(javni-valsi->string valsi) => string" (id javni-valsi->string))) (dl (dt (tt "valsi")) (dd "A " (tt "javni-valsi") ".")) (p "Return A string representation of " (tt "valsi") ".  This string representation is for debug use only, and cannot be converted back to a " (tt "javni-valsi") ".") (p "It is an error if " (tt "valsi") " is not of type " (tt "javni-valsi") "."))) (section 4 "nunvalsi" (p "A routine that generates a " (tt "valsi") ".") (def (sig (procedure "(venunjmina-nunvalsi cmene) => nunvalsi" (id venunjmina-nunvalsi))) (dl (dt (tt "cmene")) (dd "The name to associated with the " (tt "nunvalsi"))) (p "If " (tt "cmene") " is not " (tt "#f") ", return a procedure that, when called, will produce a " (tt "javni-valsi") " with a " (tt "cme") " of " (tt "cmene") " and a " (tt "val") " resulting from calling the passed in " (tt "nunvalsi") ".") (p "This procedure is used by the ordered choice and optional " (tt "javni") " to generate new " (tt "nunvalsi") " when those rules have an associated cmene.")) (def (sig (procedure "(vejmina-nunvalsi cmene nunvalsi) => nunvalsi" (id vejmina-nunvalsi))) (dl (dt (tt "cmene") " The name to associate with the newly generated " (tt "nunvalsi") ".") (dt (tt "nunvalsi")) (dd "A " (tt "javni-valsi") " generator.")) (p "Create a new " (tt "javni-valsi") " with a " (tt "cme") " of " (tt "cmene") " and a " (tt "val") " from the " (tt "val") " of generating a " (tt "valsi") " from " (tt "nunvalsi") ".") (p "This routine is is generated by " (tt "venunjmina-nunvalsi") " when the caller provides a " (tt "cmene") ".")) (def (sig (procedure "(vejmina-nunvalsi-nacmene nunvalsi) => nunvalsi" (id vejmina-nunvalsi-nacmene))) (dl (dt (tt "nunvalsi")) (dd "A " (tt "javni-valsi") " generator.")) (p "Return " (tt "nunvalsi") ".  This routine is a no-op generated by " (tt "venunjmina-nunvalsi") " when the caller has not provided a " (tt "cmene") ".")) (def (sig (procedure "(venunjmina-rodanunvalsi cmene) => nunvalsi" (id venunjmina-rodanunvalsi))) (dl (dt (tt "cmene")) (dd "The name to associated with the " (tt "nunvalsi"))) (p "If " (tt "cmene") " is not " (tt "#f") ", return a procedure that, when called, will produce a " (tt "javni-valsi") " with a " (tt "cme") " of " (tt "cmene") " and a " (tt "val") " resulting from calling the passed in " (tt "nunvalsi") ".") (p "This procedure is used by the zero or more and sequence " (tt "javni") " to generate new " (tt "nunvalsi") " when those rules have an associated cmene.")) (def (sig (procedure "(vejmina-rodanunvalsi cmene . rodanunvalsi) => nunvalsi" (id vejmina-rodanunvalsi))) (dl (dt (tt "cmene") " The name to associate with the newly generated " (tt "nunvalsi") ".") (dt (tt "rodanunvalsi") " A list of " (tt "nunvalsi") ".")) (p "Create a new " (tt "javni-valsi") " with a " (tt "cme") " of " (tt "cmene") " and a " (tt "val") " being a list of the " (tt "val") " from the " (tt "valsi") " generated from each " (tt "nunvalsi") " in " (tt "rodanunvalsi") ".") (p "This routine is is generated by " (tt "venunjmina-rodanunvalsi") " when the caller provides a " (tt "cmene") ".")) (def (sig (procedure "(vejmina-rodanunvalsi-nacmene . rodanunvalsi) => nunvalsi" (id vejmina-rodanunvalsi-nacmene))) (dl (dt (tt "rodanunvalsi") " A list of " (tt "nunvalsi") ".")) (p "Create a new " (tt "javni-valsi") " with a " (tt "cme") " of " (tt "#f") " and a " (tt "val") " being a list of the " (tt "val") " from the " (tt "valsi") " generated from each " (tt "nunvalsi") " in " (tt "rodanunvalsi") ".") (p "This routine is generated by " (tt "venunjmina-rodanunvalsi") " when the caller does not provide a " (tt "cmene") "."))) (section 4 "nunjavni" (p "A routine that generates a " (tt "javni") ".") (def (sig (procedure "(nunjavni-lerfu lerfu #!key cmene) => javni" (id nunjavni-lerfu))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching " (tt "lerfu") ".") (dt (tt "lerfu")) (dd "The character to match.")) (p "Generate a " (tt "javni") " that matches a single " (tt "lerfu") ".") (p (tt "nunjavni-lerfu") " corresponds to a nonterminal symbol in PEG syntax.")) (def (sig (procedure "(nunjavni-. #!key cmene) => javni" (id nunjavni-.))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching the next character.")) (p "Generate a " (tt "javni") " that matches the next character in the parse input, regardless of what that character is.  Call " (tt "mapti") " with the matched character.  If there are no characters remaining in the parse input, call " (tt "namapti") ".")) (def (sig (procedure "(nunjavni-e #!key cmene) => javni" (id nunjavni-e))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by this rule.")) (p "Generate a " (tt "javni") " that matches the empty string.") (p (tt "nunjavni-fanmo") " corresponds to the empty string expression in PEG syntax.")) (def (sig (procedure "(nunjavni-fanmo #!key cmene) => javni" (id nunjavni-fanmo))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching the end of the " (tt "lerfu-porsi") ".")) (p "Generate a " (tt "javni") " that matches the end of the " (tt "lerfu-porsi") ".") (p (tt "nunjavni-fanmo") " corresponds to a nonterminal symbol in PEG syntax.")) (def (sig (procedure "(nunjavni-valsi valsi #!key cmene) => javni" (id nunjavni-valsi))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching " (tt "cmene") ".") (dt (tt "valsi")) (dd "The string to try to match.")) (p "Generate a " (tt "javni") " that matches the parse input against " (tt "valsi") ".") (p (tt "nunjavni-valsi") " matches a literal string, and will be faster than " (tt "nunjavni-re") " or a composition of individual " (tt "nunjavni-lerfu") " when the input to match can be expressed as a literal string.")) (def (sig (procedure "(nunjavni-re pattern #!key cmene) => javni" (id nunjavni-re))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching " (tt "pattern") ".") (dt (tt "pattern")) (dd "the regular expression to try to match.")) (p "Generate a " (tt "javni") " that matches the next character(s) in the parse input against the regular expression " (tt "pattern") ".  If " (tt "pattern") " matches the next character(s) in the parse input, call " (tt "mapti") " with the matched characters.  Otherwise continue with " (tt "namapti") ".") (p "The character " (tt "#\\^") " is prepended to " (tt "pattern") " before compiling the regular expression.")) (def (sig (procedure "(nunjavni-* sumti-javni #!key cmene) => javni" (id nunjavni-*))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching " (tt "sumti-javni") ".") (dt (tt "sumti-javni")) (dd "The rule to match zero-or-more times.")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") " until it generates a " (tt "namapti") ".  The " (tt "javni") " returned by " (tt "nunjavni-*") " never calls its " (tt "namapti") " continuation, always calling " (tt "mapti") ".") (p (tt "nunjavni-*") " corresponds to the zero-or-more expression in PEG syntax.")) (def (sig (procedure "(nunjavni-+ sumti-javni #!key cmene) => javni" (id nunjavni-+))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by this rule.") (dt (tt "sumti-javni")) (dd "The rule to match one-or-more times.")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") " until it generates a " (tt "namapti") ".  The " (tt "javni") " returned by " (tt "nunjavni-+") " calls " (tt "mapti") " if the passed in " (tt "sumti-javni") " matches one or more times, and calls " (tt "namapti") " if " (tt "sumti-javni") " does not match.") (p (tt "nunjavni-+") " corresponds to the one-or-more expression in PEG syntax.")) (def (sig (procedure "(nunjavni-? sumti-javni #!key cmene) => javni" (id nunjavni-?))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by this rule.") (dt (tt "sumti-javni")) (dd "The rule to optionally match.")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") ". The " (tt "javni") " returned by " (tt "nunjavni-?") " never calls its " (tt "namapti") " continuation, always calling " (tt "mapti") ".") (p (tt "nunjavni-?") " corresponds to the optional expression in PEG syntax.")) (def (sig (procedure "(nunjavni-& sumti-javni) => javni" (id nunjavni-&))) (dl (dt (tt "sumti-javni")) (dd "The rule to match.")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") ". The " (tt "javni") " returned by " (tt "nunjavni-&") " calls " (tt "mapti") " or " (tt "namapti") " according to the result from " (tt "sumti-javni") ", but it does not advances the " (tt "lerfu-porsi") " when " (tt "mapti") " is called.") (p (tt "nunjavni-*") " corresponds to the and-predicate expression in PEG syntax.")) (def (sig (procedure "(nunjavni-! sumti-javni) => javni" (id nunjavni-!))) (dl (dt (tt "sumti-javni")) (dd "The rule to match.")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") ". The " (tt "javni") " returned by " (tt "nunjavni-&") " calls " (tt "mapti") " if the " (tt "sumti-javni") " calls " (tt "namapti") ", and it calls " (tt "mapti") " if the " (tt "sumti-javni") " calls " (tt "namapti") ".") (p (tt "nunjavni-!") " corresponds to the not-predicate expression in PEG syntax.")) (def (sig (procedure "(nunjavni-je #!rest rodajavni #!key cmene) => javni" (id nunjavni-je))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching all " (tt "rodajavni") ".") (dt (tt "rodajavni")) (dd "one or more rules to match in sequence.")) (p "Generate a " (tt "javni") " that runs each " (tt "javni") " in the passed in " (tt "rodajavni") " in order.  The " (tt "javni") " returned by " (tt "nunjavni-je") " calls " (tt "mapti") " if every " (tt "javni") " in " (tt "rodajavni") " matches, and " (tt "namapti") " if any " (tt "javnri") " in " (tt "rodajavni") " does not match.") (p (tt "nunjavni-je") " corresponds to the sequence expression in PEG syntax.")) (def (sig (procedure "(nunjavni-jonai #!rest rodajavni #!key cmene) => javni" (id nunjavni-jonai))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching any " (tt "rodajavni") ".") (dt (tt "rodajavni")) (dd "one or more rules to match in sequence.")) (p "Generate a " (tt "javni") " that runs each " (tt "javni") " in the passed in " (tt "rodajavni") " in order.  The " (tt "javni") " returned by " (tt "nunjavni-jonai") " calls " (tt "mapti") " with the result from the first " (tt "javni") " in " (tt "rodajavni") " that matches, ignoring all remaining " (tt "javni") " in " (tt "rodajavni") ". " (tt "nunjavni-je") " calls " (tt "namapti") " if all the " (tt "javni") " in " (tt "rodajavni") " do not match.") (p (tt "nunjavni-je") " corresponds to the ordered-choice expression in PEG syntax.")) (def (sig (procedure "(nunjavni-morji sumti-javni) => javni" (id nunjavni-morji))) (dl (dt (tt "sumti-javni")) (dd "the rule to match.")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") " and stores the result.  If the " (tt "javni") " returned by " (tt "nunjavni-morji") " is called again with the same " (tt "lerfu-porsi") ", the stored " (tt "mapti") " or " (tt "namapti") " is called instead of calling " (tt "sumti-javni") " again.") (p (tt "nunjavni-je") " corresponds to memoization in packrat parsing.") (p "Unlink other nunjavni, this rule generator does not accept a " (tt "cmene") " key.")) (def (sig (syntax "(nunjavni-naselci sumti-javni #!key cmene: cmene) => javni" (id nunjavni-naselci))) (dl (dt (tt "sumti-javni")) (dd "the rule defined in the environment being captured.") (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching " (tt "sumti-javni") ".")) (p (tt "nunjavni-nasleci") " encloses " (tt "sumti-javni") " in a lambda, which captures the environment in which " (tt "sumti-javni") " is defined.") (p "This macro is used in the letrec used to define the non-terminals in a grammar to allow mutual recursion of non-terminals.")) (def (sig (procedure "(nunjavni-samselpla samselpla sumti-javni #!key cmene) => javni" (id nunjavni-samselpla))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching " (tt "sumti-javni") " and executing " (tt "samselpla") ".") (dt (tt "samselpla")) (dd "the code to execute if the generated " (tt "javni") " calls " (tt "mapti") ".") (dt (tt "sumti-javni")) (dd "The rule generating " (tt "javni-valsi") " for " (tt "samselpla") ".")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") " and, if the " (tt "sumti-javni") " calls " (tt "mapti") ", calls " (tt "samselpla") " by passing any tokens in the " (tt "jalga") " with associated " (tt "cmene") " as DSSL-style #!key parameters.") (p "If " (tt "sumti-javni") " does not match, " (tt "samselpla") " is not called. There is no way to execute code for a " (tt "namapti") ", as there is only a single " (tt "namapti") " called during a parse.  Code that should be executed when a parse fails can be run after the parse completes; see " (tt "genturfahi") ".")) (def (sig (procedure "(nunjavni-cmene sumti-javni #!key cmene) => javni" (id nunjavni-cmene))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching " (tt "sumti-javni") ".") (dt (tt "sumti-javni")) (dd "the rule to match.")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") " and, if the " (tt "sumti-javni") " matches, associates " (tt "cmene") " with the " (tt "javni-valsi") " associated with the " (tt "mapti") ".") (p "If " (tt "sumti-javni") " does not match, call " (tt "namapti") " without associating " (tt "cmene") " with the result.") (p "All terminal " (tt "javni") " accept a cmene: argument, which should be used in preference to this function.  This function is required when matching a " (tt "javni-naselci") ", as we can't tell at compile-time that we will associate a " (tt "cmene") " with that " (tt "javni") ".  Instead, the binding waits until runtime where it is performed by this function."))) (section 4 "javni" (p "A routine that, given a " (tt "lerfu-porsi") ", creates a " (tt "javni-valsi") " indicating match or nonmatch of that " (tt "javni") " for that " (tt "lerfu-porsi") ". This " (tt "javni-valsi") " is then forwarded to the next " (tt "javni") " by means of calling " (tt "mapti") " for a match or " (tt "namapti") " for a non-match.") (p "A " (tt "javni") " is provided the following parameters:") (def (sig (procedure "(javni lerfu-porsi mapti namapti) => jalge" (id javni))) (dl (dt (tt "lerfu-porsi")) (dd "the current parse position.") (dt (tt "mapti")) (dd "continuation for rule match.") (dt (tt "namapti")) (dd "continuation for rule non-match.")) (p "Note that " (tt "jalge") " is not returned until the entire parse succeeds, and may not return at all on failure, if another path succeeds in the parse."))) (section 4 "mapti .ijo namapti" (p "A " (tt "mapti") " is a continuation called by a " (tt "javni") " when that " (tt "javni") " matches the current " (tt "lerfu-porsi") ".") (p "A " (tt "namapti") " is a continuation called by a " (tt "javni") " when that " (tt "javni") " does not match the current {lerfu-porsi}.") (p (tt "mapti") " and " (tt "namapti") " have the signatures:") (def (sig (procedure "(mapti lerfu-porsi nunvalsi) => jalge" (id mapti)) (procedure "(namapti lerfu-porsi) => jalge" (id namapti))) (dl (dt (tt "lerfu-porsi")) (dd "The current parse position.") (dt (tt "nunvalsi")) (dd "A generated returning the current parse result.")) (p (tt "genturfahi") " accepts the top-level parse rule and returns the result to the caller, rather than calling any additional " (tt "mapti") " or " (tt "namapti") "."))) (section 4 "genturfahi" (def (sig (procedure "(genturfahi-tolmohi) => '()" (id genturfahi-tolmohi))) (p "Clear the memoization cache.  This is done automatically after each parse.")) (def (sig (procedure "(genturfahi javni) => rodavalsi" (id genturfahi))) (dl (dt (tt "javni")) (dd "The starting rule of the grammar.")) (p "Parse the " (tt "javni") ", which is assumed to be the initial rule of the grammar.  Return " (tt "rodavalsi") ", the result of the parse.") (p "If the parse succeed, " (tt "rodavalsi") " is the abstract syntax tree as modified by any " (tt "samselpla") " embedded in the grammar.  If the parse failed, " (tt "#f") " is returned.  In both cases, the " (tt "lerfu-porsi") " representing the input remaining after the parse is returned as a second value.")) (def (sig (procedure "(genturfahi* javni) => (rodavalsi lefpoi)" (id genturfahi*))) (dl (dt (tt "javni")) (dd "The starting rule of the grammar.")) (p (tt "genturfahi*") " calls " (tt "genturfahi") " and converts the multiple arguments returned by " (tt "genturfahi") " to a list and returns them.") (p "This routine is used in the test framework, and might be useful elsewhere.")) (def (sig (procedure "(genturfahi-peg port) => genturfahi" (id genturfahi-peg))) (dl (dt (tt "port")) (dd "The port from which to read the PEG grammar.")) (p (tt "genturfahi-peg") " parses a PEG grammar from " (tt "port") " and returns scheme code that will generate a parser for that grammar.") (p "Note that the expression returned from this procedure is designed to be written to a file and loaded later.  It must be evaluated with eval if it is going to be used immediately.")) (def (sig (procedure "(genturfahi-peg* port) => genturfahi" (id genturfahi-peg*))) (dl (dt (tt "port")) (dd "The port from which to read the PEG grammar.")) (p (tt "genturfahi-peg*") " calls " (tt "genturfahi-peg") " and converts the multiple arguments returned by " (tt "genturfahi-peg") " to a list and returns them.") (p "This routine is used in the test framework, and might be useful elsewhere.")) (def (sig (parameter "genturfahi-status" (id genturfahi-status))) (p "The exit status of the parser.  If the parse input does not match the parser, " (tt "genturfahi-status") " is 1.  Otherwise, " (tt "genturfahi-status") " is zero.") (p "The value of " (tt "genturfahi-status") " is passed to " (tt "exit") " once the parse completes.")) (def (sig (constant "genturfahi-version-major" (id genturfahi-version-major))) (p "A number representing the major version of this module.")) (def (sig (constant "genturfahi-version-minor" (id genturfahi-version-minor))) (p "A number representing the minor version of this module.")) (def (sig (constant "genturfahi-version-patch" (id genturfahi-version-patch))) (p "A number representing the patch version of this module.")) (def (sig (constant "genturfahi-version" (id genturfahi-version))) (p "A string representing the version number of this module."))) (section 4 "Examples" (p "These examples show how to use the " (tt "genturfahi") " API to construct a parser.") (section 5 "Operators" (highlight scheme ";;;; lerfu.scm\n\n(use genturfahi)\n(use test)\n;;;\n;;; terminal:\n;;;\n;;; lerfu <- \\#a\n;;;\n(define (lerfu)\n  (set! genturfahi-lerfu\n        (genturfahi* (nunjavni-lerfu #\\a)))\n\n  ; match the only character this parser matches.\n  ;\n  (test '(#\\a \"\") (genturfahi-lerfu \"a\"))\n\n  ; There is no rule to match any other character,\n  ; so they don't match.\n  ;\n  (test '(#f \"b\") (genturfahi-lerfu \"b\"))\n  (test '(#f \"c\") (genturfahi-lerfu \"c\"))\n\n  ; there is no rule for the emtpy\n  ; string, no match\n  ;\n  (test '(#f \"\") (genturfahi-lerfu \"\"))\n\n  ; there is no rule for the end-of-file\n  ; These match, but they don't parse the\n  ; whole buffer!\n  ;\n  ; this rule won't even match two #\\a,\n  ; only one.\n  ;\n  (test '(#\\a \"a\") (genturfahi-lerfu \"aa\"))\n  (test '(#\\a \"b\") (genturfahi-lerfu \"ab\"))\n  (test '(#\\a \"c\") (genturfahi-lerfu \"ac\"))\n\n  ; later characters that would match\n  ; don't if there is no rule to match\n  ; earlier characters.\n  ;\n  (test '(#f \"da\") (genturfahi-lerfu \"da\"))\n  0)\n\n(test-group \"lerfu\"\n  (lerfu))") (highlight scheme ";;;; optional.scm\n\n(use genturfahi)\n(use test)\n\n;;;\n;;; optional: e?\n;;;\n;;; optional <- \\#a?\n;;;\n(define (optional?)\n  (set! genturfahi-optional\n        (genturfahi* (nunjavni-? (nunjavni-lerfu #\\a))))\n\n  ; match the only character this parser matches.\n  ;\n  (test '(#\\a \"\") (genturfahi-optional \"a\"))\n\n  ; There is no rule to match any other character,\n  ; but since this rule is optional, the empty string\n  ; is returned.\n  ;\n  (test '(\"\" \"b\") (genturfahi-optional \"b\"))\n  (test '(\"\" \"c\") (genturfahi-optional \"c\"))\n\n  ; there is no rule for the emtpy string, but the\n  ; optional rule matches anyway.\n  ;\n  (test '(\"\" \"\") (genturfahi-optional \"\"))\n\n  ; there is no rule for the end-of-file\n  ; These match, but they don't parse the\n  ; whole buffer!\n  ;\n  ; this rule won't even match two #\\a,\n  ; only zero or one.\n  ;\n  (test '(#\\a \"a\") (genturfahi-optional \"aa\"))\n  (test '(#\\a \"b\") (genturfahi-optional \"ab\"))\n  (test '(#\\a \"c\") (genturfahi-optional \"ac\"))\n\n  ; later characters that would match don't if there\n  ; is no rule to match earlier characters.  We match\n  ; zero #\\a at the beginning of the parser input and\n  ; return.\n  ;\n  (test '(\"\" \"da\") (genturfahi-optional \"da\"))\n  0)\n\n(test-group \"optional?\"\n  (optional?))") (highlight scheme ";;;; zero-or-more.scm\n\n(use genturfahi)\n(use test)\n\n;;;\n;;; zero-or-more: e*\n;;;\n;;; zero-or-more <- \\#a*\n;;;\n(define (zero-or-more)\n  (set! genturfahi-zero-or-more\n        (genturfahi* (nunjavni-* (nunjavni-lerfu #\\a))))\n\n  ; match the only character this parser matches.\n  ; notice that it returns a list of characters,\n  ; even if it only matches a single character.\n  ;\n  (test '((#\\a) \"\") (genturfahi-zero-or-more \"a\"))\n\n  ; though the rule matches even when the character isn't present\n  ; the empty list indicates no characters matched.\n  ;\n  (test '(() \"\") (genturfahi-zero-or-more \"\"))\n\n  ; We match as many #\\a as we can.\n  ;\n  (test '((#\\a #\\a) \"\") (genturfahi-zero-or-more \"aa\"))\n  (test '((#\\a #\\a #\\a) \"\") (genturfahi-zero-or-more \"aaa\"))\n\n  ; There is no rule to match any other character,\n  ; but since this rule matches zero-or-more, it\n  ; succeeds in matching zero #\\a.\n  ;\n  (test '(() \"b\") (genturfahi-zero-or-more \"b\"))\n  (test '(() \"c\") (genturfahi-zero-or-more \"c\"))\n\n  ; As well, it will match all #\\a before ending\n  ; the parse.  These match, but they don't parse\n  ; the whole buffer!\n  ;\n  (test '((#\\a) \"b\") (genturfahi-zero-or-more \"ab\"))\n  (test '((#\\a) \"c\") (genturfahi-zero-or-more \"ac\"))\n\n  (test '((#\\a #\\a) \"b\") (genturfahi-zero-or-more \"aab\"))\n  (test '((#\\a #\\a) \"c\") (genturfahi-zero-or-more \"aac\"))\n\n  (test '((#\\a #\\a #\\a) \"b\") (genturfahi-zero-or-more \"aaab\"))\n  (test '((#\\a #\\a #\\a) \"c\") (genturfahi-zero-or-more \"aaac\"))\n\n  ; later characters that would match don't if there is no rule\n  ; to match earlier characters.  This rule matches the empty\n  ; list, but can't access the #\\a later in the parse input.\n  ;\n  (test '(() \"da\") (genturfahi-zero-or-more \"da\"))\n  (test '(() \"daa\") (genturfahi-zero-or-more \"daa\"))\n  (test '(() \"daaa\") (genturfahi-zero-or-more \"daaa\"))\n  0)\n\n(test-group \"zero-or-more\"\n  (zero-or-more))") (highlight scheme ";;;; one-or-more.scm\n\n(use genturfahi)\n(use test)\n\n;;;\n;;; one-or-more: e+\n;;;\n;;; one-or-more <- \\#a+\n;;;\n(define (one-or-more)\n  (set! genturfahi-one-or-more\n        (genturfahi* (nunjavni-+ (nunjavni-lerfu #\\a))))\n\n  ; match the only character this parser matches.\n  ; notice that it returns a list of characters,\n  ; even if it only matches a single character.\n  ;\n  (test '((#\\a) \"\") (genturfahi-one-or-more \"a\"))\n\n  ; We match as many #\\a as we can.\n  ;\n  (test '((#\\a #\\a) \"\") (genturfahi-one-or-more \"aa\"))\n  (test '((#\\a #\\a #\\a) \"\") (genturfahi-one-or-more \"aaa\"))\n\n  ; but we don't match zero #\\a.\n  ;\n  (test '(#f \"\") (genturfahi-one-or-more \"\"))\n  (test '(#f \"b\") (genturfahi-one-or-more \"b\"))\n  (test '(#f \"c\") (genturfahi-one-or-more \"c\"))\n\n  ; As well, it will match all #\\a before ending\n  ; the parse.  These match, but they don't parse\n  ; the whole buffer!\n  ;\n  (test '((#\\a) \"b\") (genturfahi-one-or-more \"ab\"))\n  (test '((#\\a) \"c\") (genturfahi-one-or-more \"ac\"))\n\n  (test '((#\\a #\\a) \"b\") (genturfahi-one-or-more \"aab\"))\n  (test '((#\\a #\\a) \"c\") (genturfahi-one-or-more \"aac\"))\n\n  (test '((#\\a #\\a #\\a) \"b\") (genturfahi-one-or-more \"aaab\"))\n  (test '((#\\a #\\a #\\a) \"c\") (genturfahi-one-or-more \"aaac\"))\n\n  ; later characters that would match don't if there is no rule\n  ; to match earlier characters.  These rules don't match, as\n  ; the input does not begin with #\\a.\n  ;\n  (test '(#f \"da\") (genturfahi-one-or-more \"da\"))\n  (test '(#f \"daa\") (genturfahi-one-or-more \"daa\"))\n  (test '(#f \"daaa\") (genturfahi-one-or-more \"daaa\"))\n  0)\n\n(test-group \"one-or-more\"\n  (one-or-more))") (highlight scheme ";;;; je.scm\n\n(use genturfahi)\n(use test)\n\n;;;\n;;; ordered sequence: e_1 e_2\n;;;\n;;; je <- \\#a \\#b \\#c\n;;;\n(define (je)\n  (set! genturfahi-je\n        (genturfahi* (nunjavni-je (nunjavni-lerfu #\\a)\n                                  (nunjavni-lerfu #\\b)\n                                  (nunjavni-lerfu #\\c))))\n\n  ; matches each lerfu in sequence \n  ;\n  (test '((#\\a #\\b #\\c) \"\") (genturfahi-je \"abc\"))\n\n  ; matches the first rule (#\\a), but not the second or\n  ; third (#\\b and #\\c), so this match fails.\n  ;\n  (test '(#f \"a\") (genturfahi-je \"a\"))\n  (test '(#f \"ac\") (genturfahi-je \"ac\"))\n\n  ; matches the first two rules (#\\a and #\\b), but not\n  ; the third one.\n  ;\n  (test '(#f \"ab\") (genturfahi-je \"ab\"))\n  (test '(#f \"abd\") (genturfahi-je \"abd\"))\n\n  ; \"abc\" is the only correct sequence.  Every other\n  ; combination of #\\a, #\\b, and #\\c does not match.\n  ;\n  (test '(#f \"acb\") (genturfahi-je \"acb\"))\n  (test '(#f \"bac\") (genturfahi-je \"bac\"))\n  (test '(#f \"bca\") (genturfahi-je \"bca\"))\n  (test '(#f \"cab\") (genturfahi-je \"cab\"))\n  (test '(#f \"cba\") (genturfahi-je \"cba\"))\n\n  ; there is no rule for #\\d, no match\n  ;\n  (test '(#f \"d\") (genturfahi-je \"d\"))\n\n  ; there is no rule for the emtpy\n  ; string, no match\n  ;\n  (test '(#f \"\") (genturfahi-je \"\"))\n\n  ; there is no rule for the end-of-file\n  ; These match, but they don't parse the\n  ; whole buffer!\n  ;\n  (test '((#\\a #\\b #\\c) \"a\") (genturfahi-je \"abca\"))\n  (test '((#\\a #\\b #\\c) \"b\") (genturfahi-je \"abcb\"))\n  (test '((#\\a #\\b #\\c) \"c\") (genturfahi-je \"abcc\"))\n\n  ; later characters that would match\n  ; don't if there is no rule to match\n  ; earlier characters.\n  ;\n  (test '(#f \"dabc\") (genturfahi-je \"dabc\"))\n  0)\n\n(test-group \"je\"\n  (je))") (highlight scheme ";;;; jonai.scm\n\n(use genturfahi)\n(use test)\n\n;;;\n;;; ordered-choice: e_1 / e_2\n;;;\n;;; jonai <- \\#a / \\#b / \\#c\n;;;\n(define (jonai)\n  (set! genturfahi-jonai\n        (genturfahi* (nunjavni-jonai (nunjavni-lerfu #\\a)\n                                     (nunjavni-lerfu #\\b)\n                                     (nunjavni-lerfu #\\c))))\n\n  ; matches (nunjavni-jonai (nunjavni-lerfu #\\a) ...)\n  ;\n  (test '(#\\a \"\") (genturfahi-jonai \"a\"))\n\n  ; matches (nunjavni-jonai ... (nunjavni-lerfu #\\b) ...)\n  ;\n  (test '(#\\b \"\") (genturfahi-jonai \"b\"))\n\n  ; matches (nunjavni-jonai ... (nunjavni-lerfu #\\c))\n  ;\n  (test '(#\\c \"\") (genturfahi-jonai \"c\"))\n\n  ; there is no rule for #\\d, no match\n  ;\n  (test '(#f \"d\") (genturfahi-jonai \"d\"))\n\n  ; there is no rule for the emtpy\n  ; string, no match\n  ;\n  (test '(#f \"\") (genturfahi-jonai \"\"))\n\n  ; there is no rule for the end-of-file\n  ; These match, but they don't parse the\n  ; whole buffer!\n  ;\n  (test '(#\\a \"a\") (genturfahi-jonai \"aa\"))\n  (test '(#\\a \"b\") (genturfahi-jonai \"ab\"))\n  (test '(#\\a \"c\") (genturfahi-jonai \"ac\"))\n\n  ; later characters that would match\n  ; don't if there is no rule to match\n  ; earlier characters.\n  ;\n  ; none of these match.\n  ;\n  (test '(#f \"da\") (genturfahi-jonai \"da\"))\n  (test '(#f \"db\") (genturfahi-jonai \"db\"))\n  (test '(#f \"dc\") (genturfahi-jonai \"dc\"))\n  0)\n\n(test-group \"jonai\"\n  (jonai))") (highlight scheme ";;;; and-predicate.scm\n\n(use genturfahi)\n(use test)\n\n;;;\n;;; and-predicate: &e\n;;;\n;;; and-predicate <- &\\#a\n;;;\n(define (and-predicate)\n  (set! genturfahi-and-predicate\n        (genturfahi* (nunjavni-& (nunjavni-lerfu #\\a))))\n\n  ; the and-predicate matches as normal, but does not advance\n  ; the input.\n  ;\n  (test '(#\\a \"a\") (genturfahi-and-predicate \"a\"))\n\n  ; It behaves like all other rules when there is no match,\n  ; indicating no match.\n  ;\n  (test '(#f \"b\") (genturfahi-and-predicate \"b\"))\n  (test '(#f \"c\") (genturfahi-and-predicate \"c\"))\n\n  ; there is no rule for the emtpy\n  ; string, no match\n  ;\n  (test '(#f \"\") (genturfahi-and-predicate \"\"))\n\n  ; there is no rule for the end-of-file\n  ; These match, but they don't parse the\n  ; whole buffer!\n  ;\n  ; this rule won't even match two #\\a,\n  ; only one.\n  ;\n  (test '(#\\a \"aa\") (genturfahi-and-predicate \"aa\"))\n  (test '(#\\a \"ab\") (genturfahi-and-predicate \"ab\"))\n  (test '(#\\a \"ac\") (genturfahi-and-predicate \"ac\"))\n\n  ; later characters that would match\n  ; don't if there is no rule to match\n  ; earlier characters.\n  ;\n  (test '(#f \"da\") (genturfahi-and-predicate \"da\"))\n  0)\n\n(test-group \"and-predicate\"\n  (and-predicate))") (highlight scheme ";;;; not-predicate.scm\n\n(use genturfahi)\n(use test)\n\n;;;\n;;; not-predicate: !e\n;;;\n;;; not-predicate <- !\\#a\n;;;\n(define (not-predicate)\n  (set! genturfahi-not-predicate\n        (genturfahi* (nunjavni-! (nunjavni-lerfu #\\a))))\n\n  ; this not-predicate matches everything *but* \\#a.\n  ; not-predicate never advances the input.\n  ;\n  ; on match, we return the empty string.\n  ;\n  (test '(#f \"a\") (genturfahi-not-predicate \"a\"))\n  (test '(\"\" \"b\") (genturfahi-not-predicate \"b\"))\n  (test '(\"\" \"c\") (genturfahi-not-predicate \"c\"))\n\n  ; we match the empty string (because the empty string\n  ; isn't #\\a.)\n  ;\n  (test '(\"\" \"\") (genturfahi-not-predicate \"\"))\n\n  ; there is no rule for the end-of-file\n  ; These don't parse the whole buffer!\n  ;\n  (test '(#f \"aa\") (genturfahi-not-predicate \"aa\"))\n  (test '(#f \"ab\") (genturfahi-not-predicate \"ab\"))\n  (test '(#f \"ac\") (genturfahi-not-predicate \"ac\"))\n  (test '(\"\" \"ba\") (genturfahi-not-predicate \"ba\"))\n  (test '(\"\" \"bb\") (genturfahi-not-predicate \"bb\"))\n  (test '(\"\" \"bc\") (genturfahi-not-predicate \"bc\"))\n  (test '(\"\" \"ca\") (genturfahi-not-predicate \"ca\"))\n  (test '(\"\" \"cb\") (genturfahi-not-predicate \"cb\"))\n  (test '(\"\" \"cc\") (genturfahi-not-predicate \"cc\"))\n  0)\n\n(test-group \"not-predicate\"\n  (not-predicate))") (highlight scheme ";;;; empty-string.scm\n\n(use genturfahi)\n(use test)\n\n;;;\n;;; empty-string:\n;;;\n;;; empty-string <- \"\"\n;;;\n(define (empty-string)\n  (set! genturfahi-empty-string (genturfahi* (nunjavni-e)))\n\n  ; the empty string is zero characters long, so\n  ; it always matches.\n  ;\n  (test '(\"\" \"\") (genturfahi-empty-string \"\"))\n  (test '(\"\" \"a\") (genturfahi-empty-string \"a\"))\n  (test '(\"\" \"b\") (genturfahi-empty-string \"b\"))\n  (test '(\"\" \"c\") (genturfahi-empty-string \"c\"))\n  (test '(\"\" \"abc\") (genturfahi-empty-string \"abc\"))\n  0)\n\n(test-group \"empty-string\"\n  (empty-string))") (highlight scheme ";;;; end-of-input.scm\n\n(use genturfahi)\n(use test)\n\n;;;\n;;; end-of-input:\n;;;\n;;; end-of-input <- [eof]\n;;;\n(define (end-of-input)\n  (set! genturfahi-eof (genturfahi* (nunjavni-fanmo)))\n\n  ; The end of file only matches when we're at the end of\n  ; the parse input.\n  ;\n  (test '(#\\nul \"\") (genturfahi-eof \"\"))\n\n  ; it doesn't match if here are any characters left.\n  ;\n  (test '(#f \"a\") (genturfahi-eof \"a\"))\n  (test '(#f \"b\") (genturfahi-eof \"b\"))\n  (test '(#f \"c\") (genturfahi-eof \"c\"))\n\n  ; even if those remaining characters are the sentinel. \n  ;\n  (test `(#f ,(make-string 1 #\\nul)) (genturfahi-eof (make-string 1 #\\nul)))\n  0)\n\n(test-group \"end-of-input\"\n  (end-of-input))") (highlight scheme ";; jonai-naselci.scm: nonterminal symbols\n\n(use genturfahi)\n(use test)\n\n;;;\n;;; ordered choice with non-terminals\n;;; this test is identical to the ordered choice file, though the\n;;; grammar differs.\n;;;\n;;; jonai <- a / b / c\n;;; a     <- #\\a\n;;; b     <- #\\a\n;;; c     <- #\\a\n;;;\n(define (jonai-naselci)\n  (set! genturfahi-jonai-naselci\n    (letrec ((gerna (nunjavni-morji (nunjavni-jonai (nunjavni-naselci a)\n                                                    (nunjavni-naselci b)\n                                                    (nunjavni-naselci c))))\n             (a (nunjavni-morji (nunjavni-lerfu #\\a)))\n             (b (nunjavni-morji (nunjavni-lerfu #\\b)))\n             (c (nunjavni-morji (nunjavni-lerfu #\\c))))\n      (genturfahi* gerna)))\n\n  ; matches (nunjavni-jonai-naselci (nunjavni-lerfu #\\a) ...)\n  ;\n  (test '(#\\a \"\") (genturfahi-jonai-naselci \"a\"))\n\n  ; matches (nunjavni-jonai-naselci ... (nunjavni-lerfu #\\b) ...)\n  ;\n  (test '(#\\b \"\") (genturfahi-jonai-naselci \"b\"))\n\n  ; matches (nunjavni-jonai-naselci ... (nunjavni-lerfu #\\c))\n  ;\n  (test '(#\\c \"\") (genturfahi-jonai-naselci \"c\"))\n\n  ; there is no rule for #\\d, no match\n  ;\n  (test '(#f \"d\") (genturfahi-jonai-naselci \"d\"))\n\n  ; there is no rule for the emtpy\n  ; string, no match\n  ;\n  (test '(#f \"\") (genturfahi-jonai-naselci \"\"))\n\n  ; there is no rule for the end-of-file\n  ; These match, but they don't parse the\n  ; whole buffer!\n  ;\n  (test '(#\\a \"a\") (genturfahi-jonai-naselci \"aa\"))\n  (test '(#\\a \"b\") (genturfahi-jonai-naselci \"ab\"))\n  (test '(#\\a \"c\") (genturfahi-jonai-naselci \"ac\"))\n\n  ; later characters that would match\n  ; don't if there is no rule to match\n  ; earlier characters.\n  ;\n  ; none of these match.\n  ;\n  (test '(#f \"da\") (genturfahi-jonai-naselci \"da\"))\n  (test '(#f \"db\") (genturfahi-jonai-naselci \"db\"))\n  (test '(#f \"dc\") (genturfahi-jonai-naselci \"dc\"))\n  0)\n\n(test-group \"naselci\"\n  (jonai-naselci))")) (section 5 "Executing Code" (highlight scheme ";; simple (no-op) example\n\n(use genturfahi)\n\n;; XXX: I haven't written this example yet!") (highlight scheme ";; samselpla.scm\n\n(use genturfahi)\n(use test)\n\n;;;\n;;; execute code on syntax tree.\n;;;\n;;; gerna <- a b c\n;;; a     <- #\\a\n;;; b     <- #\\b\n;;; c     <- #\\c\n;;;\n(define (samselpla)\n  (set! genturfahi-samselpla\n    (letrec ((gerna (nunjavni-morji\n               ; concatenate the strings\n               (nunjavni-samselpla\n                 (lambda (#!key a b c) (string-append a b c))\n                 (nunjavni-je\n                   (nunjavni-cmene (nunjavni-naselci a) cmene: 'a:)\n                   (nunjavni-cmene (nunjavni-naselci b) cmene: 'b:)\n                   (nunjavni-cmene (nunjavni-naselci c) cmene: 'c:)))))\n             (a (nunjavni-morji\n               ; convert each character to a string.\n               (nunjavni-samselpla\n                 (lambda (#!key lerfu) (make-string 1 lerfu))\n                 (nunjavni-lerfu #\\a cmene: 'lerfu:))))\n             (b (nunjavni-morji\n               (nunjavni-samselpla\n                 (lambda (#!key lerfu) (make-string 1 lerfu))\n                 (nunjavni-lerfu #\\b cmene: 'lerfu:))))\n             (c (nunjavni-morji\n               (nunjavni-samselpla\n                 (lambda (#!key lerfu) (make-string 1 lerfu))\n                 (nunjavni-lerfu #\\c cmene: 'lerfu:)))))\n      (genturfahi* gerna)))\n\n  ; The code runs only after a a syntax tree is successfully\n  ; generated.\n  ;\n  (test '(\"abc\" \"\") (genturfahi-samselpla \"abc\"))\n\n  ; It doesn't run at all if we fail to parse.\n  ;\n  (test '(#f \"d\") (genturfahi-samselpla \"d\"))\n\n  ; Even if the parse partially matches before failing.\n  ;\n  (test '(#f \"a\") (genturfahi-samselpla \"a\"))\n  (test '(#f \"ab\") (genturfahi-samselpla \"ab\"))\n\n  ; But if we don't parse all of the input, that\n  ; is a valid parse.\n  ;\n  (test '(\"abc\" \"a\") (genturfahi-samselpla \"abca\"))\n  (test '(\"abc\" \"b\") (genturfahi-samselpla \"abcb\"))\n  (test '(\"abc\" \"c\") (genturfahi-samselpla \"abcc\"))\n  0)\n\n(test-group \"samselpla\"\n  (samselpla))") (p "Note that a tag should be placed outside of a " (tt "nunjavni-jonai") ". If a tag is placed on a " (tt "javni") " that is passed to a " (tt "nunjavni-jonai") ", that same tag must be placed on every " (tt "javni") " that is passed to that " (tt "nunjavni-jonai") ".") (p "The following example is undefined:") (highlight scheme ";; undefined interaction between nunjavni-jonai nunjavni-cmene\n\n(use genturfahi)\n\n;; XXX: This example isn't written yet!") (p "And should instead be written as:") (highlight scheme ";; defined interaction between nunjavni-jonai nunjavni-cmene\n\n(use genturfahi)\n\n;; XXX: This example isn't written yet!")) (section 5 "A Full Example" (p "Here is a complete example for using this API to construct a parser. It is the same grammar presented in " (link "http://gazette.call-cc.org/issues/5.html" "Chicken Gazette #5") ", which documents the " (tt "packrat") " parser egg.") (highlight scheme ";; mex.scm\n\n(use genturfahi)\n(use test)\n\n;;;\n;;; This example appeared in chicken gazette #5 as the example for\n;;; the packrat parser module:\n;;;\n;;;  http://gazette.call-cc.org/issues/5.html\n;;;\n;;; It is here ported to genturfa'i.\n;;;\n(define (mex)\n  (let ((mex\n    (letrec\n      ((expr   (nunjavni-morji\n                 (nunjavni-jonai\n                   (nunjavni-samselpla\n                     (lambda (#!key a b) (+ a b))\n                     (nunjavni-je\n                       (nunjavni-cmene (nunjavni-naselci mulexp) cmene: 'a:)\n                       (nunjavni-lerfu #\\+)\n                       (nunjavni-cmene (nunjavni-naselci mulexp) cmene: 'b:)))\n                   (nunjavni-naselci mulexp))))\n       (mulexp (nunjavni-morji\n                 (nunjavni-jonai\n                   (nunjavni-samselpla\n                     (lambda (#!key a b) (* a b))\n                     (nunjavni-je\n                       (nunjavni-cmene (nunjavni-naselci simple) cmene: 'a:)\n                       (nunjavni-lerfu #\\*)\n                       (nunjavni-cmene (nunjavni-naselci simple) cmene: 'b:)))\n                   (nunjavni-naselci simple))))\n       (simple (nunjavni-morji\n                 (nunjavni-jonai\n                   (nunjavni-naselci num)\n                   (nunjavni-samselpla\n                     (lambda (#!key a) a)\n                     (nunjavni-je\n                       (nunjavni-lerfu #\\()\n                       (nunjavni-cmene (nunjavni-naselci expr) cmene: 'a:)\n                       (nunjavni-lerfu #\\)))))))\n       (num    (nunjavni-morji\n                 (nunjavni-samselpla\n                   (lambda (#!key x) (string->number (list->string x)))\n                   (nunjavni-+ (nunjavni-naselci digit) cmene: 'x:))))\n       (digit  (nunjavni-morji\n                 (nunjavni-jonai\n                   (nunjavni-lerfu #\\0)\n                   (nunjavni-lerfu #\\1)\n                   (nunjavni-lerfu #\\2)\n                   (nunjavni-lerfu #\\3)\n                   (nunjavni-lerfu #\\4)\n                   (nunjavni-lerfu #\\5)\n                   (nunjavni-lerfu #\\6)\n                   (nunjavni-lerfu #\\7)\n                   (nunjavni-lerfu #\\8)\n                   (nunjavni-lerfu #\\9)))))\n      (genturfahi expr))))\n\n    (test 2  (mex \"2\"))\n    (test 22 (mex \"22\"))\n    (test 4  (mex \"2*2\"))\n    (test 4  (mex \"2+2\"))\n    (test 16 (mex \"2+2*7\"))\n    (test 28 (mex \"(2+2)*7\"))\n    (test 42 (mex \"3*4+5*6\")))\n    0)\n\n(test-group \"mex\"\n  (mex))")))) (section 3 "Source Code" (p "The source code for this egg can be viewed by version:") (ul (li (link "http://bugs.call-cc.org/browser/release/4/genturfahi/trunk" "trunk"))) (p "A copy of this project is also hosted on " (link "http://github.com" "github") ":") (ul (li (link "http://github.com/alanpost/genturfahi" "genturfahi")))) (section 3 "Salmonella Report" (p "The Salmonella Report shows the result from the current nightly build.") (ul (li (link "http://tests.call-cc.org/current/salmonella-report/genturfahi.html" "build log")) (li (link "http://tests.call-cc.org/current/salmonella-report/tests/genturfahi.html" "test output")) (li (link "http://tests.call-cc.org/current/salmonella-report/dep-graphs/genturfahi.png" "dependency graph")))) (section 3 "History" (p (link "http://pdos.csail.mit.edu/~baford/packrat/" "Brian Ford") " coined the modern terms PEGs and packrat parsing, which was the subject of his Master's Thesis.  Much of their formal theory existed earlier, the technique having been discovered by Alexander Birman in 1970.  More recent work on the topic has all been done by others.  His Master's Thesis is an accessible introduction to the topic of packrat parsing.") (p "Tony Garnock-Jones wrote a " (link "http://www.lshift.net/blog/2005/08/11/extensible-parsing-systems" "packrat parser for scheme") " in 2005.  He later packaged this work with a json parser for mzscheme " (link "http://www.lshift.net/blog/2005/08/22/json-for-mzscheme-and-a-portable-packrat-parsing-combinator-library" "and published it") ".  Tony has not updated his parser since 2006.") (p "Tony's packrat parser was ported to Chicken Scheme by " (int-link "users/christian-kellermann" "Christian Kellermann") " and " (int-link "users/felix-winkelmann" "Felix Winkelmann") " in 2009.  In 2010, it was featured in " (link "http://gazette.call-cc.org/issues/5.html" "Chicken Gazette 5") ".") (p "Alan Post began using the " (tt "packrat") " parser after it was introduced in Chicken Gazette #5 and encountered problems translating the Lojban grammar.  Some of these problems were anticipated by Tony Garnock-Jones:") (p "\"...whereas an extensible parser would require some kind of reified representation of the composite parser, along the lines of") (highlight scheme "`((expr   (or (seq (num + num) ,(lambda (a _ b) (+ a b)))\n              (seq (mulexp)    ,(lambda (a) a))))\n  (mulexp (or (seq (num * num) ,(lambda (a _ b) (* a b))))))") (p "which could then be interpreted, in order to parse some input, or stepped through, in order to debug a parser or parser extension, or used in various diagnostic printouts to help pinpoint errors in parsed text or parsing extension grammars.\"") (p (tt "genturfahi") " was written to address these shortcomings in Tony's " (tt "packrat") " parser, creating a pull PEG parser in Scheme capable of parsing Lojban's grammar.")) (section 3 "Wish List" (ul (li "Implement a PEG parser so grammar can be written in PEG format rather than being specified directly in Scheme.") (li "Implement a configuration component for modifying the configuration of the parser.") (li "Create an error handler so I know how much of the parse succeeded before failure.") (li "Implement a debug option so the parse can be traced.") (li "Implement a profiling option so grammar hotspots can be identified."))) (section 3 "See Also" (p "There are other PEG packrat parsers available:") (ul (li "The " (int-link "packrat") " parser by Tony Garnock-Jones.") (li "Jon Rafkind has written a packrat parser generator called " (link "https://github.com/kazzmir/Pegs/" "Pegs") ".") (li "John Leuner has written " (link "http://www.cliki.net/cl-peg" "cl-peg") ", a Common Lisp library for PEG parser generators."))) (section 3 "License" (pre "Copyright (c) 2010 \".alyn.post.\" <alyn.post@lodockikumazvati.org>\n \nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.")) (section 3 "Version History" (dl (dt "0.0.1") (dd "Initial release.")))))