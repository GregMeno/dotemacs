(index ("lerfu-porsi" 0) ("make-lerfu-porsi" 378) ("make-lerfu-porsi-pabalvi-lerfu" 1169) ("make-lerfu-porsi-pabalvi-valsi" 1705) ("lerfu-porsi?" 2374) ("lerfu-porsi-zva" 2610) ("lerfu-porsi-poi" 2886) ("lerfu-porsi->string" 3162) ("make-lerfu-porsi-string" 3554) ("make-lerfu-porsi-port" 3851) ("lerfu-porsi-string" 4242) ("lerfu-porsi-lerfu" 4628) ("lerfu-porsi-fanmo?" 4959) ("javni-valsi" 5288) ("make-javni-valsi" 5719) ("javni-valsi?" 6376) ("javni-valsi-cme" 6612) ("javni-valsi-val" 6892) ("javni-nunvalsi-val" 7168) ("javni-rodavalsi-val" 7771) ("javni-valsi->string" 8254) ("venunjmina-nunvalsi" 8646) ("vejmina-nunvalsi" 9221) ("vejmina-nunvalsi-nacmene" 9775) ("venunjmina-rodanunvalsi" 10104) ("vejmina-rodanunvalsi" 10685) ("vejmina-rodanunvalsi-nacmene" 11298) ("nunjavni-lerfu" 11834) ("nunjavni-." 12259) ("nunjavni-e" 12727) ("nunjavni-fanmo" 13058) ("nunjavni-valsi" 13461) ("nunjavni-re" 14046) ("nunjavni-*" 14753) ("nunjavni-+" 15391) ("nunjavni-?" 16071) ("nunjavni-&" 16621) ("nunjavni-!" 17156) ("nunjavni-je" 17673) ("nunjavni-jonai" 18398) ("nunjavni-morji" 19256) ("nunjavni-naselci" 19887) ("nunjavni-samselpla" 20492) ("nunjavni-cmene" 21588) ("javni" 22590) ("mapti" 23007) ("namapti" 23007) ("genturfahi-tolmohi" 23451) ("genturfahi" 23610) ("genturfahi*" 24207) ("genturfahi-peg" 24589) ("genturfahi-peg*" 25071) ("genturfahi-status" 25474) ("genturfahi-version-major" 25813) ("genturfahi-version-minor" 25955) ("genturfahi-version-patch" 26097) ("genturfahi-version" 26239))
(def (sig (record "lerfu-porsi" (id lerfu-porsi))) (p "The string to parse and the current parse position of that string. This structure is used by the parser to store the input to the parser.") (p "It contains the following members:") (dl (dt (tt "zva")) (dd "An integer which is the current index of " (tt "poi") ".") (dt (tt "poi")) (dd "The string which will be parsed.")))
(def (sig (procedure "(make-lerfu-porsi zva poi) => lerfu-porsi" (id make-lerfu-porsi))) (dl (dt (tt "zva")) (dd "An integer describing the current position of the parse input.") (dt (tt "poi")) (dd "The parse input, as a specially formatted string.  (See " (tt "make-lerfu-porsi-string") " and " (tt "make-lerfu-porsi-port") ".)")) (p "Create a " (tt "lerfu-porsi") " from the integer index " (tt "zva") " and the parse input " (tt "poi") ".  " (tt "poi") " is specially formatted, and must come from calling " (tt "make-lerfu-porsi-string") " or " (tt "make-lerfu-porsi-port") ".  It has an appended character acting as a \"sentinel\" for purposes of detecting the end of the input buffer.") (p (tt "zva") " must be less than or equal to the " (tt "string-length") " of " (tt "poi") "."))
(def (sig (procedure "(make-lerfu-porsi-pabalvi-lerfu porsi) => lerfu-porsi" (id make-lerfu-porsi-pabalvi-lerfu))) (dl (dt (tt "porsi")) (dd "the parse position to advance.")) (p "Create a " (tt "lerfu-porsi") " from an existing " (tt "lerfu-porsi") " by advancing the index " (tt "zva") " by a single character.") (p "It is an error if " (tt "porsi") " is not of type " (tt "lerfu-porsi") ".") (p "Behavior is undefined if this procedure is called when " (tt "lerfu-porsi-fanmo?") " returns " (tt "#t") " for this " (tt "porsi") "."))
(def (sig (procedure "(make-lerfu-porsi-pabalvi-valsi porsi nilcla) => lerfu-porsi" (id make-lerfu-porsi-pabalvi-valsi))) (dl (dt (tt "porsi")) (dd "the parse position to advance.") (dt (tt "nilcla")) (dd "The number of characters the position will be advanced by.")) (p "Create a " (tt "lerfu-porsi") " from an existing " (tt "lerfu-porsi") " by advancing the index " (tt "zva") " by the length of " (tt "lefpoi") ".") (p "It is an error if " (tt "porsi") " is not of type " (tt "lerfu-porsi") ".") (p "Behavior is undefined if this procedure is called with a " (tt "lefpoi") " whose length is greater than the number of characters in remaining in the parse input."))
(def (sig (procedure "(lerfu-porsi? porsi) => boolean" (id lerfu-porsi?))) (dl (dt (tt "porsi")) (dd "the object to test.")) (p "Return " (tt "#t") " if " (tt "porsi") " is of type " (tt "lerfu-porsi") " and " (tt "#f") " otherwise."))
(def (sig (procedure "(lerfu-porsi-zva porsi) => zva" (id lerfu-porsi-zva))) (dl (dt (tt "porsi")) (dd "A " (tt "lerfu-porsi") ".")) (p "Return the " (tt "zva") " member from " (tt "porsi") ".") (p "It is an error if " (tt "porsi") " is not of type " (tt "lerfu-porsi") "."))
(def (sig (procedure "(lerfu-porsi-poi porsi) => poi" (id lerfu-porsi-poi))) (dl (dt (tt "porsi")) (dd "A " (tt "lerfu-porsi") ".")) (p "Return the " (tt "poi") " member from " (tt "porsi") ".") (p "It is an error if " (tt "porsi") " is not of type " (tt "lerfu-porsi") "."))
(def (sig (procedure "(lerfu-porsi->string porsi) => string" (id lerfu-porsi->string))) (dl (dt (tt "porsi")) (dd "A " (tt "lerfu-porsi") ".")) (p "Return A string representation of " (tt "porsi") ".  This string representation is for debug use only, and cannot be converted back to a " (tt "lerfu-porsi") ".") (p "It is an error if " (tt "porsi") " is not of type " (tt "lerfu-porsi") "."))
(def (sig (procedure "(make-lerfu-porsi-string string) => porsi" (id make-lerfu-porsi-string))) (dl (dt (tt "string")) (dd "The input string to parse.")) (p "Return a " (tt "lerfu-porsi") " with " (tt "string") " as the parse input. " (tt "string") " is copied into the " (tt "lerfu-porsi") "."))
(def (sig (procedure "(make-lerfu-porsi-port port) => porsi" (id make-lerfu-porsi-port))) (dl (dt (tt "port")) (dd "The input port to parse.")) (p "Return a " (tt "lerfu-porsi") " with " (tt "port") " as the parse input. " (tt "port") " is read into a string before being copied into the " (tt "lerfu-porsi") ", as the parser may need to backtrack to any previous location in the string."))
(def (sig (procedure "(lerfu-porsi-string porsi) => string" (id lerfu-porsi-string))) (dl (dt (tt "porsi")) (dd "A " (tt "lerfu-porsi") ".")) (p "Return the characters that have not been parsed from " (tt "porsi") ". This routine copies the characters from the buffer into a new string.") (p "If all of the characters were parsed from " (tt "lerfu-porsi") ", return " (tt "\"\"") "."))
(def (sig (procedure "(lerfu-porsi-lerfu porsi) => character" (id lerfu-porsi-lerfu))) (dl (dt (tt "porsi")) (dd "A " (tt "lerfu-porsi") ".")) (p "Return the character at the current parse position " (tt "zva") " in the parse input " (tt "poi") ".") (p "It is an error if " (tt "porsi") " is not of type " (tt "lerfu-porsi") "."))
(def (sig (procedure "(lerfu-porsi-fanmo? porsi) => boolean" (id lerfu-porsi-fanmo?))) (dl (dt (tt "porsi")) (dd "A " (tt "lerfu-porsi") ".")) (p "Return " (tt "#t") " if this " (tt "porsi") " has no more input to parse, " (tt "#f") " otherwise.") (p "It is an error if " (tt "porsi") " is not of type " (tt "lerfu-porsi") "."))
(def (sig (record "javni-valsi" (id javni-valsi))) (p "A " (tt "javni-valsi") " is a token with an (optionally) associated name generated from a " (tt "javni") ", indicating a match of that " (tt "javni") ".") (p "It contains the following members:") (dl (dt (tt "cme")) (dd "The name associated with this token, or " (tt "#f") " if there is no associated name.") (dt (tt "val")) (dd "The token generated from matching a rule.")))
(def (sig (procedure "(make-javni-valsi cme val) => javni-valsi" (id make-javni-valsi))) (dl (dt (tt "cme")) (dd "The name associated with this token, or " (tt "#f") " if there is no associated name.") (dt (tt "val")) (dd "The token generated from matching a rule.")) (p "Create a " (tt "javni-valsi") " from the name " (tt "cme") " and the token " (tt "val") ".  If this " (tt "javni-valsi") " has no associated " (tt "cmene") ", " (tt "cme") " can be " (tt "#f") ".") (p (tt "val") " may be an object of any type, and is the current abstract syntax tree generated from this parse, as modified by " (tt "samselpla") " executed after the parse succeeds."))
(def (sig (procedure "(javni-valsi? valsi) => boolean" (id javni-valsi?))) (dl (dt (tt "valsi")) (dd "the object to test.")) (p "Return " (tt "#t") " if " (tt "valsi") " is of type " (tt "javni-valsi") " and " (tt "#f") " otherwise."))
(def (sig (procedure "(javni-valsi-cme valsi) => cmene" (id javni-valsi-cme))) (dl (dt (tt "valsi")) (dd "A " (tt "javni-valsi") ".")) (p "Return the " (tt "cmene") " member from " (tt "valsi") ".") (p "It is an error if " (tt "valsi") " is not of type " (tt "javni-valsi") "."))
(def (sig (procedure "(javni-valsi-val valsi) => val" (id javni-valsi-val))) (dl (dt (tt "valsi")) (dd "A " (tt "javni-valsi") ".")) (p "Return the " (tt "val") " member from " (tt "valsi") ".") (p "It is an error if " (tt "valsi") " is not of type " (tt "javni-valsi") "."))
(def (sig (procedure "(javni-nunvalsi-val nunvalsi) => val / (val ...)" (id javni-nunvalsi-val))) (dl (dt (tt "nunvalsi")) (dd "A " (tt "javni-valsi") " generator.")) (p "Generate the " (tt "javni-valsi") " from " (tt "nunvalsi") ".  If the result is a single " (tt "javni-valsi") ", return the " (tt "val") " member of that result.  Otherwise, treat the result as a tree containing " (tt "javnli-valsi") " and recursively retrieve the " (tt "val") " member from each " (tt "javni-valsi") " node in the tree.") (p "It is an error if " (tt "valsi") " is not (lists of) of type " (tt "javni-valsi") "."))
(def (sig (procedure "(javni-rodavalsi-val rodavalsi) => val / (val ...)" (id javni-rodavalsi-val))) (dl (dt (tt "rodavalsi")) (dd "A " (tt "javni-valsi") ".")) (p "This helper routine for " (tt "javni-nunvalsi-val") " returns the " (tt "val") " member of " (tt "rodavalsi") " if " (tt "rodavalsi") " is a " (tt "javni-valsi") ", calling itself recursively every time " (tt "rodavalsi") " is a list.") (p "It is an error if " (tt "valsi") " is not of type " (tt "javni-valsi") "."))
(def (sig (procedure "(javni-valsi->string valsi) => string" (id javni-valsi->string))) (dl (dt (tt "valsi")) (dd "A " (tt "javni-valsi") ".")) (p "Return A string representation of " (tt "valsi") ".  This string representation is for debug use only, and cannot be converted back to a " (tt "javni-valsi") ".") (p "It is an error if " (tt "valsi") " is not of type " (tt "javni-valsi") "."))
(def (sig (procedure "(venunjmina-nunvalsi cmene) => nunvalsi" (id venunjmina-nunvalsi))) (dl (dt (tt "cmene")) (dd "The name to associated with the " (tt "nunvalsi"))) (p "If " (tt "cmene") " is not " (tt "#f") ", return a procedure that, when called, will produce a " (tt "javni-valsi") " with a " (tt "cme") " of " (tt "cmene") " and a " (tt "val") " resulting from calling the passed in " (tt "nunvalsi") ".") (p "This procedure is used by the ordered choice and optional " (tt "javni") " to generate new " (tt "nunvalsi") " when those rules have an associated cmene."))
(def (sig (procedure "(vejmina-nunvalsi cmene nunvalsi) => nunvalsi" (id vejmina-nunvalsi))) (dl (dt (tt "cmene") " The name to associate with the newly generated " (tt "nunvalsi") ".") (dt (tt "nunvalsi")) (dd "A " (tt "javni-valsi") " generator.")) (p "Create a new " (tt "javni-valsi") " with a " (tt "cme") " of " (tt "cmene") " and a " (tt "val") " from the " (tt "val") " of generating a " (tt "valsi") " from " (tt "nunvalsi") ".") (p "This routine is is generated by " (tt "venunjmina-nunvalsi") " when the caller provides a " (tt "cmene") "."))
(def (sig (procedure "(vejmina-nunvalsi-nacmene nunvalsi) => nunvalsi" (id vejmina-nunvalsi-nacmene))) (dl (dt (tt "nunvalsi")) (dd "A " (tt "javni-valsi") " generator.")) (p "Return " (tt "nunvalsi") ".  This routine is a no-op generated by " (tt "venunjmina-nunvalsi") " when the caller has not provided a " (tt "cmene") "."))
(def (sig (procedure "(venunjmina-rodanunvalsi cmene) => nunvalsi" (id venunjmina-rodanunvalsi))) (dl (dt (tt "cmene")) (dd "The name to associated with the " (tt "nunvalsi"))) (p "If " (tt "cmene") " is not " (tt "#f") ", return a procedure that, when called, will produce a " (tt "javni-valsi") " with a " (tt "cme") " of " (tt "cmene") " and a " (tt "val") " resulting from calling the passed in " (tt "nunvalsi") ".") (p "This procedure is used by the zero or more and sequence " (tt "javni") " to generate new " (tt "nunvalsi") " when those rules have an associated cmene."))
(def (sig (procedure "(vejmina-rodanunvalsi cmene . rodanunvalsi) => nunvalsi" (id vejmina-rodanunvalsi))) (dl (dt (tt "cmene") " The name to associate with the newly generated " (tt "nunvalsi") ".") (dt (tt "rodanunvalsi") " A list of " (tt "nunvalsi") ".")) (p "Create a new " (tt "javni-valsi") " with a " (tt "cme") " of " (tt "cmene") " and a " (tt "val") " being a list of the " (tt "val") " from the " (tt "valsi") " generated from each " (tt "nunvalsi") " in " (tt "rodanunvalsi") ".") (p "This routine is is generated by " (tt "venunjmina-rodanunvalsi") " when the caller provides a " (tt "cmene") "."))
(def (sig (procedure "(vejmina-rodanunvalsi-nacmene . rodanunvalsi) => nunvalsi" (id vejmina-rodanunvalsi-nacmene))) (dl (dt (tt "rodanunvalsi") " A list of " (tt "nunvalsi") ".")) (p "Create a new " (tt "javni-valsi") " with a " (tt "cme") " of " (tt "#f") " and a " (tt "val") " being a list of the " (tt "val") " from the " (tt "valsi") " generated from each " (tt "nunvalsi") " in " (tt "rodanunvalsi") ".") (p "This routine is generated by " (tt "venunjmina-rodanunvalsi") " when the caller does not provide a " (tt "cmene") "."))
(def (sig (procedure "(nunjavni-lerfu lerfu #!key cmene) => javni" (id nunjavni-lerfu))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching " (tt "lerfu") ".") (dt (tt "lerfu")) (dd "The character to match.")) (p "Generate a " (tt "javni") " that matches a single " (tt "lerfu") ".") (p (tt "nunjavni-lerfu") " corresponds to a nonterminal symbol in PEG syntax."))
(def (sig (procedure "(nunjavni-. #!key cmene) => javni" (id nunjavni-.))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching the next character.")) (p "Generate a " (tt "javni") " that matches the next character in the parse input, regardless of what that character is.  Call " (tt "mapti") " with the matched character.  If there are no characters remaining in the parse input, call " (tt "namapti") "."))
(def (sig (procedure "(nunjavni-e #!key cmene) => javni" (id nunjavni-e))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by this rule.")) (p "Generate a " (tt "javni") " that matches the empty string.") (p (tt "nunjavni-fanmo") " corresponds to the empty string expression in PEG syntax."))
(def (sig (procedure "(nunjavni-fanmo #!key cmene) => javni" (id nunjavni-fanmo))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching the end of the " (tt "lerfu-porsi") ".")) (p "Generate a " (tt "javni") " that matches the end of the " (tt "lerfu-porsi") ".") (p (tt "nunjavni-fanmo") " corresponds to a nonterminal symbol in PEG syntax."))
(def (sig (procedure "(nunjavni-valsi valsi #!key cmene) => javni" (id nunjavni-valsi))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching " (tt "cmene") ".") (dt (tt "valsi")) (dd "The string to try to match.")) (p "Generate a " (tt "javni") " that matches the parse input against " (tt "valsi") ".") (p (tt "nunjavni-valsi") " matches a literal string, and will be faster than " (tt "nunjavni-re") " or a composition of individual " (tt "nunjavni-lerfu") " when the input to match can be expressed as a literal string."))
(def (sig (procedure "(nunjavni-re pattern #!key cmene) => javni" (id nunjavni-re))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching " (tt "pattern") ".") (dt (tt "pattern")) (dd "the regular expression to try to match.")) (p "Generate a " (tt "javni") " that matches the next character(s) in the parse input against the regular expression " (tt "pattern") ".  If " (tt "pattern") " matches the next character(s) in the parse input, call " (tt "mapti") " with the matched characters.  Otherwise continue with " (tt "namapti") ".") (p "The character " (tt "#\\^") " is prepended to " (tt "pattern") " before compiling the regular expression."))
(def (sig (procedure "(nunjavni-* sumti-javni #!key cmene) => javni" (id nunjavni-*))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching " (tt "sumti-javni") ".") (dt (tt "sumti-javni")) (dd "The rule to match zero-or-more times.")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") " until it generates a " (tt "namapti") ".  The " (tt "javni") " returned by " (tt "nunjavni-*") " never calls its " (tt "namapti") " continuation, always calling " (tt "mapti") ".") (p (tt "nunjavni-*") " corresponds to the zero-or-more expression in PEG syntax."))
(def (sig (procedure "(nunjavni-+ sumti-javni #!key cmene) => javni" (id nunjavni-+))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by this rule.") (dt (tt "sumti-javni")) (dd "The rule to match one-or-more times.")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") " until it generates a " (tt "namapti") ".  The " (tt "javni") " returned by " (tt "nunjavni-+") " calls " (tt "mapti") " if the passed in " (tt "sumti-javni") " matches one or more times, and calls " (tt "namapti") " if " (tt "sumti-javni") " does not match.") (p (tt "nunjavni-+") " corresponds to the one-or-more expression in PEG syntax."))
(def (sig (procedure "(nunjavni-? sumti-javni #!key cmene) => javni" (id nunjavni-?))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by this rule.") (dt (tt "sumti-javni")) (dd "The rule to optionally match.")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") ". The " (tt "javni") " returned by " (tt "nunjavni-?") " never calls its " (tt "namapti") " continuation, always calling " (tt "mapti") ".") (p (tt "nunjavni-?") " corresponds to the optional expression in PEG syntax."))
(def (sig (procedure "(nunjavni-& sumti-javni) => javni" (id nunjavni-&))) (dl (dt (tt "sumti-javni")) (dd "The rule to match.")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") ". The " (tt "javni") " returned by " (tt "nunjavni-&") " calls " (tt "mapti") " or " (tt "namapti") " according to the result from " (tt "sumti-javni") ", but it does not advances the " (tt "lerfu-porsi") " when " (tt "mapti") " is called.") (p (tt "nunjavni-*") " corresponds to the and-predicate expression in PEG syntax."))
(def (sig (procedure "(nunjavni-! sumti-javni) => javni" (id nunjavni-!))) (dl (dt (tt "sumti-javni")) (dd "The rule to match.")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") ". The " (tt "javni") " returned by " (tt "nunjavni-&") " calls " (tt "mapti") " if the " (tt "sumti-javni") " calls " (tt "namapti") ", and it calls " (tt "mapti") " if the " (tt "sumti-javni") " calls " (tt "namapti") ".") (p (tt "nunjavni-!") " corresponds to the not-predicate expression in PEG syntax."))
(def (sig (procedure "(nunjavni-je #!rest rodajavni #!key cmene) => javni" (id nunjavni-je))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching all " (tt "rodajavni") ".") (dt (tt "rodajavni")) (dd "one or more rules to match in sequence.")) (p "Generate a " (tt "javni") " that runs each " (tt "javni") " in the passed in " (tt "rodajavni") " in order.  The " (tt "javni") " returned by " (tt "nunjavni-je") " calls " (tt "mapti") " if every " (tt "javni") " in " (tt "rodajavni") " matches, and " (tt "namapti") " if any " (tt "javnri") " in " (tt "rodajavni") " does not match.") (p (tt "nunjavni-je") " corresponds to the sequence expression in PEG syntax."))
(def (sig (procedure "(nunjavni-jonai #!rest rodajavni #!key cmene) => javni" (id nunjavni-jonai))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching any " (tt "rodajavni") ".") (dt (tt "rodajavni")) (dd "one or more rules to match in sequence.")) (p "Generate a " (tt "javni") " that runs each " (tt "javni") " in the passed in " (tt "rodajavni") " in order.  The " (tt "javni") " returned by " (tt "nunjavni-jonai") " calls " (tt "mapti") " with the result from the first " (tt "javni") " in " (tt "rodajavni") " that matches, ignoring all remaining " (tt "javni") " in " (tt "rodajavni") ". " (tt "nunjavni-je") " calls " (tt "namapti") " if all the " (tt "javni") " in " (tt "rodajavni") " do not match.") (p (tt "nunjavni-je") " corresponds to the ordered-choice expression in PEG syntax."))
(def (sig (procedure "(nunjavni-morji sumti-javni) => javni" (id nunjavni-morji))) (dl (dt (tt "sumti-javni")) (dd "the rule to match.")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") " and stores the result.  If the " (tt "javni") " returned by " (tt "nunjavni-morji") " is called again with the same " (tt "lerfu-porsi") ", the stored " (tt "mapti") " or " (tt "namapti") " is called instead of calling " (tt "sumti-javni") " again.") (p (tt "nunjavni-je") " corresponds to memoization in packrat parsing.") (p "Unlink other nunjavni, this rule generator does not accept a " (tt "cmene") " key."))
(def (sig (syntax "(nunjavni-naselci sumti-javni #!key cmene: cmene) => javni" (id nunjavni-naselci))) (dl (dt (tt "sumti-javni")) (dd "the rule defined in the environment being captured.") (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching " (tt "sumti-javni") ".")) (p (tt "nunjavni-nasleci") " encloses " (tt "sumti-javni") " in a lambda, which captures the environment in which " (tt "sumti-javni") " is defined.") (p "This macro is used in the letrec used to define the non-terminals in a grammar to allow mutual recursion of non-terminals."))
(def (sig (procedure "(nunjavni-samselpla samselpla sumti-javni #!key cmene) => javni" (id nunjavni-samselpla))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching " (tt "sumti-javni") " and executing " (tt "samselpla") ".") (dt (tt "samselpla")) (dd "the code to execute if the generated " (tt "javni") " calls " (tt "mapti") ".") (dt (tt "sumti-javni")) (dd "The rule generating " (tt "javni-valsi") " for " (tt "samselpla") ".")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") " and, if the " (tt "sumti-javni") " calls " (tt "mapti") ", calls " (tt "samselpla") " by passing any tokens in the " (tt "jalga") " with associated " (tt "cmene") " as DSSL-style #!key parameters.") (p "If " (tt "sumti-javni") " does not match, " (tt "samselpla") " is not called. There is no way to execute code for a " (tt "namapti") ", as there is only a single " (tt "namapti") " called during a parse.  Code that should be executed when a parse fails can be run after the parse completes; see " (tt "genturfahi") "."))
(def (sig (procedure "(nunjavni-cmene sumti-javni #!key cmene) => javni" (id nunjavni-cmene))) (dl (dt (tt "cmene")) (dd "The optional name for the " (tt "javni-valsi") " generated by successfully matching " (tt "sumti-javni") ".") (dt (tt "sumti-javni")) (dd "the rule to match.")) (p "Generate a " (tt "javni") " that runs the passed in " (tt "sumti-javni") " and, if the " (tt "sumti-javni") " matches, associates " (tt "cmene") " with the " (tt "javni-valsi") " associated with the " (tt "mapti") ".") (p "If " (tt "sumti-javni") " does not match, call " (tt "namapti") " without associating " (tt "cmene") " with the result.") (p "All terminal " (tt "javni") " accept a cmene: argument, which should be used in preference to this function.  This function is required when matching a " (tt "javni-naselci") ", as we can't tell at compile-time that we will associate a " (tt "cmene") " with that " (tt "javni") ".  Instead, the binding waits until runtime where it is performed by this function."))
(def (sig (procedure "(javni lerfu-porsi mapti namapti) => jalge" (id javni))) (dl (dt (tt "lerfu-porsi")) (dd "the current parse position.") (dt (tt "mapti")) (dd "continuation for rule match.") (dt (tt "namapti")) (dd "continuation for rule non-match.")) (p "Note that " (tt "jalge") " is not returned until the entire parse succeeds, and may not return at all on failure, if another path succeeds in the parse."))
(def (sig (procedure "(mapti lerfu-porsi nunvalsi) => jalge" (id mapti)) (procedure "(namapti lerfu-porsi) => jalge" (id namapti))) (dl (dt (tt "lerfu-porsi")) (dd "The current parse position.") (dt (tt "nunvalsi")) (dd "A generated returning the current parse result.")) (p (tt "genturfahi") " accepts the top-level parse rule and returns the result to the caller, rather than calling any additional " (tt "mapti") " or " (tt "namapti") "."))
(def (sig (procedure "(genturfahi-tolmohi) => '()" (id genturfahi-tolmohi))) (p "Clear the memoization cache.  This is done automatically after each parse."))
(def (sig (procedure "(genturfahi javni) => rodavalsi" (id genturfahi))) (dl (dt (tt "javni")) (dd "The starting rule of the grammar.")) (p "Parse the " (tt "javni") ", which is assumed to be the initial rule of the grammar.  Return " (tt "rodavalsi") ", the result of the parse.") (p "If the parse succeed, " (tt "rodavalsi") " is the abstract syntax tree as modified by any " (tt "samselpla") " embedded in the grammar.  If the parse failed, " (tt "#f") " is returned.  In both cases, the " (tt "lerfu-porsi") " representing the input remaining after the parse is returned as a second value."))
(def (sig (procedure "(genturfahi* javni) => (rodavalsi lefpoi)" (id genturfahi*))) (dl (dt (tt "javni")) (dd "The starting rule of the grammar.")) (p (tt "genturfahi*") " calls " (tt "genturfahi") " and converts the multiple arguments returned by " (tt "genturfahi") " to a list and returns them.") (p "This routine is used in the test framework, and might be useful elsewhere."))
(def (sig (procedure "(genturfahi-peg port) => genturfahi" (id genturfahi-peg))) (dl (dt (tt "port")) (dd "The port from which to read the PEG grammar.")) (p (tt "genturfahi-peg") " parses a PEG grammar from " (tt "port") " and returns scheme code that will generate a parser for that grammar.") (p "Note that the expression returned from this procedure is designed to be written to a file and loaded later.  It must be evaluated with eval if it is going to be used immediately."))
(def (sig (procedure "(genturfahi-peg* port) => genturfahi" (id genturfahi-peg*))) (dl (dt (tt "port")) (dd "The port from which to read the PEG grammar.")) (p (tt "genturfahi-peg*") " calls " (tt "genturfahi-peg") " and converts the multiple arguments returned by " (tt "genturfahi-peg") " to a list and returns them.") (p "This routine is used in the test framework, and might be useful elsewhere."))
(def (sig (parameter "genturfahi-status" (id genturfahi-status))) (p "The exit status of the parser.  If the parse input does not match the parser, " (tt "genturfahi-status") " is 1.  Otherwise, " (tt "genturfahi-status") " is zero.") (p "The value of " (tt "genturfahi-status") " is passed to " (tt "exit") " once the parse completes."))
(def (sig (constant "genturfahi-version-major" (id genturfahi-version-major))) (p "A number representing the major version of this module."))
(def (sig (constant "genturfahi-version-minor" (id genturfahi-version-minor))) (p "A number representing the minor version of this module."))
(def (sig (constant "genturfahi-version-patch" (id genturfahi-version-patch))) (p "A number representing the patch version of this module."))
(def (sig (constant "genturfahi-version" (id genturfahi-version))) (p "A string representing the version number of this module."))
