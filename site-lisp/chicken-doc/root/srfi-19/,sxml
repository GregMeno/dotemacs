((tags "egg") (section 2 "srfi-19" (p "Time Data Types and Procedures") (toc)) (section 2 "Documentation" (p "This is a Chicken port of SRFI 19. This document only describes the extensions. For the SRFI 19 API see " (link "http://srfi.schemers.org/srfi-19/srfi-19.html" "SRFI 19") ".") (section 3 "Core Procedures" (p "The " (i "core") " procedures are those pertaining to time, date, and timezone:") (highlight scheme "(require-extension srfi-19-core)") (p "The " (i "core") " procedures can be separately accessed:") (highlight scheme "(require-extension srfi-19-time)") (highlight scheme "(require-extension srfi-19-date)") (highlight scheme "(require-extension srfi-19-timezone)") (highlight scheme "(require-extension srfi-19-io)") (section 4 "SRFI 19 Document Changes" (p "The " (b "nanosecond") " time object element is an integer between 0 and 999,999,999 inclusive. (The SRFI 19 document mis-states the value.)") (p "A " (i "tz-offset") " value follows ISO 8601; positive for " (b "east") " of UTC, and negative for " (b "west") ". This is the " (b "opposite") " of the POSIX TZ environment variable.") (p "Where the SRFI 19 document states a " (i "tz-offset") " argument a " (tt "timezone-components") " object is also legal.") (p "The " (tt "string->date") " procedure allows the template-name argument to be optional. When missing the locale's " (tt "date-time-format") " string is used. The supplied locale bundle's strings are invertible.") (section 5 "make-date" (def (sig (procedure "(make-date NANOSECOND SECOND MINUTE HOUR DAY MONTH YEAR [ZONE-OFFSET [TZ-NAME [DST-FLAG]]]) => date" (id make-date))) (p "Same as SRFI 19 except for the optional parameters and allowing a timezone-components object for the " (tt "ZONE-OFFSET") ".") (p "The " (tt "ZONE-OFFSET") " is an " (tt "integer") " or " (tt "timezone-components") ". Default is the " (tt "(timezone-locale-offset)") ", the current locale timezone offset.") (p "The " (tt "TZ-NAME") " is a " (tt "string") " or " (tt "#f") ", and is the timezone name. Default is " (tt "#f") ".") (p "The " (tt "DST-FLAG") " is a " (tt "boolean") ", and indicates whether Day Saving TIme (or Summer Time) is active. Default is " (tt "#f") ".") (p "When the " (tt "ZONE-OFFSET") " is a " (tt "timezone-components") " object the " (tt "TZ-NAME") " and " (tt "DST-FLAG") " are pulled from the " (tt "timezone-components") ", unless explicitly supplied."))) (section 5 "read-leap-second-table" (def (sig (procedure "(read-leap-second-table FILENAME)" (id read-leap-second-table))) (p "Sets the leap second table from the specified " (tt "FILENAME") ".") (p "The file format is the same as the \"tai-utc.dat\" file in the distribution. Provided by the U.S. Naval Observatory."))) (section 5 "leap-year?" (def (sig (procedure "(leap-year? DATE) => boolean" (id leap-year?))) (p "Does the specified " (tt "DATE") " fall on a leap year?") (p "The " (tt "DATE") " may be a numeric year or a " (tt "date") " object.")))) (section 4 "SRFI 18 Time" (p "Note that the " (b "SRFI 18") " identifiers " (tt "time?") ", " (tt "current-time") ", " (tt "seconds->time") ", " (tt "time->seconds") ", " (tt "milliseconds->time") ", and " (tt "time->milliseconds") " are in conflict with those of " (b "SRFI 19") ".") (section 5 "time->srfi-18-time" (def (sig (procedure "(time->srfi-18-time TIME) => srfi-18#time" (id time->srfi-18-time))) (p "Converts a SRFI 19 time object to a SRFI 18 time object. The conversion is really only meaningful for " (tt "time-duration") ", but any time-type is accepted."))) (section 5 "srfi-18-time->time" (def (sig (procedure "(srfi-18-time->time  => srfi-18#time) => srfi-19#time" (id srfi-18-time->time))) (p "Converts a SRFI 18 time object into a SRFI 19 " (tt "time-duration") " object.")))) (section 4 "Time Conversion" (section 5 "seconds->time" (def (sig (procedure "(seconds->time SECONDS [TIME-TYPE time-duration]) => time" (id seconds->time))) (p "Converts a " (tt "SECONDS") " value, may be fractional, into a " (tt "TIME-TYPE") " time object."))) (section 5 "seconds->date" (def (sig (procedure "(seconds->date SECONDS [TIMEZONE-INFO #f]) => date" (id seconds->date))) (p "Converts a " (tt "SECONDS") " value, which may be fractional, into a date object. The " (tt "TIMEZONE-INFO") " is " (tt "#t") " for the local timezone, " (tt "#f") " for the utc timezone, or a timezone-components object.") (p (tt "SECONDS") " is relative to 00:00:00 January 1, 1970 UTC."))) (section 5 "time->nanoseconds" (def (sig (procedure "(time->nanoseconds TIME) => integer" (id time->nanoseconds))) (p "Returns the " (tt "TIME") " object value as a nanoseconds value."))) (section 5 "nanoseconds->time" (def (sig (procedure "(nanoseconds->time NANOSECONDS [TIME-TYPE time-duration]) => time" (id nanoseconds->time))) (p "Returns the " (tt "NANOSECONDS") " value as a time " (tt "TIME-TYPE") " object."))) (section 5 "nanoseconds->seconds" (def (sig (procedure "(nanoseconds->seconds NANOSECONDS) => integer" (id nanoseconds->seconds))) (p "Returns the " (tt "NANOSECONDS") " value as an inexact seconds value."))) (section 5 "time->milliseconds" (def (sig (procedure "(time->milliseconds TIME) => integer" (id time->milliseconds))) (p "Returns the " (tt "TIME") " object value as a milliseconds value."))) (section 5 "milliseconds->time" (def (sig (procedure "(milliseconds->time MILLISECONDS [TIME-TYPE time-duration]) => time" (id milliseconds->time))) (p "Returns the " (tt "MILLISECONDS") " value as a time " (tt "TIME-TYPE") " object."))) (section 5 "milliseconds->seconds" (def (sig (procedure "(milliseconds->seconds MILLISECONDS) => integer" (id milliseconds->seconds))) (p "Returns the " (tt "MILLISECONDS") " value as an inexact seconds value."))) (section 5 "time->date" (def (sig (procedure "(time->date TIME) => date" (id time->date))) (p "Returns the " (tt "TIME") " object value as a date. A shorthand for the " (tt "(time-*->date...)") " procedures."))) (section 5 "time->julian-day" (def (sig (procedure "(time->julian-day TIME) => rational" (id time->julian-day))) (p "Returns the julian day for the " (tt "TIME") " object."))) (section 5 "time->modified-julian-day" (def (sig (procedure "(time->modified-julian-day TIME) => rational" (id time->modified-julian-day))) (p "Returns the modified julian day for the " (tt "TIME") " object.")))) (section 4 "Time Arithmetic" (section 5 "make-duration" (def (sig (procedure "(make-duration [#:days 0] [#:hours 0] [#:minutes 0] [#:seconds 0] [#:milliseconds 0] [#:microseconds 0] [#:nanoseconds 0]) => time" (id make-duration))) (p "Returns a time-object of clock-type " (tt "time-duration") " where the seconds and nanoseconds values are calculated by summing the keyword arguments.") (p (tt "ONE-SECOND-DURATION") " and " (tt "ONE-NANOSECOND-DURATION") " are pre-defined."))) (section 5 "divide-duration" (def (sig (procedure "(divide-duration DURATION NUMBER) => time" (id divide-duration))) (p "Returns a duration, from " (tt "DURATION") ", divided by " (tt "NUMBER") ", without remainder."))) (section 5 "divide-duration!" (def (sig (procedure "(divide-duration! DURATION NUMBER) => time" (id divide-duration!))) (p "Returns " (tt "DURATION") ", divided by " (tt "NUMBER") ", without remainder."))) (section 5 "multiply-duration" (def (sig (procedure "(multiply-duration DURATION NUMBER) => time" (id multiply-duration))) (p "Returns a duration, from " (tt "DURATION") ", multiplied by " (tt "NUMBER") ", truncated."))) (section 5 "multiply-duration!" (def (sig (procedure "(multiply-duration! DURATION NUMBER) => time" (id multiply-duration!))) (p "Returns " (tt "DURATION") ", multiplied by " (tt "NUMBER") ", truncated."))) (section 5 "time-negative?" (def (sig (procedure "(time-negative? TIME) => boolean" (id time-negative?))) (p "Is " (tt "TIME") " negative?") (p "A time object will never have a negative nanoseconds value."))) (section 5 "time-positve?" (def (sig (procedure "(time-positve? TIME) => boolean" (id time-positve?))) (p "Is " (tt "TIME") " positive?"))) (section 5 "time-zero?" (def (sig (procedure "(time-zero? TIME) => boolean" (id time-zero?))) (p "Is " (tt "TIME") " zero?"))) (section 5 "time-abs" (def (sig (procedure "(time-abs TIME) => time" (id time-abs))) (p "Returns the absolute time value, from " (tt "TIME") "."))) (section 5 "time-abs!" (def (sig (procedure "(time-abs! TIME) => time" (id time-abs!))) (p "Returns the absolute " (tt "TIME") " value."))) (section 5 "time-negate" (def (sig (procedure "(time-negate TIME) => time" (id time-negate))) (p "Returns the sign inverted time value, from " (tt "TIME") "."))) (section 5 "time-negate!" (def (sig (procedure "(time-negate! TIME) => time" (id time-negate!))) (p "Returns the " (tt "TIME") " sign inverted value.")))) (section 4 "Time Comparison" (section 5 "time-compare" (def (sig (procedure "(time-compare TIME1 TIME2) => integer" (id time-compare))) (p "Returns -1, 0, or 1."))) (section 5 "time-max" (def (sig (procedure "(time-max TIME1 [TIME2...]) => time" (id time-max))) (p "Returns the maximum time object from " (tt "TIME1 TIME2...") "."))) (section 5 "time-min" (def (sig (procedure "(time-min TIME1 [TIME2...]) => time" (id time-min))) (p "Returns the minimum time object from " (tt "TIME1 TIME2...") ".")))) (section 4 "Dates" (section 5 "default-date-clock-type" (def (sig (parameter "(default-date-clock-type [CLOCK-TYPE time-utc]) => symbol" (id default-date-clock-type))) (p "Sets or gets the clock-type used by default for conversion of a date to a time."))) (section 5 "copy-date" (def (sig (procedure "(copy-date DATE) => date" (id copy-date))) (p "Returns an exact copy of the specified " (tt "DATE") " object."))) (section 5 "date->time" (def (sig (procedure "(date->time DATE [CLOCK-TYPE (default-date-clock-type)]) => time" (id date->time))) (p "Returns the specified " (tt "DATE") " as a time-object of type " (tt "CLOCK-TYPE") "."))) (section 5 "date-zone-name" (def (sig (procedure "(date-zone-name DATE) => (union boolean string)" (id date-zone-name))) (p "Returns the timezone abbreviation of the specified " (tt "DATE") " object. The result is either a string or " (tt "#f") "."))) (section 5 "date-dst?" (def (sig (procedure "(date-dst? DATE) => boolean" (id date-dst?))) (p "Returns the daylight saving time flag of the specified " (tt "DATE") " object.") (p "Only valid for \"current\" dates. Historical dates will not have a correct setting. Future dates cannot have a correct setting.")))) (section 4 "Date Arithmetic" (section 5 "date-difference" (def (sig (procedure "(date-difference DATE1 DATE2 [CLOCK-TYPE]) => time" (id date-difference))) (p "Returns the duration between " (tt "DATE1") " and " (tt "DATE2") "."))) (section 5 "date-add-duration" (def (sig (procedure "(date-add-duration DATE DURATION [CLOCK-TYPE]) => time" (id date-add-duration))) (p "Returns the " (tt "DATE") " plus the " (tt "DURATION") "."))) (section 5 "date-subtract-duration" (def (sig (procedure "(date-subtract-duration DATE DURATION [CLOCK-TYPE]) => time" (id date-subtract-duration))) (p "Returns the " (tt "DATE") " minus the " (tt "DURATION") ".")))) (section 4 "Date Comparison" (section 5 "date-compare" (def (sig (procedure "(date-compare DATE1 DATE2) => integer" (id date-compare))) (p "Returns -1, 0, or 1."))) (section 5 "date=?" (def (sig (procedure "(date=? DATE1 DATE2) => boolean" (id date=?))) (p "Is " (tt "DATE1") " on " (tt "DATE2") "?"))) (section 5 "date>?" (def (sig (procedure "(date>? DATE1 DATE2) => boolean" (id date>?))) (p "Is " (tt "DATE1") " after " (tt "DATE2") "?"))) (section 5 "date<?" (def (sig (procedure "(date<? DATE1 DATE2) => boolean" (id date<?))) (p "Is " (tt "DATE1") " before " (tt "DATE2") "?"))) (section 5 "date>=?" (def (sig (procedure "(date>=? DATE1 DATE2) => boolean" (id date>=?))) (p "Is " (tt "DATE1") " after or on " (tt "DATE2") "?"))) (section 5 "date<=?" (def (sig (procedure "(date<=? DATE1 DATE2) => boolean" (id date<=?))) (p "Is " (tt "DATE1") " before or on " (tt "DATE2") "?")))) (section 4 "Timezone" (ul (li "Note that the daylight saving time (summer time) flag is " (b "always") " taken from the system, unless supplied. Any summer time rule component of a " (tt "timezone-components") " object is " (b "not") " processed.")) (p "Remember that SRFI 19 timezone offset follows ISO 8601.") (section 5 "local-timezone-locale" (def (sig (parameter "(local-timezone-locale [TZ-COMPONENTS])" (id local-timezone-locale))) (p "Gets or sets the local timezone-locale object."))) (section 5 "utc-timezone-locale" (def (sig (parameter "(utc-timezone-locale [TZ-COMPONENTS])" (id utc-timezone-locale))) (p "Gets or sets the utc timezone-locale object.") (p "Probably not a good idea to change the value."))) (section 5 "timezone-locale-name" (def (sig (procedure "(timezone-locale-name [TZ-COMPONENTS]) => symbol" (id timezone-locale-name))) (p "Returns the timezone-locale name of the supplied " (tt "TZ-COMPONENTS") ", or the " (tt "(local-timezone-locale)") " if missing."))) (section 5 "timezone-locale-offset" (def (sig (procedure "(timezone-locale-offset [TZ-COMPONENTS]) => integer" (id timezone-locale-offset))) (p "Returns the timezone-locale offset of the supplied " (tt "TZ-COMPONENTS") ", or the " (tt "(local-timezone-locale)") " if missing."))) (section 5 "timezone-locale-dst?" (def (sig (procedure "(timezone-locale-dst? [TZ-COMPONENTS]) => boolean" (id timezone-locale-dst?))) (p "Returns the timezone-locale daylight saving time flag of the supplied " (tt "TZ-COMPONENTS") ", or the " (tt "(local-timezone-locale)") " if missing."))))) (section 3 "Input/Output Procedures" (highlight scheme "(require-extension srfi-19-io)") (section 4 "DATE->STRING conversion specifiers" (p "The SRFI 19 document does not mention the padding character override feature for the normally zero-padded conversions " (tt "f") ", " (tt "H") ", " (tt "I") ", " (tt "j") ", " (tt "m") ", " (tt "M") ", " (tt "N") ", " (tt "S") ", " (tt "y") ". If the the tilde is followed by a " (tt "-") " then padding is suppressed. If followed by a " (tt "_") " the space character is used for padding. If followed by the conversion character then zero-padding is perfomed, the defualt.") (p "~[-_][fHIjmMNSy]") (section 5 "format-date" (def (sig (procedure "(format-date DESTINATION DATE-FORMAT-STRING DATE)" (id format-date))) (p "Displays a text form of the " (tt "DATE") " on the " (tt "DESTINATION") " using the " (tt "DATE-FORMAT-STRING") ".") (p "When the destination is " (tt "#t") " the " (tt "(current-output-port)") " is used, and the date object must be specified.") (p "When the destination is a port it must be an " (tt "output-port") ", and the date object must be specified. When the destination is a number the " (tt "(current-error-port)") " is the destination, and the " (tt "DATE") " object must be specified.") (p "When the destination is " (tt "#f") " the result is returned as a string, and the " (tt "DATE") " object must be specified.")) (def (sig (procedure "(format-date DATE-FORMAT-STRING DATE)" (id format-date))) (p "Result is returned as a string."))) (section 5 "scan-date" (def (sig (procedure "(scan-date SOURCE TEMPLATE-STRING)" (id scan-date))) (p "Reads a text form of a date from the " (tt "SOURCE") ", following the " (tt "TEMPLATE-STRING") ", and returns a date object.") (p "When the source is " (tt "#t") " the " (tt "(current-input-port)") " is used.") (p "When the source is a port it must be an " (tt "input-port") ".") (p "When the source is string it should be a date text form."))))) (section 3 "Time Period" (section 4 "Usage" (highlight scheme "(require-extension srfi-19-period)") (p "A time-period is an interval, [begin end), where begin and end are time objects of the same clock type. When end <= begin the interval is null.") (section 5 "make-null-time-period" (def (sig (procedure "(make-null-time-period [CLOCK-TYPE (default-date-clock-type)]) => time-period" (id make-null-time-period))) (p "Returns a null interval for the specified " (tt "CLOCK-TYPE") "."))) (section 5 "make-time-period" (def (sig (procedure "(make-time-period BEGIN END [CLOCK-TYPE (default-date-clock-type)]) => time-period" (id make-time-period))) (p "Returns a new time-period object. The clock types must be compatible.") (p (tt "BEGIN") " maybe a seconds value, a date, or a time (except time-duration). A seconds value or date are converted to " (tt "CLOCK-TYPE") ".") (p (tt "END") " maybe a seconds value, a date, or a time. A seconds value or date are converted to the same clock type as " (tt "BEGIN") ". A time-duration is treated as an offset from " (tt "BEGIN") "."))) (section 5 "copy-time-period" (def (sig (procedure "(copy-time-period TIME-PERIOD) => time-period" (id copy-time-period))) (p "Returns a copy of " (tt "TIME-PERIOD") "."))) (section 5 "time-period-begin" (def (sig (procedure "(time-period-begin TIME-PERIOD)" (id time-period-begin))) (p "Returns the start time for the " (tt "TIME-PERIOD") "."))) (section 5 "time-period-end" (def (sig (procedure "(time-period-end TIME-PERIOD) => time" (id time-period-end))) (p "Returns the end time for the " (tt "TIME-PERIOD") "."))) (section 5 "time-period-last" (def (sig (procedure "(time-period-last TIME-PERIOD) => time" (id time-period-last))) (p "Returns the last time for the " (tt "TIME-PERIOD") "; (time-period-end - 1ns)."))) (section 5 "time-period-type" (def (sig (procedure "(time-period-type TIME-PERIOD) => symbol" (id time-period-type))) (p "Returns the clock-type of the " (tt "TIME-PERIOD") "."))) (section 5 "time-period?" (def (sig (procedure "(time-period? OBJECT) => boolean" (id time-period?))) (p "Is " (tt "OBJECT") " a time-period?"))) (section 5 "time-period-null?" (def (sig (procedure "(time-period-null? TIME-PERIOD) => boolean" (id time-period-null?))) (p "Is the " (tt "TIME-PERIOD") " null?"))) (section 5 "time-period-length" (def (sig (procedure "(time-period-length TIME-PERIOD) => time" (id time-period-length))) (p "Returns the time-duration of the " (tt "TIME-PERIOD") "."))) (section 5 "time-period-compare" (def (sig (procedure "(time-period-compare TIME-PERIOD-1 TIME-PERIOD-2) => integer" (id time-period-compare))) (p "Returns " (tt "-1") " when " (tt "TIME-PERIOD-1") " < " (tt "TIME-PERIOD-2") ", " (tt "0") " when " (tt "TIME-PERIOD-1") " = " (tt "TIME-PERIOD-2") " and " (tt "1") " " (tt "TIME-PERIOD-1") " > " (tt "TIME-PERIOD-2") "."))) (section 5 "time-period=?" (def (sig (procedure "(time-period=? TIME-PERIOD-1 TIME-PERIOD-2) => boolean" (id time-period=?))) (p "Does " (tt "TIME-PERIOD-1") " begin & end with " (tt "TIME-PERIOD-2") "?"))) (section 5 "time-period<?" (def (sig (procedure "(time-period<? TIME-PERIOD-1 TIME-PERIOD-2) => boolean" (id time-period<?))) (p "Does " (tt "TIME-PERIOD-1") " end before " (tt "TIME-PERIOD-2") " begins?"))) (section 5 "time-period>?" (def (sig (procedure "(time-period>? TIME-PERIOD-1 TIME-PERIOD-2) => boolean" (id time-period>?))) (p "Does " (tt "TIME-PERIOD-1") " begin after " (tt "TIME-PERIOD-2") " ends?"))) (section 5 "time-period<=?" (def (sig (procedure "(time-period<=? TIME-PERIOD-1 TIME-PERIOD-2) => boolean" (id time-period<=?))) (p "Does " (tt "TIME-PERIOD-1") " end on or before " (tt "TIME-PERIOD-2") " begins?"))) (section 5 "time-period>=?" (def (sig (procedure "(time-period>=? TIME-PERIOD-1 TIME-PERIOD-2) => boolean" (id time-period>=?))) (p "Does " (tt "TIME-PERIOD-1") " begin on or after " (tt "TIME-PERIOD-2") " ends?"))) (section 5 "time-period-preceding" (def (sig (procedure "(time-period-preceding TIME-PERIOD-1 TIME-PERIOD-2) => (union boolean time-period)" (id time-period-preceding))) (p "Return the portion of " (tt "TIME-PERIOD-1") " before " (tt "TIME-PERIOD-2") " or " (tt "#f") " when it doesn't precede."))) (section 5 "time-period-succeeding" (def (sig (procedure "(time-period-succeeding TIME-PERIOD-1 TIME-PERIOD-2) => (union boolean time-period)" (id time-period-succeeding))) (p "Return the portion of " (tt "TIME-PERIOD-1") " after " (tt "TIME-PERIOD-2") " or " (tt "#f") " when it doesn't succeed."))) (section 5 "time-period-contains/period?" (def (sig (procedure "(time-period-contains/period? TIME-PERIOD-1 TIME-PERIOD-2) => boolean" (id time-period-contains/period?))) (p "Is " (tt "TIME-PERIOD-2") " within " (tt "TIME-PERIOD-1") "?"))) (section 5 "time-period-contains/time?" (def (sig (procedure "(time-period-contains/time? TIME-PERIOD TIME) => boolean" (id time-period-contains/time?))) (p "Is " (tt "TIME") " within " (tt "TIME-PERIOD") "?") (p (tt "TIME") " is converted to a compatible clock-type if possible."))) (section 5 "time-period-contains/date?" (def (sig (procedure "(time-period-contains/date? TIME-PERIOD DATE) => boolean" (id time-period-contains/date?))) (p "Is " (tt "DATE") " within " (tt "TIME-PERIOD") "?") (p (tt "DATE") " is converted to a compatible time if possible."))) (section 5 "time-period-contains?" (def (sig (procedure "(time-period-contains? TIME-PERIOD OBJECT) => boolean" (id time-period-contains?))) (p "Is " (tt "OBJECT") " within " (tt "TIME-PERIOD") "?") (p (tt "OBJECT") " maybe a time, date, or time-period."))) (section 5 "time-period-intersects?" (def (sig (procedure "(time-period-intersects? TIME-PERIOD-1 TIME-PERIOD-2) => boolean" (id time-period-intersects?))) (p "Does " (tt "TIME-PERIOD-2") " overlap " (tt "TIME-PERIOD-1") "?"))) (section 5 "time-period-intersection" (def (sig (procedure "(time-period-intersection TIME-PERIOD-1 TIME-PERIOD-2) => (union boolean time-period)" (id time-period-intersection))) (p "The overlapping time-period of " (tt "TIME-PERIOD-2") " and " (tt "TIME-PERIOD-1") ", or " (tt "#f") " when no overlap."))) (section 5 "time-period-union" (def (sig (procedure "(time-period-union TIME-PERIOD-1 TIME-PERIOD-2) => (union boolean time-period)" (id time-period-union))) (p "Returns the time-period spanned by " (tt "TIME-PERIOD-1") " and " (tt "TIME-PERIOD-2") ", or " (tt "#f") " when they do not intersect."))) (section 5 "time-period-span" (def (sig (procedure "(time-period-span TIME-PERIOD-1 TIME-PERIOD-2) => time-period" (id time-period-span))) (p "Returns the time-period spanned by " (tt "TIME-PERIOD-1") " and " (tt "TIME-PERIOD-2") ", including any gaps."))) (section 5 "time-period-shift" (def (sig (procedure "(time-period-shift TIME-PERIOD DURATION) => time-period" (id time-period-shift))) (p "Returns a copy of " (tt "TIME-PERIOD") " shifted by " (tt "DURATION") "."))) (section 5 "time-period-shift!" (def (sig (procedure "(time-period-shift! TIME-PERIOD DURATION) => time-period" (id time-period-shift!))) (p "Returns " (tt "TIME-PERIOD") " shifted by " (tt "DURATION") ".")))))) (section 2 "Usage" (ul (li "This module exports the time, date, timezone, and io APIs.")) (highlight scheme "(require-extension srfi-19)")) (section 2 "Notes" (ul (li "The " (tt "string->date") " and " (tt "scan-date") " procedures will not create an " (i "incomplete") " date. At a minimum the input must include day, month and year components; the time and timezone components default to 0 and the locale, respectively.") (li "31 December 1 BCE + 1 day => 1 January 1 CE. There is no year 0. Unlike the ISO 8601 convention do not subtract 1 when converting a year BCE to a SRFI 19 year, just negate the year.") (li "The SRFI 18 " (tt "current-time") " and " (tt "time?") " bindings conflict with SRFI 19 bindings.") (li "A SRFI 18 time object is not accepted except by the conversion procedures.") (li "The expression " (tt "(time=? (seconds->time (nanoseconds->seconds (time->nanoseconds <time-duration>))) <time-duration>)") " might be " (tt "#f") ", due to the use of inexact arithmetic.") (li "Be careful using the procedures that return some form of 'julian-day'. These are implemented using the full numeric tower and " (b "will") " return rational numbers. Performing arithmetic with such a result will require the \"numbers\" egg. See the file \"srfi-19-test.scm\" in this egg for an example.")) (p "This will be a problem with code that assumes fixnum and/or flonum " (b "only") " numbers. Perhaps an intermediate file that wraps any 'julian-day' calls and coerces to an inexact number. Use the wrapped 'julian-day' call in the problematic code.")) (section 2 "Requirements" (p (int-link "locale") " " (int-link "srfi-29") " " (int-link "miscmacros") " " (int-link "numbers"))) (section 2 "Bugs and Limitations" (ul (li "Local timezone information is not necessarily valid for historic dates and problematic for future dates. Daylight saving time is especially an issue. Conversion of a time or seconds value to a local date will use the current timezone offset value. The current offset will reflect the daylight saving time status. So target dates outside of the DST period will be converted incorrectly!") (li "Will not read years less than 1 properly. The ISO 8601 year convention for years 1 BCE and before and years 10000 CE and after is not supported.") (li "Cannot swap SRFI 29 bundle. Fixed at load time."))) (section 2 "Author" (p (int-link "/users/kon-lovett" "Kon Lovett"))) (section 2 "Version history" (dl (dt "3.1.1") (dd "Bug fix for non-unique month name key for " (i "May") ". Added padding character override information. The " (tt "ZONE-OFFSET") " argument of " (tt "make-date") " is optional. Added German bundle by Moritz Heidkamp.") (dt "3.1.0") (dd "Use of record-variants extension.") (dt "3.0.3") (dd "Bug fix for missing " (tt "seconds->time") " & " (tt "seconds->date") " in " (tt "srfi-19") ". (Reported by Alex Suraci)") (dt "3.0.2") (dd "Bug fix for " (tt "format-date") " output port check, " (tt "format-date") " and " (tt "scan-date") " argument type checks.") (dt "3.0.1") (dd "Bug fix for ~y input conversion.") (dt "3.0.0") (dd "Initial Chicken 4 release"))) (section 2 "License" (p "Copyright (C) 2009-2010 Kon Lovett.  All rights reserved.") (p "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:") (p "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.") (p "THE SOFTWARE IS PROVIDED ASIS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.") (p "Copyright (C) I/NET, Inc. (2000, 2002, 2003). All Rights Reserved. Copyright (C) Neodesic Corporation (2000). All Rights Reserved.") (p "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Scheme Request For Implementation process or editors, except as needed for the purpose of developing SRFIs in which case the procedures for copyrights defined in the SRFI process must be followed, or as required to translate it into languages other than English.") (p "The limited permissions granted above are perpetual and will not be revoked by the authors or their successors or assigns.") (p "This document and the information contained herein is provided on an \"AS IS\" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.")))