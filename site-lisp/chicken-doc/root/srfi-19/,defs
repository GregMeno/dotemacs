(index ("make-date" 0) ("read-leap-second-table" 930) ("leap-year?" 1214) ("time->srfi-18-time" 1424) ("srfi-18-time->time" 1681) ("seconds->time" 1870) ("seconds->date" 2076) ("time->nanoseconds" 2466) ("nanoseconds->time" 2622) ("nanoseconds->seconds" 2823) ("time->milliseconds" 2997) ("milliseconds->time" 3156) ("milliseconds->seconds" 3361) ("time->date" 3539) ("time->julian-day" 3726) ("time->modified-julian-day" 3871) ("make-duration" 4043) ("divide-duration" 4466) ("divide-duration!" 4656) ("multiply-duration" 4831) ("multiply-duration!" 5020) ("time-negative?" 5194) ("time-positve?" 5374) ("time-zero?" 5486) ("time-abs" 5588) ("time-abs!" 5713) ("time-negate" 5829) ("time-negate!" 5965) ("time-compare" 6092) ("time-max" 6201) ("time-min" 6347) ("default-date-clock-type" 6493) ("copy-date" 6692) ("date->time" 6827) ("date-zone-name" 7026) ("date-dst?" 7249) ("date-difference" 7537) ("date-add-duration" 7709) ("date-subtract-duration" 7877) ("date-compare" 8056) ("date=?" 8165) ("date>?" 8282) ("date<?" 8402) ("date>=?" 8523) ("date<=?" 8651) ("local-timezone-locale" 8780) ("utc-timezone-locale" 8926) ("timezone-locale-name" 9118) ("timezone-locale-offset" 9354) ("timezone-locale-dst?" 9597) ("format-date" 9855) ("format-date" 10581) ("scan-date" 10700) ("make-null-time-period" 11123) ("make-time-period" 11325) ("copy-time-period" 11886) ("time-period-begin" 12028) ("time-period-end" 12170) ("time-period-last" 12314) ("time-period-type" 12486) ("time-period?" 12635) ("time-period-null?" 12754) ("time-period-length" 12888) ("time-period-compare" 13042) ("time-period=?" 13380) ("time-period<?" 13559) ("time-period>?" 13739) ("time-period<=?" 13918) ("time-period>=?" 14106) ("time-period-preceding" 14293) ("time-period-succeeding" 14556) ("time-period-contains/period?" 14820) ("time-period-contains/time?" 15017) ("time-period-contains/date?" 15260) ("time-period-contains?" 15497) ("time-period-intersects?" 15719) ("time-period-intersection" 15909) ("time-period-union" 16177) ("time-period-span" 16446) ("time-period-shift" 16672) ("time-period-shift!" 16856))
(def (sig (procedure "(make-date NANOSECOND SECOND MINUTE HOUR DAY MONTH YEAR [ZONE-OFFSET [TZ-NAME [DST-FLAG]]]) => date" (id make-date))) (p "Same as SRFI 19 except for the optional parameters and allowing a timezone-components object for the " (tt "ZONE-OFFSET") ".") (p "The " (tt "ZONE-OFFSET") " is an " (tt "integer") " or " (tt "timezone-components") ". Default is the " (tt "(timezone-locale-offset)") ", the current locale timezone offset.") (p "The " (tt "TZ-NAME") " is a " (tt "string") " or " (tt "#f") ", and is the timezone name. Default is " (tt "#f") ".") (p "The " (tt "DST-FLAG") " is a " (tt "boolean") ", and indicates whether Day Saving TIme (or Summer Time) is active. Default is " (tt "#f") ".") (p "When the " (tt "ZONE-OFFSET") " is a " (tt "timezone-components") " object the " (tt "TZ-NAME") " and " (tt "DST-FLAG") " are pulled from the " (tt "timezone-components") ", unless explicitly supplied."))
(def (sig (procedure "(read-leap-second-table FILENAME)" (id read-leap-second-table))) (p "Sets the leap second table from the specified " (tt "FILENAME") ".") (p "The file format is the same as the \"tai-utc.dat\" file in the distribution. Provided by the U.S. Naval Observatory."))
(def (sig (procedure "(leap-year? DATE) => boolean" (id leap-year?))) (p "Does the specified " (tt "DATE") " fall on a leap year?") (p "The " (tt "DATE") " may be a numeric year or a " (tt "date") " object."))
(def (sig (procedure "(time->srfi-18-time TIME) => srfi-18#time" (id time->srfi-18-time))) (p "Converts a SRFI 19 time object to a SRFI 18 time object. The conversion is really only meaningful for " (tt "time-duration") ", but any time-type is accepted."))
(def (sig (procedure "(srfi-18-time->time  => srfi-18#time) => srfi-19#time" (id srfi-18-time->time))) (p "Converts a SRFI 18 time object into a SRFI 19 " (tt "time-duration") " object."))
(def (sig (procedure "(seconds->time SECONDS [TIME-TYPE time-duration]) => time" (id seconds->time))) (p "Converts a " (tt "SECONDS") " value, may be fractional, into a " (tt "TIME-TYPE") " time object."))
(def (sig (procedure "(seconds->date SECONDS [TIMEZONE-INFO #f]) => date" (id seconds->date))) (p "Converts a " (tt "SECONDS") " value, which may be fractional, into a date object. The " (tt "TIMEZONE-INFO") " is " (tt "#t") " for the local timezone, " (tt "#f") " for the utc timezone, or a timezone-components object.") (p (tt "SECONDS") " is relative to 00:00:00 January 1, 1970 UTC."))
(def (sig (procedure "(time->nanoseconds TIME) => integer" (id time->nanoseconds))) (p "Returns the " (tt "TIME") " object value as a nanoseconds value."))
(def (sig (procedure "(nanoseconds->time NANOSECONDS [TIME-TYPE time-duration]) => time" (id nanoseconds->time))) (p "Returns the " (tt "NANOSECONDS") " value as a time " (tt "TIME-TYPE") " object."))
(def (sig (procedure "(nanoseconds->seconds NANOSECONDS) => integer" (id nanoseconds->seconds))) (p "Returns the " (tt "NANOSECONDS") " value as an inexact seconds value."))
(def (sig (procedure "(time->milliseconds TIME) => integer" (id time->milliseconds))) (p "Returns the " (tt "TIME") " object value as a milliseconds value."))
(def (sig (procedure "(milliseconds->time MILLISECONDS [TIME-TYPE time-duration]) => time" (id milliseconds->time))) (p "Returns the " (tt "MILLISECONDS") " value as a time " (tt "TIME-TYPE") " object."))
(def (sig (procedure "(milliseconds->seconds MILLISECONDS) => integer" (id milliseconds->seconds))) (p "Returns the " (tt "MILLISECONDS") " value as an inexact seconds value."))
(def (sig (procedure "(time->date TIME) => date" (id time->date))) (p "Returns the " (tt "TIME") " object value as a date. A shorthand for the " (tt "(time-*->date...)") " procedures."))
(def (sig (procedure "(time->julian-day TIME) => rational" (id time->julian-day))) (p "Returns the julian day for the " (tt "TIME") " object."))
(def (sig (procedure "(time->modified-julian-day TIME) => rational" (id time->modified-julian-day))) (p "Returns the modified julian day for the " (tt "TIME") " object."))
(def (sig (procedure "(make-duration [#:days 0] [#:hours 0] [#:minutes 0] [#:seconds 0] [#:milliseconds 0] [#:microseconds 0] [#:nanoseconds 0]) => time" (id make-duration))) (p "Returns a time-object of clock-type " (tt "time-duration") " where the seconds and nanoseconds values are calculated by summing the keyword arguments.") (p (tt "ONE-SECOND-DURATION") " and " (tt "ONE-NANOSECOND-DURATION") " are pre-defined."))
(def (sig (procedure "(divide-duration DURATION NUMBER) => time" (id divide-duration))) (p "Returns a duration, from " (tt "DURATION") ", divided by " (tt "NUMBER") ", without remainder."))
(def (sig (procedure "(divide-duration! DURATION NUMBER) => time" (id divide-duration!))) (p "Returns " (tt "DURATION") ", divided by " (tt "NUMBER") ", without remainder."))
(def (sig (procedure "(multiply-duration DURATION NUMBER) => time" (id multiply-duration))) (p "Returns a duration, from " (tt "DURATION") ", multiplied by " (tt "NUMBER") ", truncated."))
(def (sig (procedure "(multiply-duration! DURATION NUMBER) => time" (id multiply-duration!))) (p "Returns " (tt "DURATION") ", multiplied by " (tt "NUMBER") ", truncated."))
(def (sig (procedure "(time-negative? TIME) => boolean" (id time-negative?))) (p "Is " (tt "TIME") " negative?") (p "A time object will never have a negative nanoseconds value."))
(def (sig (procedure "(time-positve? TIME) => boolean" (id time-positve?))) (p "Is " (tt "TIME") " positive?"))
(def (sig (procedure "(time-zero? TIME) => boolean" (id time-zero?))) (p "Is " (tt "TIME") " zero?"))
(def (sig (procedure "(time-abs TIME) => time" (id time-abs))) (p "Returns the absolute time value, from " (tt "TIME") "."))
(def (sig (procedure "(time-abs! TIME) => time" (id time-abs!))) (p "Returns the absolute " (tt "TIME") " value."))
(def (sig (procedure "(time-negate TIME) => time" (id time-negate))) (p "Returns the sign inverted time value, from " (tt "TIME") "."))
(def (sig (procedure "(time-negate! TIME) => time" (id time-negate!))) (p "Returns the " (tt "TIME") " sign inverted value."))
(def (sig (procedure "(time-compare TIME1 TIME2) => integer" (id time-compare))) (p "Returns -1, 0, or 1."))
(def (sig (procedure "(time-max TIME1 [TIME2...]) => time" (id time-max))) (p "Returns the maximum time object from " (tt "TIME1 TIME2...") "."))
(def (sig (procedure "(time-min TIME1 [TIME2...]) => time" (id time-min))) (p "Returns the minimum time object from " (tt "TIME1 TIME2...") "."))
(def (sig (parameter "(default-date-clock-type [CLOCK-TYPE time-utc]) => symbol" (id default-date-clock-type))) (p "Sets or gets the clock-type used by default for conversion of a date to a time."))
(def (sig (procedure "(copy-date DATE) => date" (id copy-date))) (p "Returns an exact copy of the specified " (tt "DATE") " object."))
(def (sig (procedure "(date->time DATE [CLOCK-TYPE (default-date-clock-type)]) => time" (id date->time))) (p "Returns the specified " (tt "DATE") " as a time-object of type " (tt "CLOCK-TYPE") "."))
(def (sig (procedure "(date-zone-name DATE) => (union boolean string)" (id date-zone-name))) (p "Returns the timezone abbreviation of the specified " (tt "DATE") " object. The result is either a string or " (tt "#f") "."))
(def (sig (procedure "(date-dst? DATE) => boolean" (id date-dst?))) (p "Returns the daylight saving time flag of the specified " (tt "DATE") " object.") (p "Only valid for \"current\" dates. Historical dates will not have a correct setting. Future dates cannot have a correct setting."))
(def (sig (procedure "(date-difference DATE1 DATE2 [CLOCK-TYPE]) => time" (id date-difference))) (p "Returns the duration between " (tt "DATE1") " and " (tt "DATE2") "."))
(def (sig (procedure "(date-add-duration DATE DURATION [CLOCK-TYPE]) => time" (id date-add-duration))) (p "Returns the " (tt "DATE") " plus the " (tt "DURATION") "."))
(def (sig (procedure "(date-subtract-duration DATE DURATION [CLOCK-TYPE]) => time" (id date-subtract-duration))) (p "Returns the " (tt "DATE") " minus the " (tt "DURATION") "."))
(def (sig (procedure "(date-compare DATE1 DATE2) => integer" (id date-compare))) (p "Returns -1, 0, or 1."))
(def (sig (procedure "(date=? DATE1 DATE2) => boolean" (id date=?))) (p "Is " (tt "DATE1") " on " (tt "DATE2") "?"))
(def (sig (procedure "(date>? DATE1 DATE2) => boolean" (id date>?))) (p "Is " (tt "DATE1") " after " (tt "DATE2") "?"))
(def (sig (procedure "(date<? DATE1 DATE2) => boolean" (id date<?))) (p "Is " (tt "DATE1") " before " (tt "DATE2") "?"))
(def (sig (procedure "(date>=? DATE1 DATE2) => boolean" (id date>=?))) (p "Is " (tt "DATE1") " after or on " (tt "DATE2") "?"))
(def (sig (procedure "(date<=? DATE1 DATE2) => boolean" (id date<=?))) (p "Is " (tt "DATE1") " before or on " (tt "DATE2") "?"))
(def (sig (parameter "(local-timezone-locale [TZ-COMPONENTS])" (id local-timezone-locale))) (p "Gets or sets the local timezone-locale object."))
(def (sig (parameter "(utc-timezone-locale [TZ-COMPONENTS])" (id utc-timezone-locale))) (p "Gets or sets the utc timezone-locale object.") (p "Probably not a good idea to change the value."))
(def (sig (procedure "(timezone-locale-name [TZ-COMPONENTS]) => symbol" (id timezone-locale-name))) (p "Returns the timezone-locale name of the supplied " (tt "TZ-COMPONENTS") ", or the " (tt "(local-timezone-locale)") " if missing."))
(def (sig (procedure "(timezone-locale-offset [TZ-COMPONENTS]) => integer" (id timezone-locale-offset))) (p "Returns the timezone-locale offset of the supplied " (tt "TZ-COMPONENTS") ", or the " (tt "(local-timezone-locale)") " if missing."))
(def (sig (procedure "(timezone-locale-dst? [TZ-COMPONENTS]) => boolean" (id timezone-locale-dst?))) (p "Returns the timezone-locale daylight saving time flag of the supplied " (tt "TZ-COMPONENTS") ", or the " (tt "(local-timezone-locale)") " if missing."))
(def (sig (procedure "(format-date DESTINATION DATE-FORMAT-STRING DATE)" (id format-date))) (p "Displays a text form of the " (tt "DATE") " on the " (tt "DESTINATION") " using the " (tt "DATE-FORMAT-STRING") ".") (p "When the destination is " (tt "#t") " the " (tt "(current-output-port)") " is used, and the date object must be specified.") (p "When the destination is a port it must be an " (tt "output-port") ", and the date object must be specified. When the destination is a number the " (tt "(current-error-port)") " is the destination, and the " (tt "DATE") " object must be specified.") (p "When the destination is " (tt "#f") " the result is returned as a string, and the " (tt "DATE") " object must be specified."))
(def (sig (procedure "(format-date DATE-FORMAT-STRING DATE)" (id format-date))) (p "Result is returned as a string."))
(def (sig (procedure "(scan-date SOURCE TEMPLATE-STRING)" (id scan-date))) (p "Reads a text form of a date from the " (tt "SOURCE") ", following the " (tt "TEMPLATE-STRING") ", and returns a date object.") (p "When the source is " (tt "#t") " the " (tt "(current-input-port)") " is used.") (p "When the source is a port it must be an " (tt "input-port") ".") (p "When the source is string it should be a date text form."))
(def (sig (procedure "(make-null-time-period [CLOCK-TYPE (default-date-clock-type)]) => time-period" (id make-null-time-period))) (p "Returns a null interval for the specified " (tt "CLOCK-TYPE") "."))
(def (sig (procedure "(make-time-period BEGIN END [CLOCK-TYPE (default-date-clock-type)]) => time-period" (id make-time-period))) (p "Returns a new time-period object. The clock types must be compatible.") (p (tt "BEGIN") " maybe a seconds value, a date, or a time (except time-duration). A seconds value or date are converted to " (tt "CLOCK-TYPE") ".") (p (tt "END") " maybe a seconds value, a date, or a time. A seconds value or date are converted to the same clock type as " (tt "BEGIN") ". A time-duration is treated as an offset from " (tt "BEGIN") "."))
(def (sig (procedure "(copy-time-period TIME-PERIOD) => time-period" (id copy-time-period))) (p "Returns a copy of " (tt "TIME-PERIOD") "."))
(def (sig (procedure "(time-period-begin TIME-PERIOD)" (id time-period-begin))) (p "Returns the start time for the " (tt "TIME-PERIOD") "."))
(def (sig (procedure "(time-period-end TIME-PERIOD) => time" (id time-period-end))) (p "Returns the end time for the " (tt "TIME-PERIOD") "."))
(def (sig (procedure "(time-period-last TIME-PERIOD) => time" (id time-period-last))) (p "Returns the last time for the " (tt "TIME-PERIOD") "; (time-period-end - 1ns)."))
(def (sig (procedure "(time-period-type TIME-PERIOD) => symbol" (id time-period-type))) (p "Returns the clock-type of the " (tt "TIME-PERIOD") "."))
(def (sig (procedure "(time-period? OBJECT) => boolean" (id time-period?))) (p "Is " (tt "OBJECT") " a time-period?"))
(def (sig (procedure "(time-period-null? TIME-PERIOD) => boolean" (id time-period-null?))) (p "Is the " (tt "TIME-PERIOD") " null?"))
(def (sig (procedure "(time-period-length TIME-PERIOD) => time" (id time-period-length))) (p "Returns the time-duration of the " (tt "TIME-PERIOD") "."))
(def (sig (procedure "(time-period-compare TIME-PERIOD-1 TIME-PERIOD-2) => integer" (id time-period-compare))) (p "Returns " (tt "-1") " when " (tt "TIME-PERIOD-1") " < " (tt "TIME-PERIOD-2") ", " (tt "0") " when " (tt "TIME-PERIOD-1") " = " (tt "TIME-PERIOD-2") " and " (tt "1") " " (tt "TIME-PERIOD-1") " > " (tt "TIME-PERIOD-2") "."))
(def (sig (procedure "(time-period=? TIME-PERIOD-1 TIME-PERIOD-2) => boolean" (id time-period=?))) (p "Does " (tt "TIME-PERIOD-1") " begin & end with " (tt "TIME-PERIOD-2") "?"))
(def (sig (procedure "(time-period<? TIME-PERIOD-1 TIME-PERIOD-2) => boolean" (id time-period<?))) (p "Does " (tt "TIME-PERIOD-1") " end before " (tt "TIME-PERIOD-2") " begins?"))
(def (sig (procedure "(time-period>? TIME-PERIOD-1 TIME-PERIOD-2) => boolean" (id time-period>?))) (p "Does " (tt "TIME-PERIOD-1") " begin after " (tt "TIME-PERIOD-2") " ends?"))
(def (sig (procedure "(time-period<=? TIME-PERIOD-1 TIME-PERIOD-2) => boolean" (id time-period<=?))) (p "Does " (tt "TIME-PERIOD-1") " end on or before " (tt "TIME-PERIOD-2") " begins?"))
(def (sig (procedure "(time-period>=? TIME-PERIOD-1 TIME-PERIOD-2) => boolean" (id time-period>=?))) (p "Does " (tt "TIME-PERIOD-1") " begin on or after " (tt "TIME-PERIOD-2") " ends?"))
(def (sig (procedure "(time-period-preceding TIME-PERIOD-1 TIME-PERIOD-2) => (union boolean time-period)" (id time-period-preceding))) (p "Return the portion of " (tt "TIME-PERIOD-1") " before " (tt "TIME-PERIOD-2") " or " (tt "#f") " when it doesn't precede."))
(def (sig (procedure "(time-period-succeeding TIME-PERIOD-1 TIME-PERIOD-2) => (union boolean time-period)" (id time-period-succeeding))) (p "Return the portion of " (tt "TIME-PERIOD-1") " after " (tt "TIME-PERIOD-2") " or " (tt "#f") " when it doesn't succeed."))
(def (sig (procedure "(time-period-contains/period? TIME-PERIOD-1 TIME-PERIOD-2) => boolean" (id time-period-contains/period?))) (p "Is " (tt "TIME-PERIOD-2") " within " (tt "TIME-PERIOD-1") "?"))
(def (sig (procedure "(time-period-contains/time? TIME-PERIOD TIME) => boolean" (id time-period-contains/time?))) (p "Is " (tt "TIME") " within " (tt "TIME-PERIOD") "?") (p (tt "TIME") " is converted to a compatible clock-type if possible."))
(def (sig (procedure "(time-period-contains/date? TIME-PERIOD DATE) => boolean" (id time-period-contains/date?))) (p "Is " (tt "DATE") " within " (tt "TIME-PERIOD") "?") (p (tt "DATE") " is converted to a compatible time if possible."))
(def (sig (procedure "(time-period-contains? TIME-PERIOD OBJECT) => boolean" (id time-period-contains?))) (p "Is " (tt "OBJECT") " within " (tt "TIME-PERIOD") "?") (p (tt "OBJECT") " maybe a time, date, or time-period."))
(def (sig (procedure "(time-period-intersects? TIME-PERIOD-1 TIME-PERIOD-2) => boolean" (id time-period-intersects?))) (p "Does " (tt "TIME-PERIOD-2") " overlap " (tt "TIME-PERIOD-1") "?"))
(def (sig (procedure "(time-period-intersection TIME-PERIOD-1 TIME-PERIOD-2) => (union boolean time-period)" (id time-period-intersection))) (p "The overlapping time-period of " (tt "TIME-PERIOD-2") " and " (tt "TIME-PERIOD-1") ", or " (tt "#f") " when no overlap."))
(def (sig (procedure "(time-period-union TIME-PERIOD-1 TIME-PERIOD-2) => (union boolean time-period)" (id time-period-union))) (p "Returns the time-period spanned by " (tt "TIME-PERIOD-1") " and " (tt "TIME-PERIOD-2") ", or " (tt "#f") " when they do not intersect."))
(def (sig (procedure "(time-period-span TIME-PERIOD-1 TIME-PERIOD-2) => time-period" (id time-period-span))) (p "Returns the time-period spanned by " (tt "TIME-PERIOD-1") " and " (tt "TIME-PERIOD-2") ", including any gaps."))
(def (sig (procedure "(time-period-shift TIME-PERIOD DURATION) => time-period" (id time-period-shift))) (p "Returns a copy of " (tt "TIME-PERIOD") " shifted by " (tt "DURATION") "."))
(def (sig (procedure "(time-period-shift! TIME-PERIOD DURATION) => time-period" (id time-period-shift!))) (p "Returns " (tt "TIME-PERIOD") " shifted by " (tt "DURATION") "."))
