(index ("make-bit-reader" 0))
(def (sig (procedure "(make-bit-reader BYTE-READER)" (id make-bit-reader))) (p "Given a " (tt "BYTE-READER") " (a thunk), construct and return a function " (tt "(bit-reader N)") " that reads N bits from a byte-stream represented by the " (tt "BYTE-READER") ".  The " (tt "BYTE-READER") " is a function that takes no arguments and returns the current byte as an exact integer " (tt "[0-255]") ". The byte reader should return " (tt "#f") " on EOF.") (p "The bit reader returns N bits as an exact unsigned integer, " (tt "0 -... (no limit)") ". N must be a positive integer, otherwise the bit reader returns " (tt "#f") ". There is no upper limit on N -- other than the size of the input stream itself and the amount of (virtual) memory an OS is willing to give to your process. If you want to read 1M of _bits_, go ahead.") (p "It is assumed that the bit order is the most-significant bit first.") (p "Note the bit reader keeps the following condition true at all times:") (pre " (= current-inport-pos (ceiling (/ no-bits-read 8)))") (p "That is, no byte is read until the very moment we really need (some of) its bits. The bit reader does " (i "not") " \"byte read ahead\". Therefore, it can be used to handle a concatenation of different bit/byte streams " (b "strictly") " sequentially, " (i "without") " \"backing up a char\", \"unreading-char\" etc. tricks.") (p "Thus careful attention to byte-buffering and optimization are the features of this bit reader."))
