(type egg)
(signature "binary-parse egg")
(timestamp 1281588065.0)
(sxml ((tags "egg") (section 2 "binary-parse" (toc) (section 3 "Description" (p "Simple parsing of binary data.")) (section 3 "Author" (p (int-link "Oleg Kiselyov"))) (section 3 "Requirements" (p "None")) (section 3 "Download" (p (link "http://www.call-with-current-continuation.org/eggs/binary-parse.egg" "binary-parse.egg"))) (section 3 "Documentation" (p "If you want bignum support (ie, if the " (int-link "numbers") " egg is available), you can use:") (pre " (require-extension big-binary-parse)") (p "Otherwise, the following can be used:") (pre " (require-extension binary-parse)") (section 4 "make-bit-reader" (def (sig (procedure "(make-bit-reader BYTE-READER)" (id make-bit-reader))) (p "Given a " (tt "BYTE-READER") " (a thunk), construct and return a function " (tt "(bit-reader N)") " that reads N bits from a byte-stream represented by the " (tt "BYTE-READER") ".  The " (tt "BYTE-READER") " is a function that takes no arguments and returns the current byte as an exact integer " (tt "[0-255]") ". The byte reader should return " (tt "#f") " on EOF.") (p "The bit reader returns N bits as an exact unsigned integer, " (tt "0 -... (no limit)") ". N must be a positive integer, otherwise the bit reader returns " (tt "#f") ". There is no upper limit on N -- other than the size of the input stream itself and the amount of (virtual) memory an OS is willing to give to your process. If you want to read 1M of _bits_, go ahead.") (p "It is assumed that the bit order is the most-significant bit first.") (p "Note the bit reader keeps the following condition true at all times:") (pre " (= current-inport-pos (ceiling (/ no-bits-read 8)))") (p "That is, no byte is read until the very moment we really need (some of) its bits. The bit reader does " (i "not") " \"byte read ahead\". Therefore, it can be used to handle a concatenation of different bit/byte streams " (b "strictly") " sequentially, " (i "without") " \"backing up a char\", \"unreading-char\" etc. tricks.") (p "Thus careful attention to byte-buffering and optimization are the features of this bit reader."))) (section 4 "Usage example" (highlight scheme "(use binary-parse)\n\n(define bit-reader (make-bit-reader (lambda () #b11000101)))\n\n(bit-reader 3)\n => 6\n\n(bit-reader 4)\n => 2")) (section 4 "Notes on the algorithm." (p "The function recognizes and handles the following special cases:") (ul (li "The buffer is empty and 8, 16, 24 bits are to be read") (li "Reading all bits which are currently in the byte-buffer (and then maybe more)") (li "Reading only one bit")))) (section 3 "Changelog" (ul (li "1.2 Port to chicken 4") (li "1.1 When " (int-link "numbers") " extension is available, a bignum-aware version is additionally built") (li "1.0 Initial release"))) (section 3 "License"))))
