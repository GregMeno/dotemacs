(index ("fcgi-accept-loop" 0) ("in" 745) ("out" 1934) ("err" 2179) ("env" 2423) ("fcgi-get-post-data" 3413))
(def (sig (procedure "(fcgi-accept-loop SOCKET/PORT BACKLOG CALLBACK)" (id fcgi-accept-loop))) (p "Given either the filename of a UNIX local socket (string) or a port (integer) as its first argument, this procedure opens a socket and starts a loop for accepting FastCGI requests.  An exception is raised if there is an error opening/listening on the socket.  Every time a request is accepted, the CALLBACK argument is called with four procedure arguments which will be refered to as 'in', 'out', 'err' and 'env' in the documentation below.  The BACKLOG argument is passed to the " (link "http://www.die.net/doc/linux/man/man3/listen.3.html" "listen") " system call.") (p "If the callback returns " (tt "#f") ", the accept loop is terminated."))
(def (sig (procedure "(in [INT])" (id in))) (p "[This procedure is passed to the CALLBACK argument of " (tt "fcgi-accept-loop") ".]") (p "If called with no arguments, this procedure reads in as much data as possible from the input stream, returning " (tt "#f") " if the stream is empty, and a string otherwise.  If called with a single integer argument, it reads exactly the specified number of characters from the stream (and will block indefinitely if the stream is empty or contains too few characters).") (p "In either case, an exception is raised if there is an error reading from the stream.") (p "Don't use " (tt "(in)") " to read in post data, since there is no guarantee that it will read all of it.  Instead, call " (tt "in") " with the value of the " (tt "HTTP_CONTENT_LENGTH") " environment variable, or use the " (tt "fcgi-get-post-data") " procedure.") (p "The variable " (tt "*fcgi-slurp-chunk-size*") " determines the size of the input buffer which will be allocated by a zero-argument call to " (tt "in") ".  The value of this variable does not affect the maximum amount of input which can be read in, since additional buffers are automatically allocated as necessary."))
(def (sig (procedure "(out STRING)" (id out))) (p "[This procedure is passed to the " (tt "CALLBACK") " argument of " (tt "fcgi-accept-loop") ".]") (p "Writes " (tt "STRING") " to the output stream, raising an exception if there is an error."))
(def (sig (procedure "(err STRING)" (id err))) (p "[This procedure is passed to the " (tt "CALLBACK") " argument of " (tt "fcgi-accept-loop") ".]") (p "Writes " (tt "STRING") " to the error stream, raising an exception if there is an error."))
(def (sig (procedure "(env [VARNAME [DEFAULT]])" (id env))) (p "[This procedure is passed to the " (tt "CALLBACK") " argument of " (tt "fcgi-accept-loop") ".]") (p "If called with no arguments, this procedure returns a list of " (tt "(name . value)") " pairs giving the name and value of every variable in the environment.  If called with a single argument " (tt "VARNAME") ", it returns the value of the specified variable, or " (tt "#f") "if that variable is not set.") (p (tt "VARNAME") " may optionally be followed by a second argument, which specifies a default value to be returned if the variable is not set. " (tt "(env X)") " is thus equivalent to " (tt "(env X #f)") ".") (p "Note that this procedure cannot be called after another request has been accepted, since libfcgi does not maintain environments from previous requests (you will most likely get a segfault).  However, an old environment can easily be saved if necessary by storing the return value of " (tt "(env)") "."))
(def (sig (procedure "(fcgi-get-post-data IN ENV)" (id fcgi-get-post-data))) (p "Given an " (tt "IN") " procedure and an " (tt "ENV") " procedure, this procedure returns a string containing the post data for the last request, or " (tt "#f") " if the last request was not a post request."))
