((tags "egg") (section 2 "F-operator" (toc)) (section 2 "Documentation" (p "The static delimited continuation operators shift and reset.") (section 3 "Shift/Reset - Dynamically scoped shift/reset" (highlight scheme "(require-extension shift-reset)") (p "A \"stuck on control\" situation, a 'shift' without an enclosing 'reset', is an error.") (section 4 "%reset" (def (sig (syntax "(%reset EXPRESSION ...)" (id %reset))) (p "Evaluate the body " (tt "EXPRESSION ...") " with a delimited continuation. The body will contain one or more instances of {{(%shift ...))") (p "Any use of " (tt "(dynamic-wind ...)") " within the dynamic scope of the partial continuation will be " (b "ignored") "!"))) (section 4 "%shift" (def (sig (syntax "(%shift PC-TAG EXPRESSION)" (id %shift))) (p "Within the scope of " (tt "EXPRESSION") " " (tt "PC-TAG") " is bound to the reified partial continuation delimited by the enclosing " (tt "(%reset ...)") ". Provide a value to the partial continuation using the form " (tt "(PC-TAG <something>)") "."))) (section 4 "reset" (def (sig (syntax "(reset EXPRESSION ...)" (id reset))) (p "Evaluate the body " (tt "EXPRESSION ...") " with a delimited continuation. The body will contain one or more instances of " (tt "(shift ...)") "."))) (section 4 "shift" (def (sig (syntax "(shift PC-TAG EXPRESSION)" (id shift))) (p "Within the scope of " (tt "EXPRESSION") " " (tt "PC-TAG") " is bound to the reified partial continuation delimited by the enclosing " (tt "(reset ...)") ". Provide a value to the partial continuation using the form " (tt "(PC-TAG <something>)") "."))) (section 4 "%reset-values" (def (sig (syntax "(%reset-values EXPRESSION ...)" (id %reset-values))) (p "Multiple value return version of " (tt "(%reset ...)") ". The body will contain one or more instances of " (tt "(%shift-values ...)")) (p "Any use of " (tt "(dynamic-wind ...)") " within the dynamic scope of the partial continuation will be " (b "ignored") "!"))) (section 4 "%shift-values" (def (sig (syntax "(%shift-values PC-TAG EXPRESSION)" (id %shift-values))) (p "Multiple value return version of " (tt "(%shift ...)") ". Provide a value to the partial continuation using the form " (tt "(PC-TAG <something> ...)") "."))) (section 4 "reset-values" (def (sig (syntax "(reset-values EXPRESSION ...)" (id reset-values))) (p "Multiple value return version of " (tt "(reset ...)") ". The body will contain one or more instances of " (tt "(shift-values ...)") "."))) (section 4 "shift-values" (def (sig (syntax "(shift-values PC-TAG EXPRESSION)" (id shift-values))) (p "Multiple value return version of " (tt "(shift ...)") ". Provide a value to the partial continuation using the form " (tt "(PC-TAG <something> ...)") ".")))) (section 3 "BShift/BReset - Statically scoped shift/reset" (highlight scheme "(require-extension bshift-breset)") (p "Invalid delimited continuations, what " (tt "RC-TAG") " below represents, and " (i "stuck on control") " will generate an error") (section 4 "%breset" (def (sig (syntax "(%breset RC-TAG EXPRESSION ...)" (id %breset))) (p "Evaluate the body " (tt "EXPRESSION ...") " with a delimited continuation named " (tt "RC-TAG") ". The body will contain one or more instances of " (tt "(%bshift RC-TAG ...)")) (p "Any use of " (tt "(dynamic-wind ...)") " within the dynamic scope of the partial continuation will be " (b "ignored") "!"))) (section 4 "%bshift" (def (sig (syntax "(%bshift RC-TAG PC-TAG EXPRESSION)" (id %bshift))) (p "Within the scope of " (tt "EXPRESSION") " " (tt "PC-TAG") " is bound to the reified partial continuation delimited by the enclosing " (tt "(%breset RC-TAG ...)") ". Provide a value to the partial continuation using the form " (tt "(PC-TAG <something>)") "."))) (section 4 "breset" (def (sig (syntax "(breset RC-TAG EXPRESSION ...)" (id breset))) (p "Evaluate the body " (tt "EXPRESSION ...") " with a delimited continuation named " (tt "RC-TAG") ". The body will contain one or more instances of " (tt "(bshift RC-TAG ...)") "."))) (section 4 "bshift" (def (sig (syntax "(bshift RC-TAG PC-TAG EXPRESSION)" (id bshift))) (p "Within the scope of " (tt "EXPRESSION") " " (tt "PC-TAG") " is bound to the reified partial continuation delimited by the enclosing " (tt "(breset RC-TAG ...)") ". Provide a value to the partial continuation using the form " (tt "(PC-TAG <something>)") "."))) (section 4 "%breset-values" (def (sig (syntax "(%breset-values RC-TAG EXPRESSION ...)" (id %breset-values))) (p "Multiple value return version of " (tt "(%breset ...)") ". The body will contain one or more instances of " (tt "(%bshift-values RC-TAG ...)")) (p "Any use of " (tt "(dynamic-wind ...)") " within the dynamic scope of the partial continuation will be " (b "ignored") "!"))) (section 4 "%bshift-values" (def (sig (syntax "(%bshift-values RC-TAG PC-TAG EXPRESSION)" (id %bshift-values))) (p "Multiple value return version of " (tt "(%bshift ...)") ". Provide a value to the partial continuation using the form " (tt "(PC-TAG <something> ...)") "."))) (section 4 "breset-values" (def (sig (syntax "(breset-values RC-TAG EXPRESSION ...)" (id breset-values))) (p "Multiple value return version of " (tt "(breset ...)") ". The body will contain one or more instances of " (tt "(bshift-values RC-TAG ...)") "."))) (section 4 "bshift-values" (def (sig (syntax "(bshift-values RC-TAG PC-TAG EXPRESSION)" (id bshift-values))) (p "Multiple value return version of " (tt "(bshift ...)") ". Provide a value to the partial continuation using the form " (tt "(PC-TAG <something> ...)") ".")))) (section 3 "Range" (highlight scheme "(require-extension range)") (section 4 "range" (def (sig (syntax "(range RC-TAG FROM VALUE STEP TO?)" (id range))) (p "The value of the delimited continuation " (tt "RC-TAG") " ranges over the set of values specified by the state generation procedure suite. For use with " (tt "(breset ...)")) (dl (dt "FROM") (dd "Zero argument procedure, returning the initial state") (dt "VALUE") (dd "Single argument procedure, of the state, returning the value of the state") (dt "STEP") (dd "Single argument procedure, of the state, returning the next state") (dt "TO?") (dd "Single argument procedure, of the state, returning {{#t)  when the range is complete")))) (section 4 "range" (def (sig (syntax "(range RC-TAG FROM [STEP] TO)" (id range))) (p "The value of the delimited continuation " (tt "RC-TAG") " ranges over the number interval [" (tt "FROM") " " (tt "TO") "], by " (tt "STEP") ". The increment is 1 when missing. For use with  " (tt "(breset ...)") "."))) (section 4 "%range" (def (sig (syntax "(%range RC-TAG FROM VALUE STEP TO?)" (id %range))) (p "Version of " (tt "(range ...)") " for use with " (tt "(%breset ...)") "."))) (section 4 "%range" (def (sig (syntax "(%range RC-TAG FROM [STEP] TO)" (id %range))) (p "Version of " (tt "(range ...)") " for use with " (tt "(%breset ...)") ".")))) (section 3 "Reflect/Reify - Monads" (highlight scheme "(require-extension reflect-reify)") (section 4 "define-unit" (def (sig (syntax "(define-unit KIND BODY ...)" (id define-unit))) (p "Expands to " (tt "(define (KIND-unit obj) BODY ...)") "."))) (section 4 "define-bind" (def (sig (syntax "(define-bind KIND BODY ...)" (id define-bind))) (p "Expands to " (tt "(define (KIND-bind monad func) BODY ...)") "."))) (section 4 "reflect" (def (sig (syntax "(reflect KIND MONAD)" (id reflect))) (p "Extract value from " (tt "MONAD") ". Plays the role of Haskell '<-'."))) (section 4 "reflect-values" (def (sig (syntax "(reflect-values KIND MONAD)" (id reflect-values))) (p "Extract value from " (tt "MONAD") ". Plays the role of Haskell '<-'."))) (section 4 "%reflect" (def (sig (syntax "(%reflect KIND MONAD)" (id %reflect))) (p "Extract value from " (tt "MONAD") ". Plays the role of Haskell '<-'."))) (section 4 "reify" (def (sig (syntax "(reify KIND EXPRESSION)" (id reify))) (p "Return result of " (tt "EXPRESSION") " as a monad."))) (section 4 "reify-values" (def (sig (syntax "(reify-values KIND EXPRESSION)" (id reify-values))) (p "Return result of " (tt "EXPRESSION") " as a monad."))) (section 4 "%reify" (def (sig (syntax "(%reify KIND EXPRESSION)" (id %reify))) (p "Return result of " (tt "EXPRESSION") " as a monad.")))) (section 3 "GShift/GReset - Generalized shift/reset" (highlight scheme "(require-extension gshift-greset)") (p "The generalized shift and reset operator family from " (link "http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR611" "How to remove a dynamic prompt: static and dynamic delimited continuation operators are equally expressible")) (section 4 "greset" (def (sig (syntax "(greset HR E)" (id greset))) (p "Reset parameterized by the H Reset procedure " (tt "HR") "."))) (section 4 "gshift" (def (sig (syntax "(gshift HS F E)" (id gshift))) (p "Shift parameterized by the H Shift procedure " (tt "HS") "."))) (section 4 "hr-stop" (def (sig (procedure "(hr-stop V)" (id hr-stop))) (p "H Reset Stop."))) (section 4 "hs-stop" (def (sig (procedure "(hs-stop V)" (id hs-stop))) (p "H Shift Stop"))) (section 4 "hr-prop" (def (sig (procedure "(hr-prop V)" (id hr-prop))) (p "H Reset Propagate."))) (section 4 "hs-prop" (def (sig (procedure "(hs-prop V)" (id hs-prop))) (p "H Shift Propagate."))) (section 4 "h-compose" (def (sig (procedure "(h-compose F X)" (id h-compose))) (p "Returns the composition of " (tt "F") " and " (tt "X") " as an " (tt "h-datatype") "."))) (section 4 "h-value" (def (sig (procedure "(h-value V)" (id h-value))) (p "Returns the value of " (tt "V") " as an " (tt "h-datatype") "."))) (section 4 "h-datatype?" (def (sig (procedure "(h-datatype? OBJECT)" (id h-datatype?))) (p "Is " (tt "OBJECT") " an " (tt "h-datatype") "?"))) (section 4 "h-cases" (def (sig (syntax "(h-cases E ((F X) ON-h-EXPR) (V ON-V-EXPR))" (id h-cases))) (p "Deconstructs the " (tt "h-datatype") " " (tt "E") ", binding " (tt "F") " & " (tt "X") " for an evaluation of the " (tt "ON-h-EXPR") " and " (tt "V") " for an evaluation of the " (tt "ON-V-EXPR") "."))))) (section 2 "Usage" (p "See individual sections.")) (section 2 "Examples" (highlight scheme "(use shift-reset srfi-41 srfi-45)\n\n(define (my-list->stream list)\n  (iteration-procedure->stream\n   (lambda (receiver)\n     (for-each receiver list))))\n\n(define (iteration-procedure->stream iteration-procedure)\n  (reset\n    (iteration-procedure\n     (lambda (element)\n       (shift continue-iteration\n         (stream-cons element (lazy (continue-iteration (void)))))))\n    stream-null))")) (section 2 "Notes" (ul (li "Not a direct implementation of partial continuations. Simulated using full continuations."))) (section 2 "Requirements" (p (int-link "datatype") " " (int-link "miscmacros"))) (section 2 "Bugs and Limitations") (section 2 "Author" (p (int-link "/users/kon-lovett" "Kon Lovett"))) (section 2 "Version history" (dl (dt "2.0.1") (dd "Added miscmacros as a dependency [Ivan Raikov].") (dt "2.0.0") (dd "Initial Chicken 4 release."))) (section 2 "License" (p "Copyright (C) 2009 Kon Lovett.  All rights reserved.") (p "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:") (p "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.") (p "THE SOFTWARE IS PROVIDED ASIS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.") (p "Does not supercede any restrictions found in the source code.")))