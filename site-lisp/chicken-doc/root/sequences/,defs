(index ("size" 0) ("elt" 173) ("rev" 547) ("foldl" 688) ("foldr" 948) ("sub" 1190) ("pos" 1749) ("take" 2009) ("drop" 2257) ("split" 2486) ("partition" 2724) ("fill!" 2959) ("sequence?" 3253) ("linear-sequence?" 3394) ("random-access-sequence?" 3603) ("make-random-access-sequence" 3847) ("make-linear-sequence" 4628) ("make" 5490) ("sequence" 5682) ("iterator?" 5849) ("linear-iterator?" 5998) ("random-access-iterator?" 6175) ("iterator" 6373) ("at-end?" 6563) ("advance" 6755) ("advance!" 6755) ("index" 7135) ("for" 7283) ("for*" 7283) ("smap" 7612) ("smap" 7612) ("coerce" 7901) ("copy" 8059) ("is?" 8155))
(def (sig (procedure "(size S)" (id size))) (p "Returns the number of elements in the sequence " (tt "S") ". For linear sequences, this operation traverses all elements."))
(def (sig (procedure "(elt S I)" (id elt))) (p "Returns the " (tt "I") "-th element of " (tt "S") ". " (tt "I") " may be an exact integer or an iterator (see below).") (p "A sequence-element can be modified with " (tt "(set! (elt S I) X)") ".") (p "If " (tt "I") " is an iterator, then " (tt "S") " must be the same sequence that had been used to construct the iterator."))
(def (sig (procedure "(rev S)" (id rev))) (p "Returns a new sequence of the same type with the elements of " (tt "S") " in reverse order."))
(def (sig (procedure "(foldl PROC SEED S)" (id foldl))) (p "Performs a left \"fold\" over the sequence " (tt "S") ", where the procedure " (tt "PROC") " is applied to its previous result (or " (tt "SEED") " for the first element) and each sequence-element."))
(def (sig (procedure "(foldr PROC SEED S)" (id foldr))) (p "A right \"fold\" over sequence " (tt "S") ", " (tt "PROC") " is applied to each sequence element and the result of its last invocation (or " (tt "SEED") " for the first element)."))
(def (sig (procedure "(sub S START [END])" (id sub))) (p "Returns a new sequence with the elements of " (tt "S") ", starting at position " (tt "START") " up to but not including the element at position " (tt "END") ". If " (tt "END") " is not given, all remaining elements are returned. " (tt "START") " and " (tt "END") " may be exact integers or iterators.") (p "A range of elements may be modified by executing " (tt "(set! (sub S1 START [END]) S2)") ", which assigns the elements of " (tt "S2") " to the designated locations of sequence " (tt "S1") "."))
(def (sig (procedure "(pos PRED S)" (id pos))) (p "Returns the index of the first element in " (tt "S") " that for which the one argument procedure " (tt "PRED") " returns true. If " (tt "PRED") " returns false for all arguments, " (tt "#f") " is returned."))
(def (sig (procedure "(take PRED S)" (id take))) (p "Returns a new sequence of the same type as " (tt "S") " with the elements up to but not including the first element for which the one-argument procedure " (tt "PRED") " returns " (tt "#f") "."))
(def (sig (procedure "(drop PRED S)" (id drop))) (p "Returns a new sequence of the same type as " (tt "S") " with the elements from the first element for which the one-argument procedure " (tt "PRED") " returns " (tt "#f") "."))
(def (sig (procedure "(split PRED S)" (id split))) (p "Returns two sequences of the same type as " (tt "S") " holding the elements split at the first position for which the one-argument procedure " (tt "PRED") " returns " (tt "#f") "."))
(def (sig (procedure "(partition PRED S)" (id partition))) (p "Returns two sequences of the same type as " (tt "S") " holding those elements for which the one-argument procedure " (tt "PRED") " returns true and false, respectively."))
(def (sig (procedure "(fill! PROC S [START [END]])" (id fill!))) (p "Calls " (tt "PROC") " with the sequence " (tt "S") " and an iterator object over the elements in " (tt "S") " starting at position " (tt "START") " up to but not including " (tt "END") " and returns the modified sequence."))
(def (sig (procedure "(sequence? X)" (id sequence?))) (p "Returns " (tt "#t") " if " (tt "X") " is a sequence or " (tt "#f") " otherwise."))
(def (sig (procedure "(linear-sequence? X)" (id linear-sequence?))) (p "Reurns " (tt "#t") " if " (tt "X") " is a list or a sequence created with " (tt "make-linear-sequence") " or " (tt "#f") " otherwise."))
(def (sig (procedure "(random-access-sequence? X)" (id random-access-sequence?))) (p "Returns " (tt "#t") " if " (tt "X") " is a vector, a string or a sequence created with " (tt "make-random-access-sequence") ", or " (tt "#f") " otherwise."))
(def (sig (procedure "(make-random-access-sequence MAKE ELT SIZE)" (id make-random-access-sequence))) (p "Returns an object representing a sequence that allows random access to its elements. " (tt "MAKE") " should be a procedure of two arguments, a size count and an initial value and should return a collection of elements which will be stored as \"data\" in the sequence object. " (tt "ELT") " should be a procedure of two arguments receiving the \"data\" and an exact integer index and should return the element inside the data collection at the given position. " (tt "SIZE") " should be a procedure that receives the data and returns the number of elements in that collection.") (p "Note that the \"data\" may be anything - the operators fully define how it is interpreted."))
(def (sig (procedure "(make-linear-sequence MAKE ELT NEXT)" (id make-linear-sequence))) (p "Returns an object representing a sequence that only allows sequential \"on-at-a-time\" access to its elements. " (tt "MAKE") " should be a procedure of two arguments, a size count and an initial value and should return a collection of elements which will be stored as \"state\" in the sequence object.  " (tt "ELT") " should be a procedure of one argument receiving the \"state\" and should return the element inside the collection that is represented by the currently stored state. " (tt "NEXT") " should be a procedure that receives the current state and returns a new state representing the underlying collection that will make the next element accessible via " (tt "ELT") ". If the collection has run out of elements, " (tt "NEXT") " should return " (tt "#f") "."))
(def (sig (procedure "(make S LENGTH INIT)" (id make))) (p "Creates a sequence of the same type as " (tt "S") " with " (tt "LENGTH") " elements that have the initial value " (tt "INIT") "."))
(def (sig (procedure "(sequence S X1 ...)" (id sequence))) (p "Creates a sequence of the same type as " (tt "S") " with " (tt "X1, ...") " as its initial elements."))
(def (sig (procedure "(iterator? X)" (id iterator?))) (p "Returns " (tt "#t") " if " (tt "X") " is an iterator object or " (tt "#f") " otherwise."))
(def (sig (procedure "(linear-iterator? X)" (id linear-iterator?))) (p "Returns " (tt "#t") " if " (tt "X") " is an iterator on a linear sequence or " (tt "#f") " otherwise."))
(def (sig (procedure "(random-access-iterator? X)" (id random-access-iterator?))) (p "Returns " (tt "#t") " if " (tt "X") " is an iterator on a random-access sewuence or " (tt "#f") " otherwise."))
(def (sig (procedure "(iterator S [INDEX])" (id iterator))) (p "Returns an iterator object over sequence " (tt "S") ", optionally starting at osition " (tt "INDEX") " (an exact integer)."))
(def (sig (procedure "(at-end? ITERATOR)" (id at-end?))) (p "Returns " (tt "#t") " if " (tt "ITERATOR") " points past the lat element of its associated sequence or " (tt "#f") " otherwise."))
(def (sig (procedure "(advance ITERATOR [STEPS])" (id advance)) (procedure "(advance! ITERATOR [STEPS])" (id advance!))) (p "Returns a new iterator (or modifies the given iterator in case of " (tt "advance!") ") pointing to the next element of the associated sequence or to the element at the position I + " (tt "STEPS") ", where I is the current index of " (tt "ITERATOR") "."))
(def (sig (procedure "(index ITERATOR)" (id index))) (p "Returns the exact integer index of the position to which " (tt "ITERATOR") " points to."))
(def (sig (procedure "(for PROC S)" (id for)) (procedure "(for* PROC S)" (id for*))) (p "Invokes " (tt "PROC") " for each element in sequence and returns an undefined result. " (tt "for*") " operates as " (tt "for") " but invokes " (tt "PROC") " with the sequence " (tt "S") " and an iterator pointing to the current element."))
(def (sig (procedure "(smap S1 PROC S2)" (id smap)) (procedure "(smap S1 PROC S2)" (id smap))) (p "Applies " (tt "PROC") " to each element in the sequence " (tt "S2") " and returns a new sequence of the same type as " (tt "S1") " constructed of the results returned by " (tt "PROC") "."))
(def (sig (procedure "(coerce S1 S2)" (id coerce))) (p "Returns a new sequence of the same type as " (tt "S1") " containing the elements of " (tt "S2") "."))
(def (sig (procedure "(copy S)" (id copy))) (p "Returns a copy of the sequence " (tt "S") "."))
(def (sig (procedure "(is? X)" (id is?))) (p "Returns a single-argument procedure that returns " (tt "#t") " if the argument is " (tt "equal?") " to " (tt "X") " or " (tt "#f") " otherwise."))
