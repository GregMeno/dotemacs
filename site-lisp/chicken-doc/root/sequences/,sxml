((tags "egg") (toc) (section 2 "sequences" (section 3 "Introduction" (p "Operations over generic or user-defined sequences.") (p (i "Note: this is currently under review - the API might still change"))) (section 3 "Usage" (highlight scheme "(require-extension sequences)")) (section 3 "Requirements" (p (int-link "fast-generic")) (p "This extension requires CHICKEN 4.6.3 or newer.")) (section 3 "Documentation" (p "A " (i "sequence") " is a collection of objects and may be either one of the built-in types vector, list or string, or the result of the sequence-constructors " (tt "make-linear-sequence") " and " (tt "make-random-access-sequences") ". A " (i "linear") " sequence is a sequence that only allows element-by-element access (i.e. a list), a " (i "random access") " sequences allows access to arbitrary elements through an index (i.e. vectors or strings).") (p "An " (i "iterator") " is an object that designates a particular position in a linear or random-access sequence.") (section 4 "Basic sequence operations" (section 5 "size" (def (sig (procedure "(size S)" (id size))) (p "Returns the number of elements in the sequence " (tt "S") ". For linear sequences, this operation traverses all elements."))) (section 5 "elt" (def (sig (procedure "(elt S I)" (id elt))) (p "Returns the " (tt "I") "-th element of " (tt "S") ". " (tt "I") " may be an exact integer or an iterator (see below).") (p "A sequence-element can be modified with " (tt "(set! (elt S I) X)") ".") (p "If " (tt "I") " is an iterator, then " (tt "S") " must be the same sequence that had been used to construct the iterator."))) (section 5 "rev" (def (sig (procedure "(rev S)" (id rev))) (p "Returns a new sequence of the same type with the elements of " (tt "S") " in reverse order."))) (section 5 "foldl" (def (sig (procedure "(foldl PROC SEED S)" (id foldl))) (p "Performs a left \"fold\" over the sequence " (tt "S") ", where the procedure " (tt "PROC") " is applied to its previous result (or " (tt "SEED") " for the first element) and each sequence-element."))) (section 5 "foldr" (def (sig (procedure "(foldr PROC SEED S)" (id foldr))) (p "A right \"fold\" over sequence " (tt "S") ", " (tt "PROC") " is applied to each sequence element and the result of its last invocation (or " (tt "SEED") " for the first element)."))) (section 5 "sub" (def (sig (procedure "(sub S START [END])" (id sub))) (p "Returns a new sequence with the elements of " (tt "S") ", starting at position " (tt "START") " up to but not including the element at position " (tt "END") ". If " (tt "END") " is not given, all remaining elements are returned. " (tt "START") " and " (tt "END") " may be exact integers or iterators.") (p "A range of elements may be modified by executing " (tt "(set! (sub S1 START [END]) S2)") ", which assigns the elements of " (tt "S2") " to the designated locations of sequence " (tt "S1") "."))) (section 5 "pos" (def (sig (procedure "(pos PRED S)" (id pos))) (p "Returns the index of the first element in " (tt "S") " that for which the one argument procedure " (tt "PRED") " returns true. If " (tt "PRED") " returns false for all arguments, " (tt "#f") " is returned."))) (section 5 "take" (def (sig (procedure "(take PRED S)" (id take))) (p "Returns a new sequence of the same type as " (tt "S") " with the elements up to but not including the first element for which the one-argument procedure " (tt "PRED") " returns " (tt "#f") "."))) (section 5 "drop" (def (sig (procedure "(drop PRED S)" (id drop))) (p "Returns a new sequence of the same type as " (tt "S") " with the elements from the first element for which the one-argument procedure " (tt "PRED") " returns " (tt "#f") "."))) (section 5 "split" (def (sig (procedure "(split PRED S)" (id split))) (p "Returns two sequences of the same type as " (tt "S") " holding the elements split at the first position for which the one-argument procedure " (tt "PRED") " returns " (tt "#f") "."))) (section 5 "partition" (def (sig (procedure "(partition PRED S)" (id partition))) (p "Returns two sequences of the same type as " (tt "S") " holding those elements for which the one-argument procedure " (tt "PRED") " returns true and false, respectively."))) (section 5 "fill!" (def (sig (procedure "(fill! PROC S [START [END]])" (id fill!))) (p "Calls " (tt "PROC") " with the sequence " (tt "S") " and an iterator object over the elements in " (tt "S") " starting at position " (tt "START") " up to but not including " (tt "END") " and returns the modified sequence.")))) (section 4 "Predicates" (section 5 "sequence?" (def (sig (procedure "(sequence? X)" (id sequence?))) (p "Returns " (tt "#t") " if " (tt "X") " is a sequence or " (tt "#f") " otherwise."))) (section 5 "linear-sequence?" (def (sig (procedure "(linear-sequence? X)" (id linear-sequence?))) (p "Reurns " (tt "#t") " if " (tt "X") " is a list or a sequence created with " (tt "make-linear-sequence") " or " (tt "#f") " otherwise."))) (section 5 "random-access-sequence?" (def (sig (procedure "(random-access-sequence? X)" (id random-access-sequence?))) (p "Returns " (tt "#t") " if " (tt "X") " is a vector, a string or a sequence created with " (tt "make-random-access-sequence") ", or " (tt "#f") " otherwise."))) (section 5 "at-end?")) (section 4 "Sequence constructors" (section 5 "make-random-access-sequence" (def (sig (procedure "(make-random-access-sequence MAKE ELT SIZE)" (id make-random-access-sequence))) (p "Returns an object representing a sequence that allows random access to its elements. " (tt "MAKE") " should be a procedure of two arguments, a size count and an initial value and should return a collection of elements which will be stored as \"data\" in the sequence object. " (tt "ELT") " should be a procedure of two arguments receiving the \"data\" and an exact integer index and should return the element inside the data collection at the given position. " (tt "SIZE") " should be a procedure that receives the data and returns the number of elements in that collection.") (p "Note that the \"data\" may be anything - the operators fully define how it is interpreted."))) (section 5 "make-linear-sequence" (def (sig (procedure "(make-linear-sequence MAKE ELT NEXT)" (id make-linear-sequence))) (p "Returns an object representing a sequence that only allows sequential \"on-at-a-time\" access to its elements. " (tt "MAKE") " should be a procedure of two arguments, a size count and an initial value and should return a collection of elements which will be stored as \"state\" in the sequence object.  " (tt "ELT") " should be a procedure of one argument receiving the \"state\" and should return the element inside the collection that is represented by the currently stored state. " (tt "NEXT") " should be a procedure that receives the current state and returns a new state representing the underlying collection that will make the next element accessible via " (tt "ELT") ". If the collection has run out of elements, " (tt "NEXT") " should return " (tt "#f") "."))) (section 5 "make" (def (sig (procedure "(make S LENGTH INIT)" (id make))) (p "Creates a sequence of the same type as " (tt "S") " with " (tt "LENGTH") " elements that have the initial value " (tt "INIT") "."))) (section 5 "sequence" (def (sig (procedure "(sequence S X1 ...)" (id sequence))) (p "Creates a sequence of the same type as " (tt "S") " with " (tt "X1, ...") " as its initial elements.")))) (section 4 "Iterators" (section 5 "iterator?" (def (sig (procedure "(iterator? X)" (id iterator?))) (p "Returns " (tt "#t") " if " (tt "X") " is an iterator object or " (tt "#f") " otherwise."))) (section 5 "linear-iterator?" (def (sig (procedure "(linear-iterator? X)" (id linear-iterator?))) (p "Returns " (tt "#t") " if " (tt "X") " is an iterator on a linear sequence or " (tt "#f") " otherwise."))) (section 5 "random-access-iterator?" (def (sig (procedure "(random-access-iterator? X)" (id random-access-iterator?))) (p "Returns " (tt "#t") " if " (tt "X") " is an iterator on a random-access sewuence or " (tt "#f") " otherwise."))) (section 5 "iterator" (def (sig (procedure "(iterator S [INDEX])" (id iterator))) (p "Returns an iterator object over sequence " (tt "S") ", optionally starting at osition " (tt "INDEX") " (an exact integer)."))) (section 5 "at-end?" (def (sig (procedure "(at-end? ITERATOR)" (id at-end?))) (p "Returns " (tt "#t") " if " (tt "ITERATOR") " points past the lat element of its associated sequence or " (tt "#f") " otherwise."))) (section 5 "advance") (section 5 "advance!" (def (sig (procedure "(advance ITERATOR [STEPS])" (id advance)) (procedure "(advance! ITERATOR [STEPS])" (id advance!))) (p "Returns a new iterator (or modifies the given iterator in case of " (tt "advance!") ") pointing to the next element of the associated sequence or to the element at the position I + " (tt "STEPS") ", where I is the current index of " (tt "ITERATOR") "."))) (section 5 "index" (def (sig (procedure "(index ITERATOR)" (id index))) (p "Returns the exact integer index of the position to which " (tt "ITERATOR") " points to.")))) (section 4 "Iteration constructs" (section 5 "for") (section 5 "for*" (def (sig (procedure "(for PROC S)" (id for)) (procedure "(for* PROC S)" (id for*))) (p "Invokes " (tt "PROC") " for each element in sequence and returns an undefined result. " (tt "for*") " operates as " (tt "for") " but invokes " (tt "PROC") " with the sequence " (tt "S") " and an iterator pointing to the current element."))) (section 5 "smap") (section 5 "smap*" (def (sig (procedure "(smap S1 PROC S2)" (id smap)) (procedure "(smap S1 PROC S2)" (id smap))) (p "Applies " (tt "PROC") " to each element in the sequence " (tt "S2") " and returns a new sequence of the same type as " (tt "S1") " constructed of the results returned by " (tt "PROC") ".")))) (section 4 "Other operations" (section 5 "coerce" (def (sig (procedure "(coerce S1 S2)" (id coerce))) (p "Returns a new sequence of the same type as " (tt "S1") " containing the elements of " (tt "S2") "."))) (section 5 "copy" (def (sig (procedure "(copy S)" (id copy))) (p "Returns a copy of the sequence " (tt "S") "."))) (section 5 "is?" (def (sig (procedure "(is? X)" (id is?))) (p "Returns a single-argument procedure that returns " (tt "#t") " if the argument is " (tt "equal?") " to " (tt "X") " or " (tt "#f") " otherwise.")))) (section 4 "SRFI-42 comprehensions" (p "(This code was kindly contributed by Thomas Chust)") (p "SRFI-42 comprehensions for sequences are provided using the " (tt ":seq") " generator, here an example:") (pre " (string-ec (:seq x \"aAbBcC\") (if (char-lower-case? x)) x)  ==>  \"abc\"") (p "This is mostly useful with user-defined sequences created by " (tt "make-linear-sequence") " and " (tt "make-random-access-sequence") ".") (p "To use this feature, execute") (pre " (require-extension sequence-comprehensions)"))) (section 3 "Author" (p (int-link "/users/felix winkelmann" "felix"))) (section 3 "License" (pre "Copyright (c) 2010, Felix L. Winkelmann and Thomas Chust\nAll rights reserved. \n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions\nare met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n3. The name of the authors may not be used to endorse or promote products\n   derived from this software without specific prior written permission. \n\nTHIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES \nOF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\nNOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")) (section 3 "Version History" (dl (dt "0.1") (dd "initial release")))))