(index ("thread-signal!" 0) ("thread-quantum" 265) ("thread-quantum-set!" 478) ("thread-suspend!" 633) ("thread-resume!" 770) ("thread-wait-for-i/o!" 894) ("current-thread" 1270) ("thread?" 1428) ("make-thread" 1662) ("thread-name" 3003) ("thread-specific" 3186) ("thread-specific-set!" 3327) ("thread-start!" 3704) ("thread-yield!" 4455) ("thread-sleep!" 5025) ("thread-terminate!" 5697) ("thread-join!" 8781) ("mutex?" 10943) ("make-mutex" 11164) ("mutex-name" 11642) ("mutex-specific" 11804) ("mutex-specific-set!" 11941) ("mutex-state" 12803) ("mutex-lock!" 13687) ("mutex-unlock!" 17282) ("condition-variable?" 20082) ("make-condition-variable" 20394) ("condition-variable-name" 20836) ("condition-variable-specific" 21076) ("condition-variable-specific-set!" 21265) ("condition-variable-signal!" 21741) ("condition-variable-broadcast!" 23654) ("current-time" 24711) ("time?" 24886) ("time->seconds" 25113) ("seconds->time" 25425) ("current-exception-handler" 25798) ("with-exception-handler" 25990) ("raise" 26440) ("join-timeout-exception?" 27190) ("abandoned-mutex-exception?" 27535) ("terminated-thread-exception?" 27900) ("uncaught-exception?" 28290) ("uncaught-exception-reason" 28680))
(def (sig (procedure "(thread-signal! THREAD X)" (id thread-signal!))) (p "This will cause " (tt "THREAD") " to signal the condition " (tt "X") " once it is scheduled for execution. After signalling the condition, the thread continues with its normal execution."))
(def (sig (procedure "(thread-quantum THREAD)" (id thread-quantum))) (p "Returns the quantum of " (tt "THREAD") ", which is an exact integer specifying the approximate time-slice of the thread in milliseconds."))
(def (sig (procedure "(thread-quantum-set! THREAD QUANTUM)" (id thread-quantum-set!))) (p "Sets the quantum of " (tt "THREAD") " to " (tt "QUANTUM") "."))
(def (sig (procedure "(thread-suspend! THREAD)" (id thread-suspend!))) (p "Suspends the execution of " (tt "THREAD") " until resumed."))
(def (sig (procedure "(thread-resume! THREAD)" (id thread-resume!))) (p "Readies the suspended thread " (tt "THREAD") "."))
(def (sig (procedure "(thread-wait-for-i/o! FD [MODE])" (id thread-wait-for-i/o!))) (p "Suspends the current thread until input (" (tt "MODE") " is " (tt "#:input") "), output (" (tt "MODE") " is " (tt "#:output") ") or both (" (tt "MODE") " is " (tt "#:all") ") is available. " (tt "FD") " should be a file-descriptor (not a port!) open for input or output, respectively."))
(def (sig (procedure "(current-thread)" (id current-thread))) (p "Returns the current thread.") (pre "    (eq? (current-thread) (current-thread))  ==>  #t"))
(def (sig (procedure "(thread? obj)" (id thread?))) (p "Returns " (tt "#t") " if " (tt "obj") " is a thread, otherwise returns " (tt "#f") ".") (pre "    (thread? (current-thread))  ==>  #t\n    (thread? 'foo)              ==>  #f"))
(def (sig (procedure "(make-thread thunk [name])" (id make-thread))) (p "Returns a new thread. This thread is not automatically made runnable (the procedure " (tt "thread-start!") " must be used for this).") (p "A thread has the following fields: name, specific, end-result, end-exception, and a list of locked/owned mutexes it owns. The thread's execution consists of a call to " (i "thunk") " with the \"initial continuation\". This continuation causes the (then) current thread to store the result in its end-result field, abandon all mutexes it owns, and finally terminate. The " (tt "dynamic-wind") " stack of the initial continuation is empty. The optional " (tt "name") " is an arbitrary Scheme object which identifies the thread (useful for debugging); it defaults to an unspecified value. The specific field is set to an unspecified value.") (p "The thread inherits the dynamic environment from the current thread. Moreover, in this dynamic environment the exception handler is bound to the \"initial exception handler\" which is a unary procedure which causes the (then) current thread to store in its end-exception field an \"uncaught exception\" object whose \"reason\" is the argument of the handler, abandon all mutexes it owns, and finally terminate.") (pre "    (make-thread (lambda () (write 'hello)))  ==>  ''a thread''"))
(def (sig (procedure "(thread-name thread)" (id thread-name))) (p "Returns the name of the " (tt "thread") ".") (pre "    (thread-name (make-thread (lambda () #f) 'foo))  ==>  foo"))
(def (sig (procedure "(thread-specific thread)" (id thread-specific))) (p "Returns the content of the " (tt "thread") "'s specific field."))
(def (sig (procedure "(thread-specific-set! thread obj)" (id thread-specific-set!))) (p "Stores " (tt "obj") " into the " (tt "thread") "'s specific field. " (tt "thread-specific-set!") " returns an unspecified value.") (pre "    (thread-specific-set! (current-thread) \"hello\")  ==>  ''unspecified''\n \n    (thread-specific (current-thread))               ==>  \"hello\""))
(def (sig (procedure "(thread-start! thread)" (id thread-start!))) (p "Makes " (tt "thread") " runnable. The " (tt "thread") " must be a new thread. " (tt "thread-start!") " returns the " (tt "thread") ".") (pre "    (let ((t (thread-start! (make-thread (lambda () (write 'a))))))\n      (write 'b)\n      (thread-join! t))             ==>  ''unspecified''\n                                         ''after writing'' ab ''or'' ba") (p "NOTE: It is useful to separate thread creation and thread activation to avoid the race condition that would occur if the created thread tries to examine a table in which the current thread stores the created thread. See the last example of " (tt "thread-terminate!") " which contains mutually recursive threads."))
(def (sig (procedure "(thread-yield!)" (id thread-yield!))) (p "The current thread exits the running state as if its quantum had expired. " (tt "thread-yield!") " returns an unspecified value.") (pre "    ; a busy loop that avoids being too wasteful of the CPU\n \n    (let loop ()\n      (if (mutex-lock! m 0) ; try to lock m but don't block\n          (begin\n            (display \"locked mutex m\")\n            (mutex-unlock! m))\n          (begin\n            (do-something-else)\n            (thread-yield!) ; relinquish rest of quantum\n            (loop))))"))
(def (sig (procedure "(thread-sleep! timeout)" (id thread-sleep!))) (p "The current thread waits until the timeout is reached. This blocks the thread only if " (tt "timeout") " represents a point in the future. It is an error for " (tt "timeout") " to be " (tt "#f") ". " (tt "thread-sleep!") " returns an unspecified value.") (pre "    ; a clock with a gradual drift:\n \n    (let loop ((x 1))\n      (thread-sleep! 1)\n      (write x)\n      (loop (+ x 1)))\n \n    ; a clock with no drift:\n \n    (let ((start (time->seconds (current-time)))\n      (let loop ((x 1))\n        (thread-sleep! (seconds->time (+ x start)))\n        (write x)\n        (loop (+ x 1))))"))
(def (sig (procedure "(thread-terminate! thread)" (id thread-terminate!))) (p "Causes an abnormal termination of the " (tt "thread") ". If the " (tt "thread") " is not already terminated, all mutexes owned by the " (tt "thread") " become unlocked/abandoned and a \"terminated thread exception\" object is stored in the " (tt "thread") "'s end-exception field. If " (tt "thread") " is the current thread, " (tt "thread-terminate!") " does not return. Otherwise " (tt "thread-terminate!") " returns an unspecified value; the termination of the " (tt "thread") " will occur before " (tt "thread-terminate!") " returns.") (pre "    (thread-terminate! (current-thread))  ==>  ''does not return''\n \n    (define (amb thunk1 thunk2)\n      (let ((result #f)\n            (result-mutex (make-mutex))\n            (done-mutex (make-mutex)))\n        (letrec ((child1\n                  (make-thread\n                    (lambda ()\n                      (let ((x (thunk1)))\n                        (mutex-lock! result-mutex #f #f)\n                        (set! result x)\n                        (thread-terminate! child2)\n                        (mutex-unlock! done-mutex)))))\n                 (child2\n                  (make-thread\n                    (lambda ()\n                      (let ((x (thunk2)))\n                        (mutex-lock! result-mutex #f #f)\n                        (set! result x)\n                        (thread-terminate! child1)\n                        (mutex-unlock! done-mutex))))))\n          (mutex-lock! done-mutex #f #f)\n          (thread-start! child1)\n          (thread-start! child2)\n          (mutex-lock! done-mutex #f #f)\n          result)))") (p "NOTE: This operation must be used carefully because it terminates a thread abruptly and it is impossible for that thread to perform any kind of cleanup. This may be a problem if the thread is in the middle of a critical section where some structure has been put in an inconsistent state. However, another thread attempting to enter this critical section will raise an \"abandoned mutex exception\" because the mutex is unlocked/abandoned. This helps avoid observing an inconsistent state. Clean termination can be obtained by polling, as shown in the example below.") (pre "    (define (spawn thunk)\n      (let ((t (make-thread thunk)))\n        (thread-specific-set! t #t)\n        (thread-start! t)\n        t))\n \n    (define (stop! thread)\n      (thread-specific-set! thread #f)\n      (thread-join! thread))\n \n    (define (keep-going?)\n      (thread-specific (current-thread)))\n \n    (define count!\n      (let ((m (make-mutex))\n            (i 0))\n        (lambda ()\n          (mutex-lock! m)\n          (let ((x (+ i 1)))\n            (set! i x)\n            (mutex-unlock! m)\n            x))))\n \n    (define (increment-forever!)\n      (let loop () (count!) (if (keep-going?) (loop))))\n \n    (let ((t1 (spawn increment-forever!))\n          (t2 (spawn increment-forever!)))\n      (thread-sleep! 1)\n      (stop! t1)\n      (stop! t2)\n      (count!))  ==>  377290"))
(def (sig (procedure "(thread-join! thread [timeout [timeout-val]])" (id thread-join!))) (p "The current thread waits until the " (tt "thread") " terminates (normally or not) or until the timeout is reached if " (tt "timeout") " is supplied. If the timeout is reached, " (tt "thread-join!") " returns " (tt "timeout-val") " if it is supplied, otherwise a \"join timeout exception\" is raised. If the " (tt "thread") " terminated normally, the content of the end-result field is returned, otherwise the content of the end-exception field is raised.") (pre "    (let ((t (thread-start! (make-thread (lambda () (expt 2 100))))))\n      (do-something-else)\n      (thread-join! t))  ==>  1267650600228229401496703205376\n \n    (let ((t (thread-start! (make-thread (lambda () (raise 123))))))\n      (do-something-else)\n      (with-exception-handler\n        (lambda (exc)\n          (if (uncaught-exception? exc)\n              (* 10 (uncaught-exception-reason exc))\n              99999))\n        (lambda ()\n          (+ 1 (thread-join! t)))))  ==>  1231\n \n    (define thread-alive?\n      (let ((unique (list 'unique)))\n        (lambda (thread)\n          ; Note: this procedure raises an exception if\n          ; the thread terminated abnormally.\n          (eq? (thread-join! thread 0 unique) unique))))\n \n    (define (wait-for-termination! thread)\n      (let ((eh (current-exception-handler)))\n        (with-exception-handler\n          (lambda (exc)\n            (if (not (or (terminated-thread-exception? exc)\n                         (uncaught-exception? exc)))\n                (eh exc))) ; unexpected exceptions are handled by eh\n          (lambda ()\n            ; The following call to thread-join! will wait until the\n            ; thread terminates.  If the thread terminated normally\n            ; thread-join! will return normally.  If the thread\n            ; terminated abnormally then one of these two exceptions\n            ; is raised by thread-join!:\n            ;   - terminated thread exception\n            ;   - uncaught exception\n            (thread-join! thread)\n            #f)))) ; ignore result of thread-join!"))
(def (sig (procedure "(mutex? obj)" (id mutex?))) (p "Returns " (tt "#t") " if " (tt "obj") " is a mutex, otherwise returns " (tt "#f") ".") (pre "    (mutex? (make-mutex))  ==>  #t\n    (mutex? 'foo)          ==>  #f"))
(def (sig (procedure "(make-mutex [name])" (id make-mutex))) (p "Returns a new mutex in the unlocked/not-abandoned state. The optional " (tt "name") " is an arbitrary Scheme object which identifies the mutex (useful for debugging); it defaults to an unspecified value. The mutex's specific field is set to an unspecified value.") (pre "    (make-mutex)       ==>  ''an unlocked/not-abandoned mutex''\n    (make-mutex 'foo)  ==>  ''an unlocked/not-abandoned mutex named'' foo"))
(def (sig (procedure "(mutex-name mutex)" (id mutex-name))) (p "Returns the name of the " (tt "mutex") ".") (pre "    (mutex-name (make-mutex 'foo))  ==>  foo"))
(def (sig (procedure "(mutex-specific mutex)" (id mutex-specific))) (p "Returns the content of the " (tt "mutex") "'s specific field."))
(def (sig (procedure "(mutex-specific-set! mutex obj)" (id mutex-specific-set!))) (p "Stores " (tt "obj") " into the " (tt "mutex") "'s specific field. " (tt "mutex-specific-set!") " returns an unspecified value.") (pre "    (define m (make-mutex))\n    (mutex-specific-set! m \"hello\")  ==>  ''unspecified''\n \n    (mutex-specific m)               ==>  \"hello\"\n \n    (define (mutex-lock-recursively! mutex)\n      (if (eq? (mutex-state mutex) (current-thread))\n          (let ((n (mutex-specific mutex)))\n            (mutex-specific-set! mutex (+ n 1)))\n          (begin\n            (mutex-lock! mutex)\n            (mutex-specific-set! mutex 0))))\n \n    (define (mutex-unlock-recursively! mutex)\n      (let ((n (mutex-specific mutex)))\n        (if (= n 0)\n            (mutex-unlock! mutex)\n            (mutex-specific-set! mutex (- n 1)))))"))
(def (sig (procedure "(mutex-state mutex)" (id mutex-state))) (p "Returns information about the state of the " (tt "mutex") ". The possible results are:") (ul (li (b "thread T") ": the " (tt "mutex") " is in the locked/owned state and thread T is the owner of the " (tt "mutex") " ") (li (b "symbol " (tt "not-owned")) ": the " (tt "mutex") " is in the locked/not-owned state ") (li (b "symbol " (tt "abandoned")) ": the " (tt "mutex") " is in the unlocked/abandoned state ") (li (b "symbol " (tt "not-abandoned")) ": the " (tt "mutex") " is in the unlocked/not-abandoned state ")) (pre "    (mutex-state (make-mutex))  ==>  not-abandoned\n \n    (define (thread-alive? thread)\n      (let ((mutex (make-mutex)))\n        (mutex-lock! mutex #f thread)\n        (let ((state (mutex-state mutex)))\n          (mutex-unlock! mutex) ; avoid space leak\n          (eq? state thread))))"))
(def (sig (procedure "(mutex-lock! mutex [timeout [thread]])" (id mutex-lock!))) (p "If the " (tt "mutex") " is currently locked, the current thread waits until the " (tt "mutex") " is unlocked, or until the timeout is reached if " (tt "timeout") " is supplied. If the timeout is reached, " (tt "mutex-lock!") " returns " (tt "#f") ". Otherwise, the state of the " (tt "mutex") " is changed as follows:") (ul (li "if " (tt "thread") " is " (tt "#f") " the " (tt "mutex") " becomes locked/not-owned, ") (li "otherwise, let T be " (tt "thread") " (or the current thread if " (tt "thread") " is not supplied), " (ul (li "if T is terminated the " (tt "mutex") " becomes unlocked/abandoned, ") (li "otherwise " (tt "mutex") " becomes locked/owned with T as the owner. ")))) (p "After changing the state of the " (tt "mutex") ", an \"abandoned mutex exception\" is raised if the " (tt "mutex") " was unlocked/abandoned before the state change, otherwise " (tt "mutex-lock!") " returns " (tt "#t") ". It is not an error if the " (tt "mutex") " is owned by the current thread (but the current thread will have to wait).") (pre "    ; an implementation of a mailbox object of depth one; this\n    ; implementation does not behave well in the presence of forced\n    ; thread terminations using thread-terminate! (deadlock can occur\n    ; if a thread is terminated in the middle of a put! or get! operation)\n \n    (define (make-empty-mailbox)\n      (let ((put-mutex (make-mutex)) ; allow put! operation\n            (get-mutex (make-mutex))\n            (cell #f))\n \n        (define (put! obj)\n          (mutex-lock! put-mutex #f #f) ; prevent put! operation\n          (set! cell obj)\n          (mutex-unlock! get-mutex)) ; allow get! operation\n \n        (define (get!)\n          (mutex-lock! get-mutex #f #f) ; wait until object in mailbox\n          (let ((result cell))\n            (set! cell #f) ; prevent space leaks\n            (mutex-unlock! put-mutex) ; allow put! operation\n            result))\n \n        (mutex-lock! get-mutex #f #f) ; prevent get! operation\n \n        (lambda (msg)\n          (case msg\n            ((put!) put!)\n            ((get!) get!)\n            (else (error \"unknown message\"))))))\n \n    (define (mailbox-put! m obj) ((m 'put!) obj))\n    (define (mailbox-get! m) ((m 'get!)))\n \n    ; an alternate implementation of thread-sleep!\n \n    (define (sleep! timeout)\n      (let ((m (make-mutex)))\n        (mutex-lock! m #f #f)\n        (mutex-lock! m timeout #f)))\n \n    ; a procedure that waits for one of two mutexes to unlock\n \n    (define (lock-one-of! mutex1 mutex2)\n      ; this procedure assumes that neither mutex1 or mutex2\n      ; are owned by the current thread\n      (let ((ct (current-thread))\n            (done-mutex (make-mutex)))\n        (mutex-lock! done-mutex #f #f)\n        (let ((t1 (thread-start!\n                   (make-thread\n                    (lambda ()\n                      (mutex-lock! mutex1 #f ct)\n                      (mutex-unlock! done-mutex)))))\n              (t2 (thread-start!\n                   (make-thread\n                    (lambda ()\n                      (mutex-lock! mutex2 #f ct)\n                      (mutex-unlock! done-mutex))))))\n          (mutex-lock! done-mutex #f #f)\n          (thread-terminate! t1)\n          (thread-terminate! t2)\n          (if (eq? (mutex-state mutex1) ct)\n              (begin\n                (if (eq? (mutex-state mutex2) ct)\n                    (mutex-unlock! mutex2)) ; don't lock both\n                mutex1)\n              mutex2))))"))
(def (sig (procedure "(mutex-unlock! mutex [condition-variable [timeout]])" (id mutex-unlock!))) (p "Unlocks the " (tt "mutex") " by making it unlocked/not-abandoned. It is not an error to unlock an unlocked mutex and a mutex that is owned by any thread. If " (tt "condition-variable") " is supplied, the current thread is blocked and added to the " (tt "condition-variable") " before unlocking " (tt "mutex") "; the thread can unblock at any time but no later than when an appropriate call to " (tt "condition-variable-signal!") " or " (tt "condition-variable-broadcast!") " is performed (see below), and no later than the timeout (if " (tt "timeout") " is supplied). If there are threads waiting to lock this " (tt "mutex") ", the scheduler selects a thread, the mutex becomes locked/owned or locked/not-owned, and the thread is unblocked. " (tt "mutex-unlock!") " returns " (tt "#f") " when the timeout is reached, otherwise it returns " (tt "#t") ".") (p "NOTE: The reason the thread can unblock at any time (when " (tt "condition-variable") " is supplied) is to allow extending this SRFI with primitives that force a specific blocked thread to become runnable. For example a primitive to interrupt a thread so that it performs a certain operation, whether the thread is blocked or not, may be useful to handle the case where the scheduler has detected a serious problem (such as a deadlock) and it must unblock one of the threads (such as the primordial thread) so that it can perform some appropriate action. After a thread blocked on a condition-variable has handled such an interrupt it would be wrong for the scheduler to return the thread to the blocked state, because any calls to " (tt "condition-variable-broadcast!") " during the interrupt will have gone unnoticed. It is necessary for the thread to remain runnable and return from the call to " (tt "mutex-unlock!") " with a result of " (tt "#t") ".") (p "NOTE: " (tt "mutex-unlock!") " is related to the \"wait\" operation on condition variables available in other thread systems. The main difference is that \"wait\" automatically locks " (tt "mutex") " just after the thread is unblocked. This operation is not performed by " (tt "mutex-unlock!") " and so must be done by an explicit call to " (tt "mutex-lock!") ". This has the advantages that a different timeout and exception handler can be specified on the " (tt "mutex-lock!") " and " (tt "mutex-unlock!") " and the location of all the mutex operations is clearly apparent. A typical use with a condition variable is:") (pre "    (let loop ()\n      (mutex-lock! m)\n      (if (condition-is-true?)\n          (begin\n            (do-something-when-condition-is-true)\n            (mutex-unlock! m))\n          (begin\n            (mutex-unlock! m cv)\n            (loop))))"))
(def (sig (procedure "(condition-variable? obj)" (id condition-variable?))) (p "Returns " (tt "#t") " if " (tt "obj") " is a condition variable, otherwise returns " (tt "#f") ".") (pre "    (condition-variable? (make-condition-variable))  ==>  #t\n    (condition-variable? 'foo)                       ==>  #f"))
(def (sig (procedure "(make-condition-variable [name])" (id make-condition-variable))) (p "Returns a new empty condition variable. The optional " (tt "name") " is an arbitrary Scheme object which identifies the condition variable (useful for debugging); it defaults to an unspecified value. The condition variable's specific field is set to an unspecified value.") (pre "    (make-condition-variable)  ==>  ''an empty condition variable''"))
(def (sig (procedure "(condition-variable-name condition-variable)" (id condition-variable-name))) (p "Returns the name of the " (tt "condition-variable") ".") (pre "    (condition-variable-name (make-condition-variable 'foo))  ==>  foo"))
(def (sig (procedure "(condition-variable-specific condition-variable)" (id condition-variable-specific))) (p "Returns the content of the " (tt "condition-variable") "'s specific field."))
(def (sig (procedure "(condition-variable-specific-set! condition-variable obj)" (id condition-variable-specific-set!))) (p "Stores " (tt "obj") " into the " (tt "condition-variable") "'s specific field. " (tt "condition-variable-specific-set!") " returns an unspecified value.") (pre "    (define cv (make-condition-variable))\n    (condition-variable-specific-set! cv \"hello\")  ==>  ''unspecified''\n \n    (condition-variable-specific cv)               ==>  \"hello\""))
(def (sig (procedure "(condition-variable-signal! condition-variable)" (id condition-variable-signal!))) (p "If there are threads blocked on the " (tt "condition-variable") ", the scheduler selects a thread and unblocks it. " (tt "condition-variable-signal!") " returns an unspecified value.") (pre "    ; an implementation of a mailbox object of depth one; this\n    ; implementation behaves gracefully when threads are forcibly\n    ; terminated using thread-terminate! (the \"abandoned mutex\"\n    ; exception will be raised when a put! or get! operation is attempted\n    ; after a thread is terminated in the middle of a put! or get!\n    ; operation)\n \n    (define (make-empty-mailbox)\n      (let ((mutex (make-mutex))\n            (put-condvar (make-condition-variable))\n            (get-condvar (make-condition-variable))\n            (full? #f)\n            (cell #f))\n \n        (define (put! obj)\n          (mutex-lock! mutex)\n          (if full?\n              (begin\n                (mutex-unlock! mutex put-condvar)\n                (put! obj))\n              (begin\n                (set! cell obj)\n                (set! full? #t)\n                (condition-variable-signal! get-condvar)\n                (mutex-unlock! mutex))))\n \n        (define (get!)\n          (mutex-lock! mutex)\n          (if (not full?)\n              (begin\n                (mutex-unlock! mutex get-condvar)\n                (get!))\n              (let ((result cell))\n                (set! cell #f) ; avoid space leaks\n                (set! full? #f)\n                (condition-variable-signal! put-condvar)\n                (mutex-unlock! mutex))))\n \n        (lambda (msg)\n          (case msg\n            ((put!) put!)\n            ((get!) get!)\n            (else (error \"unknown message\"))))))\n \n    (define (mailbox-put! m obj) ((m 'put!) obj))\n    (define (mailbox-get! m) ((m 'get!)))"))
(def (sig (procedure "(condition-variable-broadcast! condition-variable)" (id condition-variable-broadcast!))) (p "Unblocks all the threads blocked on the " (tt "condition-variable") ". " (tt "condition-variable-broadcast!") " returns an unspecified value.") (pre "    (define (make-semaphore n)\n      (vector n (make-mutex) (make-condition-variable)))\n \n    (define (semaphore-wait! sema)\n      (mutex-lock! (vector-ref sema 1))\n      (let ((n (vector-ref sema 0)))\n        (if (> n 0)\n            (begin\n              (vector-set! sema 0 (- n 1))\n              (mutex-unlock! (vector-ref sema 1)))\n            (begin\n              (mutex-unlock! (vector-ref sema 1) (vector-ref sema 2))\n              (semaphore-wait! sema))))\n \n    (define (semaphore-signal-by! sema increment)\n      (mutex-lock! (vector-ref sema 1))\n      (let ((n (+ (vector-ref sema 0) increment)))\n        (vector-set! sema 0 n)\n        (if (> n 0)\n            (condition-variable-broadcast! (vector-ref sema 2)))\n        (mutex-unlock! (vector-ref sema 1))))"))
(def (sig (procedure "(current-time)" (id current-time))) (p "Returns the time object corresponding to the current time.") (pre "    (current-time)  ==>  ''a time object''"))
(def (sig (procedure "(time? obj)" (id time?))) (p "Returns " (tt "#t") " if " (tt "obj") " is a time object, otherwise returns " (tt "#f") ".") (pre "    (time? (current-time))  ==>  #t\n    (time? 123)             ==>  #f"))
(def (sig (procedure "(time->seconds time)" (id time->seconds))) (p "Converts the time object " (tt "time") " into an exact or inexact real number representing the number of seconds elapsed since some implementation dependent reference point.") (pre "    (time->seconds (current-time))  ==>  955039784.928075"))
(def (sig (procedure "(seconds->time x)" (id seconds->time))) (p "Converts into a time object the exact or inexact real number " (tt "x") " representing the number of seconds elapsed since some implementation dependent reference point.") (pre "    (seconds->time (+ 10 (time->seconds (current-time)))\n       ==>  ''a time object representing 10 seconds in the future''"))
(def (sig (procedure "(current-exception-handler)" (id current-exception-handler))) (p "Returns the current exception handler.") (pre "    (current-exception-handler)  ==>  ''a procedure''"))
(def (sig (procedure "(with-exception-handler handler thunk)" (id with-exception-handler))) (p "Returns the result(s) of calling " (tt "thunk") " with no arguments. The " (tt "handler") ", which must be a procedure, is installed as the current exception handler in the dynamic environment in effect during the call to " (tt "thunk") ".") (pre "    (with-exception-handler\n      list\n      current-exception-handler)  ==>  ''the procedure'' list"))
(def (sig (procedure "(raise obj)" (id raise))) (p "Calls the current exception handler with " (tt "obj") " as the single argument. " (tt "obj") " may be any Scheme object.") (pre "    (define (f n)\n      (if (< n 0) (raise \"negative arg\") (sqrt n))))\n \n    (define (g)\n      (call-with-current-continuation\n        (lambda (return)\n          (with-exception-handler\n            (lambda (exc)\n              (return\n                (if (string? exc)\n                    (string-append \"error: \" exc)\n                    \"unknown error\")))\n            (lambda ()\n              (write (f 4.))\n              (write (f -1.))\n              (write (f 9.)))))))\n \n    (g)  ==>  ''writes'' 2. ''and returns'' \"error: negative arg\""))
(def (sig (procedure "(join-timeout-exception? obj)" (id join-timeout-exception?))) (p "Returns " (tt "#t") " if " (tt "obj") " is a \"join timeout exception\" object, otherwise returns " (tt "#f") ". A join timeout exception is raised when " (tt "thread-join!") " is called, the timeout is reached and no " (tt "timeout-val") " is supplied."))
(def (sig (procedure "(abandoned-mutex-exception? obj)" (id abandoned-mutex-exception?))) (p "Returns " (tt "#t") " if " (tt "obj") " is an \"abandoned mutex exception\" object, otherwise returns " (tt "#f") ". An abandoned mutex exception is raised when the current thread locks a mutex that was owned by a thread which terminated (see " (tt "mutex-lock!") ")."))
(def (sig (procedure "(terminated-thread-exception? obj)" (id terminated-thread-exception?))) (p "Returns " (tt "#t") " if " (tt "obj") " is a \"terminated thread exception\" object, otherwise returns " (tt "#f") ". A terminated thread exception is raised when " (tt "thread-join!") " is called and the target thread has terminated as a result of a call to " (tt "thread-terminate!") "."))
(def (sig (procedure "(uncaught-exception? obj)" (id uncaught-exception?))) (p "Returns " (tt "#t") " if " (tt "obj") " is an \"uncaught exception\" object, otherwise returns " (tt "#f") ". An uncaught exception is raised when " (tt "thread-join!") " is called and the target thread has terminated because it raised an exception that called the initial exception handler of that thread."))
(def (sig (procedure "(uncaught-exception-reason exc)" (id uncaught-exception-reason))) (p (tt "exc") " must be an \"uncaught exception\" object. " (tt "uncaught-exception-reason") " returns the object which was passed to the initial exception handler of that thread."))
