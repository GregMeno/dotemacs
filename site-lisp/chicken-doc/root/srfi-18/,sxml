((tags "manual") (toc) (section 2 "Unit srfi-18" (p "A simple multithreading package, largely following the specification of " (link "http://srfi.schemers.org/srfi-18/srfi-18.html" "SRFI-18") ".  This document contains the core of the SRFI-18 documentation as well as information on Chicken deviations from the spec.") (p "SRFI-18 defines the following multithreading datatypes:") (ul (li "Thread ") (li "Mutex ") (li "Condition variable ") (li "Time ")) (p "It also defines a mechanism to handle exceptions and some multithreading exception datatypes.")) (section 2 "Chicken implementation" (section 3 "Notes" (ul (li (tt "thread-start!") " accepts a thunk (a zero argument procedure) as argument, which is equivalent to " (tt "(thread-start! (make-thread THUNK))") ".") (li (tt "thread-sleep!") " accepts a seconds real number value in addition to a time object.") (li "When an uncaught exception (i.e. an error) is signalled in a thread other than the primordial thread and warnings are enabled (see: " (tt "enable-warnings") ", then a warning message is written to the port that is the value of " (tt "(current-error-port)") ".") (li "Blocking I/O will block all threads, except for some socket operations (see the section about the " (tt "tcp") " unit). An exception is the read-eval-print loop on UNIX platforms: waiting for input will not block other threads, provided the current input port reads input from a console.") (li "It is generally not a good idea for one thread to call a continuation created by another thread, if " (tt "dynamic-wind") " is involved.") (li "When more than one thread compete for the current time-slice, the thread that was waiting first will become the next runnable thread.") (li "The dynamic environment of a thread consists of the following state:" (ul (li "The current input-, output- and error-port") (li "The current exception handler") (li "The values of all current parameters (created by " (tt "make-parameter") ")") (li "Any pending " (tt "dynamic-wind") " thunks."))) (li "When an error is triggered inside the execution context of a thread, the default exception-handler will simply terminate the thread (and store the error condition for later use). Pending " (tt "dynamic-wind") " thunks will " (i "not") " be invoked. Use a custom exception handler for the thread in that case."))) (section 3 "Procedures" (p "The following procedures are provided in addition to the procedures defined in SRFI-18.") (def (sig (procedure "(thread-signal! THREAD X)" (id thread-signal!))) (p "This will cause " (tt "THREAD") " to signal the condition " (tt "X") " once it is scheduled for execution. After signalling the condition, the thread continues with its normal execution.")) (def (sig (procedure "(thread-quantum THREAD)" (id thread-quantum))) (p "Returns the quantum of " (tt "THREAD") ", which is an exact integer specifying the approximate time-slice of the thread in milliseconds.")) (def (sig (procedure "(thread-quantum-set! THREAD QUANTUM)" (id thread-quantum-set!))) (p "Sets the quantum of " (tt "THREAD") " to " (tt "QUANTUM") ".")) (def (sig (procedure "(thread-suspend! THREAD)" (id thread-suspend!))) (p "Suspends the execution of " (tt "THREAD") " until resumed.")) (def (sig (procedure "(thread-resume! THREAD)" (id thread-resume!))) (p "Readies the suspended thread " (tt "THREAD") ".")) (def (sig (procedure "(thread-wait-for-i/o! FD [MODE])" (id thread-wait-for-i/o!))) (p "Suspends the current thread until input (" (tt "MODE") " is " (tt "#:input") "), output (" (tt "MODE") " is " (tt "#:output") ") or both (" (tt "MODE") " is " (tt "#:all") ") is available. " (tt "FD") " should be a file-descriptor (not a port!) open for input or output, respectively.")))) (section 2 "SRFI-18 specification" (p "The thread system provides the following data types:") (ul (li "Thread (a virtual processor which shares object space with all other threads) ") (li "Mutex (a mutual exclusion device, also known as a lock and binary semaphore) ") (li "Condition variable (a set of blocked threads) ") (li "Time (an absolute point on the time line) ")) (p "Some multithreading exception datatypes are also specified, and a general mechanism for handling exceptions.") (section 3 "Background information" (section 4 "Threads" (p "A \"running\" thread is a thread that is currently executing. There can be more than one running thread on a multiprocessor machine. A \"runnable\" thread is a thread that is ready to execute or running. A thread is \"blocked\" if it is waiting for a mutex to become unlocked, an I/O operation to become possible, the end of a \"sleep\" period, etc. A \"new\" thread is a thread that has not yet become runnable. A new thread becomes runnable when it is started. A \"terminated\" thread is a thread that can no longer become runnable (but \"deadlocked\" threads are not considered terminated). The only valid transitions between the thread states are from new to runnable, between runnable and blocked, and from any state to terminated:") (pre "                         unblock\n       start            <-------\n  NEW -------> RUNNABLE -------> BLOCKED\n    \\             |      block  /\n     \\            v            /\n      +-----> TERMINATED <----+") (p "Each thread has a \"specific\" field which can be used in an application specific way to associate data with the thread (some thread systems call this \"thread local storage\").")) (section 4 "Mutexes" (p "A mutex can be in one of four states: locked (either owned or not owned) and unlocked (either abandoned or not abandoned). An attempt to lock a mutex only succeeds if the mutex is in an unlocked state, otherwise the current thread must wait. A mutex in the locked/owned state has an associated \"owner\" thread, which by convention is the thread that is responsible for unlocking the mutex (this case is typical of critical sections implemented as \"lock mutex, perform operation, unlock mutex\"). A mutex in the locked/not-owned state is not linked to a particular thread. A mutex becomes locked when a thread locks it using the " (tt "mutex-lock!") " primitive. A mutex becomes unlocked/abandoned when the owner of a locked/owned mutex terminates. A mutex becomes unlocked/not-abandoned when a thread unlocks it using the " (tt "mutex-unlock!") " primitive. The mutex primitives specified in this SRFI do not implement \"recursive\" mutex semantics; an attempt to lock a mutex that is locked implies that the current thread must wait even if the mutex is owned by the current thread (this can lead to a deadlock if no other thread unlocks the mutex).") (p "Each mutex has a \"specific\" field which can be used in an application specific way to associate data with the mutex.")) (section 4 "Condition variables" (p "A condition variable represents a set of blocked threads. These blocked threads are waiting for a certain condition to become true. When a thread modifies some program state that might make the condition true, the thread unblocks some number of threads (one or all depending on the primitive used) so they can check the value of the condition. This allows complex forms of interthread synchronization to be expressed more conveniently than with mutexes alone.") (p "Each condition variable has a \"specific\" field which can be used in an application specific way to associate data with the condition variable.")) (section 4 "Fairness" (p "In various situations the scheduler must select one thread from a set of threads (e.g. which thread to run when a running thread blocks or expires its quantum, which thread to unblock when a mutex unlocks or a condition variable is signaled). The constraints on the selection process determine the scheduler's \"fairness\". Typically the selection depends on the order in which threads become runnable or blocked and on some \"priority\" attached to the threads.") (p "Because we do not wish to preclude extensions to this SRFI (such as for real-time multithreading) that require specific fairness constraints, there are no fairness constraints imposed by this SRFI. It is expected however that implementations of Scheme that support this SRFI will document the fairness constraints they provide.")) (section 4 "Memory coherency and lack of atomicity" (p "Read and write operations on the store (such as reading and writing a variable, an element of a vector or a string) are not required to be atomic. It is an error for a thread to write a location in the store while some other thread reads or writes that same location. It is the responsibility of the application to avoid write/read and write/write races through appropriate uses of the synchronization primitives.") (p "Concurrent reads and writes to ports are allowed. It is the responsibility of the implementation to serialize accesses to a given port using the appropriate synchronization primitives.")) (section 4 ("Dynamic environments, continuations and " (tt "dynamic-wind")) (p "The \"dynamic environment\" is a structure which allows the system to find the value returned by " (tt "current-input-port") ", " (tt "current-output-port") ", etc. The procedures " (tt "with-input-from-file") ", " (tt "with-output-to-file") ", etc extend the dynamic environment to produce a new dynamic environment which is in effect for the duration of the call to the thunk passed as the last argument. Some Scheme systems generalize the dynamic environment by providing procedures and special forms to define new \"dynamic variables\" and bind them in the dynamic environment (e.g. " (tt "make-parameter") " and " (tt "parameterize") ").") (p "Each thread has its own dynamic environment. When a thread's dynamic environment is extended this does not affect the dynamic environment of other threads. When a thread creates a continuation, the thread's dynamic environment and the " (tt "dynamic-wind") " stack are saved within the continuation (an alternate but equivalent point of view is that the " (tt "dynamic-wind") " stack is part of the dynamic environment). When this continuation is invoked the required " (tt "dynamic-wind") " before and after thunks are called and the saved dynamic environment is reinstated as the dynamic environment of the current thread. During the call to each required " (tt "dynamic-wind") " before and after thunk, the dynamic environment and the " (tt "dynamic-wind") " stack in effect when the corresponding " (tt "dynamic-wind") " was executed are reinstated. Note that this specification clearly defines the semantics of calling " (tt "call-with-current-continuation") " or invoking a continuation within a before or after thunk. The semantics are well defined even when a continuation created by another thread is invoked. Below is an example exercising the subtleties of this semantics.") (pre "    (with-output-to-file\n     \"foo\"\n     (lambda ()\n       (let ((k (call-with-current-continuation\n                 (lambda (exit)\n                   (with-output-to-file\n                    \"bar\"\n                    (lambda ()\n                      (dynamic-wind\n                       (lambda () (write '(b1)))\n                       (lambda ()\n                         (let ((x (call-with-current-continuation\n                                   (lambda (cont) (exit cont)))))\n                           (write '(t1))\n                           x))\n                       (lambda () (write '(a1))))))))))\n         (if k\n             (dynamic-wind\n              (lambda () (write '(b2)))\n              (lambda ()\n                (with-output-to-file\n                 \"baz\"\n                 (lambda ()\n                   (write '(t2))\n                   ; go back inside (with-output-to-file \"bar\" ...)\n                   (k #f))))\n              (lambda () (write '(a2))))))))") (p "In an implementation of Scheme where " (tt "with-output-to-file") " only closes the port it opened when the thunk returns normally, then the following actions will occur: " (tt "(b1)(a1)") " is written to \"bar\", " (tt "(b2)") " is written to \"foo\", " (tt "(t2)") " is written to \"baz\", " (tt "(a2)") " is written to \"foo\", and " (tt "(b1)(t1)(a1)") " is written to \"bar\".") (p "When the scheduler stops the execution of a running thread T1 (whether because it blocked, expired its quantum, was terminated, etc) and then resumes the execution of a thread T2, there is in a sense a transfer of control between T1's current continuation and the continuation of T2. This transfer of control by the scheduler does not cause any " (tt "dynamic-wind") " before and after thunks to be called. It is only when a thread itself transfers control to a continuation that " (tt "dynamic-wind") " before and after thunks are called.")) (section 4 "Time objects and timeouts" (p "A time object represents a point on the time line. Its resolution is implementation dependent (implementations are encouraged to implement at least millisecond resolution so that precise timing is possible). Using " (tt "time->seconds") " and " (tt "seconds->time") ", a time object can be converted to and from a real number which corresponds to the number of seconds from a reference point on the time line. The reference point is implementation dependent and does not change for a given execution of the program (e.g. the reference point could be the time at which the program started).") (p "All synchronization primitives which take a timeout parameter accept three types of values as a timeout, with the following meaning:") (ul (li "a time object represents an absolute point in time ") (li "an exact or inexact real number represents a relative time in seconds from the moment the primitive was called ") (li (tt "#f") " means that there is no timeout ")) (p "When a timeout denotes the current time or a time in the past, the synchronization primitive claims that the timeout has been reached only after the other synchronization conditions have been checked. Moreover the thread remains running (it does not enter the blocked state). For example, " (tt "(mutex-lock! m 0)") " will lock mutex " (tt "m") " and return " (tt "#t") " if " (tt "m") " is currently unlocked, otherwise " (tt "#f") " is returned because the timeout is reached.")) (section 4 "Primitives and exceptions" (p "When one of the primitives defined in this SRFI raises an exception defined in this SRFI, the exception handler is called with the same continuation as the primitive (i.e. it is a tail call to the exception handler). This requirement avoids having to use " (tt "call-with-current-continuation") " to get the same effect in some situations.")) (section 4 "Primordial thread" (p "The execution of a program is initially under the control of a single thread known as the \"primordial thread\". The primordial thread has an unspecified name, specific field, dynamic environment, " (tt "dynamic-wind") " stack, and exception handler. All threads are terminated when the primordial thread terminates (normally or not)."))) (section 3 "Procedures" (def (sig (procedure "(current-thread)" (id current-thread))) (p "Returns the current thread.") (pre "    (eq? (current-thread) (current-thread))  ==>  #t")) (def (sig (procedure "(thread? obj)" (id thread?))) (p "Returns " (tt "#t") " if " (tt "obj") " is a thread, otherwise returns " (tt "#f") ".") (pre "    (thread? (current-thread))  ==>  #t\n    (thread? 'foo)              ==>  #f")) (def (sig (procedure "(make-thread thunk [name])" (id make-thread))) (p "Returns a new thread. This thread is not automatically made runnable (the procedure " (tt "thread-start!") " must be used for this).") (p "A thread has the following fields: name, specific, end-result, end-exception, and a list of locked/owned mutexes it owns. The thread's execution consists of a call to " (i "thunk") " with the \"initial continuation\". This continuation causes the (then) current thread to store the result in its end-result field, abandon all mutexes it owns, and finally terminate. The " (tt "dynamic-wind") " stack of the initial continuation is empty. The optional " (tt "name") " is an arbitrary Scheme object which identifies the thread (useful for debugging); it defaults to an unspecified value. The specific field is set to an unspecified value.") (p "The thread inherits the dynamic environment from the current thread. Moreover, in this dynamic environment the exception handler is bound to the \"initial exception handler\" which is a unary procedure which causes the (then) current thread to store in its end-exception field an \"uncaught exception\" object whose \"reason\" is the argument of the handler, abandon all mutexes it owns, and finally terminate.") (pre "    (make-thread (lambda () (write 'hello)))  ==>  ''a thread''")) (def (sig (procedure "(thread-name thread)" (id thread-name))) (p "Returns the name of the " (tt "thread") ".") (pre "    (thread-name (make-thread (lambda () #f) 'foo))  ==>  foo")) (def (sig (procedure "(thread-specific thread)" (id thread-specific))) (p "Returns the content of the " (tt "thread") "'s specific field.")) (def (sig (procedure "(thread-specific-set! thread obj)" (id thread-specific-set!))) (p "Stores " (tt "obj") " into the " (tt "thread") "'s specific field. " (tt "thread-specific-set!") " returns an unspecified value.") (pre "    (thread-specific-set! (current-thread) \"hello\")  ==>  ''unspecified''\n \n    (thread-specific (current-thread))               ==>  \"hello\"")) (def (sig (procedure "(thread-start! thread)" (id thread-start!))) (p "Makes " (tt "thread") " runnable. The " (tt "thread") " must be a new thread. " (tt "thread-start!") " returns the " (tt "thread") ".") (pre "    (let ((t (thread-start! (make-thread (lambda () (write 'a))))))\n      (write 'b)\n      (thread-join! t))             ==>  ''unspecified''\n                                         ''after writing'' ab ''or'' ba") (p "NOTE: It is useful to separate thread creation and thread activation to avoid the race condition that would occur if the created thread tries to examine a table in which the current thread stores the created thread. See the last example of " (tt "thread-terminate!") " which contains mutually recursive threads.")) (def (sig (procedure "(thread-yield!)" (id thread-yield!))) (p "The current thread exits the running state as if its quantum had expired. " (tt "thread-yield!") " returns an unspecified value.") (pre "    ; a busy loop that avoids being too wasteful of the CPU\n \n    (let loop ()\n      (if (mutex-lock! m 0) ; try to lock m but don't block\n          (begin\n            (display \"locked mutex m\")\n            (mutex-unlock! m))\n          (begin\n            (do-something-else)\n            (thread-yield!) ; relinquish rest of quantum\n            (loop))))")) (def (sig (procedure "(thread-sleep! timeout)" (id thread-sleep!))) (p "The current thread waits until the timeout is reached. This blocks the thread only if " (tt "timeout") " represents a point in the future. It is an error for " (tt "timeout") " to be " (tt "#f") ". " (tt "thread-sleep!") " returns an unspecified value.") (pre "    ; a clock with a gradual drift:\n \n    (let loop ((x 1))\n      (thread-sleep! 1)\n      (write x)\n      (loop (+ x 1)))\n \n    ; a clock with no drift:\n \n    (let ((start (time->seconds (current-time)))\n      (let loop ((x 1))\n        (thread-sleep! (seconds->time (+ x start)))\n        (write x)\n        (loop (+ x 1))))")) (def (sig (procedure "(thread-terminate! thread)" (id thread-terminate!))) (p "Causes an abnormal termination of the " (tt "thread") ". If the " (tt "thread") " is not already terminated, all mutexes owned by the " (tt "thread") " become unlocked/abandoned and a \"terminated thread exception\" object is stored in the " (tt "thread") "'s end-exception field. If " (tt "thread") " is the current thread, " (tt "thread-terminate!") " does not return. Otherwise " (tt "thread-terminate!") " returns an unspecified value; the termination of the " (tt "thread") " will occur before " (tt "thread-terminate!") " returns.") (pre "    (thread-terminate! (current-thread))  ==>  ''does not return''\n \n    (define (amb thunk1 thunk2)\n      (let ((result #f)\n            (result-mutex (make-mutex))\n            (done-mutex (make-mutex)))\n        (letrec ((child1\n                  (make-thread\n                    (lambda ()\n                      (let ((x (thunk1)))\n                        (mutex-lock! result-mutex #f #f)\n                        (set! result x)\n                        (thread-terminate! child2)\n                        (mutex-unlock! done-mutex)))))\n                 (child2\n                  (make-thread\n                    (lambda ()\n                      (let ((x (thunk2)))\n                        (mutex-lock! result-mutex #f #f)\n                        (set! result x)\n                        (thread-terminate! child1)\n                        (mutex-unlock! done-mutex))))))\n          (mutex-lock! done-mutex #f #f)\n          (thread-start! child1)\n          (thread-start! child2)\n          (mutex-lock! done-mutex #f #f)\n          result)))") (p "NOTE: This operation must be used carefully because it terminates a thread abruptly and it is impossible for that thread to perform any kind of cleanup. This may be a problem if the thread is in the middle of a critical section where some structure has been put in an inconsistent state. However, another thread attempting to enter this critical section will raise an \"abandoned mutex exception\" because the mutex is unlocked/abandoned. This helps avoid observing an inconsistent state. Clean termination can be obtained by polling, as shown in the example below.") (pre "    (define (spawn thunk)\n      (let ((t (make-thread thunk)))\n        (thread-specific-set! t #t)\n        (thread-start! t)\n        t))\n \n    (define (stop! thread)\n      (thread-specific-set! thread #f)\n      (thread-join! thread))\n \n    (define (keep-going?)\n      (thread-specific (current-thread)))\n \n    (define count!\n      (let ((m (make-mutex))\n            (i 0))\n        (lambda ()\n          (mutex-lock! m)\n          (let ((x (+ i 1)))\n            (set! i x)\n            (mutex-unlock! m)\n            x))))\n \n    (define (increment-forever!)\n      (let loop () (count!) (if (keep-going?) (loop))))\n \n    (let ((t1 (spawn increment-forever!))\n          (t2 (spawn increment-forever!)))\n      (thread-sleep! 1)\n      (stop! t1)\n      (stop! t2)\n      (count!))  ==>  377290")) (def (sig (procedure "(thread-join! thread [timeout [timeout-val]])" (id thread-join!))) (p "The current thread waits until the " (tt "thread") " terminates (normally or not) or until the timeout is reached if " (tt "timeout") " is supplied. If the timeout is reached, " (tt "thread-join!") " returns " (tt "timeout-val") " if it is supplied, otherwise a \"join timeout exception\" is raised. If the " (tt "thread") " terminated normally, the content of the end-result field is returned, otherwise the content of the end-exception field is raised.") (pre "    (let ((t (thread-start! (make-thread (lambda () (expt 2 100))))))\n      (do-something-else)\n      (thread-join! t))  ==>  1267650600228229401496703205376\n \n    (let ((t (thread-start! (make-thread (lambda () (raise 123))))))\n      (do-something-else)\n      (with-exception-handler\n        (lambda (exc)\n          (if (uncaught-exception? exc)\n              (* 10 (uncaught-exception-reason exc))\n              99999))\n        (lambda ()\n          (+ 1 (thread-join! t)))))  ==>  1231\n \n    (define thread-alive?\n      (let ((unique (list 'unique)))\n        (lambda (thread)\n          ; Note: this procedure raises an exception if\n          ; the thread terminated abnormally.\n          (eq? (thread-join! thread 0 unique) unique))))\n \n    (define (wait-for-termination! thread)\n      (let ((eh (current-exception-handler)))\n        (with-exception-handler\n          (lambda (exc)\n            (if (not (or (terminated-thread-exception? exc)\n                         (uncaught-exception? exc)))\n                (eh exc))) ; unexpected exceptions are handled by eh\n          (lambda ()\n            ; The following call to thread-join! will wait until the\n            ; thread terminates.  If the thread terminated normally\n            ; thread-join! will return normally.  If the thread\n            ; terminated abnormally then one of these two exceptions\n            ; is raised by thread-join!:\n            ;   - terminated thread exception\n            ;   - uncaught exception\n            (thread-join! thread)\n            #f)))) ; ignore result of thread-join!")) (def (sig (procedure "(mutex? obj)" (id mutex?))) (p "Returns " (tt "#t") " if " (tt "obj") " is a mutex, otherwise returns " (tt "#f") ".") (pre "    (mutex? (make-mutex))  ==>  #t\n    (mutex? 'foo)          ==>  #f")) (def (sig (procedure "(make-mutex [name])" (id make-mutex))) (p "Returns a new mutex in the unlocked/not-abandoned state. The optional " (tt "name") " is an arbitrary Scheme object which identifies the mutex (useful for debugging); it defaults to an unspecified value. The mutex's specific field is set to an unspecified value.") (pre "    (make-mutex)       ==>  ''an unlocked/not-abandoned mutex''\n    (make-mutex 'foo)  ==>  ''an unlocked/not-abandoned mutex named'' foo")) (def (sig (procedure "(mutex-name mutex)" (id mutex-name))) (p "Returns the name of the " (tt "mutex") ".") (pre "    (mutex-name (make-mutex 'foo))  ==>  foo")) (def (sig (procedure "(mutex-specific mutex)" (id mutex-specific))) (p "Returns the content of the " (tt "mutex") "'s specific field.")) (def (sig (procedure "(mutex-specific-set! mutex obj)" (id mutex-specific-set!))) (p "Stores " (tt "obj") " into the " (tt "mutex") "'s specific field. " (tt "mutex-specific-set!") " returns an unspecified value.") (pre "    (define m (make-mutex))\n    (mutex-specific-set! m \"hello\")  ==>  ''unspecified''\n \n    (mutex-specific m)               ==>  \"hello\"\n \n    (define (mutex-lock-recursively! mutex)\n      (if (eq? (mutex-state mutex) (current-thread))\n          (let ((n (mutex-specific mutex)))\n            (mutex-specific-set! mutex (+ n 1)))\n          (begin\n            (mutex-lock! mutex)\n            (mutex-specific-set! mutex 0))))\n \n    (define (mutex-unlock-recursively! mutex)\n      (let ((n (mutex-specific mutex)))\n        (if (= n 0)\n            (mutex-unlock! mutex)\n            (mutex-specific-set! mutex (- n 1)))))")) (def (sig (procedure "(mutex-state mutex)" (id mutex-state))) (p "Returns information about the state of the " (tt "mutex") ". The possible results are:") (ul (li (b "thread T") ": the " (tt "mutex") " is in the locked/owned state and thread T is the owner of the " (tt "mutex") " ") (li (b "symbol " (tt "not-owned")) ": the " (tt "mutex") " is in the locked/not-owned state ") (li (b "symbol " (tt "abandoned")) ": the " (tt "mutex") " is in the unlocked/abandoned state ") (li (b "symbol " (tt "not-abandoned")) ": the " (tt "mutex") " is in the unlocked/not-abandoned state ")) (pre "    (mutex-state (make-mutex))  ==>  not-abandoned\n \n    (define (thread-alive? thread)\n      (let ((mutex (make-mutex)))\n        (mutex-lock! mutex #f thread)\n        (let ((state (mutex-state mutex)))\n          (mutex-unlock! mutex) ; avoid space leak\n          (eq? state thread))))")) (def (sig (procedure "(mutex-lock! mutex [timeout [thread]])" (id mutex-lock!))) (p "If the " (tt "mutex") " is currently locked, the current thread waits until the " (tt "mutex") " is unlocked, or until the timeout is reached if " (tt "timeout") " is supplied. If the timeout is reached, " (tt "mutex-lock!") " returns " (tt "#f") ". Otherwise, the state of the " (tt "mutex") " is changed as follows:") (ul (li "if " (tt "thread") " is " (tt "#f") " the " (tt "mutex") " becomes locked/not-owned, ") (li "otherwise, let T be " (tt "thread") " (or the current thread if " (tt "thread") " is not supplied), " (ul (li "if T is terminated the " (tt "mutex") " becomes unlocked/abandoned, ") (li "otherwise " (tt "mutex") " becomes locked/owned with T as the owner. ")))) (p "After changing the state of the " (tt "mutex") ", an \"abandoned mutex exception\" is raised if the " (tt "mutex") " was unlocked/abandoned before the state change, otherwise " (tt "mutex-lock!") " returns " (tt "#t") ". It is not an error if the " (tt "mutex") " is owned by the current thread (but the current thread will have to wait).") (pre "    ; an implementation of a mailbox object of depth one; this\n    ; implementation does not behave well in the presence of forced\n    ; thread terminations using thread-terminate! (deadlock can occur\n    ; if a thread is terminated in the middle of a put! or get! operation)\n \n    (define (make-empty-mailbox)\n      (let ((put-mutex (make-mutex)) ; allow put! operation\n            (get-mutex (make-mutex))\n            (cell #f))\n \n        (define (put! obj)\n          (mutex-lock! put-mutex #f #f) ; prevent put! operation\n          (set! cell obj)\n          (mutex-unlock! get-mutex)) ; allow get! operation\n \n        (define (get!)\n          (mutex-lock! get-mutex #f #f) ; wait until object in mailbox\n          (let ((result cell))\n            (set! cell #f) ; prevent space leaks\n            (mutex-unlock! put-mutex) ; allow put! operation\n            result))\n \n        (mutex-lock! get-mutex #f #f) ; prevent get! operation\n \n        (lambda (msg)\n          (case msg\n            ((put!) put!)\n            ((get!) get!)\n            (else (error \"unknown message\"))))))\n \n    (define (mailbox-put! m obj) ((m 'put!) obj))\n    (define (mailbox-get! m) ((m 'get!)))\n \n    ; an alternate implementation of thread-sleep!\n \n    (define (sleep! timeout)\n      (let ((m (make-mutex)))\n        (mutex-lock! m #f #f)\n        (mutex-lock! m timeout #f)))\n \n    ; a procedure that waits for one of two mutexes to unlock\n \n    (define (lock-one-of! mutex1 mutex2)\n      ; this procedure assumes that neither mutex1 or mutex2\n      ; are owned by the current thread\n      (let ((ct (current-thread))\n            (done-mutex (make-mutex)))\n        (mutex-lock! done-mutex #f #f)\n        (let ((t1 (thread-start!\n                   (make-thread\n                    (lambda ()\n                      (mutex-lock! mutex1 #f ct)\n                      (mutex-unlock! done-mutex)))))\n              (t2 (thread-start!\n                   (make-thread\n                    (lambda ()\n                      (mutex-lock! mutex2 #f ct)\n                      (mutex-unlock! done-mutex))))))\n          (mutex-lock! done-mutex #f #f)\n          (thread-terminate! t1)\n          (thread-terminate! t2)\n          (if (eq? (mutex-state mutex1) ct)\n              (begin\n                (if (eq? (mutex-state mutex2) ct)\n                    (mutex-unlock! mutex2)) ; don't lock both\n                mutex1)\n              mutex2))))")) (def (sig (procedure "(mutex-unlock! mutex [condition-variable [timeout]])" (id mutex-unlock!))) (p "Unlocks the " (tt "mutex") " by making it unlocked/not-abandoned. It is not an error to unlock an unlocked mutex and a mutex that is owned by any thread. If " (tt "condition-variable") " is supplied, the current thread is blocked and added to the " (tt "condition-variable") " before unlocking " (tt "mutex") "; the thread can unblock at any time but no later than when an appropriate call to " (tt "condition-variable-signal!") " or " (tt "condition-variable-broadcast!") " is performed (see below), and no later than the timeout (if " (tt "timeout") " is supplied). If there are threads waiting to lock this " (tt "mutex") ", the scheduler selects a thread, the mutex becomes locked/owned or locked/not-owned, and the thread is unblocked. " (tt "mutex-unlock!") " returns " (tt "#f") " when the timeout is reached, otherwise it returns " (tt "#t") ".") (p "NOTE: The reason the thread can unblock at any time (when " (tt "condition-variable") " is supplied) is to allow extending this SRFI with primitives that force a specific blocked thread to become runnable. For example a primitive to interrupt a thread so that it performs a certain operation, whether the thread is blocked or not, may be useful to handle the case where the scheduler has detected a serious problem (such as a deadlock) and it must unblock one of the threads (such as the primordial thread) so that it can perform some appropriate action. After a thread blocked on a condition-variable has handled such an interrupt it would be wrong for the scheduler to return the thread to the blocked state, because any calls to " (tt "condition-variable-broadcast!") " during the interrupt will have gone unnoticed. It is necessary for the thread to remain runnable and return from the call to " (tt "mutex-unlock!") " with a result of " (tt "#t") ".") (p "NOTE: " (tt "mutex-unlock!") " is related to the \"wait\" operation on condition variables available in other thread systems. The main difference is that \"wait\" automatically locks " (tt "mutex") " just after the thread is unblocked. This operation is not performed by " (tt "mutex-unlock!") " and so must be done by an explicit call to " (tt "mutex-lock!") ". This has the advantages that a different timeout and exception handler can be specified on the " (tt "mutex-lock!") " and " (tt "mutex-unlock!") " and the location of all the mutex operations is clearly apparent. A typical use with a condition variable is:") (pre "    (let loop ()\n      (mutex-lock! m)\n      (if (condition-is-true?)\n          (begin\n            (do-something-when-condition-is-true)\n            (mutex-unlock! m))\n          (begin\n            (mutex-unlock! m cv)\n            (loop))))")) (def (sig (procedure "(condition-variable? obj)" (id condition-variable?))) (p "Returns " (tt "#t") " if " (tt "obj") " is a condition variable, otherwise returns " (tt "#f") ".") (pre "    (condition-variable? (make-condition-variable))  ==>  #t\n    (condition-variable? 'foo)                       ==>  #f")) (def (sig (procedure "(make-condition-variable [name])" (id make-condition-variable))) (p "Returns a new empty condition variable. The optional " (tt "name") " is an arbitrary Scheme object which identifies the condition variable (useful for debugging); it defaults to an unspecified value. The condition variable's specific field is set to an unspecified value.") (pre "    (make-condition-variable)  ==>  ''an empty condition variable''")) (def (sig (procedure "(condition-variable-name condition-variable)" (id condition-variable-name))) (p "Returns the name of the " (tt "condition-variable") ".") (pre "    (condition-variable-name (make-condition-variable 'foo))  ==>  foo")) (def (sig (procedure "(condition-variable-specific condition-variable)" (id condition-variable-specific))) (p "Returns the content of the " (tt "condition-variable") "'s specific field.")) (def (sig (procedure "(condition-variable-specific-set! condition-variable obj)" (id condition-variable-specific-set!))) (p "Stores " (tt "obj") " into the " (tt "condition-variable") "'s specific field. " (tt "condition-variable-specific-set!") " returns an unspecified value.") (pre "    (define cv (make-condition-variable))\n    (condition-variable-specific-set! cv \"hello\")  ==>  ''unspecified''\n \n    (condition-variable-specific cv)               ==>  \"hello\"")) (def (sig (procedure "(condition-variable-signal! condition-variable)" (id condition-variable-signal!))) (p "If there are threads blocked on the " (tt "condition-variable") ", the scheduler selects a thread and unblocks it. " (tt "condition-variable-signal!") " returns an unspecified value.") (pre "    ; an implementation of a mailbox object of depth one; this\n    ; implementation behaves gracefully when threads are forcibly\n    ; terminated using thread-terminate! (the \"abandoned mutex\"\n    ; exception will be raised when a put! or get! operation is attempted\n    ; after a thread is terminated in the middle of a put! or get!\n    ; operation)\n \n    (define (make-empty-mailbox)\n      (let ((mutex (make-mutex))\n            (put-condvar (make-condition-variable))\n            (get-condvar (make-condition-variable))\n            (full? #f)\n            (cell #f))\n \n        (define (put! obj)\n          (mutex-lock! mutex)\n          (if full?\n              (begin\n                (mutex-unlock! mutex put-condvar)\n                (put! obj))\n              (begin\n                (set! cell obj)\n                (set! full? #t)\n                (condition-variable-signal! get-condvar)\n                (mutex-unlock! mutex))))\n \n        (define (get!)\n          (mutex-lock! mutex)\n          (if (not full?)\n              (begin\n                (mutex-unlock! mutex get-condvar)\n                (get!))\n              (let ((result cell))\n                (set! cell #f) ; avoid space leaks\n                (set! full? #f)\n                (condition-variable-signal! put-condvar)\n                (mutex-unlock! mutex))))\n \n        (lambda (msg)\n          (case msg\n            ((put!) put!)\n            ((get!) get!)\n            (else (error \"unknown message\"))))))\n \n    (define (mailbox-put! m obj) ((m 'put!) obj))\n    (define (mailbox-get! m) ((m 'get!)))")) (def (sig (procedure "(condition-variable-broadcast! condition-variable)" (id condition-variable-broadcast!))) (p "Unblocks all the threads blocked on the " (tt "condition-variable") ". " (tt "condition-variable-broadcast!") " returns an unspecified value.") (pre "    (define (make-semaphore n)\n      (vector n (make-mutex) (make-condition-variable)))\n \n    (define (semaphore-wait! sema)\n      (mutex-lock! (vector-ref sema 1))\n      (let ((n (vector-ref sema 0)))\n        (if (> n 0)\n            (begin\n              (vector-set! sema 0 (- n 1))\n              (mutex-unlock! (vector-ref sema 1)))\n            (begin\n              (mutex-unlock! (vector-ref sema 1) (vector-ref sema 2))\n              (semaphore-wait! sema))))\n \n    (define (semaphore-signal-by! sema increment)\n      (mutex-lock! (vector-ref sema 1))\n      (let ((n (+ (vector-ref sema 0) increment)))\n        (vector-set! sema 0 n)\n        (if (> n 0)\n            (condition-variable-broadcast! (vector-ref sema 2)))\n        (mutex-unlock! (vector-ref sema 1))))")) (def (sig (procedure "(current-time)" (id current-time))) (p "Returns the time object corresponding to the current time.") (pre "    (current-time)  ==>  ''a time object''")) (def (sig (procedure "(time? obj)" (id time?))) (p "Returns " (tt "#t") " if " (tt "obj") " is a time object, otherwise returns " (tt "#f") ".") (pre "    (time? (current-time))  ==>  #t\n    (time? 123)             ==>  #f")) (def (sig (procedure "(time->seconds time)" (id time->seconds))) (p "Converts the time object " (tt "time") " into an exact or inexact real number representing the number of seconds elapsed since some implementation dependent reference point.") (pre "    (time->seconds (current-time))  ==>  955039784.928075")) (def (sig (procedure "(seconds->time x)" (id seconds->time))) (p "Converts into a time object the exact or inexact real number " (tt "x") " representing the number of seconds elapsed since some implementation dependent reference point.") (pre "    (seconds->time (+ 10 (time->seconds (current-time)))\n       ==>  ''a time object representing 10 seconds in the future''")) (def (sig (procedure "(current-exception-handler)" (id current-exception-handler))) (p "Returns the current exception handler.") (pre "    (current-exception-handler)  ==>  ''a procedure''")) (def (sig (procedure "(with-exception-handler handler thunk)" (id with-exception-handler))) (p "Returns the result(s) of calling " (tt "thunk") " with no arguments. The " (tt "handler") ", which must be a procedure, is installed as the current exception handler in the dynamic environment in effect during the call to " (tt "thunk") ".") (pre "    (with-exception-handler\n      list\n      current-exception-handler)  ==>  ''the procedure'' list")) (def (sig (procedure "(raise obj)" (id raise))) (p "Calls the current exception handler with " (tt "obj") " as the single argument. " (tt "obj") " may be any Scheme object.") (pre "    (define (f n)\n      (if (< n 0) (raise \"negative arg\") (sqrt n))))\n \n    (define (g)\n      (call-with-current-continuation\n        (lambda (return)\n          (with-exception-handler\n            (lambda (exc)\n              (return\n                (if (string? exc)\n                    (string-append \"error: \" exc)\n                    \"unknown error\")))\n            (lambda ()\n              (write (f 4.))\n              (write (f -1.))\n              (write (f 9.)))))))\n \n    (g)  ==>  ''writes'' 2. ''and returns'' \"error: negative arg\"")) (def (sig (procedure "(join-timeout-exception? obj)" (id join-timeout-exception?))) (p "Returns " (tt "#t") " if " (tt "obj") " is a \"join timeout exception\" object, otherwise returns " (tt "#f") ". A join timeout exception is raised when " (tt "thread-join!") " is called, the timeout is reached and no " (tt "timeout-val") " is supplied.")) (def (sig (procedure "(abandoned-mutex-exception? obj)" (id abandoned-mutex-exception?))) (p "Returns " (tt "#t") " if " (tt "obj") " is an \"abandoned mutex exception\" object, otherwise returns " (tt "#f") ". An abandoned mutex exception is raised when the current thread locks a mutex that was owned by a thread which terminated (see " (tt "mutex-lock!") ").")) (def (sig (procedure "(terminated-thread-exception? obj)" (id terminated-thread-exception?))) (p "Returns " (tt "#t") " if " (tt "obj") " is a \"terminated thread exception\" object, otherwise returns " (tt "#f") ". A terminated thread exception is raised when " (tt "thread-join!") " is called and the target thread has terminated as a result of a call to " (tt "thread-terminate!") ".")) (def (sig (procedure "(uncaught-exception? obj)" (id uncaught-exception?))) (p "Returns " (tt "#t") " if " (tt "obj") " is an \"uncaught exception\" object, otherwise returns " (tt "#f") ". An uncaught exception is raised when " (tt "thread-join!") " is called and the target thread has terminated because it raised an exception that called the initial exception handler of that thread.")) (def (sig (procedure "(uncaught-exception-reason exc)" (id uncaught-exception-reason))) (p (tt "exc") " must be an \"uncaught exception\" object. " (tt "uncaught-exception-reason") " returns the object which was passed to the initial exception handler of that thread.")) (hr) (p "Previous: " (int-link "Unit srfi-14")) (p "Next: " (int-link "Unit srfi-69")))))