((tags "egg") (section 2 "graph-dfs" (p "Depth-first search in a graph.") (toc)) (section 2 "Usage" (p "(require-extension graph-dfs)")) (section 2 "Documentation" (p "The graph-dfs library is an implementation of depth-first search on a graph object that follows the API of e.g. the " (int-link "digraph" "digraph egg") ".") (section 3 "Depth-first-search procedures" (def (sig (procedure "graph-dfs-foreach:: G FNODE FEDGE ROOTS -> UNDEFINED" (id graph-dfs-foreach))) (p "depth-first search iterator; given a list of initial nodes, " (tt "ROOTS") ", the successors of each initial node are visited in depth-first search order, and procedures " (tt "FNODE") " and " (tt "FEDGE") " are applied to each node or edge, respectively, as the graph is traversed. " (tt "FNODE") " is of the form " (tt "LAMBDA N -> _") " where " (tt "N") " is node number; and " (tt "FEDGE") " is of the form " (tt "LAMBDA EDGE") " where " (tt "EDGE") " is a list of the form " (tt "(I J INFO)") "; " (tt "I") " and " (tt "J") " are the nodes defining the edge, and " (tt "INFO") " is edge metadata.")) (def (sig (procedure "graph-dfs-fold:: G FNODE FEDGE ROOTS NODE-INIT EDGE-INIT -> NODE-STATE EDGE-STATE" (id graph-dfs-fold))) (p "depth-first search iterator with state; given a list of initial nodes, " (tt "ROOTS") ", and initial node state and edge state, " (tt "NODE-INIT") " and " (tt "EDGE-INIT") " the successors of each initial node are visited in depth-first search order, and procedures " (tt "FNODE") " and " (tt "FEDGE") " are applied to each node and the node state, or edge and the edge state, respectively, as the graph is traversed. " (tt "FNODE") " is of the form " (tt "LAMBDA N NODE-STATE -> NODE-STATE") " where " (tt "N") " is node number, and NODE-STATE can be of arbitrary type and must of the same type as " (tt "NODE-INIT") ". " (tt "FEDGE") " is of the form " (tt "LAMBDA EDGE EDGE-STATE") " where " (tt "EDGE") " is a list of the form " (tt "(I J INFO)") "; " (tt "I") " and " (tt "J") " are the nodes defining the edge, and " (tt "INFO") " is edge metadata; " (tt "EDGE-STATE") " must be of the same type as " (tt "EDGE-INIT"))) (def (sig (procedure "graph-dfs-depth:: G ROOTS -> NODE-DEPTH TRAVERSAL-TIME" (id graph-dfs-depth))) (p "depth-first search depth; given a list of initial nodes, this procedure computes shortest DFS depth for each nodes traversed, and the number of nodes visited while traversing the successors of each node. " (tt "NODE-DEPTH") " is an array that contains the corresponding DFS depth for each node; " (tt "TRAVERSAL-TIME") " is also an array, where each value is the number of nodes visited in the sub-graph of that node.")) (def (sig (procedure "graph-preorder:: G ROOT -> ((NODE NUM) ... )" (id graph-preorder))) (p "compute the preorder traversal sequence number for each successor of the given initial node.")) (def (sig (procedure "graph-postorder:: G ROOT -> ((NODE NUM) ... )" (id graph-postorder))) (p "compute the postorder traversal sequence number for each successor of the given initial node.")))) (section 2 "Examples" (pre ";; example adapted from graph example in the Boost library documentation\n(use srfi-1 digraph graph-dfs)\n\n(define g (make-digraph 'depgraph \"dependency graph\"))\n\n(define used-by\n   (list \n     (cons 'dax_h 'foo_cpp) (cons 'dax_h 'bar_cpp) (cons 'dax_h 'yow_h)\n     (cons 'yow_h 'bar_cpp) (cons 'yow_h 'zag_cpp) (cons 'boz_h 'bar_cpp)\n     (cons 'boz_h 'zig_cpp) (cons 'boz_h 'zag_cpp) (cons 'zow_h 'foo_cpp)\n     (cons 'foo_cpp 'foo_o) (cons 'foo_o 'libfoobar_a) \n     (cons 'bar_cpp 'bar_o) (cons 'bar_o 'libfoobar_a) \n     (cons 'libfoobar_a 'libzigzag_a) (cons 'zig_cpp 'zig_o) \n     (cons 'zig_o 'libzigzag_a) (cons 'zag_cpp 'zag_o) \n     (cons 'zag_o 'libzigzag_a) (cons 'libzigzag_a 'killerapp)))\n\n\n(define node-list (delete-duplicates \n\t\t   (concatenate (list (map car used-by) (map cdr used-by)))))\n\n(define node-ids (list-tabulate (length node-list) values))\n \n(for-each (lambda (i n) ((g 'add-node!) i n)) node-ids node-list)\n(define node-map (zip node-list node-ids))\n\n(for-each (lambda (e) \n\t    (match e ((ni . nj) (let ((i (car (alist-ref ni node-map)))\n\t\t\t\t      (j (car (alist-ref nj node-map))))\n\t\t\t\t  ((g 'add-edge!) (list i j (format \"~A->~A\" ni nj)))))\n\t\t   (else (error \"invalid edge \" e))))\n\t  used-by)\n\n(define roots (map car ((g 'roots))))\n\n(graph-dfs-foreach g \n\t   (lambda (n) (print (format \"node ~A; \" n)))\n\t   (lambda (e) (print (format \"edge ~A; \" e)))\n\t   roots)\n\n(graph-dfs-fold g \n\t       (lambda (n ax) (cons (list 'node n) ax)) \n\t       (lambda (e ax) (cons (list 'edge e) ax)) \n\t       roots (list) (list))")) (section 2 "About this egg" (section 3 "Author" (p (int-link "/users/ivan-raikov" "Ivan Raikov"))) (section 3 "Version history" (dl (dt "1.9") (dd "Documentation converted to wiki format") (dt "1.8") (dd "Ported to Chicken 4") (dt "1.7") (dd "Now using matchable extension") (dt "1.6") (dd "Unit tests updated to use testbase") (dt "1.5") (dd "Build script updated for better cross-platform compatibility") (dt "1.4") (dd "eggdoc documentation fix") (dt "1.3") (dd "License upgrade to GPL v3") (dt "1.2") (dd "Added support for chicken-setup -test") (dt "1.1") (dd "Fixed a syntactic error in graph-dfs-fold") (dt "1.0") (dd "Initial release"))) (section 3 "License" (pre "Copyright 2007-2010 Ivan Raikov and the Okinawa Institute of Science and Technology\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or (at\nyour option) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nA full copy of the GPL license can be found at\n<http://www.gnu.org/licenses/>."))))