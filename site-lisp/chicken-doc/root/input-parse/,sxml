((tags "egg") (section 2 "input-parse" (toc) (section 3 "Description" (p "Oleg Kiselyov's basic input-stream tokenizing and parsing routines.")) (section 3 "Author" (p "Oleg Kiselyov. Ported to chicken by Shawn Wagner.")) (section 3 "Requirements" (p (int-link "input-parse"))) (section 3 "Documentation" (p "input-parse is a chicken port of Oleg Kiselyov's input-stream tokenizing and parsing library found at " (link "http://okmij.org/ftp/Scheme/parsing.html") ".") (p "The following is adopted from Oleg's source documentation.") (section 4 "Simple Parsing of Input" (p "The following simple functions surprisingly often suffice to parse an input stream. They either skip, or build and return tokens, according to inclusion or delimiting semantics. The list of characters to expect, include, or to break at may vary from one invocation of a function to another. This allows the functions to easily parse even context-sensitive languages.") (p "EOF is generally frowned on, and thrown up upon if encountered. Exceptions are mentioned specifically. The list of expected characters (characters to skip until, or break-characters) may include an EOF \"character\", which is to be coded as symbol " (tt "*eof*") ".") (p "The input stream to parse is specified as a " (tt "PORT") ", which is usually he last (and optional) argument.  It defaults to the current input port if omitted.") (p "This package relies on a function " (tt "parser-error") ", which must be defined by a user of the package. The function has the following signature:") (def (sig (procedure "(parser-error PORT MESSAGE SPECIALISING-MSG*)" (id parser-error))) (p "Many procedures of this package call parser-error to report a parsing error.  The first argument is a port, which typically points to the offending character or its neighborhood. Most of the Scheme systems let the user query a " (tt "PORT") " for the current position.  " (tt "MESSAGE") " is the description of the error.  Other arguments supply more details about the problem."))) (section 4 "API" (section 5 "Scanning" (def (sig (procedure "(peek-next-char [PORT])" (id peek-next-char))) (p "advances to the next character in the " (tt "PORT") " and peeks at it. This function is useful when parsing LR(1)-type languages (one-char-read-ahead).") (p "The optional argument " (tt "PORT") " defaults to the current input port.")) (def (sig (procedure "(assert-curr-char CHAR-LIST STRING [PORT])" (id assert-curr-char))) (p "Reads a character from the " (tt "PORT") " and looks it up in the " (tt "CHAR-LIST") " of expected characters. If the read character was found among expected, it is returned Otherwise, the procedure writes a nasty message using " (tt "STRING") " as a comment, and quits.") (p "The optional argument " (tt "PORT") " defaults to the current input port.")) (def (sig (procedure "(skip-until CHAR-LIST [PORT])" (id skip-until))) (p "Reads and skips characters from the " (tt "PORT") " until one of the break characters is encountered. This break character is returned. The break characters are specified as the " (tt "CHAR-LIST") ". This list may include EOF, which is to be coded as a symbol " (tt "*eof*") ".") (p "The optional argument " (tt "PORT") " defaults to the current input port.")) (def (sig (procedure "(skip-until NUMBER [PORT])" (id skip-until))) (p "Skips the specified " (tt "NUMBER") " of characters from the " (tt "PORT") " and returns " (tt "#f") ".") (p "The optional argument " (tt "PORT") " defaults to the current input port.")) (def (sig (procedure "(skip-while CHAR-LIST [PORT])" (id skip-while))) (p "Reads characters from the " (tt "PORT") " and disregards them, as long as they are mentioned in the " (tt "CHAR-LIST") ". The first character (which may be EOF) peeked from the stream that is NOT a member of the " (tt "CHAR-LIST") " is returned. This character is left on the stream.") (p "The optional argument " (tt "PORT") " defaults to the current input port."))) (section 5 "Stream tokenizers" (def (sig (procedure "(next-token PREFIX-CHAR-LIST BREAK-CHAR-LIST [COMMENT-STRING] [PORT])" (id next-token))) (p "Skips any number of the prefix characters (members of the " (tt "PREFIX-CHAR-LIST") "), if any, and reads the sequence of characters up to (but not including) a break character, one of the " (tt "BREAK-CHAR-LIST") ". The string of characters thus read is returned. The break character is left on the input stream. The list of break characters may include EOF, which is to be coded as a symbol " (tt "*eof*") ". Otherwise, EOF is fatal, generating an error message including a specified " (tt "{COMMENT-STRING") " (if any)") (p "The optional argument " (tt "PORT") " defaults to the current input port.") (p "Note: since we can't tell offhand how large the token being read is going to be, we make a guess, pre-allocate a string, and grow it by quanta if necessary. The quantum is always the length of the string before it was extended the last time. Thus the algorithm does a Fibonacci-type extension, which has been proven optimal. Note, explicit port specification in read-char, peek-char helps.")) (def (sig (procedure "(next-token-of INC-CHARSET [PORT])" (id next-token-of))) (p "Reads characters from the " (tt "PORT") " that belong to the list of characters " (tt "INC-CHARSET") ". The reading stops at the first character which is not a member of the set. This character is left on the stream. All the read characters are returned in a string.") (p "The optional argument " (tt "PORT") " defaults to the current input port.")) (def (sig (procedure "(next-token-of PRED [PORT])" (id next-token-of))) (p "Reads characters from the " (tt "PORT") " for which " (tt "PRED") " (a procedure of one argument) returns non-" (tt "#f") ". The reading stops at the first character for which " (tt "PRED") " returns " (tt "#f") ".") (p "That character is left on the stream. All the results of evaluating of " (tt "PRED") " up to " (tt "#f") " are returned in a string.") (p (tt "PRED") " is a procedure that takes one argument (a character or the EOF object) and returns a character or #f. The returned character does not have to be the same as the input argument to the " (tt "PRED") ". For example,") (pre " (next-token-of (lambda (c)\n                  (cond ((eof-object? c) #f)\n                        ((char-alphabetic? c) (char-downcase c))\n                        (else #f))))") (p "will try to read an alphabetic token from the current input port, and return it in lower case.") (p "The optional argument " (tt "PORT") " defaults to the current input port.") (p "This procedure is similar to next-token but only it implements an inclusion rather than delimiting semantics."))) (section 5 "Reading input" (def (sig (procedure "(read-text-line [PORT])" (id read-text-line))) (p "Reads one line of text from the " (tt "PORT") ", and returns it as a string.") (p "A line is a (possibly empty) sequence of characters terminated by CR, CRLF or LF (or even the end of file). The terminating character (or CRLF combination) is removed from the input stream. The terminating character(s) is not a part of the return string either. If EOF is encountered before any character is read, the return value is EOF.") (p "The optional argument " (tt "PORT") " defaults to the current input port.")) (def (sig (procedure "(read-string N [PORT])" (id read-string))) (p "Reads " (tt "N") " characters from the " (tt "PORT") ", and  returns them in a string. If EOF is encountered before N characters are read, a shorter string will be returned. If " (tt "N") " is not positive, an empty string will be returned. The optional argument PORT defaults to the current input port.") (p "Note: In this implementation, this function is part of the " (tt "extras") " unit."))))) (section 3 "Examples" (p "See the source of the cgi-utils egg.")) (section 3 "Changelog" (ul (li "1.0 Initial release as a chicken egg."))) (section 3 "License" (p "Public Domain"))))