(index ("list-of" 0) ("fold-of" 4216))
(def (sig (syntax "(list-of expr clause ...)" (id list-of))) (p "List-of provices the syntax of list comprehensions, which generate lists by means of looping expressions. The result is a list of objects of the type returned by " (tt "expr") ". There are four types of clauses:") (pre " (var range first past [step])") (p "Loop over the implicit list of numbers that contains " (tt "first") " as its first element and increments each succeeding element by " (tt "step") ". The list ends before " (tt "past") ", which is not an element of the list. If " (tt "step") " is not given it defaults to 1, if " (tt "first") " is less than " (tt "past") " and -1 otherwise. " (tt "first") ", " (tt "past") " and " (tt "step") " may be of any numeric type; if any of " (tt "first") ", " (tt "past") " or " (tt "step") " are inexact, the length of the output list may differ from " (tt "(ceiling (- (/ (- past first) step) 1)") ".") (pre " (var in list-expr)") (p "Loop over the elements of " (tt "list-expr") ", in order from the start of the list, binding each element of the list in turn to " (tt "var") ".") (pre " (var is expr)") (p "Bind " (tt "var") " to the value obtained by evaluating " (tt "expr") ".") (pre " (pred? expr)") (p "Include in the output list only those elements " (tt "expr") " for which " (tt "(pred? expr)") " is non-#f.") (p "The scope of variables bound in the list comprehension is the clauses to the right of the binding clause (but not the binding clause itself) plus the result expression. When two or more generators are present, the loops are processed as if they are nested from left to right; that is, the rightmost generator varies fastest. If no generators are present, the result of the list comprehension is a list containing the result expression; thus, " (tt "(list-of 1)") " produces the list " (tt "'(1)") ".") (p "Consider the example list comprehension shown below:") (highlight scheme "  (list-of (+ y 6)\n    (x in '(1 2 3 4 5))\n    (odd? x)\n    (y is (* x x)))") (p "The first clause is " (tt "(x in '(1 2 3 4 5))") ", where " (tt "in") " is a keyword, " (tt "x") " is a binding variable, and " (tt "'(1 2 3 4 5)") " is a literal list (or an expression evaluating to a list); the list comprehension will loop through " (tt "'(1 2 3 4 5)") ", binding each list element in turn to the variable " (tt "x") ", continuing through the rest of the list comprehension.") (p "The second clause is a predicate, " (tt "(odd? x)") ", which passes only those elements which cause the predicate to be true. In this case, the loop which originally had five elements will pass only three elements, 1, 3, and 5, to the remaining elements of the list comprehension.") (p "The third clause is " (tt "(y is (* x x))") ", which binds " (tt "y") " to the value resulting from the expression " (tt "(* x x)") ". This binding is applied to three items in turn, returning 1, 9, and 25.") (p "Finally, the list comprehension returns the value " (tt "'(7 15 31)") ", which is the result of applying the result expression " (tt "(+ y 6)") " to each of the three items returned by the third clause.") (p "That macro could be written several other ways. A range clause loops over numeric sequences, so the in clause above could be rewritten as shown below; note that the final argument of the range clause never appears, which is useful in those frequent cases where you want to iterate from 0 to n-1.") (highlight scheme "  (list-of (+ y 6)\n    (x range 1 6)\n    (odd? x)\n    (y is (* x x)))") (p "Yet another way to write that same comprehension uses a step size provided by the user instead of a default step size of 1:") (highlight scheme "  (list-of (+ y 6)\n    (x range 1 6 2)\n    (y is (* x x)))") (p "The macro calls itself recursively, one level of recursion for each clause plus a final level of recursion for the base case. The expansion of the first sample list comprehension is shown below:") (highlight scheme "  (let loop ((z '(1 2 3 4 5)))\n    (if (null? z)\n\t'()\n\t(let ((x (car z)))\n\t  (if (odd? x)\n\t      (let ((y (* x x)))\n\t\t(cons (+ y 6) (loop (cdr z))))\n\t      (loop (cdr z))))))") (p "When this final expression is evaluated, the result is " (tt "'(7 16 31)") "."))
(def (sig (syntax "(fold-of KONS KNIL ARG ...)" (id fold-of))) (p "The underlying primitive used to implement " (tt "list-of") ":") (highlight scheme "(define-syntax list-of\n  (syntax-rules () \n    ((_ arg ...)\n     (reverse (fold-of (lambda (d a) (cons a d)) '() arg ...)))))"))
