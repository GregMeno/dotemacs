(index ("dsssl-fixup" 0) ("fixup-dsssl-lambda-list" 716) ("define+" 1083) ("lambda+" 1519))
(def (sig (syntax "(dsssl-fixup OPTIONALS KEYS REST BODY...)" (id dsssl-fixup))) (p "Expands the " (tt "BODY...") " in a new lexical scope where the " (tt "#!optional") ", " (tt "#!key") ", and " (tt "#!rest") " variables have the " (i "correct") " value.") (p (tt "OPTIONALS") " is " (tt "(OPTIONAL-BINDING...)") ".") (p (tt "KEYS") " is " (tt "((KEYWORD KEYWORD-BINDING)...)") ", where " (tt "KEYWORD") " is a " (tt "keyword") ".") (p (tt "OPTIONAL-BINDING") " & " (tt "KEYWORD-BINDING") " have the form:") (dl (dt "(" (tt "IDENTIFIER") " " (tt "DEFAULT") ")") (dd "as is") (dt "(" (tt "IDENTIFIER") ")") (dd "becomes (" (tt "IDENTIFIER") " #f)") (dt (tt "IDENTIFIER")) (dd "becomes (" (tt "IDENTIFIER") " #f)")))
(def (sig (procedure "(fixup-dsssl-lambda-list OPTIONALS KEYS REST) => values" (id fixup-dsssl-lambda-list))) (p "Returns 3 \"correct\" values: the rest " (tt "list") ", optionals " (tt "list") ", and keys " (tt "list") ".") (p (tt "OPTIONALS") " is " (tt "((OPTIONAL-VALUE OPTIONAL-DEFAULT)...)") ".") (p (tt "KEYS") " is " (tt "((KEYWORD KEYWORD-VALUE)...)") "."))
(def (sig (syntax "(define+ (NAME [ARGUMENT...]) BODY...)" (id define+))) (p "Replacement for " (tt "define") " that uses " (tt "lambda+") ", if necessary.") (p "The " (i "curried define") " form is recognized.") (p "The " (tt "define") " form " (tt "(name arg0 arg1 ... . rest)") " is " (b "not") " supported. However " (tt "(name . rest)") " is recognized. In any case this is about extended lambda lists so use " (tt "#!rest") "."))
(def (sig (syntax "(lambda+ [REQUIRED...] [#!optional OPTIONAL...] [#!rest REST] [#!key KEY...])" (id lambda+))) (p "Replacement for " (tt "lambda") " that that binds formals in the " (i "correct") " order."))
