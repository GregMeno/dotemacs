((tags "manual") (toc) (section 2 "Unit ports" (p "This unit contains various extended port definitions. This unit is used by default, unless the program is compiled with the " (tt "-explicit-use") " option.") (section 3 "Input/output port extensions" (section 4 "with-output-to-port" (def (sig (procedure "(with-output-to-port PORT THUNK)" (id with-output-to-port))) (p "Call procedure " (tt "THUNK") " with the current output-port temporarily bound to " (tt "PORT") "."))) (section 4 "make-input-port" (def (sig (procedure "(make-input-port READ READY? CLOSE [PEEK])" (id make-input-port))) (p "Returns a custom input port. Common operations on this port are handled by the given parameters, which should be procedures of no arguments. " (tt "READ") " is called when the next character is to be read and should return a character or " (tt "#!eof") ". " (tt "READY?") " is called when " (tt "char-ready?") " is called on this port and should return " (tt "#t") " or " (tt "#f") ".  " (tt "CLOSE") " is called when the port is closed. " (tt "PEEK") " is called when " (tt "peek-char") " is called on this port and should return a character or " (tt "#!eof") ". if the argument " (tt "PEEK") " is not given, then " (tt "READ") " is used instead and the created port object handles peeking automatically (by calling " (tt "READ") " and buffering the character)."))) (section 4 "make-output-port" (def (sig (procedure "(make-output-port WRITE CLOSE [FLUSH])" (id make-output-port))) (p "Returns a custom output port. Common operations on this port are handled by the given parameters, which should be procedures.  " (tt "WRITE") " is called when output is sent to the port and receives a single argument, a string.  " (tt "CLOSE") " is called when the port is closed and should be a procedure of no arguments. " (tt "FLUSH") " (if provided) is called for flushing the output port."))) (section 4 "with-error-output-to-port" (def (sig (procedure "(with-error-output-to-port PORT THUNK)" (id with-error-output-to-port))) (p "Call procedure " (tt "THUNK") " with the current error output-port temporarily bound to " (tt "PORT") "."))) (section 4 "with-input-from-port" (def (sig (procedure "(with-input-from-port PORT THUNK)" (id with-input-from-port))) (p "Call procedure " (tt "THUNK") " with the current input-port temporarily bound to " (tt "PORT") ".")))) (section 3 "String-port extensions" (section 4 "call-with-input-string" (def (sig (procedure "(call-with-input-string STRING PROC)" (id call-with-input-string))) (p "Calls the procedure " (tt "PROC") " with a single argument that is a string-input-port with the contents of " (tt "STRING") "."))) (section 4 "call-with-output-string" (def (sig (procedure "(call-with-output-string PROC)" (id call-with-output-string))) (p "Calls the procedure " (tt "PROC") " with a single argument that is a string-output-port.  Returns the accumulated output-string."))) (section 4 "with-input-from-string" (def (sig (procedure "(with-input-from-string STRING THUNK)" (id with-input-from-string))) (p "Call procedure " (tt "THUNK") " with the current input-port temporarily bound to an input-string-port with the contents of " (tt "STRING") "."))) (section 4 "with-output-to-string" (def (sig (procedure "(with-output-to-string THUNK)" (id with-output-to-string))) (p "Call procedure " (tt "THUNK") " with the current output-port temporarily bound to a string-output-port and return the accumulated output string.")))) (section 3 "Port iterators" (section 4 "port-for-each" (def (sig (procedure "(port-for-each FN THUNK)" (id port-for-each))) (p "Apply " (tt "FN") " to successive results of calling the zero argument procedure " (tt "THUNK") " until it returns " (tt "#!eof") ", discarding the results."))) (section 4 "port-map" (def (sig (procedure "(port-map FN THUNK)" (id port-map))) (p "Apply " (tt "FN") " to successive results of calling the zero argument procedure " (tt "THUNK") " until it returns " (tt "#!eof") ", returning a list of the collected results."))) (section 4 "port-fold" (def (sig (procedure "(port-fold FN ACC THUNK)" (id port-fold))) (p "Apply " (tt "FN") " to successive results of calling the zero argument procedure " (tt "THUNK") ", passing the " (tt "ACC") " value as the second argument. The " (tt "FN") " result becomes the new " (tt "ACC") " value. When " (tt "THUNK") " returns " (tt "#!eof") ", the last " (tt "FN") " result is returned."))) (section 4 "copy-port" (def (sig (procedure "(copy-port FROM TO [READ [WRITE]])" (id copy-port))) (p "Reads all remaining data from port " (tt "FROM") " using the reader procedure " (tt "READ") " and writes it to port " (tt "TO") " using the writer procedure " (tt "WRITE") ". " (tt "READ") " defaults to " (tt "read-char") " and " (tt "WRITE} to {{write-char") ". Note that this procedure does not check " (tt "FROM") " and " (tt "TO") " for being ports, so the reader and writer procedures may perform arbitrary operations as long as they can be invoked as " (tt "(READ FROM)") " and " (tt "(WRITE X TO)") ", respectively. " (tt "copy-port") " returns an undefined value.")))) (section 3 "Funky ports" (section 4 "make-broadcast-port" (def (sig (procedure "(make-broadcast-port PORT ...)" (id make-broadcast-port))) (p "Returns a custom output port that emits everything written into it to the ports given as " (tt "PORT ...") ". Closing the broadcast port does not close any of the argument ports."))) (section 4 "make-concatenated-port" (def (sig (procedure "(make-concatenated-port PORT1 PORT2 ...)" (id make-concatenated-port))) (p "Returns a custom input port that reads its input from " (tt "PORT1") ", until it is empty, then from " (tt "PORT2") " and so on. Closing the concatenated port does not close any of the argument ports.")) (hr) (p "Previous: " (int-link "Unit data-structures")) (p "Next: " (int-link "Unit files"))))))