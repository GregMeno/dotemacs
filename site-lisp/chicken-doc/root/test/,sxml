((tags "egg") (section 2 "test" (p "Yet another testing utility.") (toc) (section 3 "Usage" (highlight scheme "(require-extension test)\n(test 4 (+ 2 2))")) (section 3 "Interface" (p "This is designed to be as simple and friendly as possible.") (def (sig (syntax "(test [<name>] <expected-value> <expression>)" (id test))) (p "The basic test interface; really all you need to use.  It will catch errors and print informative failure messages, including the name (which defaults to an abbreviated form of the test expression), the source, and the line number information of the failed expression.  Equality is checked with EQUAL?, unless the expected value is inexact, in which case it checks to be sure the percentage difference between the result and expected value fall within the TEST-EPSILON parameter of each other.  This is because it almost never makes sense to test inexact numbers with EQUAL? or =, and usually you'll want a single epsilon throughout a range of tests.")) (def (sig (syntax "(test-assert [<name>] <expression>)" (id test-assert)) (syntax "(test-error [<name>] <expression>)" (id test-error))) (p "Convenience wrappers around " (tt "test") ". " (tt "test-assert") " asserts that the expression is non-false; " (tt "test-error") " asserts that the expression results in an error.")) (def (sig (syntax "(test-begin [<name>])" (id test-begin)) (syntax "(test-end [<name>])" (id test-end))) (p "Test group reporting, including elapsed time and pass percentages, can be achieved using") (highlight scheme " (test-begin [<name>])\n (test ...)\n ...\n (test-end [<name>])") (p "where the group name is optional in either case.")) (def (sig (syntax "(test-group <name> ...)" (id test-group))) (p "You can group tests in a single lexical scope (and also establish nested groups) with the " (tt "test-group") " macro:") (highlight scheme " (test-group <name>\n   (test ...)\n   ...\n )") (p "The name for " (tt "test-group") " is not optional.")) (def (sig (procedure "(test-exit [<failure-exit-code>])" (id test-exit))) (p "As a convenience there is a " (tt "test-exit") " procedure, which exits the process with a status of 0 if all tests in all groups have passed, and with an optional numeric status (defaulting to 1), if there have been any failures or errors."))) (section 3 "Parameters" (p "All other aspects of testing are controlled by parameters.") (def (sig (parameter "current-test-verbosity" (id current-test-verbosity))) (p "Default to " (tt "#t") ", prints full diagnostics for failures")) (def (sig (parameter "current-test-epsilon" (id current-test-epsilon))) (p "Percentage difference allowed for inexact comparisons")) (def (sig (parameter "current-test-comparator" (id current-test-comparator))) (p (tt "TEST-EQUAL?"))) (def (sig (parameter "current-test-filters" (id current-test-filters))) (p "List of predicates to filter (not run) tests")) (def (sig (parameter "current-test-group-filters" (id current-test-group-filters))) (p "List of predicates to filter entire test groups")) (def (sig (parameter "current-test-applier" (id current-test-applier)) (parameter "current-test-handler" (id current-test-handler)) (parameter "current-test-skipper" (id current-test-skipper)) (parameter "current-test-group-reporter" (id current-test-group-reporter))) (p "These parameters can be used to override the reporting behavior, for example if you wanted a GUI interface instead of the default textual reporting."))) (section 3 "Environment" (p "Often you'll be working on a change or new feature, and while the code is changing the test suite remains relatively constant.  However, it's a pain to recompile the test suite every time, and to re-run the entire suite when just working on one area, or even when you just want to run a single test by name.") (p "The parameters allow filtering, but it can be a pain to setup an interface to this or to recompile with different settings.  So for easy use, by default the parameters can be initialized from environment variables.") (p (tt "CURRENT-TEST-FILTERS") " can be set by the environment variables " (tt "TEST_FILTER") ", a regexp which test names must match to be run, and " (tt "TEST_REMOVE") ", a regexp of tests not to run.  For example, if you have your test suite in the file " (tt "test-foo.scm") ", compiled to test-foo, and you only want to run the test named \"test-foo-with-bells-on,\" you could do so with") (pre " $ TEST_FILTER=bells-on ./test-foo") (p "The test name defaults to the source expression, which can also be handy for quick filtering.  For instance, if in the same test suite you knew that you had broken the \"flurble\" data structure, you could filter out all tests using it with") (pre " $ TEST_REMOVE=flurble- ./test-foo") (p "For more structured filtering you can also filter by group.  The " (tt "CURRENT-TEST-GROUP-FILTERS") " parameter can be initialized with the " (tt "TEST_GROUP_FILTER") " and " (tt "TEST_GROUP_REMOVE") " environment variables in the same way as above.") (p "You can also default the " (tt "CURRENT-TEST-VERBOSITY") " parameter to " (tt "#f") " by setting the " (tt "TEST_QUIET") " environment variable.") (p "test tries to automatically determine if your terminal supports ANSI colors and uses them (sparingly, mostly so that failures and errors stand out).  You can force this on or off by setting the environment variable TEST_USE_ANSI variable to 0 or 1.")) (section 3 "License" (p "BSD")) (section 3 "Author" (p "Alex Shinn")) (section 3 "History" (dl (dt "0.9.9.1") (dd "renamed use of deprecated " (tt "getenv") " [felix]") (dt "0.9.9") (dd "added regex dependency") (dt "0.8") (dd "Port to hygienic chicken [Peter Bex]") (dt "0.7") (dd "fix for dynamic test names w/o syntax-rules [Peter Bex]") (dt "0.6") (dd "adding several TERM settings to those recognized as ANSI") (dt "0.5") (dd "fixing spurious warning in nested groups") (dt "0.4") (dd "time reporting was off") (dt "0.3") (dd "minor bugfixes") (dt "0.2") (dd "minor bugfixes") (dt "0.1") (dd "initial release")))))