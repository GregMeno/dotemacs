(index ("zmq-version" 0) ("zmq-default-context" 144) ("zmq-io-threads" 570) ("make-context" 748) ("context?" 886) ("make-socket" 1005) ("socket?" 1543) ("close-socket" 1657) ("bind-socket" 1890) ("connect-socket" 2194) ("socket-option-set!" 2508) ("socket-option" 3710) ("socket-fd" 4246) ("make-message" 4625) ("message?" 4930) ("message-size" 5056) ("message->string" 5174) ("copy-message" 5304) ("send-message" 5531) ("receive-message" 6164) ("make-poll-item" 6470) ("poll-item-fd" 6913) ("poll-item-socket" 7095) ("poll-item-in?" 7270) ("poll-item-out?" 7422) ("poll-item-error?" 7576) ("poll" 7790))
(def (sig (procedure "(zmq-version)" (id zmq-version))) (p "Returns the ZeroMQ version as a list of the form " (tt "(major minor patch)") "."))
(def (sig (parameter "(zmq-default-context [context])" (id zmq-default-context))) (p "The ZeroMQ " (tt "context") " used by all " (tt "make-socket") " calls as the default context argument. Usually, you only need one context per application (unless you know what you need more than one for). Note that this parameter is initialized lazily upon the first call to " (tt "make-socket") ". See also: " (tt "zmq-io-threads") "."))
(def (sig (parameter "(zmq-io-threads [number])" (id zmq-io-threads))) (p (tt "number") " of I/O threads to use for the " (tt "zmq-default-context") ". Default: " (tt "1") "."))
(def (sig (procedure "(make-context number)" (id make-context))) (p "Creates a new ZeroMQ context using " (tt "number") " I/O threads."))
(def (sig (procedure "(context? context)" (id context?))) (p "Check whether " (tt "context") " is a ZeroMQ context."))
(def (sig (procedure "(make-socket type [context])" (id make-socket))) (p "Create a ZeroMQ socket of " (tt "type") ", which must be one of the symbols " (tt "pull") ", " (tt "push") ", " (tt "pair") ", " (tt "pub") ", " (tt "sub") ", " (tt "req") ", " (tt "rep") ", " (tt "xreq") " or " (tt "xrep") ". See the " (link "http://api.zeromq.org/zmq_socket.html" "zmq_socket documentation") " for information about what the different types mean. " (tt "context") " must be a ZeroMQ context and is " (tt "zmq-default-context") " by default."))
(def (sig (procedure "(socket? socket)" (id socket?))) (p "Check whether " (tt "socket") " is a ZeroMQ socket."))
(def (sig (procedure "(close-socket socket)" (id close-socket))) (p "Close the ZeroMQ " (tt "socket") ". This is usually done by the finalizer so you only have to call this if you want to close a socket early for whatever reason."))
(def (sig (procedure "(bind-socket socket endpoint)" (id bind-socket))) (p "Bind " (tt "socket") " to " (tt "endpoint") " which must be given as a string of the format " (tt "transport://address") " (for details, see the documentation for " (link "http://api.zeromq.org/zmq_bind.html" "zmq_bind") ")."))
(def (sig (procedure "(connect-socket socket endpoint)" (id connect-socket))) (p "Connect " (tt "socket") " to " (tt "endpoint") " which is given as a string of the format " (tt "transport://address") " (for details, see the documentation for " (link "http://api.zeromq.org/zmq_connect.html" "zmq_connect") ")."))
(def (sig (procedure "(socket-option-set! socket option value)" (id socket-option-set!))) (p "Destructively set " (tt "option") " (a symbol) of " (tt "socket") " to " (tt "value") " (type depending on the respective " (tt "option") "). The following options are available:") (dl (dt "hwm") (dd "high water mark (integer, maximum number of outstanding messages)") (dt "swap") (dd "disk offload size (integer, bytes)") (dt "affinity") (dd "I/O thread affinity (integer, bitmap)") (dt "identity") (dd "socket identity (string, max. 255 bytes)") (dt "subscribe") (dd "add message filter (string, message prefix)") (dt "unsubscribe") (dd "remove message filter (string, message prefix)") (dt "rate") (dd "multicast data rate (integer, kilobits per second)") (dt "recovery-ivl") (dd "multicast recovery interval (integer, seconds)") (dt "mcast-loop") (dd "multicast loopback (boolean)") (dt "sndbuf") (dd "kernel transmit buffer size (integer, bytes, 0 for OS default)") (dt "rcvbuf") (dd "kernel receive buffer size (integer, bytes, 0 for OS default)")) (p "For more detailed descriptions of the options, see the " (link "http://api.zeromq.org/zmq_setsockopt.html" "documentation for zmq_setsockopt") "."))
(def (sig (procedure "(socket-option socket option)" (id socket-option))) (p "Retrieve " (tt "socket") "'s current " (tt "option") " value. " (tt "option") " must be given as one the symbols " (tt "hwm") ", " (tt "swap") ", " (tt "affinity") ", " (tt "rate") ", " (tt "recovery-ivl") ", " (tt "sndbuf") ", " (tt "rcvbuf") ", " (tt "rcvmore") ", " (tt "mcast-loop") " or " (tt "identity") ". For descriptions of the individual options see the " (link "http://api.zeromq.org/zmq_getsockopt.html" "documentation for zmq_getsockopt") "."))
(def (sig (procedure "(socket-fd socket)" (id socket-fd))) (p "Retrieve the " (tt "socket") "'s file descriptor which can be used for traditional polling purposes. It is especially useful in conjunction with Chicken's SRFI-18 extension " (tt "thread-wait-for-i/o!") " to be able to idly wait for messages in a separate thread. Note that the file descriptor is edge-triggered."))
(def (sig (procedure "(make-message [data-or-size])" (id make-message))) (p "If the optional argument " (tt "data-or-size") " is not given (or " (tt "#f") "), create an empty message. If a string is given, use it as the message's payload. If an integer is given, allocate a message of that many bytes."))
(def (sig (procedure "(message? message)" (id message?))) (p "Check whether " (tt "message") " is a ZeroMQ message record."))
(def (sig (procedure "(message-size message)" (id message-size))) (p "Retrieve " (tt "message") "'s size in bytes."))
(def (sig (procedure "(message->string message)" (id message->string))) (p "Retrieve " (tt "message") "'s payload as a string."))
(def (sig (procedure "(copy-message message)" (id copy-message))) (p "Rteurn a copy of " (tt "message") ". Note that this actually copies " (tt "message") "'s data, i.e. it doesn't bind the API call " (tt "zmq_msg_copy") "."))
(def (sig (procedure "(send-message socket message #!key non-blocking send-more)" (id send-message))) (p "Send " (tt "message") " via " (tt "socket") " with " (tt "message") " being either a message record or a string. If " (tt "non-blocking") " is not " (tt "#f") ", the function call will not block (default: " (tt "#f") "). If " (tt "send-more") " is not " (tt "#f") ", mark this message as part of a multi-part messaging and that further parts are to follow (see " (link "http://api.zeromq.org/zmq_send.html#_multi_part_messages" "the documentation about multi-part messages for more information") ", default: " (tt "#f") ")."))
(def (sig (procedure "(receive-message socket #!key non-blocking)" (id receive-message))) (p "Receive the next message from " (tt "socket") ". If " (tt "non-blocking") " is not " (tt "#f") ", the function call will not block and return " (tt "#f") " if no message is available (default: " (tt "#f") ")."))
(def (sig (procedure "(make-poll-item socket/fd #!key in out)" (id make-poll-item))) (p "Create a ZeroMQ " (tt "poll-item") " for " (tt "socket/fd") " which can either be a ZeroMQ socket or a POSIX file descriptor. The keyword arguments " (tt "in") " and " (tt "out") " are booleans indicating whether the item should poll for incoming or outgoing data. Both are " (tt "#f") " by default so make sure to pass at least one as " (tt "#t") "."))
(def (sig (procedure "(poll-item-fd item)" (id poll-item-fd))) (p "Return " (tt "item") "'s POSIX file descriptor if is has been created with one (see " (tt "make-poll-item") ")."))
(def (sig (procedure "(poll-item-socket item)" (id poll-item-socket))) (p "Return " (tt "item") "'s socket if is has been created with one (see " (tt "make-poll-item") ")."))
(def (sig (procedure "(poll-item-in? item)" (id poll-item-in?))) (p "Check whether " (tt "item") "'s socket or file descriptor is ready for reading."))
(def (sig (procedure "(poll-item-out? item)" (id poll-item-out?))) (p "Check whether " (tt "item") "'s socket or file descriptor is ready for writing."))
(def (sig (procedure "(poll-item-error? item)" (id poll-item-error?))) (p "Check whether there is an error condition present on " (tt "item") "'s file descriptor. This will never be the case for ZeroMQ sockets."))
(def (sig (procedure "(poll poll-items timeout/block)" (id poll))) (p "Poll the poll-item list " (tt "poll-items") " for activity. " (tt "timeout/block") " can either be " (tt "#t") " which will block until one of the " (tt "poll-items") " is ready. When " (tt "#f") " is passed the call will not block and return " (tt "#f") " when no " (tt "poll-item") " is ready. Alternatively, an integer may be passed, indicating the number of microseconds to wait for activity.") (p "The return value is a number indicating how many " (tt "poll-items") " are ready."))
