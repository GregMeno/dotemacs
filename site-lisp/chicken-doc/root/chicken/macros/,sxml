((tags "manual") (toc) (section 2 "Macros" (p "CHICKEN supports standard R5RS " (tt "syntax-rules") " macros and a low-level macro system based on " (i "explicit renaming") ".") (section 3 "Macro definitions" (section 4 "define-syntax" (def (sig (syntax "(define-syntax IDENTIFIER TRANSFORMER)" (id define-syntax))) (p "Defines a macro named " (tt "IDENTIFIER") " that will transform an expression with " (tt "IDENTIFIER") " in operator position according to " (tt "TRANSFORMER") ". The transformer expression must be a procedure with three arguments or a " (tt "syntax-rules") " form. If " (tt "syntax-rules") " is used, the usual R5RS semantics apply. If " (tt "TRANSFORMER") " is a procedure, then it will be called on expansion with the complete s-expression of the macro invocation, a rename procedure that hygienically renames identifiers and a comparison procedure that compares (possibly renamed) identifiers (see the section \"Explicit renaming macros\" below for a detailed explanation on non-R5RS macros).") (p (tt "define-syntax") " may be used to define local macros that are visible throughout the rest of the body in which the definition occurred, i.e.") (pre " (let ()\n   ...\n   (define-syntax foo ...)\n   (define-syntax bar ...)\n   ...)") (p "is expanded into") (pre " (let ()\n   ...\n   (letrec-syntax ((foo ...) (bar ...))\n     ...) )") (p (tt "syntax-rules") " partially supports " (link "http://srfi.schemers.org/srfi-46/" "SRFI-46") " in allowing the ellipsis identifier to be user-defined by passing it as the first argument to the " (tt "syntax-rules") " form.") (p "The effect of destructively modifying the s-expression passed to a transformer procedure is undefined."))) (section 4 "syntax" (def (sig (syntax "(syntax EXPRESSION)" (id syntax))) (p "Similar to " (tt "quote") " but retains syntactical context information for embedded identifiers."))) (section 4 "strip-syntax" (def (sig (procedure "(strip-syntax EXPRESSION)" (id strip-syntax))) (p "Strips all syntactical information from " (tt "EXPRESSION") ", returning a new expression where symbols have all context-information removed.")))) (section 3 "Explicit renaming macros" (p "The low-level macro facility that CHICKEN provides is called \"explicit renaming\" and allows writing hygienic or non-hygienic macros procedurally. When given a lambda-expression instead of a " (tt "syntax-rules") " form, " (tt "define-syntax") " evaluates the procedure in a distinct expansion environment (initially having access to the exported identifiers of the " (tt "scheme") " module). The procedure takes an expression and two other arguments and returns a transformed expression.") (p "For example, the transformation procedure for a " (tt "call") " macro such that " (tt "(call proc arg ...)") " expands into " (tt "(proc arg ...)") " can be written as") (pre " (lambda (exp rename compare)\n   (cdr exp))") (p "Expressions are represented as lists in the traditional manner, except that identifiers are represented as special uninterned symbols.") (p "The second argument to a transformation procedure is a renaming procedure that takes the representation of an identifier as its argument and returns the representation of a fresh identifier that occurs nowhere else in the program.  For example, the transformation procedure for a simplified version of the " (tt "let") " macro might be written as") (pre " (lambda (exp rename compare)\n   (let ((vars (map car (cadr exp)))\n         (inits (map cadr (cadr exp)))\n         (body (cddr exp)))\n     `((lambda ,vars ,@body)\n       ,@inits)))") (p "This would not be hygienic, however.  A hygienic " (tt "let") " macro must rename the identifier " (tt "lambda") " to protect it from being captured by a local binding.  The renaming effectively creates a fresh alias for " (tt "lambda") ", one that cannot be captured by any subsequent binding:") (pre " (lambda (exp rename compare)\n   (let ((vars (map car (cadr exp)))\n         (inits (map cadr (cadr exp)))\n         (body (cddr exp)))\n     `((,(rename 'lambda) ,vars ,@body)\n       ,@inits)))") (p "The expression returned by the transformation procedure will be expanded in the syntactic environment obtained from the syntactic environment of the macro application by binding any fresh identifiers generated by the renaming procedure to the denotations of the original identifiers in the syntactic environment in which the macro was defined.  This means that a renamed identifier will denote the same thing as the original identifier unless the transformation procedure that renamed the identifier placed an occurrence of it in a binding position.") (p "Identifiers obtained from any two calls to the renaming procedure with the same argument will necessarily be the same, but will denote the same syntactical binding. It is an error if the renaming procedure is called after the transformation procedure has returned.") (p "The third argument to a transformation procedure is a comparison predicate that takes the representations of two identifiers as its arguments and returns true if and only if they denote the same thing in the syntactic environment that will be used to expand the transformed macro application.  For example, the transformation procedure for a simplified version of the " (tt "cond") " macro can be written as") (pre " (lambda (exp rename compare)\n   (let ((clauses (cdr exp)))\n     (if (null? clauses)\n         `(,(rename 'quote) unspecified)\n         (let* ((first (car clauses))\n                (rest (cdr clauses))\n                (test (car first)))\n           (cond ((and (symbol? test)\n                       (compare test (rename 'else)))\n                  `(,(rename 'begin) ,@(cdr first)))\n                 (else `(,(rename 'if)\n                         ,test\n                          (,(rename 'begin) ,@(cdr first))\n                          (cond ,@rest))))))))") (p "In this example the identifier " (tt "else") " is renamed before being passed to the comparison predicate, so the comparison will be true if and only if the test expression is an identifier that denotes the same thing in the syntactic environment of the expression being transformed as " (tt "else") " denotes in the syntactic environment in which the " (tt "cond") " macro was defined.  If " (tt "else") " were not renamed before being passed to the comparison predicate, then it would match a local variable that happened to be named " (tt "else") ", and the macro would not be hygienic.") (p "Some macros are non-hygienic by design.  For example, the following defines a " (tt "loop") " macro that implicitly binds " (tt "exit") " to an escape procedure.  The binding of " (tt "exit") " is intended to capture free references to " (tt "exit") " in the body of the loop, so " (tt "exit") " is not renamed.") (pre " (define-syntax loop\n   (lambda (x r c)\n     (let ((body (cdr x)))\n       `(,(r 'call-with-current-continuation)\n         (,(r 'lambda) (exit)\n          (,(r 'let) ,(r 'f) () ,@body (,(r 'f))))))))") (p "Suppose a " (tt "while") " macro is implemented using " (tt "loop") ", with the intent that " (tt "exit") " may be used to escape from the " (tt "while") " loop.  The " (tt "while") " macro cannot be written as") (pre " (define-syntax while\n   (syntax-rules ()\n     ((while test body ...)\n      (loop (if (not test) (exit #f))\n            body ...))))") (p "because the reference to " (tt "exit") " that is inserted by the " (tt "while") " macro is intended to be captured by the binding of " (tt "exit") " that will be inserted by the " (tt "loop") " macro.  In other words, this " (tt "while") " macro is not hygienic.  Like " (tt "loop") ", it must be written using procedurally:") (pre " (define-syntax while\n   (lambda (x r c)\n     (let ((test (cadr x))\n           (body (cddr x)))\n       `(,(r 'loop)\n         (,(r 'if) (,(r 'not) ,test) (exit #f))\n         ,@body))))") (p "Note: this implementation of explicit-renaming macros allows passing arbitrary expressions to the renaming and comparison procedures. When being renamed, a fresh copy of the expression will be produced, with all identifiers renamed appropriately. Comparison also supports arbitrary expressions as arguments.") (hr) (p "Previous: " (int-link "Non-standard macros and special forms")) (p "Next: " (int-link "Modules")))))