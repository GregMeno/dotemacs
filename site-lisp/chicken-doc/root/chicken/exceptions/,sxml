((tags "manual") (toc) (section 2 "Exceptions" (p "Chicken's exception handling is based on the " (link "http://srfi.schemers.org/srfi-12/srfi-12.html" "SRFI-12") " exception system.  This document contains the core of the SRFI-12 spec as well as Chicken implementation specifics.")) (section 2 "Chicken implementation" (section 3 "System conditions" (p "All error-conditions signaled by the system are of kind " (tt "exn") ". The following composite conditions are additionally defined:") (table "\n" (tr (td " (exn arity) ") (td "\n\nSignaled when a procedure is called with the wrong number of arguments.\n\n")) (tr (td " (exn type) ") (td "\n\nSignaled on type-mismatch errors, for example when an argument of the wrong\ntype is passed to a built-in procedure.\n\n")) (tr (td " (exn arithmetic) ") (td "\n\nSignaled on arithmetic errors, like division by zero.\n\n")) (tr (td " (exn i/o) ") (td "\n\nSignaled on input/output errors.\n\n")) (tr (td " (exn i/o file) ") (td "\n\nSignaled on file-related errors.\n\n")) (tr (td " (exn i/o net) ") (td "\n\nSignaled on network errors.\n\n")) (tr (td " (exn bounds) ") (td "\n\nSignaled on errors caused by accessing non-existent elements of a collection.\n\n")) (tr (td " (exn runtime) ") (td "\n\nSignaled on low-level runtime-system error-situations.\n\n")) (tr (td " (exn runtime limit) ") (td "\n\nSignaled when an internal limit is exceeded (like running out of memory).\n\n")) (tr (td " (exn match) ") (td "\n\nSignaled on errors raised by failed matches (see the section on " (tt "match") ").\n\n")) (tr (td " (exn syntax) ") (td "\n\nSignaled on syntax errors.\n\n")) "\n")) (section 3 "Notes" (ul (li "All error-exceptions (of the kind " (tt "exn") ") are non-continuable.") (li "Error-exceptions of the " (tt "exn") " kind have additional " (tt "arguments") " and " (tt "location") " properties that contain the arguments passed to the exception-handler and the name of the procedure where the error occurred (if available).") (li "When the " (tt "posix") " unit is available and used, then a user-interrupt (" (tt "signal/int") ") signals an exception of the kind " (tt "user-interrupt") ".") (li "The procedure " (tt "condition-property-accessor") " accepts an optional third argument. If the condition does not have a value for the desired property and if the optional argument is given, no error is signaled and the accessor returns the third argument."))) (section 3 "Additional API" (def (sig (syntax "(condition-case EXPRESSION CLAUSE ...)" (id condition-case))) (p "Evaluates " (tt "EXPRESSION") " and handles any exceptions that are covered by " (tt "CLAUSE ...") ", where " (tt "CLAUSE") " should be of the following form:") (highlight scheme "CLAUSE = ([VARIABLE] (KIND ...) BODY ...)") (p "If provided, " (tt "VARIABLE") " will be bound to the signaled exception object. " (tt "BODY ...") " is executed when the exception is a property- or composite condition with the kinds given " (tt "KIND ...") " (unevaluated). If no clause applies, the exception is re-signaled in the same dynamic context as the " (tt "condition-case") " form.") (highlight scheme "(define (check thunk)\n  (condition-case (thunk)\n    [(exn file) (print \"file error\")]\n    [(exn) (print \"other error\")]\n    [var () (print \"something else\")] ) )\n\n(check (lambda () (open-input-file \"\")))   ; -> \"file error\"\n(check (lambda () some-unbound-variable))  ; -> \"othererror\"\n(check (lambda () (signal 99)))            ; -> \"something else\"\n\n(condition-case some-unbound-variable\n  ((exn file) (print \"ignored\")) )      ; -> signals error")) (def (sig (procedure "(get-condition-property CONDITION KIND PROPERTY [DEFAULT])" (id get-condition-property))) (p "A slightly more convenient condition property accessor, equivalent to") (pre "((condition-property-accessor KIND PROPERTY [DEFAULT]) CONDITION)")))) (section 2 "SRFI-12 specification" (p "A Scheme implementation (\"the system\") raises an exception whenever an error is to be signaled or whenever the system determines that evaluation cannot proceed in a manner consistent with the semantics of Scheme. A program may also explicitly raise an exception.") (p "Whenever the system raises an exception, it invokes the current exception handler with a condition object (encapsulating information about the exception) as its only argument. Any procedure accepting one argument may serve as an exception handler. When a program explicitly raises an exception, it may supply any object to the exception handler.") (p "An exception is either continuable or non-continuable. When the current exception handler is invoked for a continuable exception, the continuation uses the handler's result(s) in an exception-specific way to continue. When an exception handler is invoked for a non-continuable exception, the continuation raises a non-continuable exception indicating that the exception handler returned.  On CHICKEN, system error exceptions (of kind " (tt "exn") ") are non-continuable.") (section 3 "Exception Handlers" (def (sig (parameter "(current-exception-handler [PROCEDURE])" (id current-exception-handler))) (p "Sets or returns the current exception handler, a procedure of one argument, the exception object.")) (def (sig (procedure "(with-exception-handler handler thunk)" (id with-exception-handler))) (p "Returns the result(s) of invoking " (i "thunk") ". The " (i "handler") " procedure is installed as the current exception handler in the dynamic context of invoking " (i "thunk") ".") (p "Example:") (pre "(call-with-current-continuation\n (lambda (k)\n  (with-exception-handler (lambda (x) (k '()))\n                          (lambda () (car '())))))\n;=> '()")) (def (sig (syntax "(handle-exceptions var handle-expr expr1 expr2 ...)" (id handle-exceptions))) (p "Evaluates the body expressions " (i "expr1") ", " (i "expr2") ", ... in sequence with an exception handler constructed from " (i "var") " and " (i "handle-expr") ". Assuming no exception is raised, the result(s) of the last body expression is(are) the result(s) of the " (tt "handle-exceptions") " expression.") (p "The exception handler created by " (tt "handle-exceptions") " restores the dynamic context (continuation, exception handler, etc.) of the " (tt "handle-exceptions") " expression, and then evaluates " (i "handle-expr") " with " (i "var") " bound to the value provided to the handler.") (p "Examples:") (pre "(handle-exceptions exn\n\t    (begin\n\t      (display \"Went wrong\")\n\t      (newline))\n (car '()))\n; displays \"Went wrong\"\n\n(handle-exceptions exn \n\t    (cond\n\t     ((eq? exn 'one) 1)\n\t     (else (ABORT exn)))\n  (case (random-number)\n   [(0) 'zero]\n   [(1) (abort 'one)]\n   [else (abort \"Something else\")]))\n;=> 'zero, 1, or (abort \"Something else\")"))) (section 3 "Raising Exceptions" (def (sig (procedure "(abort obj)" (id abort))) (p "Raises a non-continuable exception represented by " (i "obj") ". The " (tt "abort") " procedure can be implemented as follows:") (pre "(define (abort obj)\n  ((current-exception-handler) obj)\n  (abort (make-property-condition\n    'exn\n    'message\n    \"Exception handler returned\")))") (p "The " (tt "abort") " procedure does not ensure that its argument is a condition. If its argument is a condition, " (tt "abort") " does not ensure that the condition indicates a non-continuable exception.")) (def (sig (procedure "(signal obj)" (id signal))) (p "Raises a continuable exception represented by " (i "obj") ". The " (tt "signal") " procedure can be implemented as follows:") (pre "(define (signal exn)\n ((current-exception-handler) exn))") (p "The " (tt "signal") " procedure does not ensure that its argument is a condition. If its argument is a condition, " (tt "signal") " does not ensure that the condition indicates a continuable exception."))) (section 3 "Condition Objects" (def (sig (procedure "(condition? obj)" (id condition?))) (p "Returns #t if " (i "obj") " is a condition, otherwise returns #f. If any of the predicates listed in Section 3.2 of the R5RS is true of " (i "obj") ", then " (tt "condition?") " is false of " (i "obj") ".") (p "Rationale: Any Scheme object may be passed to an exception handler. This would cause ambiguity if conditions were not disjoint from all of Scheme's standard types.")) (def (sig (procedure "(make-property-condition kind-key prop-key value ...)" (id make-property-condition))) (p "This procedure accepts any even number of arguments after " (i "kind-key") ", which are regarded as a sequence of alternating " (i "prop-key") " and " (i "value") " objects. Each " (i "prop-key") " is regarded as the name of a property, and each " (i "value") " is regarded as the value associated with the " (i "key") " that precedes it. Returns a " (i "kind-key") " condition that associates the given " (i "prop-key") "s with the given " (i "value") "s.")) (def (sig (procedure "(make-composite-condition condition ...)" (id make-composite-condition))) (p "Returns a newly-allocated condition whose components correspond to the the given " (i "condition") "s. A predicate created by " (tt "condition-predicate") " returns true for the new condition if and only if it returns true for one or more of its component conditions.")) (def (sig (procedure "(condition-predicate kind-key)" (id condition-predicate))) (p "Returns a predicate that can be called with any object as its argument. Given a condition that was created by " (tt "make-property-condition") ", the predicate returns #t if and only if " (i "kind-key") " is EQV? to the kind key that was passed to " (tt "make-property-condition") ". Given a composite condition created with " (tt "make-composite-condition") ", the predicate returns #t if and only if the predicate returns #t for at least one of its components.")) (def (sig (procedure "(condition-property-accessor kind-key prop-key [default])" (id condition-property-accessor))) (p "Returns a procedure that can be called with any condition that satisfies " (tt "(condition-predicate ''kind-key'')") ". Given a condition that was created by " (tt "make-property-condition") " and " (i "kind-key") ", the procedure returns the value that is associated with " (i "prop-key") ". Given a composite condition created with " (tt "make-composite-condition") ", the procedure returns the value that is associated with " (i "prop-key") " in one of the components that satisfies " (tt "(condition-predicate ''kind-key'')") ".") (p "On Chicken, this procedure accepts an optional third argument DEFAULT. If the condition does not have a value for the desired property and if the optional argument is given, no error is signaled and the accessor returns the third argument.") (p "When the system raises an exception, the condition it passes to the exception handler includes the " (tt "'exn") " kind with the following properties:") (dl (dt "message") (dd "the error message") (dt "arguments") (dd "the arguments passed to the exception handler") (dt "location") (dd "the name of the procedure where the error occurred (if available)")) (p "Thus, if " (i "exn") " is a condition representing a system exception, then") (pre "((condition-property-accessor 'exn 'message) exn)") (p "extracts the error message from " (i "exn") ". Example:") (pre "(handle-exceptions exn \n\t    (begin\n\t      (display \"Went wrong: \")\n\t      (display\n\t       ((condition-property-accessor 'exn 'message) exn))\n\t      (newline))\n (car '()))\n; displays something like \"Went wrong: can't take car of nil\""))) (section 3 "More Examples" (pre "(define (try-car v)\n (let ((orig (current-exception-handler)))\n   (with-exception-handler\n    (lambda (exn)\n      (orig (make-composite-condition\n      (make-property-condition\n       'not-a-pair\n       'value\n       v)\n      exn)))\n    (lambda () (car v)))))\n\n(try-car '(1))\n;=> 1") (pre "(handle-exceptions exn\n\t    (if ((condition-predicate 'not-a-pair) exn)\n\t\t(begin\n\t\t (display \"Not a pair: \")\n\t\t (display\n\t\t  ((condition-property-accessor 'not-a-pair 'value) exn))\n\t\t (newline))\n\t\t(ABORT exn))\n  (try-car 0))\n; displays \"Not a pair: 0\"") (pre "(let* ((cs-key (list 'color-scheme))\n(bg-key (list 'background))\n(color-scheme? (condition-predicate cs-key))\n(color-scheme-background \n (condition-property-accessor cs-key bg-key))\n(condition1 (make-property-condition cs-key bg-key 'green))\n(condition2 (make-property-condition cs-key bg-key 'blue))\n(condition3 (make-composite-condition condition1 condition2)))\n  (and (color-scheme? condition1)\n(color-scheme? condition2)\n(color-scheme? condition3)\n(color-scheme-background condition3)))\n; => 'green or 'blue") (hr) (p "Previous: " (int-link "Parameters") " Next: " (int-link "Unit library")))))