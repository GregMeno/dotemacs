((tags "manual") (section 2 "Getting started " (p "CHICKEN is a compiler that translates Scheme source files into C, which in turn can be fed to a C compiler to generate a standalone executable.  An interpreter is also available and can be used as a scripting environment or for testing programs before compilation.") (p "This chapter is designed to get you started with CHICKEN programming, describing what it is and what it will do for you, and covering basic use of the system. With almost everything discussed here, there is more to the story, which the remainder of the manual reveals. Here, we only cover enough to get you started. Nonetheless, someone who knows Scheme already should be able to use this chapter as the basis for writing and running small CHICKEN programs.") (section 3 "Scheme" (p "Scheme is a member of the Lisp family of languages, of which Common Lisp and Emacs Lisp are the other two widely-known members. As with Lisp dialects, Scheme features") (ul (li "a wide variety of programming paradigms, including imperative, functional, and object-oriented") (li "a very simple syntax, based upon nested parenthesization ") (li "the ability to extend the language in meaningful and useful ways")) (p "In contrast to Common Lisp, Scheme is very minimal, and tries to include only those features absolutely necessary in programming. In contrast to Emacs Lisp, Scheme is not anchored into any one program (Emacs), and has a somewhat more modern language design.") (p "Scheme is defined in a document called " (i "The Revised^5 Report on the Algorithmic Language Scheme") ", or " (i "R5RS") " for short. (Yes, it really has been revised five times, so an expanded version of its name would be " (i "The Revised Revised Revised Revised Revised Report") ".)  A newer report, " (i "R6RS") ", was released in 2007, but this report has attracted considerable controversy, and not all Scheme implementations will be made compliant with it. CHICKEN essentially complies with R5RS.") (p "Even though Scheme is consciously minimalist, it is recognized that a language must be more than a minimal core in order to be useful. Accordingly, the Scheme community uses a process known as `Scheme Requests For Implementation' (SRFI, pronounced `SUR-fee') to define new language features. A typical Scheme system therefore complies with one of the Scheme reports plus some or all of the accepted SRFIs.") (p "A good starting point for Scheme knowledge is " (link "http://www.schemers.org") ". There you will find the defining reports, FAQs, lists of useful books and other resources, and the SRFIs.") (p "The CHICKEN community is at present developing tutorials for programmers who are new to Scheme but experienced with Python, Ruby, or other languages. These can be found on the CHICKEN wiki.")) (section 3 "CHICKEN" (p "CHICKEN is an implementation of Scheme that has many advantages.") (p "CHICKEN Scheme combines an optimising compiler with a reasonably fast interpreter.  It supports almost all of R5RS and the important SRFIs. The compiler generates portable C code that supports tail recursion, first-class continuations, and lightweight threads, and the interface to and from C libraries is flexible, efficient, and easy to use.  There are hundreds of contributed CHICKEN libraries that make the programmer's task easier.  The interpreter allows interactive use, fast prototyping, debugging, and scripting.  The active and helpful CHICKEN community fixes bugs and provides support.  Extensive documentation is supplied.") (p "CHICKEN was developed by Felix L. Winkelmann over the period from 2000 through 2007. In early 2008, Felix asked the community to take over the responsibility of developing and maintaining the system, though he still takes a strong interest in it, and participates actively.") (p "CHICKEN includes") (ul (li "a Scheme interpreter that supports almost all of  R5RS Scheme, with only a few relatively minor omissions, and with many extensions") (li "a compatible compiler whose target is C, thus making porting to new machines and architectures relatively straightforward" (ul (li "the C support allows Scheme code to include `embedded' C code, thus making it relatively easy to invoke host OS or library functions"))) (li "a framework for language extensions, library modules that broaden the functionality of the system")) (p "This package is distributed under the " (b "BSD license") " and as such is free to use and modify.") (p "Scheme cognoscenti will appreciate the method of compilation and the design of the runtime-system, which follow closely Henry Baker's " (link "http://home.pipeline.com/~hbaker1/CheneyMTA.html" "CONS Should Not CONS Its Arguments, Part II: Cheney on the M.T.A.") " paper and expose a number of interesting properties.") (ul (li "Consing (creation of data on the heap) is relatively inexpensive, because a generational garbage collection scheme is used, in which short-lived data structures are reclaimed extremely quickly.") (li "Moreover, " (tt "call-with-current-continuation") " is practically for free and CHICKEN does not suffer under any performance penalties if first-class continuations are used in complex ways.")) (p "The generated C code is fully tail-recursive.") (p "Some of the features supported by CHICKEN:") (ul (li "SRFIs 0, 1, 2, 4, 6-19, 23, 25-31, 37-40, 42, 43, 45, 47, 55, 57, 60-63, 66, 69, 72, 78, 85, 95 and 98.") (li "Lightweight threads based on first-class continuations") (li "Pattern matching with Andrew Wright's " (tt "match") " package") (li "Record structures") (li "Extended comment- and string-literal syntaxes") (li "Libraries for regular expressions, string handling") (li "UNIX system calls and extended data structures") (li "Create interpreted or compiled shell scripts written in Scheme for UNIX or Windows") (li "Compiled C files can be easily distributed") (li "Allows the creation of fully self-contained statically linked executables") (li "On systems that support it, compiled code can be loaded dynamically") (li "Built-in support for cross-compilation and deployment")) (p "CHICKEN has been used in many environments ranging from embedded systems through desktop machines to large-scale server deployments. The number of language extensions, or " (b "eggs") ", is constantly growing.") (ul (li "extended language features") (li "development tools, such as documentation generators, debugging, and automated testing libraries") (li "interfaces to other languages such as Java, Python, and Objective-C") (li "interfaces to database systems, GUIs, and other large-scale libraries,") (li "network applications, such as servers and clients for ftp, smtp/pop3, irc, and http") (li "web servers and related tools, including URL parsing, HTML generation, AJAX, and HTTP session management") (li "data formats, including XML, JSON, and Unicode support")) (p "CHICKEN is supported by SWIG (Simplified Wrapper and Interface Generator), a tool that produces quick-and-dirty interface modules for C libraries (" (link "http://www.swig.org") ").") (p "This chapter provides you with an overview of the entire system, with enough information to get started writing and running small Scheme programs.")) (section 3 "CHICKEN repositories, websites, and community" (p "The master CHICKEN website is " (link "http://www.call-with-current-continuation.org") ". Here you can find basic information about CHICKEN, downloads, and pointers to other key resources.") (p "The CHICKEN wiki (" (link "http://wiki.call-cc.org") ") contains the most current version of the User's manual, along with various tutorials and other useful documents. The list of eggs is at " (link "http://wiki.call-cc.org/chicken-projects/egg-index-4.html#category-list") ".") (p "A very useful search facility for questions about CHICKEN is found at " (link "http://chickadee.call-cc.org") ". The CHICKEN issue tracker is at " (link "http://bugs.call-cc.org") ".") (p "The CHICKEN community has two major mailing lists. If you are a CHICKEN user, " (tt "chicken-users") " (" (link "http://lists.nongnu.org/mailman/listinfo/chicken-users") ") will be of interest. The crew working on the CHICKEN system itself uses the very low-volume " (tt "chicken-hackers") " list (" (link "http://lists.nongnu.org/mailman/listinfo/chicken-hackers") ") for communication.")) (section 3 "Installing CHICKEN" (p "CHICKEN is available in source form (C) which can be built on several platforms. Refer to the " (tt "README") " file in the distribution for instructions on installing it on your system.") (p "Because it compiles to C, CHICKEN requires that a C compiler be installed on your system. (If you're not writing embedded C code, you can pretty much ignore the C compiler once you have installed it.)") (ul (li "On a Linux system, the GNU Compiler Collection (" (tt "gcc") ") should be installed as part of the basic operating system, or should be available through the package management system (e.g., APT, Synaptic, RPM, or Yum, depending upon your Linux distribution).") (li "On Macintosh OS X, you will need the XCode tools, which are shipped on the OS X DVD with recent versions of the operating system.") (li "On Windows, you have three choices." (ul (li "Cygwin (" (link "http://sources.redhat.com/cygwin") ") provides a relatively full-featured Unix environment for Windows.  CHICKEN works substantially the same in Cygwin and Unix.") (li "The GNU Compiler Collection has been ported to Windows, in the MinGW system (" (link "http://mingw.sourceforge.net") "). Unlike Cygwin, executables produced with MinGW do not need the Cygwin DLLs in order to run.   MSys is a companion package to MinGW; it provides a minimum Unix-style development/build environment, again ported from free software." (ul (li "You can build CHICKEN either with MinGW alone or with MinGW plus  MSYS. Both approaches produce a CHICKEN built against the mingw headers and import libraries. The only difference is the environment where you actually run make. " (tt "Makefile.mingw") " is can be used in " (tt "cmd.exe") " with the version of make that comes with mingw.  " (tt "Makefile.mingw-msys") " uses unix commands such as " (tt "cp") " and " (tt "rm") ".  The end product is the same.")))))) (p "Refer to the " (tt "README") " file for the version you're installing for more information on the installation process.") (p "Alternatively, third party packages in binary format are available. Se " (link "http://wiki.call-cc.org/platforms") " for information about how to obtain them.")) (section 3 "Development environments" (p "The simplest development environment is a text editor and terminal window (Windows: Command Prompt, OSX: Terminal, Linux/Unix: xterm) for using the interpreter and/or calling the compiler. If you " (int-link "/egg/readline" ("install the " (tt "readline") " egg")) ", you have all the benefits of command history in the interpreter, Emacs or vi-compatible line editing, and customization.") (p "You will need a text editor that knows Scheme; it's just too painful with editors that don't do parenthesis matching and proper indentation. Some editors allow you to execute Scheme code directly in the editor. This makes programming very interactive: you can type in a function and then try it right away. This feature is very highly recommended.") (p "As programmers have very specific tastes about editors, the editors listed here are shown in alphabetic order. We aren't about to tell you which editor to use, and there may be editors not shown here that might satisfy your needs. We would be very interested in reports of other editors that have been used with CHICKEN, especially those that support interactive evaluation of forms during editing. Pointers to these (and to any editor customization files appropriate) should be put on the CHICKEN wiki, and will likely be added to future editions of this manual. (We have had a request for editors that support proportional fonts, in particular.)") (ul (li "Emacs (" (link "http://www.gnu.org/software/emacs") ") is an extensible, customizable, self-documenting editor available for Linux/Unix, Macintosh, and Windows systems; See " (int-link "/emacs") " for more information about the available options.") (li "Epsilon (" (link "http://www.lugaru.com") ") is a commercial (proprietary) text editor whose design was inspired by Emacs. Although Scheme support isn't provided, a Lisp mode is available on Lugaru's FTP site, and could with some work be made to duplicate the Emacs support.") (li "SciTE (" (link "http://scintilla.sourceforge.net/SciTE.html") "),  unlike Emacs or Vim, follows typical graphical UI design conventions and control-key mappings, and for simple tasks is as familiar and easy to use as Notepad, KEdit, TeachText etc.  However it has many programming features such as multiple open files, syntax highlighting for a large number of languages (including Lisps), matching of brackets, ability to fold sections of code based on the matched brackets, column selections, comment/uncomment, and the ability to run commands in the same directory as the current file (such as make, grep, etc.)  SciTE is written with the GTK toolkit and is portable to any GTK platform, including Windows, Linux and MacOS.  It uses the Scintilla text-editing component, which lends itself well to embedding within other IDEs and graphical toolkits. It does not have any other Scheme-specific features, but being open-source and modular, features like auto-formatting of S-expressions could be added.  The syntax highlighting can be configured to use different fonts for different types of syntax, including proportional fonts.") (li "Vim (" (link "http://www.vim.org") ") is a highly configurable text editor built to enable efficient and fast text editing. It is an improved version of the vi editor distributed with most UNIX systems. Vim comes with generic Lisp (and therefore Scheme) editing capabilities out of the box. A few tips on using Vim with CHICKEN can be found at " (link "http://cybertiggyr.com/gene/15-vim/") ".")) (p "In the rest of this chapter, we'll assume that you are using an editor of your choice and a regular terminal window for executing your CHICKEN code.")) (section 3 "The Read-Eval-Print loop" (p "To invoke the CHICKEN interpreter, you use the " (tt "csi") " command.") (pre "$ csi\nCHICKEN\n(c)2008 The CHICKEN Team\n(c)2000-2007 Felix L. Winkelmann\nVersion 3.1.2 - macosx-unix-gnu-x86\t[ manyargs dload ptables applyhook ]\nSVN rev. 10185\tcompiled 2008-03-27 on argyre.local (Darwin)\n#;1>") (p "This brings up a brief banner, and then the prompt. You can use this pretty much like any other Scheme system, e.g.,") (pre "#;1> (define (twice f) (lambda (x) (f (f x))))\n#;2> ((twice (lambda (n) (* n 10))) 3)\n300") (p "Suppose  we have already created a file " (tt "fact.scm") " containing a function definition.") (pre "(define (fact n)\n  (if (= n 0)\n      1\n      (* n (fact (- n 1)))))") (p "We can now load this file and try out the function.") (pre "#;3> (load \"fact.scm\")\n; loading fact.scm ...\n#;4> (fact 3)\n6") (p "The " (b "read-eval-print loop") " (" (b "REPL") ") is the component of the Scheme system that " (i "reads") " a Scheme expression, " (i "eval") "uates it, and " (i "prints") " out the result. The REPL's prompt can be customized (see the " (int-link "Using the interpreter") ") but the default prompt, showing the number of the form, is quite convenient.") (p "The REPL also supports debugging commands: input lines beginning with a " (tt ",") " (comma) are treated as special commands. (See the " (int-link "Using the interpreter#Toplevel commands" "full list") ".)") (section 4 "Scripts" (p "You can use the interpreter to run a Scheme program from the command line. Here we create a program that does a quick search-and-replace on an input file; the arguments are a regular expression and a replacement string.") (pre "$ cat quickrep.dat\nxyzabcghi\nabxawxcgh\nfoonly \n$ csi -ss quickrep.scm <quickrep.dat 'a.*c' A\nxyzAghi\nAgh\nfoonly ") (p "The " (tt "-ss") " option sets several options that work smoothly together to execute a script. You can make the command directly executable from the shell by inserting a `" (int-link "Using the interpreter#Writing Scheme scripts" "shebang line") "' at the beginning of the program.") (p (tt "regex") ", the regular expression library, is one of the libraries included with CHICKEN.") (highlight scheme "(use regex) \n\n(define (process-line line re rplc) \n  (string-substitute re rplc line 'all))\n\n(define (quickrep re rplc) \n  (let ((line (read-line)))\n    (if (not (eof-object? line))\n        (begin \n          (display (process-line line re rplc))\n          (newline)\n          (quickrep re rplc)))))\n\n;;; Does a lousy job of error checking!\n(define (main args)\n  (quickrep (regexp (car args)) (cadr args)))") (p "The " (tt "-ss") " option arranges to call a procedure named " (tt "main") ", with the command line arguments, packed in a list, as its arguments. (There are a number of ways this program could be made more idiomatic CHICKEN Scheme, see the rest of the manual for details.)"))) (section 3 "The compiler " (p "There are several reasons you might want to compile your code.") (ul (li "Compiled code executes substantially faster than interpreted code.") (li "You might want to deploy an application onto machines where the users aren't expected to have CHICKEN installed: compiled applications can be self-contained.")) (p "The CHICKEN compiler is provided as the command " (tt "chicken") ", but in almost all cases, you will want to use the " (tt "csc") " command instead. " (tt "csc") " is a convenient driver that automates compiling Scheme programs into C, compiling C code into object code, and linking the results into an executable file. (Note: in a Windows environment with Visual Studio, you may find that " (tt "csc") " refers to Microsoft's C# compiler. There are a number of ways of sorting this out, of which the simplest is to rename one of the two tools, and/or to organize your " (tt "PATH") " according to the task at hand.)") (p "Compiled code can be intermixed with interpreted code on systems that support dynamic loading, which includes modern versions of *BSD, Linux, Mac OS X, Solaris, and Windows.") (p "We can compile our factorial function, producing a file named " (tt "fact.so") " (`shared object' in Linux-ese, the same file type is used in OS X and Windows, rather than " (tt "dylib") " or " (tt "dll") ", respectively).") (pre "chicken$ csc -dynamic fact.scm\nchicken$ csi -quiet\n#;1> (load \"fact.so\")\n; loading fact.so ...\n#;2> (fact 6)\n720") (p "On any system, we can just compile a program directly into an executable. Here's a program that tells you whether its argument is a palindrome.") (highlight scheme "(define (palindrome? x)\n  (define (check left right)\n    (if (>= left right)\n        #t\n        (and (char=? (string-ref x left) (string-ref x right))\n             (check (add1 left) (sub1 right)))))\n  (check 0 (sub1 (string-length x))))\n(let ((arg (car (command-line-arguments))))\n  (display \n   (string-append arg \n                  (if (palindrome? arg) \n                      \" is a palindrome\\n\"\n                      \" isn't a palindrome\\n\"))))") (p "We can compile this program using " (tt "csc") ", creating an executable named " (tt "palindrome") ".") (pre "$ csc -o palindrome palindrome.scm\n$ ./palindrome level\nlevel is a palindrome\n$ ./palindrome liver\nliver isn't a palindrome") (p "CHICKEN supports separate compilation, using some extensions to Scheme. Let's divide our palindrome program into a library module (" (tt "pal-proc.scm") ") and a client module (" (tt "pal-user.scm") ").") (p "Here's the external library. We " (tt "declare") " that " (tt "pal-proc") " is a `unit', which is the basis of separately-compiled modules in CHICKEN. (Units deal with separate compilation, but don't involve separated namespaces; namespaced module systems are available as eggs.)") (highlight scheme ";;; Library pal-proc.scm\n(declare (unit pal-proc))\n(define (palindrome? x)\n  (define (check left right)\n    (if (>= left right)\n        #t\n        (and (char=? (string-ref x left) (string-ref x right))\n             (check (add1 left) (sub1 right)))))\n  (check 0 (sub1 (string-length x))))") (p "Next we have some  client code that `uses' this separately-compiled module.") (highlight scheme ";;; Client pal-user.scm\n(declare (uses pal-proc))\n(let ((arg (car (command-line-arguments))))\n  (display \n   (string-append arg \n                  (if (palindrome? arg) \n                      \" is a palindrome\\n\"\n                      \" isn't a palindrome\\n\"))))") (p "Now we can compile and link everything together. (We show the compile and link operations separately, but they can of course be combined into one command.)") (pre "$ csc -c pal-proc.scm\n$ csc -c pal-user.scm\n$ csc -o pal-separate pal-proc.o pal-user.o\n$ ./pal-separate level\nlevel is a palindrome")) (section 3 "Installing an egg" (p "Installing eggs is quite straightforward on systems that support dynamic loading (again, that would include *BSD, Linux, Mac OS X, Solaris, and Windows).  The command " (tt "chicken-install") " will fetch an egg from the master CHICKEN repository, and install it on your local system.") (p "In this example, we install the " (tt "uri") " egg, for parsing Uniform Resource Identifiers. The installation produces a lot of output, which we have edited for space reasons.") (pre "$ chicken-install uri") (pre "The extension uri does not exist.\nDo you want to download it ? (yes/no/abort) [yes] yes\ndownloading uri.egg from (www.call-with-current-continuation.org eggs/3 80) \n  gzip -d -c ../uri.egg | tar xf -\n.  /Users/vmanis/local/bin/csc -feature compiling-extension \n     -s -O2 -d1 uri.scm -o uri.so -check-imports -emit-exports uri.exports\n... (lots of stuff elided)\n.  rm -fr /Users/vmanis/project/chicken/uri.egg") (p "First, " (tt "chicken-install") " asks us if we want to download the egg. It then uncompresses the egg, compiles the code, and installs the egg in the local CHICKEN repository.") (p "Now we can use our new egg.") (pre "#;1> (use uri)\n; loading /Users/vmanis/local/lib/chicken/3/uri.so ...\n; loading /Users/vmanis/local/lib/chicken/3/coerce-support.so ...\n; loading /Users/vmanis/local/lib/chicken/3/misc-extn-list-support.so ...\n; loading /Users/vmanis/local/lib/chicken/3/synch-support.so ...\n; loading /Users/vmanis/local/lib/chicken/3/lookup-table.so ...\n; loading /Users/vmanis/local/lib/chicken/3/misc-extn-control-support.so ...\n#;2> (uri-host (uri \"http://www.foobar.org/blah\"))\n\"www.foobar.org\"")) (section 3 "Accessing C libraries " (p "Because CHICKEN compiles to C, and because a foreign function interface is built into the compiler, interfacing to a C library is quite straightforward. This means that nearly any facility available on the host system is accessible from CHICKEN, with more or less work.") (p "Let's create a simple C library, to demonstrate how this works. Here we have a function that will compute and return the " (b "n") "th Fibonacci number. (This isn't a particularly good use of C here, because we could write this function just as easily in Scheme, but a real example would take far too much space here.)") (pre "/* fib.c */\nint fib(int n) {\n  int prev = 0, curr = 1;\n  int next; \n  int i; \n  for (i = 0; i < n; i++) {\n    next = prev + curr;\n    prev = curr;\n    curr = next; \n  }\n  return curr;\n} ") (p "Now we can call this function from CHICKEN.") (pre ";;; fib-user.scm\n#>\n  extern int fib(int n);\n<# \n(define xfib (foreign-lambda int \"fib\" int))\n(do ((i 0 (+ i 1))) ((> i 10))\n  (printf \"~A \" (xfib i)))\n(newline)") (p "The syntax " (tt "#>...<#") " allows you to include literal C (typically external declarations) in your CHICKEN code. We access " (tt "fib") " by defining a " (tt "foreign-lambda") " for it, in this case saying that the function takes one integer argument (the " (tt "int") " after the function name), and that it returns an integer result (the " (tt "int") " before.) Now we can invoke " (tt "xfib") " as though it were an ordinary Scheme function.") (pre "$ gcc -c fib.c\n$ csc -o fib-user fib.o fib-user.scm\n$ ./fib-user\n0 1 1 2 3 5 8 13 21 34 55 ") (p "Those who are interfacing to substantial C libraries should consider using the " (int-link "/egg/bind" "bind egg") ".") (hr) (p "Back to " (int-link "The User's Manual")) (p "Next: " (int-link "Basic mode of operation")))))