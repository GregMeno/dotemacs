((tags "manual") (toc) (section 2 "Non-standard macros and special forms" (section 3 "Making extra libraries and extensions available" (section 4 "require-library" (def (sig (syntax "(require-library ID ...)" (id require-library))) (p "This form does all the necessary steps to make the libraries or extensions given in " (tt "ID ...") " available. It loads syntactic extensions, if needed and generates code for loading/linking with core library modules or separately installed extensions.") (p "During interpretation/evaluation " (tt "require-library") " performs one of the following:") (ul (li "If " (tt "ID") " names a built-in feature " (tt "chicken srfi-0 srfi-2 srfi-6 srfi-8 srfi-9 srfi-10 srfi-17 srfi-23 srfi-30 srfi-39 srfi-55") ", then nothing is done.") (li "If " (tt "ID") " names one of the syntactic extensions " (tt "chicken-syntax chicken-ffi-syntax") ", then this extension will be loaded.") (li "If " (tt "ID") " names one of the core library units shipped with CHICKEN, then a " (tt "(load-library 'ID)") " will be performed.") (li "If " (tt "ID") " names an installed extension with the " (tt "syntax") " or " (tt "require-at-runtime") " attribute, then the extensions is loaded at compile-time, probably doing a run-time " (tt "(require ...)") " for any run-time requirements.") (li "Otherwise, " (tt "(require-library ID)") " is equivalent to " (tt "(require 'ID)") ".")) (p "During compilation, one of the following happens instead:") (ul (li "If " (tt "ID") " names a built-in feature " (tt "chicken srfi-0 srfi-2 srfi-6 srfi-8 srfi-9 srfi-10 srfi-17 srfi-23 srfi-30 srfi-39 srfi-55") ", then nothing is done.") (li "If " (tt "ID") " names one of the syntactic extensions " (tt "chicken-syntax chicken-ffi-syntax") ", then this extension will be loaded at compile-time, making the syntactic extensions available in compiled code.") (li "If " (tt "ID") " names one of the core library units shipped with CHICKEN, or if the option " (tt "-uses ID") " has been passed to the compiler, then a " (tt "(declare (uses ID))") " is generated.") (li "If " (tt "ID") " names an installed extension with the " (tt "syntax") " or " (tt "require-at-runtime") " attribute, then the extension is loaded at compile-time, and code is emitted to " (tt "(require ...)") " any needed run-time requirements.") (li "Otherwise " (tt "(require-library ID)") " is equivalent to " (tt "(require 'ID)") ".")) (p "To make long matters short - just use " (tt "require-library") " and it will normally figure everything out for dynamically loadable extensions and core library units.") (p (tt "ID") " should be a pure extension name and should not contain any path prefixes (for example " (tt "dir/lib...") ") is illegal).") (p (tt "ID") " may also be a list that designates an extension-specifier. Currently the following extension specifiers are defined:") (ul (li (tt "(srfi NUMBER ...)") " is required for SRFI-55 compatibility and is fully implemented") (li (tt "(version ID NUMBER)") " is equivalent to " (tt "ID") ", but checks at compile-time whether the extension named " (tt "ID") " is installed and whether its version is equal or higher than " (tt "NUMBER") ". " (tt "NUMBER") " may be a string or a number, the comparison is done lexicographically (using " (tt "string>=?") ").")) (p "See also: " (tt "set-extension-specifier!")))) (section 4 "require-extension" (def (sig (syntax "(require-extension ID ...)" (id require-extension))) (p "This is equivalent to " (tt "(require-library ID ...)") " but performs an implicit " (tt "import") ", if necessary. " (tt "ID") " may also be an import specification (using " (tt "rename") ", " (tt "only") ", " (tt "except") " or " (tt "prefix") ").") (p "This implementation of " (tt "require-extension") " is compliant with " (link "http://srfi.schemers.org/srfi-55/srfi-55.html" "SRFI-55") " (see the " (link "http://srfi.schemers.org/srfi-55/srfi-55.html" "SRFI-55") " document for more information)."))) (section 4 "use" (def (sig (syntax "(use ID ...)" (id use))) (p (tt "use") " is just a shorter alias for " (tt "require-extension") ".")))) (section 3 "Binding forms for optional arguments" (section 4 "optional" (def (sig (syntax "(optional ARGS DEFAULT)" (id optional))) (p "Use this form for procedures that take a single optional argument. If " (tt "ARGS") " is the empty list " (tt "DEFAULT") " is evaluated and returned, otherwise the first element of the list " (tt "ARGS") ". It is an error if " (tt "ARGS") " contains more than one value.") (highlight scheme "(define (incr x . i) (+ x (optional i 1)))\n(incr 10)                                   ==> 11\n(incr 12 5)                                 ==> 17"))) (section 4 "case-lambda" (def (sig (syntax "(case-lambda (LAMBDA-LIST1 EXP1 ...) ...)" (id case-lambda))) (p "Expands into a lambda that invokes the body following the first matching lambda-list.") (highlight scheme "(define plus\n  (case-lambda \n    (() 0)\n    ((x) x)\n    ((x y) (+ x y))\n    ((x y z) (+ (+ x y) z))\n    (args (apply + args))))\n\n(plus)                      ==> 0\n(plus 1)                    ==> 1\n(plus 1 2 3)                ==> 6") (p "For more information see the documentation for " (link "http://srfi.schemers.org/srfi-16/srfi-16.html" "SRFI-16")))) (section 4 "let-optionals" (def (sig (syntax " (let-optionals ARGS ((VAR1 DEFAULT1) ...) BODY ...)" (id let-optionals))) (p "Binding constructs for optional procedure arguments. " (tt "ARGS") " should be a rest-parameter taken from a lambda-list. " (tt "let-optionals") " binds " (tt "VAR1 ...") " to available arguments in parallel, or to " (tt "DEFAULT1 ...") " if not enough arguments were provided. " (tt "let-optionals*") " binds " (tt "VAR1 ...") " sequentially, so every variable sees the previous ones. it is an error if any excess arguments are provided.") (highlight scheme "(let-optionals '(one two) ((a 1) (b 2) (c 3))\n  (list a b c) )                               ==> (one two 3)"))) (section 4 "let-optionals*" (def (sig (syntax " (let-optionals* ARGS ((VAR1 DEFAULT1) ... [RESTVAR]) BODY ...)" (id let-optionals*))) (p "Binding constructs for optional procedure arguments. " (tt "ARGS") " should be a rest-parameter taken from a lambda-list. " (tt "let-optionals") " binds " (tt "VAR1 ...") " to available arguments in parallel, or to " (tt "DEFAULT1 ...") " if not enough arguments were provided. " (tt "let-optionals*") " binds " (tt "VAR1 ...") " sequentially, so every variable sees the previous ones. If a single variable " (tt "RESTVAR") " is given, then it is bound to any remaining arguments, otherwise it is an error if any excess arguments are provided.") (highlight scheme "(let-optionals* '(one two) ((a 1) (b 2) (c a))\n  (list a b c) )                               ==> (one two one)")))) (section 3 "Other binding forms" (section 4 "and-let*" (def (sig (syntax "(and-let* (BINDING ...) EXP1 EXP2 ...)" (id and-let*))) (p "SRFI-2. Bind sequentially and execute body. " (tt "BINDING") " can be a list of a variable and an expression, a list with a single expression, or a single variable. If the value of an expression bound to a variable is " (tt "#f") ", the " (tt "and-let*") " form evaluates to " (tt "#f") " (and the subsequent bindings and the body are not executed).  Otherwise the next binding is performed. If all bindings/expressions evaluate to a true result, the body is executed normally and the result of the last expression is the result of the " (tt "and-let*") " form. See also the documentation for " (link "http://srfi.schemers.org/srfi-2/srfi-2.html" "SRFI-2") "."))) (section 4 "rec" (def (sig (syntax "(rec NAME EXPRESSION)" (id rec)) (syntax "(rec (NAME VARIABLE ...) BODY ...)" (id rec))) (p "Allows simple definition of recursive definitions. " (tt "(rec NAME EXPRESSION)") " is equivalent to " (tt "(letrec ((NAME EXPRESSION)) NAME)") " and " (tt "(rec (NAME VARIABLE ...) BODY ...)") " is the same as " (tt "(letrec ((NAME (lambda (VARIABLE ...) BODY ...))) NAME)") "."))) (section 4 "cut" (def (sig (syntax "(cut SLOT ...)" (id cut)) (syntax "(cute SLOT ...)" (id cute))) (p (link "http://srfi.schemers.org/srfi-26/srfi-26.html" "Syntactic sugar for specializing parameters") "."))) (section 4 "define-values" (def (sig (syntax "(define-values (NAME ...) EXP)" (id define-values))) (p "Defines several variables at once, with the result values of expression " (tt "EXP") "."))) (section 4 "fluid-let" (def (sig (syntax "(fluid-let ((VAR1 X1) ...) BODY ...)" (id fluid-let))) (p "Binds the variables " (tt "VAR1 ...") " dynamically to the values " (tt "X1 ...") " during execution of " (tt "BODY ...") ". This implements " (link "http://srfi.schemers.org/srfi-15/srfi-15.html" "SRFI-15") "."))) (section 4 "let-values" (def (sig (syntax "(let-values (((NAME ...) EXP) ...) BODY ...)" (id let-values))) (p "Binds multiple variables to the result values of " (tt "EXP ...") ". All variables are bound simultaneously. This implements " (link "http://srfi.schemers.org/srfi-11/srfi-11.html" "SRFI-11") "."))) (section 4 "let*-values" (def (sig (syntax "(let*-values (((NAME ...) EXP) ...) BODY ...)" (id let*-values))) (p "Binds multiple variables to the result values of " (tt "EXP ...") ". The variables are bound sequentially. This is also part of " (link "http://srfi.schemers.org/srfi-11/srfi-11.html" "SRFI-11") ".") (highlight scheme "(let*-values (((a b) (values 2 3))\n              ((p) (+ a b)) )\n  p)                               ==> 5"))) (section 4 "letrec-values" (def (sig (syntax "(letrec-values (((NAME ...) EXP) ...) BODY ...)" (id letrec-values))) (p "Binds the result values of " (tt "EXP ...") " to multiple variables at once. All variables are mutually recursive.") (highlight scheme "(letrec-values (((odd even)\n                   (values \n                     (lambda (n) (if (zero? n) #f (even (sub1 n))))\n                     (lambda (n) (if (zero? n) #t (odd (sub1 n)))) ) ) )\n  (odd 17) )                           ==> #t"))) (section 4 "parameterize" (def (sig (syntax "(parameterize ((PARAMETER1 X1) ...) BODY ...)" (id parameterize))) (p "Binds the parameters " (tt "PARAMETER1 ...") " dynamically to the values " (tt "X1 ...") " during execution of " (tt "BODY ...") ".  (see also: " (tt "make-parameter") " in " (int-link "Parameters") "). Note that " (tt "PARAMETER") " may be any expression that evaluates to a parameter procedure."))) (section 4 "receive" (def (sig (syntax "(receive (NAME ...) VALUEEXP BODY ...)" (id receive)) (syntax "(receive (NAME1 ... NAMEn . NAMEn+1) VALUEEXP BODY ...)" (id receive)) (syntax "(receive VALUEEXP)" (id receive))) (p (link "http://srfi.schemers.org/srfi-8/srfi-8.html" "SRFI-8") ". Syntactic sugar for " (tt "call-with-values") ". Binds variables to the result values of " (tt "VALUEEXP") " and evaluates " (tt "BODY ...") ".") (p (tt "(receive VALUEEXP)") " is equivalent to " (tt "(receive _ VALUEEXP _)") "."))) (section 4 "set!-values" (def (sig (syntax "(set!-values (NAME ...) EXP)" (id set!-values))) (p "Assigns the result values of expression " (tt "EXP") " to multiple variables.")))) (section 3 "Substitution forms and macros" (section 4 "define-constant" (def (sig (syntax "(define-constant NAME CONST)" (id define-constant))) (p "Define a variable with a constant value, evaluated at compile-time. Any reference to such a constant should appear textually " (b "after") " its definition. This construct is equivalent to " (tt "define") " when evaluated or interpreted. Constant definitions should only appear at toplevel. Note that constants are local to the current compilation unit and are not available outside of the source file in which they are defined. Names of constants still exist in the Scheme namespace and can be lexically shadowed.  If the value is mutable, then the compiler is careful to preserve its identity. " (tt "CONST") " may be any constant expression, and may also refer to constants defined via " (tt "define-constant") " previously. This form should only be used at top-level."))) (section 4 "define-inline" (def (sig (syntax "(define-inline (NAME VAR ...) BODY ...)" (id define-inline)) (syntax "(define-inline (NAME VAR1 ... VARn . VARn+1) BODY ...)" (id define-inline)) (syntax "(define-inline NAME EXP)" (id define-inline))) (p "Defines an inline procedure. Any occurrence of " (tt "NAME") " will be replaced by " (tt "EXP") " or " (tt "(lambda (VAR ... [. VAR]) BODY ...)") ". This is similar to a macro, but variable-names and -scope will be correctly handled.  Inline substitutions take place " (b "after") " macro-expansion.  " (tt "EXP") " should be a lambda-expression. Any reference to " (tt "NAME") " should appear textually " (b "after") " its definition. Note that inline procedures are local to the current compilation unit and are not available outside of the source file in which they are defined. Names of inline procedures still exist in the Scheme namespace and can be lexically shadowed.  This construct is equivalent to " (tt "define") " when evaluated or interpreted. Inline definitions should only appear at toplevel."))) (section 4 "define-for-syntax" (def (sig (syntax "(define-for-syntax (NAME VAR ...) EXP1 ...)" (id define-for-syntax)) (syntax "(define-for-syntax (NAME VAR1 ... VARn . VARn+1) EXP1 ...)" (id define-for-syntax)) (syntax "(define-for-syntax NAME [VALUE])" (id define-for-syntax))) (p "Defines the toplevel variable " (tt "NAME") " at macro-expansion time. This can be helpful when you want to define support procedures for use in macro-transformers, for example."))) (section 4 "define-compiler-syntax" (def (sig (syntax "(define-compiler-syntax NAME)" (id define-compiler-syntax)) (syntax "(define-compiler-syntax NAME TRANSFORMER)" (id define-compiler-syntax)) (syntax "(define-compiler-syntax (NAME VAR ...) BODY ...)" (id define-compiler-syntax))) (p "Defines what is usually called a " (i "compiler macro") " in Lisp: " (tt "NAME") " should be the name of a globally or locally bound procedure. Any direct call to this procedure will be transformed before compilation, which allows arbitrary rewritings of function calls.") (p (tt "TRANSFORMER") " can be a " (tt "syntax-rules") " expression or an explicit-renaming transformer procedure. Returning the original form in an explicit-renaming macro or simply \"falling trough\" all patterns in a " (tt "syntax-rules") " form will keep the original expression and compile it normally.") (p "In the interpreter this form does nothing and returns an unspecified value.") (p "Compiler-syntax is always local to the current compilation unit and can not be exported. Compiler-syntax defined inside a module is not visible outside of that module.") (p (tt "define-compiler-syntax") " should only be used at top-level. Local compiler-syntax can be defined with " (tt "let-compiler-syntax") ".") (highlight scheme "(define-compiler-syntax +\n  (syntax-rules ()\n    ((_) 1)\n    ((_ x 0) x) ) )") (p "If no transformer is given, then " (tt "(define-compiler-syntax NAME)") " removes any compiler-syntax definitions for " (tt "NAME") "."))) (section 4 "let-compiler-syntax" (def (sig (syntax "(let-compiler-syntax ((NAME [TRANSFORMER]) ...) BODY ...)" (id let-compiler-syntax))) (p "Allows definition local compiler macros, which are only applicable inside " (tt "BODY ...") ". By not providing a " (tt "TRANSFORMER") " expression, compiler-syntax for specific identifiers can be temporarily disabled.")))) (section 3 "Conditional forms" (section 4 "select" (def (sig (syntax "(select EXP ((KEY ...) EXP1 ...) ... [(else EXPn ...)])" (id select))) (p "This is similar to " (tt "case") ", but the keys are evaluated."))) (section 4 "unless" (def (sig (syntax "(unless TEST EXP1 EXP2 ...)" (id unless))) (p "Equivalent to:") (highlight scheme "(if (not TEST) (begin EXP1 EXP2 ...))"))) (section 4 "when" (def (sig (syntax "(when TEST EXP1 EXP2 ...)" (id when))) (p "Equivalent to:") (highlight scheme "(if TEST (begin EXP1 EXP2 ...))")))) (section 3 "Record structures" (section 4 "define-record" (def (sig (syntax "(define-record NAME SLOTNAME ...)" (id define-record))) (p "Defines a record type. Call " (tt "make-NAME") " to create an instance of the structure (with one initialization-argument for each slot). " (tt "(NAME? STRUCT)") " tests any object for being an instance of this structure.  Slots are accessed via " (tt "(NAME-SLOTNAME STRUCT)") " and updated using " (tt "(NAME-SLOTNAME-set!") " " (tt "STRUCT") " " (tt "VALUE)") ".") (highlight scheme "(define-record point x y)\n(define p1 (make-point 123 456))\n(point? p1)                      ==> #t\n(point-x p1)                     ==> 123\n(point-y-set! p1 99)\n(point-y p1)                     ==> 99"))) (section 4 "define-record-type" (def (sig (syntax "(define-record-type NAME (CONSTRUCTOR TAG ...) PREDICATE (FIELD ACCESSOR [MODIFIER]) ...)" (id define-record-type))) (p "SRFI-9 record types. For more information see the documentation for " (link "http://srfi.schemers.org/srfi-9/srfi-9.html" "SRFI-9") ".") (p "As an extension the " (tt "MODIFIER") " may have the form " (tt "(setter PROCEDURE)") ", which will define a SRFI-17 setter-procedure for the given " (tt "PROCEDURE") " that sets the field value. Usually " (tt "PROCEDURE") " has the same name is " (tt "ACCESSOR") " (but it doesn't have to)."))) (section 4 "define-record-printer" (def (sig (syntax "(define-record-printer (NAME RECORDVAR PORTVAR) BODY ...)" (id define-record-printer)) (syntax "(define-record-printer NAME PROCEDURE)" (id define-record-printer))) (p "Defines a printing method for record of the type " (tt "NAME") " by associating a procedure with the record type. When a record of this type is written using " (tt "display, write") " or " (tt "print") ", then the procedure is called with two arguments: the record to be printed and an output-port.") (highlight scheme "(define-record-type foo (make-foo x y z) foo?\n  (x foo-x)\n  (y foo-y)\n  (z foo-z))\n(define f (make-foo 1 2 3))\n(define-record-printer (foo x out)\n  (fprintf out \"#,(foo ~S ~S ~S)\"\n           (foo-x x) (foo-y x) (foo-z x)) )\n(define-reader-ctor 'foo make-foo)\n(define s (with-output-to-string\n              (lambda () (write f))))\ns                                   ==> \"#,(foo 1 2 3)\"\n(equal? f (with-input-from-string\n              s read)))             ==> #t")))) (section 3 "Other forms" (section 4 "assert" (def (sig (syntax "(assert EXP [STRING ARG ...])" (id assert))) (p "Signals an error if " (tt "EXP") " evaluates to false. An optional message " (tt "STRING") " and arguments " (tt "ARG ...") " may be supplied to give a more informative error-message.  If compiled in " (i "unsafe") " mode (either by specifying the " (tt "-unsafe") " compiler option or by declaring " (tt "(unsafe)") "), then this expression expands to an unspecified value. The result is the value of " (tt "EXP") "."))) (section 4 "begin-for-syntax" (def (sig (syntax "(begin-for-syntax EXP ...)" (id begin-for-syntax))) (p "Equivalent to " (tt "(begin EXP ...)") ", but performs the evaluation of the expression during macro-expansion time."))) (section 4 "cond-expand" (def (sig (syntax "(cond-expand FEATURE-CLAUSE ...)" (id cond-expand))) (p "Expands by selecting feature clauses. This form is allowed to appear in non-toplevel expressions.") (p "Predefined feature-identifiers are \"situation\" specific:") (dl (dt "compile") (dd (tt "chicken") ", " (tt "compiling") ", " (tt "library") ", " (tt "eval") ", " (tt "extras") ", " (tt "utils") ", " (tt "regex") ", " (tt "srfi-0") ", " (tt "srfi-1") ", " (tt "srfi-2") ", " (tt "srfi-4") ", " (tt "srfi-6") ", " (tt "srfi-8") ", " (tt "srfi-9") ", " (tt "srfi-10") ", " (tt "srfi-11") ", " (tt "srfi-12") ", " (tt "srfi-15") ", " (tt "srfi-16") ", " (tt "srfi-17") ", " (tt "srfi-23") ", " (tt "srfi-26") ", " (tt "srfi-28") ", " (tt "srfi-30") ", " (tt "srfi-31") ", " (tt "srfi-39") ", " (tt "srfi-55") ", " (tt "srfi-61") ", " (tt "srfi-62") ", " (tt "srfi-69")) (dt "load") (dd (tt "chicken") ", " (tt "extras") ", " (tt "srfi-0") ", " (tt "srfi-2") ", " (tt "srfi-6") ", " (tt "srfi-8") ", " (tt "srfi-9") ", " (tt "srfi-10") ", " (tt "srfi-12") ", " (tt "srfi-17") ", " (tt "srfi-23") ", " (tt "srfi-28") ", " (tt "srfi-30") ", " (tt "srfi-39") ", " (tt "srfi-55") ", " (tt "srfi-61") ", " (tt "srfi-62") ", " (tt "srfi-69") ". " (tt "library") " is implicit.") (dt "eval") (dd (tt "csi") ", " (tt "chicken") ", " (tt "extras") ", " (tt "srfi-0") ", " (tt "srfi-2") ", " (tt "srfi-6") ", " (tt "srfi-8") ", " (tt "srfi-9") ", " (tt "srfi-10") ", " (tt "srfi-11") ", " (tt "srfi-12") ", " (tt "srfi-15") ", " (tt "srfi-16") ", " (tt "srfi-17") ", " (tt "srfi-23") ", " (tt "srfi-26") ", " (tt "srfi-28") ", " (tt "srfi-30") ", " (tt "srfi-31") ", " (tt "srfi-39") ", " (tt "srfi-55") ", " (tt "srfi-61") ", " (tt "srfi-62") ", " (tt "srfi-69") ". " (tt "library") " is implicit.")) (p "The following feature-identifier classes are available in all situations: " (tt "(machine-byte-order)") ", " (tt "(machine-type)") ", " (tt "(software-type)") ", " (tt "(software-version)") ", where the actual feature-identifier is platform dependent.") (p "In addition the following feature-identifiers may exist: " (tt "cross-chicken") ", " (tt "dload") ", " (tt "manyargs") ", " (tt "ptables") ".") (p "For further information, see the documentation for " (link "http://srfi.schemers.org/srfi-0/srfi-0.html" "SRFI-0") "."))) (section 4 "ensure" (def (sig (syntax "(ensure PREDICATE EXP [ARGUMENTS ...])" (id ensure))) (p "Evaluates the expression " (tt "EXP") " and applies the one-argument procedure " (tt "PREDICATE") " to the result. If the predicate returns " (tt "#f") " an error is signaled, otherwise the result of " (tt "EXP") " is returned.  If compiled in " (i "unsafe") " mode (either by specifying the " (tt "-unsafe") " compiler option or by declaring " (tt "(unsafe)") "), then this expression expands to an unspecified value.  If specified, the optional " (tt "ARGUMENTS") " are used as arguments to the invocation of the error-signalling code, as in " (tt "(error ARGUMENTS ...)") ". If no " (tt "ARGUMENTS") " are given, a generic error message is displayed with the offending value and " (tt "PREDICATE") " expression."))) (section 4 "eval-when" (def (sig (syntax "(eval-when (SITUATION ...) EXP ...)" (id eval-when))) (p "Controls evaluation/compilation of subforms. " (tt "SITUATION") " should be one of the symbols " (tt "eval") ", " (tt "compile") " or " (tt "load") ". When encountered in the evaluator, and the situation specifier " (tt "eval") " is not given, then this form is not evaluated and an unspecified value is returned.  When encountered while compiling code, and the situation specifier " (tt "compile") " is given, then this form is evaluated at compile-time.  When encountered while compiling code, and the situation specifier " (tt "load") " is not given, then this form is ignored and an expression resulting into an unspecified value is compiled instead.") (p "The following table should make this clearer:") (table (tr (th) (th "In compiled code") (th "In interpreted code")) "\n" (tr (td (tt "eval")) (td "ignore") (td "evaluate")) "\n" (tr (td (tt "compile")) (td "evaluate at compile time") (td "ignore")) "\n" (tr (td (tt "load")) (td "compile as normal") (td "ignore"))))) (section 4 "include" (def (sig (syntax "(include STRING)" (id include))) (p "Include toplevel-expressions from the given source file in the currently compiled/interpreted program.  If the included file has the extension " (tt ".scm") ", then it may be omitted.  The file is searched in the current directory and, if not found, in all directories specified in the " (tt "-include-path") " option."))) (section 4 "nth-value" (def (sig (syntax "(nth-value N EXP)" (id nth-value))) (p "Returns the " (tt "N") "th value (counting from zero) of the values returned by expression " (tt "EXP") "."))) (section 4 "time" (def (sig (syntax "(time EXP1 ...)" (id time))) (p "Performs a major garbage collection, evaluates " (tt "EXP1 ...") " and prints elapsed CPU time and some values about GC use, like time spent in major GCs, number of minor and major GCs. The output is sent to the port that is the current value of " (tt "(current-error-port)") ". Nested invocations of this form will give incorrect results for all output but the innermost.")) (hr) (p "Previous: " (int-link "Non-standard read syntax")) (p "Next: " (int-link "Macros"))))))