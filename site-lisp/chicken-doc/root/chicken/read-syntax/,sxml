((tags "manual") (toc) (section 2 "Non-standard read syntax" (section 3 "Escapes in symbols" (p (tt "| ... |") " may be used to escape a sequence of characters when reading a symbol. " (tt "\\X") " escapes a single character in a symbols name:") (pre " (symbol->string '|abc def|)       =>   \"abc def\"\n (symbol->string '|abc||def|)      =>   \"abcdef\"\n (symbol->string '|abc|xyz|def|)   =>   \"abcxyzdef\"\n (symbol->string '|abc\\|def|)      =>   \"abc|def\"\n (symbol->string 'abc\\ def)        =>   \"abc def\"")) (section 3 "Multiline Block Comment" (pre "#| ... |# ") (p "A multiline " (i "block") " comment. May be nested. Implements " (link "http://srfi.schemers.org/srfi-30/srfi-30.html" "SRFI-30") ".")) (section 3 "Expression Comment" (pre "#;EXPRESSION") (p "Treats " (tt "EXPRESSION") " as a comment.  That is, the comment runs through the whole S-expression, regardless of newlines, which saves you from having to comment out every line, or add a newline in the middle of your parens to make the commenting of the last line work, or other things like that. Implements " (link "http://srfi.schemers.org/srfi-62/srfi-62.html" "SRFI-62") ".")) (section 3 "External Representation" (pre "#,(CONSTRUCTORNAME DATUM ...)") (p "Allows user-defined extension of external representations. (For more information see the documentation for " (link "http://srfi.schemers.org/srfi-10/srfi-10.html" "SRFI-10") ")")) (section 3 "Location Expression" (pre "#$EXPRESSION") (p "An abbreviation for " (tt "(location EXPRESSION)") ".")) (section 3 "Keyword" (pre "#:SYMBOL\nSYMBOL:\n:SYMBOL") (p "Syntax for keywords. Keywords are symbols that evaluate to themselves, and as such don't have to be quoted.  Either " (tt "SYMBOL:") " or " (tt ":SYMBOL") " is accepted, depending on the setting of the " (tt "keyword-style") " parameter, but never both.  " (tt "#:SYMBOL") " is always accepted.")) (section 3 "Multiline String Constant" (pre "#<<TAG") (p "Specifies a multiline string constant. Anything up to a line equal to " (tt "TAG") " (or end of file) will be returned as a single string:") (pre "(define msg #<<END\n \"Hello, world!\", she said.\nEND\n)") (p "is equivalent to") (pre "(define msg \"\\\"Hello, world!\\\", she said.\")")) (section 3 "Multiline String Constant with Embedded Expressions" (pre "#<#TAG") (p "Similar to " (tt "#<<") ", but allows substitution of embedded Scheme expressions prefixed with " (tt "#") " and optionally enclosed in curly brackets. Two consecutive " (tt "#") "s are translated to a single " (tt "#") ":") (pre "(define three 3)\n(display #<#EOF\nThis is a simple string with an embedded `##' character\nand substituted expressions: (+ three 99) ==> #(+ three 99)\n(three is \"#{three}\")\nEOF\n)") (p "prints") (pre "This is a simple string with an embedded `#' character\nand substituted expressions: (+ three 99) ==> 102\n(three is \"3\")")) (section 3 "Foreign Declare" (pre "#> ... <#") (p "Abbreviation for " (tt "foreign-declare \" ... \")") ".")) (section 3 "Sharp Prefixed Symbol" (pre "#%... ") (p "Reads like a normal symbol.")) (section 3 "Bang" (pre "#!... ") (p "Interpretation depends on the directly following characters. Only the following are recognized. Any other case results in a read error.") (section 4 "Line Comment" (ul (li "If followed by whitespace or a slash, then everything up the end of the current line is ignored"))) (section 4 "Eof Object" (ul (li "If followed by the character sequence " (tt "eof") ", then the (self-evaluating) end-of-file object is returned"))) (section 4 "DSSSL Formal Parameter List Annotation" (ul (li "If followed by any of the character sequences " (tt "optional") ", " (tt "rest") " or " (tt "key") ", then a symbol with the same name (and prefixed with " (tt "#!") ") is returned"))) (section 4 "Read Mark Invocation" (ul (li "If a " (i "read mark") " with the same name as the token is registered, then its procedure is called and the result of the read-mark procedure will be returned")))) (section 3 "Case Sensitive Expression" (pre "#cs...") (p "Read the next expression in case-sensitive mode (regardless of the current global setting).")) (section 3 "Case Insensitive Expression" (pre "#ci...") (p "Read the next expression in case-insensitive mode (regardless of the current global setting).")) (section 3 "Conditional Expansion" (pre "#+FEATURE EXPR") (p "Equivalent to") (pre "(cond-expand (FEATURE EXPR) (else))") (hr) (p "Previous: " (int-link "Extensions to the standard")) (p "Next: " (int-link "Non-standard macros and special forms")))))