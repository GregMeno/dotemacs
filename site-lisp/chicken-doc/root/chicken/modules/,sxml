((tags "manual") (toc) (section 3 "Modules" (p "To allow some control over visible bindings and to organize code at the global level, a simple module system is available. A " (i "module") " defines a set of toplevel expressions that are initially evaluated in an empty syntactical environment. By " (i "importing") " other modules, exported value- and macro-bindings are made visible inside the environment of the module that imports them.") (p "Note that modules are purely syntactical - they do not change the control flow or delay the execution of the contained toplevel forms. The body of a module is executed at load-time, when code is loaded or accessed via the " (tt "uses") " declaration, just like normal toplevel expressions. Exported macro-definitions are compiled as well, and can be accessed in interpreted or compiled code by loading and importing the compiled file that contains the module.") (p "Imported toplevel bindings can be assigned (with " (tt "set!") "), any modifications to these will change the global value and will be visible to other modules that export or import the same toplevel binding.") (p "A module is initially empty (has no visible bindings). You must at least import the " (tt "scheme") " module to do anything useful. To access any of the non-standard macros and procedures, import the " (tt "chicken") " module.") (p "CHICKEN's module system has the following features and shortcomings:") (ul (li "Indirect exports for syntax definitions must be listed") (li "Separation of compile/expansion-time and run-time code is provided, which allows cross compilation") (li "Module-generating code is only created, when needed") (li "Supports batch-compilation of separate compilation units") (li "No separate \"identifier\" type is used, all identifiers appearing in code and processed in expansions are symbols") (li "The module system is fully optional")) (section 4 "module" (def (sig (syntax "(module NAME (EXPORT ...) BODY ...)" (id module)) (syntax "(module NAME (EXPORT ...) FILENAME)" (id module)) (syntax "(module NAME * BODY ...)" (id module))) (p "Defines a module with the name " (tt "NAME") ", a set of exported bindings and a contained sequence of toplevel expressions that are evaluated in an empty syntactical environment. " (tt "EXPORT") " may be a symbol or a list of the form " (tt "(IDENTIFIER1 IDENTIFIER2 ...)") ". In the former case the identifier given is exported from the module and can be imported at the toplevel or in other modules. The latter case exports " (tt "IDENTIFIER1") " (which should name a macro) and also arranges for the remaining identifiers in the list to be visible in the expansion of the macro (this is a hint to the module expander to export bindings referenced by syntax-definitions which make use of them, but which would normally be internal to the module - which gives more opportunities for optimization).") (p "When the " (tt "BODY") " consists of a single string, it is handled as " (tt "(include FILENAME)") ".") (p "Nested modules, modules not at toplevel (i.e. local modules) or mutually recursive modules are not supported.") (p "When compiled, the module information, including exported macros is stored in the generated binary and available when loading it into interpreted or compiled code. Note that this is different to normal macros (outside of module declarations), which are normally not exported from compiled code.") (p "As a special case, specifying " (tt "*") " instead of an export-list will export all definitions.") (p "Note that the module system is only a device for controlling the mapping of identifiers to value or syntax bindings. Modules do not instantiate separate environments that contain their own bindings, as do many other module systems. Redefinition or assignment of value or syntax bindings will modify the original, imported definition.") (p "Syntax expansions may result in module-definitions, but must be at toplevel."))) (section 4 "export" (def (sig (syntax "(export EXPORT ...)" (id export))) (p "Allows augmenting module-exports from inside the module-body. " (tt "EXPORT") " is if the same form as an export-specifier in a " (tt "module") " export list. An export must precede its first occurrence (either use or definition).") (p "If used outside of a module, then this form does nothing."))) (section 4 "import" (def (sig (syntax "(import IMPORT ...)" (id import))) (p "Imports module bindings into the current syntactical environment. The visibility of any imported bindings is limited to the current module, if used inside a module-definition, or to the current compilation unit, if compiled and used outside of a module.") (p "Importing a module does not load or link it - this is a separate operation from importing its bindings.") (p (tt "IMPORT") " may be a module name or an " (i "import specifier") ", where a module name is either a symbol or a list of the form " (tt "(srfi N)") ". An " (tt "IMPORT") " defines a set of bindings that are to be made visible in the current scope.") (p "Note that the imported bindings are only visible in the next toplevel expression (regardless of whether the import appears inside or outside a module):") (pre " (begin\n   (import m1)\n   ...)              ; imports not visible here\n \n ...                ; imports visible here")) (section 5 "only" (pre "[import specifier] (only IMPORT IDENTIFIER ...)") (p "Only import the listed value- or syntax bindings from the set given by " (tt "IMPORT") ".")) (section 5 "except" (pre "[import specifier] (except IMPORT IDENTIFIER ...)") (p "Remove the listed identifiers from the import-set defined by " (tt "IMPORT") ".")) (section 5 "rename" (pre "[import specifier] (rename IMPORT (OLD1 NEW1) ...)") (p "Renames identifiers imported from " (tt "IMPORT") ".")) (section 5 "prefix" (pre "[import specifier] (prefix IMPORT SYMBOL)") (p "Prefixes all imported identifiers with " (tt "SYMBOL") "."))) (section 4 "import-for-syntax" (def (sig (syntax "(import-for-syntax IMPORT ...)" (id import-for-syntax))) (p "Similar to " (tt "import") ", but imports exported bindings of a module into the environment in which macro transformers are evaluated.") (p "Note: currently this isn't fully correct - value bindings are still imported into the normal environment because a separate import environment for syntax has not been implemented (syntactic bindings are kept separate correctly)."))) (section 4 "reexport" (def (sig (syntax "(reexport IMPORT ...)" (id reexport))) (p "Imports " (tt "IMPORT ...") " and automatically exports all imported identifiers. This can be used to build " (i "compound modules") ": modules that just extend other modules:") (highlight scheme "(module r4rs ()\n  (import scheme chicken)\n  (reexport \n    (except scheme \n      dynamic-wind values call-with-values eval scheme-report-environment\n      null-environment interaction-environment)))")))) (section 3 "import libraries" (p (i "import libraries") " allow the syntactical (compile-time) and run-time parts of a compiled module to be separated into a normal compiled file and a shared library that only contains macro definitions and module information. This reduces the size of executables and simplifies compiling code that uses modules for a different architecture than the machine the compiler is executing on (i.e. \"cross\" compilation).") (p "By using the " (tt "emit-import-library") " compiler-option or declaration, a separate file is generated that only contains syntactical information (including macros) for a module. " (tt "import") " will automatically find and load an import library for a currently unknown module, if the import- library is either in the extension repository or the current include path. Import libraries may also be explicitly loaded into the compiler by using the " (tt "-extend") " compiler option. Interpreted code can simply load the import library to make the module-definition available. Macro-support definitions defined with " (tt "define-for-syntax") " and expansion-time expressions of the form " (tt "(begin-for-syntax ...)") " will be added to import libraries to make them available for exported macros. Note that these definitions will ruthlessly pollute the toplevel namespace and so they should be used sparingly.")) (section 3 "Predefined modules" (p "Import libraries for the following modules are initially available:") (pre "[module] scheme") (p "Exports the standard R5RS bindings.") (pre "[module] chicken") (p "Everything from the " (tt "library") ", " (tt "eval") " and " (tt "expand") " library units.") (pre "[module] extras\n[module] data-structures\n[module] ports\n[module] lolevel\n[module] posix\n[module] regex\n[module] srfi-1\n[module] srfi-4\n[module] srfi-13\n[module] srfi-14\n[module] srfi-18\n[module] srfi-69\n[module] tcp\n[module] utils") (p "Modules exporting the bindings from the respective library units.") (pre "[module] foreign") (p "Exports all macros and procedures that are used to access foreign C/C++ code.")) (section 3 "Examples of using modules" (p "Here is a silly little test module to demonstrate how modules are defined and used:") (pre ";; hello.scm\n\n(module test (hello greet)\n  (import scheme)\n\n  (define-syntax greet\n    (syntax-rules ()\n      ((_ whom) \n       (begin\n         (display \"Hello, \")\n         (display whom)\n         (display \" !\\n\") ) ) ) )\n\n  (define (hello)\n    (greet \"world\") )  )") (p "The module " (tt "test") " exports one value (" (tt "hello") ") and one syntax binding (" (tt "greet") "). To use it in " (tt "csi") ", the interpreter, simply load and import it:") (pre " #;1> ,l hello.scm\n ; loading hello.scm ...\n ; loading /usr/local/lib/chicken/4/scheme.import.so ...\n #;1> (import test)\n #;2> (hello)\n Hello, world !\n #;3> (greet \"you\")\n Hello, you !") (p "The module can easily be compiled") (pre " % csc -s hello.scm") (p "and used in an identical manner:") (pre " #;1> ,l hello.so\n ; loading hello.so ...\n #;1> (import test)\n #;2> (hello)\n Hello, world !\n #;3> (greet \"you\")\n Hello, you !") (p "If you want to keep macro-definitions in a separate file, use import libraries:") (pre " % csc -s hello.scm -j test\n % csc -s test.import.scm") (pre " #;1> ,l hello.so\n ; loading hello.so ...\n #;1> (import test)\n ; loading ./test.import.so ...\n #;2> (hello)\n Hello, world !\n #;3> (greet \"you\")\n Hello, you !") (p "If an import library (compiled or in source-form) is located somewhere in the extensions-repository or include path, it is automatically loaded on import. Otherwise you have to load it manually:") (pre " #;1> ,l hello.so\n ; loading hello.so ...\n #;1> ,l test.import.so\n ; loading test.import.so ...\n #;1> (import test)\n #;2> ") (p "Note that you must us import libraries if you compile code that depends on other modules. The compiler will not execute the modules that are refered to by compiled code, and thus the binding information and exported syntax of the former must be available separately.")) (section 3 "Caveats" (p "The macro- and module system has been implemented relatively recently and is likely to contain bugs. Please contact the maintainers if you encounter behavior that you think is not correct or that triggers an error where there shouldn't be one.") (ul (li "In evaluated code, loading a file containing module information and importing from a module contained in that file will not work when the loading and import is performed in the same toplevel expression (this does not apply, when import libraries are used) ") (li "Currently value bindings imported by " (tt "import") " and " (tt "import-for-syntax") " share the same import-environment.")) (hr) (p "Previous: " (int-link "Macros")) (p "Next: " (int-link "Declarations"))))