(index ("module" 0) ("module" 0) ("module" 0) ("export" 2036) ("import" 2392) ("import-for-syntax" 3358) ("reexport" 3812))
(def (sig (syntax "(module NAME (EXPORT ...) BODY ...)" (id module)) (syntax "(module NAME (EXPORT ...) FILENAME)" (id module)) (syntax "(module NAME * BODY ...)" (id module))) (p "Defines a module with the name " (tt "NAME") ", a set of exported bindings and a contained sequence of toplevel expressions that are evaluated in an empty syntactical environment. " (tt "EXPORT") " may be a symbol or a list of the form " (tt "(IDENTIFIER1 IDENTIFIER2 ...)") ". In the former case the identifier given is exported from the module and can be imported at the toplevel or in other modules. The latter case exports " (tt "IDENTIFIER1") " (which should name a macro) and also arranges for the remaining identifiers in the list to be visible in the expansion of the macro (this is a hint to the module expander to export bindings referenced by syntax-definitions which make use of them, but which would normally be internal to the module - which gives more opportunities for optimization).") (p "When the " (tt "BODY") " consists of a single string, it is handled as " (tt "(include FILENAME)") ".") (p "Nested modules, modules not at toplevel (i.e. local modules) or mutually recursive modules are not supported.") (p "When compiled, the module information, including exported macros is stored in the generated binary and available when loading it into interpreted or compiled code. Note that this is different to normal macros (outside of module declarations), which are normally not exported from compiled code.") (p "As a special case, specifying " (tt "*") " instead of an export-list will export all definitions.") (p "Note that the module system is only a device for controlling the mapping of identifiers to value or syntax bindings. Modules do not instantiate separate environments that contain their own bindings, as do many other module systems. Redefinition or assignment of value or syntax bindings will modify the original, imported definition.") (p "Syntax expansions may result in module-definitions, but must be at toplevel."))
(def (sig (syntax "(export EXPORT ...)" (id export))) (p "Allows augmenting module-exports from inside the module-body. " (tt "EXPORT") " is if the same form as an export-specifier in a " (tt "module") " export list. An export must precede its first occurrence (either use or definition).") (p "If used outside of a module, then this form does nothing."))
(def (sig (syntax "(import IMPORT ...)" (id import))) (p "Imports module bindings into the current syntactical environment. The visibility of any imported bindings is limited to the current module, if used inside a module-definition, or to the current compilation unit, if compiled and used outside of a module.") (p "Importing a module does not load or link it - this is a separate operation from importing its bindings.") (p (tt "IMPORT") " may be a module name or an " (i "import specifier") ", where a module name is either a symbol or a list of the form " (tt "(srfi N)") ". An " (tt "IMPORT") " defines a set of bindings that are to be made visible in the current scope.") (p "Note that the imported bindings are only visible in the next toplevel expression (regardless of whether the import appears inside or outside a module):") (pre " (begin\n   (import m1)\n   ...)              ; imports not visible here\n \n ...                ; imports visible here"))
(def (sig (syntax "(import-for-syntax IMPORT ...)" (id import-for-syntax))) (p "Similar to " (tt "import") ", but imports exported bindings of a module into the environment in which macro transformers are evaluated.") (p "Note: currently this isn't fully correct - value bindings are still imported into the normal environment because a separate import environment for syntax has not been implemented (syntactic bindings are kept separate correctly)."))
(def (sig (syntax "(reexport IMPORT ...)" (id reexport))) (p "Imports " (tt "IMPORT ...") " and automatically exports all imported identifiers. This can be used to build " (i "compound modules") ": modules that just extend other modules:") (highlight scheme "(module r4rs ()\n  (import scheme chicken)\n  (reexport \n    (except scheme \n      dynamic-wind values call-with-values eval scheme-report-environment\n      null-environment interaction-environment)))"))
