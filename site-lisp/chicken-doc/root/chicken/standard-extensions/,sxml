((tags "manual") (section 2 "Extensions to the standard" (section 3 "Identifiers" (p "Identifiers may contain special characters if delimited with " (tt "| ... |") ".")) (section 3 "Brackets and braces" (p "The brackets " (tt "[ ... ]") " and the braces " (tt " { ... } ") " are provided as an alternative syntax for " (tt "( ... )") ".  A number of reader extensions is provided. See " (int-link "Non-standard read syntax") ".")) (section 3 "Non-standard macros" (p "Numerous non-standard macros are provided. See " (int-link "Non-standard macros and special forms") " for more information.")) (section 3 "Extended DSSSL style lambda lists" (p "Extended DSSSL style lambda lists are supported. DSSSL parameter lists are defined by the following grammar:") (pre "<parameter-list> ==> <required-parameter>*\n                     [(#!optional <optional-parameter>*)]\n                     [(#!rest <rest-parameter>)]\n                     [(#!key <keyword-parameter>*)]\n<required-parameter> ==> <ident>\n<optional-parameter> ==> <ident>\n                         | (<ident> <initializer>)\n<rest-parameter> ==> <ident>\n<keyword-parameter> ==> <ident>\n                        | (<ident> <initializer>)\n<initializer> ==> <expr>") (p "When a procedure is applied to a list of arguments, the parameters and arguments are processed from left to right as follows:") (ul (li "Required-parameters are bound to successive arguments starting with the first argument. It shall be an error if there are fewer arguments than required-parameters.") (li "Next, the optional-parameters are bound with the remaining arguments. If there are fewer arguments than optional-parameters, then the remaining optional-parameters are bound to the result of the evaluation of their corresponding <initializer>, if one was specified, otherwise " (tt "#f") ". The corresponding <initializer> is evaluated in an environment in which all previous parameters have been bound.") (li "If there is a rest-parameter, then it is bound to a list containing all the remaining arguments left over after the argument bindings with required-parameters and optional-parameters have been made. ") (li "If " (tt "#!key") " was specified in the parameter-list, there should be an even number of remaining arguments. These are interpreted as a series of pairs, where the first member of each pair is a keyword specifying the parameter name, and the second member is the corresponding value. If the same keyword occurs more than once in the list of arguments, then the corresponding value of the first keyword is the binding value. If there is no argument for a particular keyword-parameter, then the variable is bound to the result of evaluating <initializer>, if one was specified, otherwise " (tt "#f") ". The corresponding <initializer> is evaluated in an environment in which all previous parameters have been bound. ")) (p "Needing a special mention is the close relationship between the rest-parameter and possible keyword-parameters.  Declaring a rest-parameter binds up all remaining arguments in a list, as described above. These same remaining arguments are also used for attempted matches with declared keyword-parameters, as described above, in which case a matching keyword-parameter binds to the corresponding value argument at the same time that both the keyword and value arguments are added to the rest parameter list. Note that for efficiency reasons, the keyword-parameter matching does nothing more than simply attempt to match with pairs that may exist in the remaining arguments.  Extra arguments that don't match are simply unused and forgotten if no rest-parameter has been declared.  Because of this, the caller of a procedure containing one or more keyword-parameters cannot rely on any kind of system error to report wrong keywords being passed in.") (p "It shall be an error for an " (tt "<ident>") " to appear more than once in a parameter-list.") (p "If there is no rest-parameter and no keyword-parameters in the parameter-list, then it shall be an error for any extra arguments to be passed to the procedure.") (p "Example:") (pre "((lambda x x) 3 4 5 6)       => (3 4 5 6)\n((lambda (x y #!rest z) z)\n 3 4 5 6)                    => (5 6)\n((lambda (x y #!optional z #!rest r #!key i (j 1)) \n    (list x y z i: i j: j))\n 3 4 5 i: 6 i: 7)            => (3 4 5 i: 6 j: 1)")) (section 3 (tt "set!") (p (tt "set!") " for unbound toplevel variables is allowed. " (tt "set! (PROCEDURE ...) ...)") " is supported, as CHICKEN implements " (link "http://srfi.schemers.org/srfi-17/srfi-17.html" "SRFI-17") ".")) (section 3 (tt "cond") (p "The " (tt "cond") " form supports " (link "http://srfi.schemers.org/srfi-61" "SRFI-61") ".")) (section 3 ("Binding values in " (tt "letrec")) (p "It is allowed for initialization values of bindings in a " (tt "letrec") " construct to refer to previous variables in the same set of bindings, so") (pre "(letrec ((foo 123)\n         (bar foo) )\n  bar)") (p "is allowed and returns " (tt "123") ".")) (section 3 (tt "begin") (p (tt "(begin)") " is allowed in non-toplevel contexts and evaluates to an unspecified value.")) (section 3 "Delayed expressions" (p "Delayed expressions may return multiple values.")) (section 3 "Internal definitions" (p "CHICKEN extends standard semantics by allowing internal definitions everywhere, and not only at the beginning of a body. A set of internal definitions is equivalent to a " (tt "letrec") " form enclosing all following expressions in the body:") (pre "(let ((foo 123))\n  (bar)\n  (define foo 456)\n  (baz foo) )") (p "expands into") (pre "(let ((foo 123))\n  (bar)\n  (letrec ((foo 456))\n    (baz foo) ) )") (p "Local sequences of " (tt "define-syntax") " forms are translated into equivalent " (tt "letrec-syntax") " forms that enclose the following forms as the body of the expression.")) (section 3 (tt "define") (p (tt "define") " with a single argument is allowed and initializes the toplevel or local binding to an unspecified value. CHICKEN supports " (i "curried") " definitions, where the variable name may also be a list specifying a name and a nested lambda list. So") (pre "(define ((make-adder x) y) (+ x y))") (p "is equivalent to") (pre "(define (make-adder x) (lambda (y) (+ x y)))")) (section 3 "Non-standard procedures" (p "CHICKEN provides numerous non-standard procedures. See the manual sections on library units for more information.")) (section 3 "Special IEEE floating-point numbers" (p "The special IEEE floating-point numbers " (i "+nan") ", " (i "+inf") " and " (i "-inf") " are supported, as is negative zero.")) (section 3 "User defined character names" (p "User defined character names are supported. See " (tt "char-name") ". Characters can be given in hexadecimal notation using the " (i "#\\xXX") " syntax where " (i "XX") " specifies the character code. Character codes above 255 are supported and can be read (and are written) using the " (i "#\\uXXXX") " and " (i "#\\UXXXXXXXX") " notations.") (p "Non-standard characters names supported are " (tt "#\\tab") ", " (tt "#\\linefeed") ", " (tt "#\\return") ", " (tt "#\\alarm") ", " (tt "#\\vtab") ", " (tt "#\\nul") ", " (tt "#\\page") ", " (tt "#\\esc") ", " (tt "#\\delete") " and " (tt "#\\backspace") ".")) (section 3 "Special characters in strings" (p "CHICKEN supports special characters preceded with a backslash " (i "\\") " in quoted string constants. " (i "\\n") " denotes the newline-character, " (i "\\r") " carriage return, " (i "\\b") " backspace, " (i "\\t") " TAB, " (i "\\v") " vertical TAB, " (i "\\a") " alarm, " (i "\\f") " formfeed, " (i "\\xXX") " a character with the code " (tt "XX") " in hex and " (i "\\uXXXX") " (and " (i "\\UXXXXXXXX") ") a unicode character with the code " (tt "XXXX") ". The latter is encoded in UTF-8 format.") (p "The third argument to " (tt "substring") " is optional and defaults to the length of the string.")) (section 3 "Number/String conversions" (p "The optional \"base\" argument to " (tt "string->number") " and " (tt "number->string") " may be any integral value from 2 to 36.")) (section 3 (tt "force") (p (tt "force") " called with an argument that is not a promise returns that object unchanged.  Captured continuations can be safely invoked inside before- and after-thunks of a " (tt "dynamic-wind") " form and execute in the outer dynamic context of the " (tt "dynamic-wind") " form.") (p (b "Implicit") " non-multival continuations accept multiple values by discarding all but the first result. Zero values result in the continuation receiving an unspecified value. Note that this slight relaxation of the behaviour of returning mulitple values to non-multival continuations does not apply to explicit continuations (created with " (tt "call-with-current-continuation") ").")) (section 3 (tt "eval") (p "The second argument to " (tt "eval") " is optional and defaults to the value of " (tt "(interaction-environment)") ". " (tt "scheme-report-environment") " and " (tt "null-environment") " accept an optional 2nd parameter: if not " (tt "#f") " (which is the default), toplevel bindings to standard procedures are mutable and new toplevel bindings may be introduced.")) (section 3 "Pathnames expansion" (p "The " (i "tilde") " character (" (tt "~") ") is automatically expanded in pathnames. Additionally, if a pathname starts with " (tt "$VARIABLE...") ", then the prefix is replaced by the value of the given environment variable.")) (section 3 "Optional arguments for port-related procedures" (p "If the procedures " (tt "current-input-port") " and " (tt "current-output-port") " are called with an argument (which should be a port), then that argument is selected as the new current input- and output-port, respectively.  The procedures " (tt "open-input-file") ", " (tt "open-output-file") ", " (tt "with-input-from-file") ", " (tt "with-output-to-file") ", " (tt "call-with-input-file") " and " (tt "call-with-output-file") " accept an optional second (or third) argument which should be one or more keywords, if supplied. These arguments specify the mode in which the file is opened. Possible values are the keywords " (tt "#:text") ", " (tt "#:binary") " or " (tt "#:append") ".")) (section 3 (tt "exit") (p "The " (tt "exit") " procedure exits a program right away and does " (i "not") " invoke pending " (tt "dynamic-wind") " thunks.") (hr) (p "Previous: " (int-link "Deviations from the standard")) (p "Next: " (int-link "Non-standard read syntax")))))