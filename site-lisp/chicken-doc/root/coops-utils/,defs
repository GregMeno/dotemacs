(index ("slot@" 0) ("slot@" 143) ("make/copy" 794) ("describe-object" 1052) ("instance-of?" 1427) ("class?" 1586) ("check-class" 1737) ("error-class" 1737) ("instance?" 1878) ("check-instance" 2039) ("error-instance" 2039) ("primitive-instance?" 2192) ("primitive?" 2192) ("generic?" 2438) ("check-generic" 2556) ("error-generic" 2556) ("method?" 2705) ("check-method" 2854) ("error-method" 2854) ("class-precedence-list" 2999) ("class-cpl" 2999) ("class-supers" 2999) ("class-slots" 3291) ("class-direct-supers" 3424) ("class-direct-slots" 3586) ("generic-anonymous?" 3745) ("generic-name" 3904) ("generic-specialized-arguments" 4100) ("generic-primary-methods" 4286) ("generic-methods" 4286) ("generic-before-methods" 4554) ("generic-after-methods" 4738) ("generic-around-methods" 4919) ("method-specializers" 5103) ("method-procedure" 5263))
(def (sig (syntax "(slot@ INSTANCE SLOT ...) => *" (id slot@))) (p "Returns the slot value of the N'th named slot from " (tt "INSTANCE") "."))
(def (sig (syntax "(slot@ INSTANCE SLOT ... [= OBJECT])" (id slot@))) (p "Sets the slot value of the N'th named slot of " (tt "INSTANCE") " to " (tt "OBJECT") ".") (p "Example:") (highlight scheme "(use coops coops-extras)\n\n; Needlessly complex for example\n\n(define-class <first> () (next))\n(define-class <second> (<first>) ())\n(define-class <third> (<second>) ())\n\n(define 1st (make <first> 'next (make <second> 'next (make <third> 'next \"the end\"))))\n\n(slot@ 1st next next next) ;=> \"the end\"\n\n(slot@ 1st next next next = \"still the end\")\n(slot@ 1st next next next) ;=> \"still the end\"") (p "(From '@' macro by Dan Muresan.)"))
(def (sig (procedure "(make/copy INSTANCE [INITFORM ...]) => coops-instance" (id make/copy))) (p "Returns a copy of the object " (tt "INSTANCE") " except where an " (tt "INITFORM") " overrides an existing " (tt "SLOT") " value of the " (tt "INSTANCE") "."))
(def (sig (procedure "(describe-object INSTANCE [OUT (current-output-port)])" (id describe-object))) (p "Prints information about the " (tt "INSTANCE") " to the " (tt "output-port") " " (tt "OUT") ".") (p (tt "describe-object") " is a " (tt "generic-procedure") " specializing the first argument.") (p "A more detailed " (tt "print-object") " for use in a " (i "REPL") "."))
(def (sig (procedure "(instance-of? OBJECT CLASS) => boolean" (id instance-of?))) (p "Is " (tt "OBJECT") " an " (tt "instance") " of the " (tt "CLASS>") "?"))
(def (sig (procedure "(class? OBJECT) => boolean" (id class?))) (p "Is " (tt "OBJECT") " an " (tt "instance") " of the " (tt "<standard-class>") "?"))
(def (sig (procedure "(check-class LOC OBJ [ARGNAM]) => *" (id check-class)) (procedure "(error-class LOC OBJ [ARGNAM])" (id error-class))))
(def (sig (procedure "(instance? OBJECT) => boolean" (id instance?))) (p "Is " (tt "OBJECT") " not an " (tt "instance") " of the " (tt "<standard-class>") "?"))
(def (sig (procedure "(check-instance LOC OBJ [ARGNAM]) => *" (id check-instance)) (procedure "(error-instance LOC OBJ [ARGNAM])" (id error-instance))))
(def (sig (procedure "(primitive-instance? OBJECT) => boolean" (id primitive-instance?)) (procedure "(primitive? OBJECT) => boolean" (id primitive?))) (p "Is " (tt "OBJECT") " an " (tt "instance") " of the " (tt "<primitive-object>") " class?"))
(def (sig (procedure "(generic? OBJECT) => boolean" (id generic?))) (p "Synonym for " (tt "generic-procedure?") "."))
(def (sig (procedure "(check-generic LOC OBJ [ARGNAM]) => *" (id check-generic)) (procedure "(error-generic LOC OBJ [ARGNAM])" (id error-generic))))
(def (sig (procedure "(method? OBJECT) => boolean" (id method?))) (p "Is " (tt "OBJECT") " a " (tt "method") " of a " (tt "generic-procedure") "?"))
(def (sig (procedure "(check-method LOC OBJ [ARGNAM]) => *" (id check-method)) (procedure "(error-method LOC OBJ [ARGNAM])" (id error-method))))
(def (sig (procedure "(class-precedence-list CLASS) => (list-of class)" (id class-precedence-list)) (procedure "(class-cpl CLASS) => (list-of class)" (id class-cpl)) (procedure "(class-supers CLASS) => (list-of class)" (id class-supers))) (p "Returns the superclasses of " (tt "CLASS") "."))
(def (sig (procedure "(class-slots CLASS) => (list-of symbol)" (id class-slots))) (p "Returns the slot names of " (tt "CLASS") "."))
(def (sig (procedure "(class-direct-supers CLASS) => (list-of class)" (id class-direct-supers))) (p "Returns the uninherited superclasses of " (tt "CLASS") "."))
(def (sig (procedure "(class-direct-slots CLASS) => (list-of symbol)" (id class-direct-slots))) (p "Returns the uninherited slot names of " (tt "CLASS") "."))
(def (sig (procedure "(generic-anonymous? GENERIC) => boolean" (id generic-anonymous?))) (p "Is " (tt "GENERIC") " an unnamed " (tt "generic-procedure") "."))
(def (sig (procedure "(generic-name GENERIC) => (union #f symbol)" (id generic-name))) (p "Returns the name of " (tt "GENERIC") ". The name is " (tt "#f") " for an anonymous generic procedure."))
(def (sig (procedure "(generic-specialized-arguments GENERIC) => (list-of symbol)" (id generic-specialized-arguments))) (p "The arguments that " (tt "GENERIC") " is specialized upon."))
(def (sig (procedure "(generic-primary-methods GENERIC) => (list-of method)" (id generic-primary-methods)) (procedure "(generic-methods GENERIC) => (list-of method)" (id generic-methods))) (p "Returns the list of " (tt "primary:") " methods for " (tt "GENERIC") "."))
(def (sig (procedure "(generic-before-methods GENERIC) => (list-of method)" (id generic-before-methods))) (p "Returns the  list of" (tt "before:") " methods for " (tt "GENERIC") "."))
(def (sig (procedure "(generic-after-methods GENERIC) => (list-of method)" (id generic-after-methods))) (p "Returns the list of " (tt "after:") " methods for " (tt "GENERIC") "."))
(def (sig (procedure "(generic-around-methods GENERIC) => (list-of method)" (id generic-around-methods))) (p "Returns the list of " (tt "around:") " methods for " (tt "GENERIC") "."))
(def (sig (procedure "(method-specializers METHOD) => (list-of class)" (id method-specializers))) (p "Returns the classes that specialize " (tt "METHOD") "."))
(def (sig (procedure "(method-procedure METHOD) => procedure" (id method-procedure))) (p "Returns the " (tt "procedure") " for " (tt "METHOD") "."))
