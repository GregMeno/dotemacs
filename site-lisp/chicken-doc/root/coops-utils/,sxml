((tags "egg") (section 2 "coops-utils" (toc)) (section 2 "Documentation" (p "Some " (int-link "coops") " stuff.") (section 3 "Extras" (p "Miscellaneous coops extensions.") (section 4 "Argument Conventions" (p (tt "INSTANCE") " is a " (tt "coops-instance") ".") (p (tt "SLOT") " is a " (tt "symbol") ".") (p (tt "INITFORM") " is " (tt "'SLOT OBJECT") ".")) (section 4 "Usage" (highlight scheme "(require-extension coops-extras)")) (section 4 "slot@" (p "The slot accessor recursion.") (def (sig (syntax "(slot@ INSTANCE SLOT ...) => *" (id slot@))) (p "Returns the slot value of the N'th named slot from " (tt "INSTANCE") ".")) (def (sig (syntax "(slot@ INSTANCE SLOT ... [= OBJECT])" (id slot@))) (p "Sets the slot value of the N'th named slot of " (tt "INSTANCE") " to " (tt "OBJECT") ".") (p "Example:") (highlight scheme "(use coops coops-extras)\n\n; Needlessly complex for example\n\n(define-class <first> () (next))\n(define-class <second> (<first>) ())\n(define-class <third> (<second>) ())\n\n(define 1st (make <first> 'next (make <second> 'next (make <third> 'next \"the end\"))))\n\n(slot@ 1st next next next) ;=> \"the end\"\n\n(slot@ 1st next next next = \"still the end\")\n(slot@ 1st next next next) ;=> \"still the end\"") (p "(From '@' macro by Dan Muresan.)"))) (section 4 "make/copy" (def (sig (procedure "(make/copy INSTANCE [INITFORM ...]) => coops-instance" (id make/copy))) (p "Returns a copy of the object " (tt "INSTANCE") " except where an " (tt "INITFORM") " overrides an existing " (tt "SLOT") " value of the " (tt "INSTANCE") "."))) (section 4 "describe-object" (def (sig (procedure "(describe-object INSTANCE [OUT (current-output-port)])" (id describe-object))) (p "Prints information about the " (tt "INSTANCE") " to the " (tt "output-port") " " (tt "OUT") ".") (p (tt "describe-object") " is a " (tt "generic-procedure") " specializing the first argument.") (p "A more detailed " (tt "print-object") " for use in a " (i "REPL") ".")))) (section 3 "Introspection" (p "Some " (int-link "TInyCLOS") " inspired property readers.") (section 4 "Argument Conventions" (p "Provides predicates and read accessors for " (tt "coops objects") ".") (p (tt "OBJECT") " is a Scheme " (tt "object") ".") (p (tt "CLASS") " is a coops " (tt "class") ".") (p (tt "GENERIC") " is a coops " (tt "generic-procedure") ".") (p (tt "METHOD") " is a coops " (tt "generic-procedure") " " (tt "method") ". Do not apply any but the supplied API to instances of this type!")) (section 4 "Usage" (highlight scheme "(require-extension coops-introspection)")) (section 4 "instance-of?" (def (sig (procedure "(instance-of? OBJECT CLASS) => boolean" (id instance-of?))) (p "Is " (tt "OBJECT") " an " (tt "instance") " of the " (tt "CLASS>") "?"))) (section 4 "class?" (def (sig (procedure "(class? OBJECT) => boolean" (id class?))) (p "Is " (tt "OBJECT") " an " (tt "instance") " of the " (tt "<standard-class>") "?")) (def (sig (procedure "(check-class LOC OBJ [ARGNAM]) => *" (id check-class)) (procedure "(error-class LOC OBJ [ARGNAM])" (id error-class))))) (section 4 "instance?" (def (sig (procedure "(instance? OBJECT) => boolean" (id instance?))) (p "Is " (tt "OBJECT") " not an " (tt "instance") " of the " (tt "<standard-class>") "?")) (def (sig (procedure "(check-instance LOC OBJ [ARGNAM]) => *" (id check-instance)) (procedure "(error-instance LOC OBJ [ARGNAM])" (id error-instance))))) (section 4 "primitive-instance?" (def (sig (procedure "(primitive-instance? OBJECT) => boolean" (id primitive-instance?)) (procedure "(primitive? OBJECT) => boolean" (id primitive?))) (p "Is " (tt "OBJECT") " an " (tt "instance") " of the " (tt "<primitive-object>") " class?"))) (section 4 "generic?" (def (sig (procedure "(generic? OBJECT) => boolean" (id generic?))) (p "Synonym for " (tt "generic-procedure?") ".")) (def (sig (procedure "(check-generic LOC OBJ [ARGNAM]) => *" (id check-generic)) (procedure "(error-generic LOC OBJ [ARGNAM])" (id error-generic))))) (section 4 "method?" (def (sig (procedure "(method? OBJECT) => boolean" (id method?))) (p "Is " (tt "OBJECT") " a " (tt "method") " of a " (tt "generic-procedure") "?")) (def (sig (procedure "(check-method LOC OBJ [ARGNAM]) => *" (id check-method)) (procedure "(error-method LOC OBJ [ARGNAM])" (id error-method))))) (section 4 "class-precedence-list" (def (sig (procedure "(class-precedence-list CLASS) => (list-of class)" (id class-precedence-list)) (procedure "(class-cpl CLASS) => (list-of class)" (id class-cpl)) (procedure "(class-supers CLASS) => (list-of class)" (id class-supers))) (p "Returns the superclasses of " (tt "CLASS") "."))) (section 4 "class-slots" (def (sig (procedure "(class-slots CLASS) => (list-of symbol)" (id class-slots))) (p "Returns the slot names of " (tt "CLASS") "."))) (section 4 "class-direct-supers" (def (sig (procedure "(class-direct-supers CLASS) => (list-of class)" (id class-direct-supers))) (p "Returns the uninherited superclasses of " (tt "CLASS") "."))) (section 4 "class-direct-slots" (def (sig (procedure "(class-direct-slots CLASS) => (list-of symbol)" (id class-direct-slots))) (p "Returns the uninherited slot names of " (tt "CLASS") "."))) (section 4 "generic-anonymous?" (def (sig (procedure "(generic-anonymous? GENERIC) => boolean" (id generic-anonymous?))) (p "Is " (tt "GENERIC") " an unnamed " (tt "generic-procedure") "."))) (section 4 "generic-name" (def (sig (procedure "(generic-name GENERIC) => (union #f symbol)" (id generic-name))) (p "Returns the name of " (tt "GENERIC") ". The name is " (tt "#f") " for an anonymous generic procedure."))) (section 4 "generic-specialized-arguments" (def (sig (procedure "(generic-specialized-arguments GENERIC) => (list-of symbol)" (id generic-specialized-arguments))) (p "The arguments that " (tt "GENERIC") " is specialized upon."))) (section 4 "generic-primary-methods" (def (sig (procedure "(generic-primary-methods GENERIC) => (list-of method)" (id generic-primary-methods)) (procedure "(generic-methods GENERIC) => (list-of method)" (id generic-methods))) (p "Returns the list of " (tt "primary:") " methods for " (tt "GENERIC") "."))) (section 4 "generic-before-methods" (def (sig (procedure "(generic-before-methods GENERIC) => (list-of method)" (id generic-before-methods))) (p "Returns the  list of" (tt "before:") " methods for " (tt "GENERIC") "."))) (section 4 "generic-after-methods" (def (sig (procedure "(generic-after-methods GENERIC) => (list-of method)" (id generic-after-methods))) (p "Returns the list of " (tt "after:") " methods for " (tt "GENERIC") "."))) (section 4 "generic-around-methods" (def (sig (procedure "(generic-around-methods GENERIC) => (list-of method)" (id generic-around-methods))) (p "Returns the list of " (tt "around:") " methods for " (tt "GENERIC") "."))) (section 4 "method-specializers" (def (sig (procedure "(method-specializers METHOD) => (list-of class)" (id method-specializers))) (p "Returns the classes that specialize " (tt "METHOD") "."))) (section 4 "method-procedure" (def (sig (procedure "(method-procedure METHOD) => procedure" (id method-procedure))) (p "Returns the " (tt "procedure") " for " (tt "METHOD") "."))))) (section 2 "Examples" (highlight scheme "(use coops coops-introspection)\n\n(define (print-methods generic)\n  (for-each\n    (lambda (m)\n      (print\n        (generic-name generic)\n        \" specialized by \" (method-specializers m)\n        \" as \" (method-procedure m)))\n    (generic-methods generic)) )")) (section 2 "Notes" (ul (li "The introspection API is not for use in production code.")) (p "While useful it relies on knowledge of the internals of the coops implementation and Chicken. It is " (i "very") " brittle, especially the generics portion.") (p "Suggested only for use during " (i "REPL") " development with " (int-link "coops") ".")) (section 2 "Requirements" (p (int-link "coops") " " (int-link "type-checks"))) (section 2 "Bugs and Limitations") (section 2 "Author" (p (int-link "/users/kon-lovett" "Kon Lovett"))) (section 2 "Version history" (dl (dt "0.0.1"))) (section 2 "License" (p "Copyright (C) 2010 Kon Lovett.  All rights reserved.") (p "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:") (p "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.") (p "THE SOFTWARE IS PROVIDED ASIS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.")))