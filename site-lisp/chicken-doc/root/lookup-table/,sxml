((tags "egg") (section 2 "lookup-table" (p "Provides a " (i "Dictionary") " abstraction.") (toc)) (section 2 "Documentation" (p "Purports to be a simple key -> value lookup table. Known as a 'Dictionary' in some circles. It attempts to optimize for speed of lookup by choosing different storage models.") (p "Four variants of the API are available:") (dl (dt "safe") (dd "Perfroms argument and other constraint checks.") (dt "unsafe") (dd "Performs no constraint checks.") (dt "safe synchronized") (dd "Suffixes each procedure name with \"/synch\". All access to the dict object is synchronized.") (dt "unsafe synchronized") (dd "Suffixes each procedure name with \"/%synch\", except constructors & predicates which use \"/synch\".")) (p "Example:") (ul (li (tt "dict?") " is the name of the safe & unsafe variant's predicate, while " (tt "dict?/synch") " is the safe synchronized and unsafe synchronized variant's name.") (li (tt "dict-count") " is the name of the safe & unsafe variant's operation, while " (tt "dict-count/synch") " is the safe synchronized name and " (tt "dict-count/%synch") " the unsafe synchronized name.")) (section 3 "make-dict" (def (sig (procedure "(make-dict [EQUALITY eq? [ESTIMATE <small-number>]]) -> dict" (id make-dict))) (p "Returns a dictionary using the supplied " (tt "EQUALITY") " test, optimized for the number of elements " (tt "ESTIMATE") "."))) (section 3 "alist->dict" (def (sig (procedure "(alist->dict ALIST [EQUALITY eq?] [ESTIMATE 0]) -> dict" (id alist->dict))) (p "Returns a dictionary constructed from " (tt "ALIST") " using the supplied " (tt "EQUALITY") " test, and optional " (tt "ESTIMATE") "."))) (section 3 "dict?" (def (sig (procedure "(dict? OBJECT) -> boolean" (id dict?))) (p "Is the " (tt "OBJECT") " a dictionary?"))) (section 3 "dict-equivalence-function" (def (sig (procedure "(dict-equivalence-function DICT) -> (procedure (object object) boolean)" (id dict-equivalence-function))) (p "Returns the equality test predicate procedure for " (tt "DICT") "."))) (section 3 "dict-count" (def (sig (procedure "(dict-count DICT) -> integer" (id dict-count))) (p "Returns the number of items in the " (tt "DICT") "."))) (section 3 "dict-keys" (def (sig (procedure "(dict-keys DICT) -> list" (id dict-keys))) (p "Returns the keys in the " (tt "DICT") "."))) (section 3 "dict-values" (def (sig (procedure "(dict-values DICT) -> list" (id dict-values))) (p "Returns the values in the " (tt "DICT") "."))) (section 3 "dict->alist" (def (sig (procedure "(dict->alist DICT) => list" (id dict->alist))) (p "Returns the " (tt "DICT") " as an association list. The result may not be mutated!"))) (section 3 "dict-ref" (def (sig (procedure "(dict-ref DICT KEY [DEFAULT #f]) => *" (id dict-ref))) (p "Returns the value associated with " (tt "KEY") " in the " (tt "DICT") ", otherwise " (tt "DEFAULT") "."))) (section 3 "dict-Idempotent-ref!" (def (sig (procedure "(dict-Idempotent-ref! DICT KEY FUNC [DEFAULT #f]) => *" (id dict-Idempotent-ref!))) (p "Should a value for " (tt "KEY") " exist in " (tt "DICT") " it is returned. Otherwise " (tt "FUNC") " is invoked on " (tt "DEFAULT") ". Any result other than " (tt "DEFAULT") " is the value for the " (tt "KEY") " and that value is returned. Otherwise returns " (tt "DEFAULT") "."))) (section 3 "dict-exists?" (def (sig (procedure "(dict-exists? DICT KEY) => boolean" (id dict-exists?))) (p "Does an entry with " (tt "KEY") " exist in the " (tt "DICT") " ?"))) (section 3 "dict-set!" (def (sig (procedure "(dict-set! DICT KEY VALUE)" (id dict-set!))) (p "Associate " (tt "VALUE") " with " (tt "KEY") " in the " (tt "DICT") ".") (p (tt "VALUE") " must not be " (tt "(void)") "!"))) (section 3 "dict-update!" (def (sig (procedure "(dict-update! DICT KEY DEFAULT-VALUE-PROCEDURE [FUNC identity])" (id dict-update!))) (p "Invokes " (tt "FUNC") " on either the existing value for " (tt "KEY") " in the " (tt "DICT") ", or the result of the " (tt "DEFAULT-VALUE-PROCEDURE") " when no existing value. The result then becomes the value for " (tt "KEY") " in the " (tt "DICT") ".") (p "Returns the updated value for " (tt "KEY") " in the " (tt "DICT") ".") (p (tt "DEFAULT-VALUE-PROCEDURE") " must not return " (tt "(void)") "!"))) (section 3 "dict-update-list!" (def (sig (procedure "(dict-update-list! DICT KEY [OBJECT]...)" (id dict-update-list!))) (p "Updates the value for " (tt "KEY") " in the " (tt "DICT") " with a list of " (tt "OBJECT") "."))) (section 3 "dict-update-dict!" (def (sig (procedure "(dict-update-dict! DICT KEY [EQUALITY eq? [ESTIMATE <small-number>]])" (id dict-update-dict!))) (p "Updates the value for " (tt "KEY") " in the " (tt "DICT") " with a " (tt "dict") ".") (p (tt "EQUALITY") " and " (tt "ESTIMATE") " as for " (tt "make-dict") "."))) (section 3 "dict-delete!" (def (sig (procedure "(dict-delete! DICT KEY)" (id dict-delete!))) (p "Removes any association of " (tt "KEY") " in the " (tt "DICT") "."))) (section 3 "dict-for-each" (def (sig (procedure "(dict-for-each DICT (PROCEDURE (-> KEY VALUE <ignored>)))" (id dict-for-each))) (p "Invokes the supplied " (tt "PROCEDURE") " with each association in the " (tt "DICT") "."))) (section 3 "dict-merge!" (def (sig (procedure "(dict-merge! DICT [DICT1...]) => dict" (id dict-merge!))) (p "Returns the " (tt "DICT") " as the " (tt "(union DICT DICT1 ...)") " using overwrite semantics.") (p "Tables must have the same equality predicate."))) (section 3 "dict-search" (def (sig (procedure "(dict-search DICT PROCEDURE [DEFAULT #f]) => *" (id dict-search))) (p "Returns the first entry value matched by the " (tt "PROCEDURE") ". Otherwise the " (tt "DEFAULT") " value is returned.)") (p (tt "PROCEDURE") " is a " (tt "(procedure (object object) boolean)") " where the first argument is the key and the second is the value."))) (section 3 "dict-print" (def (sig (procedure "(dict-print DICT [PORT (current-output-port)])" (id dict-print))) (p "Pretty-print " (tt "DICT") " to " (tt "PORT") ".")))) (section 2 "Usage" (ul (li "Safe variant")) (highlight scheme "(require-extension lookup-table)") (ul (li "Synchronized safe variant")) (highlight scheme "(require-extension lookup-table-synch)") (ul (li "Unsafe variant")) (highlight scheme "(require-extension lookup-table-unsafe)") (ul (li "Synchronized unsafe variant")) (highlight scheme "(require-extension lookup-table-unsafe-synch)")) (section 2 "Requirements" (p (int-link "miscmacros") " " (int-link "check-errors") " " (int-link "record-variants") " " (int-link "synch"))) (section 2 "Author" (p (int-link "/users/kon-lovett" "Kon Lovett"))) (section 2 "Version history" (dl (dt "1.13.2") (dd "Fix for backwards incompatible use of " (i "module body string") " feature. ") (dt "1.13.1") (dd "Made " (tt "dict-safe-mode") " a plain procedure since it is a no-op.") (dt "1.13.0") (dd "Uses " (i "record-variants") ".") (dt "1.12.0") (dd "Added 'make-dict' parameters to 'dict-update-dict!'.") (dt "1.11.0") (dd "Added 'dict-Idempotent-ref!' and 'synch' versions.") (dt "1.10.0") (dd "Split into safe & unsafe") (dt "1.9.1") (dd "Fix for strange compile output (C procedures being redefined).") (dt "1.9.0") (dd "Use of primitives.") (dt "1.8.0") (dd "Chicken 4 release."))) (section 2 "License" (p "Copyright (C) 2009-2010 Kon Lovett.  All rights reserved.") (p "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:") (p "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.") (p "THE SOFTWARE IS PROVIDED ASIS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.")))