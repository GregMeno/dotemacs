((tags "egg") (section 2 "yasos" (toc) (section 3 "Description" (p "\"Yet another Scheme Object System\"") (p "A very simple OOP system with multiple inheritance, that allows mixing of styles and separates interface from implementation. There are no classes, no meta-anything, simply closures.")) (section 3 "Author" (p "Kenneth Dickey") (p "ported to CHICKEN by Juergen Lorenz")) (section 3 "Version" (pre "1.2")) (section 3 "Usage" (p "(require-extension yasos)")) (section 3 "Scheming with  Objects" (p "There is a saying--attributed to Norman Adams--that \"Objects are a poor man's closures.\" In this article we discuss what closures are and how objects and closures are related, show code samples to make these abstract ideas concrete, and implement a Scheme Object System which solves the problems we uncover along the way.") (section 4 "The Classical Object Model" (p "Before discussing object oriented programming in Scheme, it pays to take a look at the classical model so that we have something to compare with and in order to clarify some of the terminology.  One of the problems that the OO movement created for itself was the use of new terms to get away from older concepts and the confusion this has caused.  So before going further I would like to give some of my own definitions and a simple operational model.  The model is not strictly correct as most compiled systems use numerous short cuts and special optimization tricks, but it is close enough for most practical purposes and has been used to implement OO programming in imperative languages.") (p "An object \"instance\" consists of local (encapsulated) state and a reference to shared code which operates on its state.  The easy way to think of this is as a C struct or Pascal record which has one field reserved for a pointer to its shared code environment and other slots for its instance variables.  Each procedure in this shared environment is called a \"method.\" A \"class\" is code which is can generate instances (new records) by initializing their fields, including a pointer to the instance's shared method environment.  The environment just maps method names to their values (their code).  Each method is a procedure which takes the record it is operating on as its first, sometimes hidden, argument.  The first argument is called the \"reciever\" and typically aliased to the name \"self\" within the procedure's code.") (p "In order to make code management easy, object oriented systems such as Actor or Smalltalk wish to deal with code as objects and the way this is done is by making each class an object instance as well.  In order to manipulate the class's code, however a \"meta-class\" is typically defined and in some cases a meta-meta...  Well, you get the idea. Many people have spent a great deal of time in theories of how to \"ground\" such systems without infinite recursion.  To confuse things further, many object systems have an object named \"object\" and a class object named \"class\"--so that the class of the \"class\" object is `class'.") (p "By making every data object an instance of the OO system, uniformity demands that numbers are added, e.g. 1 + 2 by \"sending the message\" + to the object 1 with the argument 2.  This has the advantage that + is polymorphic--it can be applied to any data object.  Unfortunately, polymorphism also makes optimization hard in that the compiler can no longer make assumptions about + and may not be able to do constant folding or inlining.") (p "The set of methods an object responds to is called a \"protocol\". Another way of saying this is that the functions or operations that are invokeable on an object make up its interface.  More than one class of object may respond to the same protocol--i.e. many different types of objects have the same operation names available.")) (section 4 "Object Based Message Passing" (p "So how can this \"message passing\" be implemented with lexical closures?  And what are these closure things anyway?") (p "References within a function to variables outside of the local scope--free references--are resolved by looking them up in the environment in which the function finds itself.  When a language is lexically scoped, you see the shape of the environment when you read--lex--the code.  In Scheme, when a function is created it remembers the environment in which it was created.  Free names are looked up in that environment, so the environment is said to be \"closed over\" when the function is created.  Hence the term \"closure.\"") (p "An example may help here:") (pre " (define (CURRIED-ADD x) (lambda (y) (+ x y))") (pre " (define ADD8 (curried-add 8))") (pre " (add8 3)\t-> 11") (p "When add8 is applied to its argument, we are doing ((lambda (y) (+ x y)) 3)") (p "The function add8 remembers that X has the value 8.  It gets the value Y when it is applied to 3.  It finds that + is the addition function. So (add8 3) evaluates to 11.") (p "(define ADD5 (curried-add 5)) makes a new function which shares the curried-add code (lambda (y) (+ x y)), but remembers that in its closed over environment, X has the value 5.") (p "Now that we have a way to create data objects, closures, which share code but have different data, we just need a \"dispatching function\" to which we can pass the symbols we will use for messages:") (pre " (define (MAKE-POINT the-x the-y)\n   (lambda (message)\n      (case message\n  ((x)  (lambda () the-x)) ;; return a function which returns the answer\n  ((y)  (lambda () the-y))\n  ((set-x!) \n       (lambda (new-value)\n\t       (set! the-x new-value)  ;; do the assignment\n\t\tthe-x))                ;; return the new value\n  ((set-y!) \n       (lambda (new-value)\n\t       (set! the-y new-value)\n\t\tthe-y))\n (else (error \"POINT: Unknown message ->\" message))\n ) )  )") (pre " (define p1 (make-point 132 75))") (pre " (define p2 (make-point 132 57))") (pre " ((p1 'x))\t\t-> 132") (pre " ((p1 'set-x!) 5)\t-> 5") (p "We can even change the message passign style to function calling style:") (pre " (define (x obj) (obj 'x))") (pre " (define (set-x! obj new-val) ((obj 'set-x!) new-val))") (pre " (set-x! p1 12) \t-> 12 ") (pre " (x p1) \t\t-> 12") (pre " (x p2)\t\t-> 132\t;; p1 and p2 share code but have different local data") (p "Using Scheme's lexical scoping, we can also define make-point as:") (pre " (define (MAKE-POINT the-x the-y)") (pre "   (define (get-x) the-x)\t;; a \"method\"") (pre "   (define (get-y) the-y)") (pre "   (define (set-x! new-x) \n      (set! the-x new-x)\n      the-x)") (pre "   (define (set-y! new-y) \n      (set! the-y new-y)\n      the-y)") (pre "   (define (self message)\n      (case message\n  ((x)   \t  get-x) ;; return the local function\n  ((y)  \t  get-y)\n  ((set-x!) set-x!)\n  ((set-y!) set-y!)\n  (else (error \"POINT: Unknown message ->\" message))))") (pre "   self\t ;; the return value of make-point is the dispatch function\n )")) (section 4 "Adding Inheritance" (p "\"Inheritance\" means that one object may be specialized by adding to and/or shadowing another's behavior.  It is said that \"object based\" programming together with inheritance is \"object oriented\" programming. How can we add inheritance to the above picture?  By delegating to another object!") (pre " (define (MAKE-POINT-3D a b the-z)\n   (let ( (point (make-point a b)) )") (pre "    (define (get-z) the-z)") (pre "    (define (set-z! new-value)\n(set! the-z new-value)\nthe-z)") (pre "    (define (self message)\n      (case message\n   ((z) \t\tget-z)\n   ((set-z!) \tset-z!)\n   (else (point message))))") (pre "   self\n )") (pre " (define p3 (make-point-3d 12 34 217))") (pre " (x p3)\t\t-> 12") (pre " (z p3)\t\t-> 217") (pre " (set-x! p3 12)\t-> 12") (pre " (set-x! p2 12)\t-> 12") (pre " (set-z! p3 14)\t-> 14") (p "Note that in this style, we are not required to have a single distinguished base object, \"object\"--although we may do so if we wish.")) (section 4 "What Is Wrong With The Above Picture ?" (p "While the direct strategy above is perfectly adequate for OO programming, there are a couple of rough spots.  For example, how can we tell which functions are points and which are not?  We can define a POINT?  predicate, but not all Scheme data objects will take a 'point? message.  Most will generate error messages, but some will just \"do the wrong thing.\"") (pre " (define (POINT? obj) (and (procedure? obj) (obj 'point?)))") (pre " (point? list)         -> (point?)  ;; a list with the symbol 'point?") (p "We want a system in which all objects participate and in which we can mix styles.  Building dispatch functions is repetitive and can certainly be automated--and let's throw in multiple inheritance while we are at it.  Also, it is generally a good design principle to separate interface from implementation, so we will.")) (section 4 "One Set Of Solutions" (p "The following is one of a large number of possible implementations. Most Scheme programmers I know have written at least one object system and some have written several.  Let's first look at the interface, then how it is used, then how it was implemented.") (p "In order to know what data objects are \"instances\", we have a predicate, INSTANCE?, which takes a single argument and answers #t or #f.") (p "For each kind of object is also useful to have a predicate, so we define a predicate maker: (DEFINE-PREDICATE <opname?>) which by default answers #f.") (p "To define operations which operate on any data, we need a default behavior for data objects which don't handle the operation: (DEFINE-OPERATION (opname self arg ...) default-body).  If we don't supply a default-behavior, the default default-behavior is to generate an error.") (p "We certainly need to return values which are instances of our object system: (OBJECT operation... ), where an operation has the form: ((opname self arg ...) body).  There is also a LET-like form for multiple inheritance:") (pre "  (OBJECT-WITH-ANCESTORS ( (ancestor1 init1) ...) \n    operation ...).") (p "In the case of multiple inherited operations with the same identity, the operation used is the one found in the first ancestor in the ancestor list.") (p "And finally, there is the \"send to super\" problem, where we want to operate as an ancestor, but maintain our own self identity {more on this below}:  (OPERATE-AS component operation composite arg ...).") (p "Note that in this system, code which creates instances is just code, so there there is no need to define \"classes\" and no meta-<anything>!")) (section 4 "Examples" (p "O.K., let's see how this fits together.  First, another look at points.") (pre " (define P2 (make-point 123 32131))\n (define P3 (make-point-3d 32 121 3232))\n (size \"a string\")\t-> 8\n (size p2)\t\t-> 2\n (size p3)\t\t-> 3\n (point? p2)\t\t-> #t\n (point? p3)\t\t-> #t\n (point? \"a string\")\t-> #f\n (x p2)\t\t\t-> 123\n (x p3)\t\t\t-> 32\n (x \"a string\")\t\t-> ERROR: Operation not handled: x \"a string\"\n (print p2 #t)\t\t#<point: 123 32131>\n (print p3 #t)   \t#<3D-point: 32 121 3232>\n (print \"a string\" #t) \t\"a string\"") (p "Things to notice...") (ul (li "Interface is separate from implementation") (li "All objects participate") (li "Inheritance is simplified") (li "Print unifies treatment of objects--each decides how it is to be displayed") (li "Default behaviors are useful ")) (p "Now lets look at a more interesting example, a simplified savings account with history and passwords.") (p (i "(See below for the example code)")) (pre " (define FRED  (make-person \"Fred\" 19 \"573-19-4279\" #xFadeCafe))\n (define SALLY\n   (make-account \"Sally\" 26 \"629-26-9742\" #xFeedBabe 263 bank-password))") (pre " (print fred #t)\t\t#<Person: Fred age: 19>\n (print sally #t)\t#<Bank-Customer Sally>\n (person? sally)\t\t-> #t\n (bank-account? sally)\t-> #t\n (ssn fred  #xFadeCafe)\t-> \"573-19-4279\"\n (ssn sally #xFeedBabe)\t-> \"629-26-9742\"\n (add sally 130) \tNew balance: $393\n (add sally 55)\t\tNew balance: $448") (pre " ; the bank can act in Sally's behalf\n (get-account-history sally bank-password)  \t\t--> (448 393 263)\n (withdraw sally 100 (get-pin sally bank-password))\tNew balance: $348\n (get-account-history sally bank-password)          \t--> (348 448 393 263)") (pre " ;; Fred forgets\n (ssn fred 'bogus)\tBad password: bogus\t;; Fred gets another chance") (pre " ;; Sally forgets\n (ssn sally 'bogus)\tCALL THE POLICE!!\t;; A more serious result..") (p "Now we see the reason we need OPERATE-AS.  The when the bank-account object delegates the SSN operation to its ancestor, person, SELF is bound to the bank-account object--not the person object.  This means that while the code for SSN is inherited from person, the BAD-PASSWORD operation of the bank-account is used.") (p "This is an important behavior to have in an object system.  If there were no OPERATE-AS, code would have to be duplicated in order to implement the stricter form of BAD-PASSWORD.  With OPERATE-AS, we can safely share code while keeping operations localized within the inheritance hierarchy.")) (section 4 "Our Implementation" (p "Given the sophisticated behavior of our object system, the implementation is surprisingly small.") (p "Unlike some other languages, Scheme does not have a standard way of defining opaque types.  In order to distinguish data objects which are instances of our object system, we just uniquely tag a closure.  As we are only introducing one new datatype it is not much work to hide this by rewriting Scheme's WRITE and DISPLAY routines.") (p "In order to allow lexical scoping of objects and operations, the values of operations, rather than their names, are used in the dispatch functions created for objects.  Those of you who have used languages such as Smalltalk or Actor may have been bitten by the inadvertant name collisions in the single, global environment.") (p "Note that there are no global tables.  A general rule of thumb is that for less than 100 elements, linear search beats hashing.  While we can speed up operation dispatch by some simple caching, the general performance for this system will be pretty good up through moderately large systems.  Also, we can optimize the implementation with no change to the interface.  If our systems start getting too slow, its time to smarten the compiler.")) (section 4 "How This Compares To The Classical Model" (p "It is time to compare this implementation to the model given at the beginning of this article.") (p "One thing you may notice right away is the power of closures.  The object system is small and simpler than the class model.  There are no grounding problems.  No \"Meta\".  I find it interesting that Whitewater's Actor 4.0 implements code sharing between classes (which they call multiple inheritance) in an attempt to get more of the benefits that closures provide directly.") (p "The Scheme solution is also more general.  It keeps lexical scoping, and one can freely mix OO with functional & imperative styles.") (p "Programming Environment work still has to be done for code management & debugging (e.g. doing an object inspector), but OO helps here just as in other OO systems.") (p "Separating the interface from the implementation is a better software engineering solution than the classical model.  We can define our \"protocols\" independently of their implementation.  This helps us hide our implementation.  One might think that object oriented programming in general would solve the problems here, but this has not been the case because people still use inheritance to share code rather than just to share abstractions.  An example of this is the complex behavior of Smalltalk dictionaries because they inherit the implementation of Sets.  While code sharing is a benefit of OO it is still considered bad form when your code breaks because of a change in the implementation of an inherited abstraction.") (p "Finally, I would like to point out that one can implement other OO models directly in Scheme, including smaller, simpler ones!  You can also implement the classical model (e.g. see D. Friedman, M. Wand, & C. Haynes: _Essentials of Programming Languages_, McGraw Hill, 1992).") (p "Remember, your programming language should be part of the solution, not part of your problems.  Scheme for success!"))) (section 3 "Examples" (pre " ;;;===============\n ;;;file yasos-examples.scm\n ;;;===============\n \n (require-extension yasos format)\n \n ;;----------------------------\n ;; general operations\n ;;----------------------------\n \n (define-operation (print-obj obj port)\n   (format port\n     ;; if an instance does not have a print-obj operation..\n     (if (instance? obj) \"#<INSTANCE>~%\" \"#<NOT-AN-INSTANCE: ~s>~%\") obj))\n \n (define-operation (size-obj obj)\n   ;; default behavior\n   (cond\n     ((vector? obj) (vector-length obj))\n     ((list? obj) (length obj))\n     ((pair? obj) 2)\n     ((string? obj) (string-length obj))\n     ((char? obj) 1)\n     (else\n       (error \"Operation not supported: size-obj\" obj))))\n \n ;;----------------------\n ;; point interface\n ;;----------------------\n \n (define-predicate point?) ;; answers #f  by default\n (define-operation (x obj))\n (define-operation (y obj))\n (define-operation (set-x! obj new-x))\n (define-operation (set-y! obj new-y))\n \n ;;--------------------------------\n ;; point implementation\n ;;--------------------------------\n \n (define (make-point the-x the-y)\n   (object\n     ((point? self) #t) ;; yes, this is a point object\n     ((x self) the-x)\n     ((y self) the-y)\n     ((set-x! self val)\n       (set! the-x val)\n       the-x)\n     ((set-y! self val)\n       (set! the-y val)\n       the-y)\n     ((size-obj self) 2)\n     ((print-obj self port)\n       (format port \"#<point: ~a ~a>~%\" (x self) (y self)))))\n \n ;;-----------------------------------------\n ;; 3D point interface additions\n ;;-----------------------------------------\n \n (define-predicate point-3d?) ;; #f by defualt\n (define-operation (z obj))\n (define-operation (set-z! obj new-z))\n \n ;;------------------------------------\n ;; 3D point implementation\n ;;------------------------------------\n \n (define (make-point-3d the-x the-y the-z)\n   (object-with-ancestors ( (a-point (make-point the-x the-y)) )\n     ((point-3d? self) #t)\n     ((z self) the-z)\n     ((set-z! self val) (set! the-z val) the-z)\n     ;; override inherited size-obj and print-obj operations\n     ((size-obj self) 3)\n     ((print-obj self port)\n       (format port \"#<3d-point: ~a ~a ~a>~%\" (x self) (y self) (z self)))))\n \n ;;;-----------------------\n ;; person interface\n ;;------------------------\n \n (define-predicate person?)\n (define-operation (name obj))\n (define-operation (age obj))\n (define-operation (set-age! obj new-age))\n (define-operation (ssn obj password)) ;; Social Security # is protected\n (define-operation (new-password obj old-passwd new-passwd))\n (define-operation (bad-password obj bogus-passwd)\n   ;; assume internal (design) error\n   (error (format #f \"Bad Password: ~s given to ~a~%\"\n           bogus-passwd\n           (print-obj obj #f))))\n \n ;;----------------------------------\n ;; person implementation\n ;;----------------------------------\n \n (define (make-person a-name an-age a-ssn the-password)\n   (object\n     ((person? self) #t)\n     ((name self) a-name)\n     ((age self) an-age)\n     ((set-age! self val) (set! an-age val) an-age)\n     ((ssn self password)\n       (if (equal? password the-password)\n         a-ssn\n         (bad-password self password)))\n     ((new-password self old-passwd new-passwd)\n       (cond\n         ((equal? old-passwd the-password) (set! the-password new-passwd) self)\n         (else (bad-password self old-passwd))))\n     ((bad-password self bogus-passwd)\n       (format #t \"Bad password: ~s~%\" bogus-passwd)) ;; let user recover\n     ((print-obj self port)\n       (format port \"#<Person: ~a age: ~a>~%\" (name self) (age self)))))\n \n ;;;---------------------------------------------------------------\n ;; account-history and bank-account interfaces\n ;;----------------------------------------------------------------\n  \n (define-predicate bank-account?)\n (define-operation (current-balance obj pin))\n (define-operation (add obj amount))\n (define-operation (withdraw obj amount pin))\n (define-operation (get-pin obj master-password))\n (define-operation (get-account-history obj master-password))\n \n ;;----------------------------------------------\n ;; account-history implementation\n ;;----------------------------------------------\n \n ;; put access to bank database and report generation here\n (define (make-account-history initial-balance a-pin master-password)\n   ;; history is a simple list of balances -- no transaction times\n   (letrec \n     ((history (list initial-balance))\n      (balance (lambda () (car history))) ; balance is a function\n      (remember\n        (lambda (datum) (set! history (cons datum history)))))\n     (object\n       ((bank-account? self) #t)\n       ((add self amount) ;; bank will accept money without a password\n         (remember (+ amount (balance)))\n         ;; print new balance\n         (format #t \"New balance: $~a~%\" (balance)))\n       ((withdraw self amount pin)\n         (cond\n           ((not (equal? pin a-pin)) (bad-password self pin))\n           ((< (- (balance) amount) 0)\n             (format \n               #t\n               \"No overdraft~% Can't withdraw more than you have: $~a~%\"\n               (balance)))\n           (else\n             (remember (- (balance) amount))\n             (format #t \"New balance: $~a~%\" (balance)))))\n       ((current-balance self password)\n         (if (or (eq? password master-password) (equal? password a-pin))\n           (format #t \"Your Balance is $~a~%\" (balance))\n           (bad-password self password)))\n       ;; only bank has access to account history\n       ((get-account-history self password)\n         (if (eq? password master-password)\n           history\n           (bad-password self password))))))\n \n ;;;------------------------------------------\n ;; bank-account implementation\n ;;-------------------------------------------\n \n (define (make-account a-name an-age a-ssn a-pin initial-balance master-password)\n   (object-with-ancestors\n     ((customer (make-person a-name an-age a-ssn a-pin))\n      (account (make-account-history initial-balance a-pin master-password)))\n     ((get-pin self password)\n       (if (eq? password master-password)\n         a-pin\n         (bad-password self password)))\n     ((get-account-history self password)\n       (operate-as account get-account-history self password))\n     ;; our bank is very conservative...\n     ((bad-password self bogus-passwd)\n       (format #t \"~%CALL THE POLICE!!~%\"))\n     ;; protect the customer as well\n     ((ssn self password)\n       (operate-as customer ssn self password))\n     ((print-obj self port)\n       (format port \"#<Bank-Customer ~a>~%\" (name self)))))\n \n ;;; eof yasos-examples.scm\n \n ;;;============\n ;;; file: yasos-test.scm\n ;;;============") (pre " (require-extension yasos)\n \n (define main\n   (lambda ()\n     (let\n       ((p2 (make-point 1 2))\n        (p3 (make-point-3d 4 5 6))\n        (fred  (make-person  \"Fred\"  19 \"573-19-4279\" 'FadeCafe))\n        (sally (make-account \"Sally\" 26 \"629-26-9742\" 'FeedBabe 263 'bank-password)))\n       (printf \"(size-obj p2) => ~a (size-obj p3) => ~a~%\" (size-obj p2) (size-obj p3))\n       (print-obj 'mist #t)\n       (print-obj p2 #t)\n       (printf \"(point? p2) => ~A (point-3d? p2) => ~A~%\" (point? p2) (point-3d? p2))\n       (print-obj p3 #t)\n       (printf \"(point? p3) => ~A (point-3d? p3) => ~A~%\" (point? p3) (point-3d? p3))\n       (print-obj fred #t)\n       (printf \"Fred's ssn: ~a~%\" (ssn fred 'FadeCafe))\n       (printf \"Fred: person? ~a bank-account? ~a~%\" (person? fred) (bank-account? fred))\n       (print-obj sally #t)\n       (printf \"Sally's  ssn: ~a~%\" (ssn sally 'FeedBabe))\n       (printf \"Sally: person? ~a bank-account? ~a~%\" (person? sally) (bank-account? sally))\n       (current-balance sally 'FeedBabe)\n       (add sally 200)\n       (add sally 300)\n       (withdraw sally 400 'FeedBabe)\n       (printf \"Account history of Sally: ~a~%\" (get-account-history sally 'bank-password))\n       (withdraw sally 150 (get-pin sally 'bank-password))\n       (printf \"Account history of Sally: ~a~%\" (get-account-history sally 'bank-password))\n       (printf \"Bad password for Fred:~%\")\n       (ssn fred 'bogus)\n       (printf \"Bad password for Sally:\")\n       (ssn sally 'bogus)\n       (void) \n ) ) )   \n (main)\n \n ;;; eof yasos-test.scm")) (section 3 "Changelog" (ul (li "1.2 fixes in the setup script and simplification of the set of files") (li "1.1") (li "1.0"))) (section 3 "License" (pre " COPYRIGHT (c) 1992,2008 by Kenneth A Dickey, All rights reserved.\n \n Permission is hereby granted, free of charge, to any person obtaining\n a copy of this software and associated documentation files (the\n \"Software\"), to deal in the Software without restriction, including\n without limitation the rights to use, copy, modify, merge, publish,\n distribute, sublicense, and/or sell copies of the Software, and to\n permit persons to whom the Software is furnished to do so, subject to\n the following conditions:\n \n The above copyright notice and this permission notice shall be\n included in all copies or substantial portions of the Software.\n \n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION\n OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."))))