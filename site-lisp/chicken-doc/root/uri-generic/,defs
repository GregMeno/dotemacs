(index ("uri-reference" 0) ("uri-reference?" 318) ("absolute-uri" 685) ("absolute-uri?" 1161) ("uri?" 1277) ("relative-ref?" 1481) ("uri-path-absolute?" 1815) ("uri-path-relative?" 1961) ("uri-authority" 2106) ("uri-scheme" 2106) ("uri-path" 2106) ("uri-query" 2106) ("uri-fragment" 2106) ("uri-host" 2106) ("uri-port" 2106) ("uri-username" 2106) ("uri-password" 2106) ("authority?" 2106) ("authority-host" 2106) ("authority-port" 2106) ("authority-username" 2106) ("authority-password" 2106) ("update-uri" 3102) ("update-authority" 3102) ("uri->string" 3478) ("uri->list" 3810) ("uri-relative-to" 4026) ("uri-relative-from" 4224) ("uri-encode-string" 4765) ("uri-decode-string" 5192) ("uri-normalize-case" 5460) ("uri-normalize-path-segments" 5598) ("char-set:gen-delims" 5762) ("char-set:sub-delims" 5936) ("char-set:uri-reserved" 6138) ("char-set:uri-unreserved" 6357))
(def (sig (procedure "(uri-reference STRING) => URI" (id uri-reference))) (p "A URI reference is either a URI or a relative reference (RFC 3986, Section 4.1).  If the given string's prefix does not match the syntax of a scheme followed by a colon separator, then the given string is parsed as a relative reference."))
(def (sig (procedure "(uri-reference? URI) => BOOL" (id uri-reference?))) (p "Is the given object a URI reference?  " (b "All objects created by URI-generic constructors are URI references") "; they are either URIs or relative references.  The constructors below are just more strict checking versions of " (tt "uri-reference") ".  They all create URI references."))
(def (sig (procedure "(absolute-uri STRING) => URI" (id absolute-uri))) (p "Parses the given string as an absolute URI, in which no fragments are allowed.  If no URI scheme is found, or a fragment is detected, this raises an error.") (p "Absolute URIs are defined by RFC 3986 as non-relative URI references without a fragment (RFC 3986, Section 4.2).  Absolute URIs can be used as a base URI to resolve a relative-ref against, using " (tt "uri-relative-to") " (see below)."))
(def (sig (procedure "(absolute-uri? URI) => BOOL" (id absolute-uri?))) (p "Is the given object an absolute URI?"))
(def (sig (procedure "(uri? URI) => BOOL" (id uri?))) (p "Is the given object a URI?  URIs are all URI references that include a scheme part.  The other type of URI references are relative references."))
(def (sig (procedure "(relative-ref? URI) => BOOL" (id relative-ref?))) (p "Is the given object a relative reference?  Relative references are defined by RFC 3986 as URI references which are not URIs; they contain no URI scheme and can be resolved against an absolute URI to obtain a complete URI using " (tt "uri-relative-to") "."))
(def (sig (procedure "(uri-path-absolute? URI) => BOOL" (id uri-path-absolute?))) (p "Is the " (tt "URI") "'s path component an absolute path?"))
(def (sig (procedure "(uri-path-relative? URI) => BOOL" (id uri-path-relative?))) (p "Is the " (tt "URI") "'s path component a relative path?"))
(def (sig (procedure "(uri-authority URI) => URI-AUTH" (id uri-authority)) (procedure "(uri-scheme URI) => SYMBOL" (id uri-scheme)) (procedure "(uri-path URI) => LIST" (id uri-path)) (procedure "(uri-query URI) => STRING" (id uri-query)) (procedure "(uri-fragment) URI => STRING" (id uri-fragment)) (procedure "(uri-host URI) => STRING" (id uri-host)) (procedure "(uri-port URI) => INTEGER" (id uri-port)) (procedure "(uri-username URI) => STRING" (id uri-username)) (procedure "(uri-password URI) => STRING" (id uri-password)) (procedure "(authority? URI-AUTH) => BOOL" (id authority?)) (procedure "(authority-host URI-AUTH) => STRING" (id authority-host)) (procedure "(authority-port URI-AUTH) => INTEGER" (id authority-port)) (procedure "(authority-username URI-AUTH) => STRING" (id authority-username)) (procedure "(authority-password URI-AUTH) => STRING" (id authority-password))) (p "If a component is not defined in the given URI, then the corresponding accessor returns " (tt "#f") "."))
(def (sig (procedure "(update-uri URI #!key authority scheme path query fragment host port username password) => URI" (id update-uri)) (procedure "(update-authority URI-AUTH #!key host port username password) => URI" (id update-authority))) (p "Update the specified keys in the URI or URI-AUTH object in a functional way (ie, it creates a new copy with the modifications)."))
(def (sig (procedure "(uri->string URI [USERINFO]) => STRING" (id uri->string))) (p "Reconstructs the given URI into a string; uses a supplied function " (tt "LAMBDA USERNAME PASSWORD -> STRING") " to map the userinfo part of the URI.  If not given, it represents the userinfo as the username followed by " (tt "\":******\"") "."))
(def (sig (procedure "(uri->list URI USERINFO) => LIST" (id uri->list))) (p "Returns a list of the form " (tt "(SCHEME SPECIFIC FRAGMENT)") "; " (tt "SPECIFIC") " is of the form " (tt "(AUTHORITY PATH QUERY)") "."))
(def (sig (procedure "(uri-relative-to URI URI) => URI" (id uri-relative-to))) (p "Resolve the first URI as a reference relative to the second URI, returning a new URI (RFC 3986, Section 5.2.2)."))
(def (sig (procedure "(uri-relative-from URI URI) => URI" (id uri-relative-from))) (p "Constructs a new, possibly relative, URI which represents the location of the first URI with respect to the second URI.") (highlight scheme "(use uri-generic)\n(uri->string (uri-relative-to (uri-reference \"../qux\") (uri-reference \"http://example.com/foo/bar/\")))\n => \"http://example.com/foo/qux\"\n\n(uri->string (uri-relative-from (uri-reference \"http://example.com/foo/qux\") (uri-reference \"http://example.com/foo/bar/\")))\n => \"../qux\""))
(def (sig (procedure "(uri-encode-string STRING [CHAR-SET]) => STRING" (id uri-encode-string))) (p "Returns the percent-encoded form of the given string.  The optional char-set argument controls which characters should be encoded. It defaults to the complement of " (tt "char-set:uri-unreserved") ". This is always safe, but often overly careful; it is allowed to leave certain characters unquoted depending on the context."))
(def (sig (procedure "(uri-decode-string STRING [CHAR-SET]) => STRING" (id uri-decode-string))) (p "Returns the decoded form of the given string.  The optional char-set argument controls which characters should be decoded.  It defaults to " (tt "char-set:full") "."))
(def (sig (procedure "(uri-normalize-case URI) => URI" (id uri-normalize-case))) (p "URI case normalization (RFC 3986 section 6.2.2.1)"))
(def (sig (procedure "(uri-normalize-path-segments URI) => URI" (id uri-normalize-path-segments))) (p "URI path segment normalization (RFC 3986 section 6.2.2.3)"))
(def (sig (constant "char-set:gen-delims" (id char-set:gen-delims))) (p "Generic delimiters.") (pre " gen-delims  =  \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\""))
(def (sig (constant "char-set:sub-delims" (id char-set:sub-delims))) (p "Sub-delimiters.") (pre " sub-delims  =  \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\""))
(def (sig (constant "char-set:uri-reserved" (id char-set:uri-reserved))) (p "The union of " (tt "gen-delims") " and " (tt "sub-delims") "; all reserved URI characters.") (pre " reserved    =  gen-delims / sub-delims"))
(def (sig (constant "char-set:uri-unreserved" (id char-set:uri-unreserved))) (p "All unreserved characters that are allowed in a URI.") (pre " unreserved  =  ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"") (p "Note that this is _not_ the complement of " (tt "char-set:uri-reserved") "! There are several characters (even printable, noncontrol characters) which are not allowed at all in a URI."))
