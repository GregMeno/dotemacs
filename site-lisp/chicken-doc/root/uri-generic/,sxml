((tags "eggs") (toc) (section 2 "uri-generic" (section 3 "Description" (p "The " (tt "uri-generic") " library contains procedures for parsing and manipulation of Uniform Resource Identifiers (" (link "http://tools.ietf.org/html/rfc3986" "RFC 3986") "). It is intended to conform more closely to the RFC, and uses combinator parsing and character classes rather than regular expressions.") (p "This library should be considered to be a " (i "basis") " for creating scheme-specific URI parser libraries. This library only parses the generic components from a URI.  Any specific library can further parse subcomponents. For this reason, encoding and decoding of percent-encoded characters is not done automatically. This should be handled by specific URI scheme implementations.")) (section 3 "Library Procedures" (section 4 "Constructors and predicates" (p "As specified in section 2.3 of RFC 3986, URI constructors automatically decode percent-encoded octets in the range of unreserved characters. This means that the following holds true:") (pre "(equal? (uri-reference \"http://example.com/foo-bar\")\n        (uri-reference \"http://example.com/foo%2Dbar\"))  => #t") (def (sig (procedure "(uri-reference STRING) => URI" (id uri-reference))) (p "A URI reference is either a URI or a relative reference (RFC 3986, Section 4.1).  If the given string's prefix does not match the syntax of a scheme followed by a colon separator, then the given string is parsed as a relative reference.")) (def (sig (procedure "(uri-reference? URI) => BOOL" (id uri-reference?))) (p "Is the given object a URI reference?  " (b "All objects created by URI-generic constructors are URI references") "; they are either URIs or relative references.  The constructors below are just more strict checking versions of " (tt "uri-reference") ".  They all create URI references.")) (def (sig (procedure "(absolute-uri STRING) => URI" (id absolute-uri))) (p "Parses the given string as an absolute URI, in which no fragments are allowed.  If no URI scheme is found, or a fragment is detected, this raises an error.") (p "Absolute URIs are defined by RFC 3986 as non-relative URI references without a fragment (RFC 3986, Section 4.2).  Absolute URIs can be used as a base URI to resolve a relative-ref against, using " (tt "uri-relative-to") " (see below).")) (def (sig (procedure "(absolute-uri? URI) => BOOL" (id absolute-uri?))) (p "Is the given object an absolute URI?")) (def (sig (procedure "(uri? URI) => BOOL" (id uri?))) (p "Is the given object a URI?  URIs are all URI references that include a scheme part.  The other type of URI references are relative references.")) (def (sig (procedure "(relative-ref? URI) => BOOL" (id relative-ref?))) (p "Is the given object a relative reference?  Relative references are defined by RFC 3986 as URI references which are not URIs; they contain no URI scheme and can be resolved against an absolute URI to obtain a complete URI using " (tt "uri-relative-to") ".")) (def (sig (procedure "(uri-path-absolute? URI) => BOOL" (id uri-path-absolute?))) (p "Is the " (tt "URI") "'s path component an absolute path?")) (def (sig (procedure "(uri-path-relative? URI) => BOOL" (id uri-path-relative?))) (p "Is the " (tt "URI") "'s path component a relative path?"))) (section 4 "Attribute accessors" (def (sig (procedure "(uri-authority URI) => URI-AUTH" (id uri-authority)) (procedure "(uri-scheme URI) => SYMBOL" (id uri-scheme)) (procedure "(uri-path URI) => LIST" (id uri-path)) (procedure "(uri-query URI) => STRING" (id uri-query)) (procedure "(uri-fragment) URI => STRING" (id uri-fragment)) (procedure "(uri-host URI) => STRING" (id uri-host)) (procedure "(uri-port URI) => INTEGER" (id uri-port)) (procedure "(uri-username URI) => STRING" (id uri-username)) (procedure "(uri-password URI) => STRING" (id uri-password)) (procedure "(authority? URI-AUTH) => BOOL" (id authority?)) (procedure "(authority-host URI-AUTH) => STRING" (id authority-host)) (procedure "(authority-port URI-AUTH) => INTEGER" (id authority-port)) (procedure "(authority-username URI-AUTH) => STRING" (id authority-username)) (procedure "(authority-password URI-AUTH) => STRING" (id authority-password))) (p "If a component is not defined in the given URI, then the corresponding accessor returns " (tt "#f") ".")) (def (sig (procedure "(update-uri URI #!key authority scheme path query fragment host port username password) => URI" (id update-uri)) (procedure "(update-authority URI-AUTH #!key host port username password) => URI" (id update-authority))) (p "Update the specified keys in the URI or URI-AUTH object in a functional way (ie, it creates a new copy with the modifications)."))) (section 4 "String and List Representations" (def (sig (procedure "(uri->string URI [USERINFO]) => STRING" (id uri->string))) (p "Reconstructs the given URI into a string; uses a supplied function " (tt "LAMBDA USERNAME PASSWORD -> STRING") " to map the userinfo part of the URI.  If not given, it represents the userinfo as the username followed by " (tt "\":******\"") ".")) (def (sig (procedure "(uri->list URI USERINFO) => LIST" (id uri->list))) (p "Returns a list of the form " (tt "(SCHEME SPECIFIC FRAGMENT)") "; " (tt "SPECIFIC") " is of the form " (tt "(AUTHORITY PATH QUERY)") "."))) (section 4 "Reference Resolution" (def (sig (procedure "(uri-relative-to URI URI) => URI" (id uri-relative-to))) (p "Resolve the first URI as a reference relative to the second URI, returning a new URI (RFC 3986, Section 5.2.2).")) (def (sig (procedure "(uri-relative-from URI URI) => URI" (id uri-relative-from))) (p "Constructs a new, possibly relative, URI which represents the location of the first URI with respect to the second URI.") (highlight scheme "(use uri-generic)\n(uri->string (uri-relative-to (uri-reference \"../qux\") (uri-reference \"http://example.com/foo/bar/\")))\n => \"http://example.com/foo/qux\"\n\n(uri->string (uri-relative-from (uri-reference \"http://example.com/foo/qux\") (uri-reference \"http://example.com/foo/bar/\")))\n => \"../qux\""))) (section 4 "String encoding and decoding" (def (sig (procedure "(uri-encode-string STRING [CHAR-SET]) => STRING" (id uri-encode-string))) (p "Returns the percent-encoded form of the given string.  The optional char-set argument controls which characters should be encoded. It defaults to the complement of " (tt "char-set:uri-unreserved") ". This is always safe, but often overly careful; it is allowed to leave certain characters unquoted depending on the context.")) (def (sig (procedure "(uri-decode-string STRING [CHAR-SET]) => STRING" (id uri-decode-string))) (p "Returns the decoded form of the given string.  The optional char-set argument controls which characters should be decoded.  It defaults to " (tt "char-set:full") "."))) (section 4 "Normalization  " (def (sig (procedure "(uri-normalize-case URI) => URI" (id uri-normalize-case))) (p "URI case normalization (RFC 3986 section 6.2.2.1)")) (def (sig (procedure "(uri-normalize-path-segments URI) => URI" (id uri-normalize-path-segments))) (p "URI path segment normalization (RFC 3986 section 6.2.2.3)"))) (section 4 "Character sets" (p "As a convenience for sub-parsers or other special-purpose URI handling code, there are a couple of character sets exported by uri-generic.") (def (sig (constant "char-set:gen-delims" (id char-set:gen-delims))) (p "Generic delimiters.") (pre " gen-delims  =  \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"")) (def (sig (constant "char-set:sub-delims" (id char-set:sub-delims))) (p "Sub-delimiters.") (pre " sub-delims  =  \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"")) (def (sig (constant "char-set:uri-reserved" (id char-set:uri-reserved))) (p "The union of " (tt "gen-delims") " and " (tt "sub-delims") "; all reserved URI characters.") (pre " reserved    =  gen-delims / sub-delims")) (def (sig (constant "char-set:uri-unreserved" (id char-set:uri-unreserved))) (p "All unreserved characters that are allowed in a URI.") (pre " unreserved  =  ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"") (p "Note that this is _not_ the complement of " (tt "char-set:uri-reserved") "! There are several characters (even printable, noncontrol characters) which are not allowed at all in a URI.")))) (section 3 "Requires" (ul (li (int-link "matchable")) (li (int-link "defstruct")))) (section 3 "Version History" (ul (li "2.35 Added some extra checks so we do not try to parse URIs containing invalid (non-hexnum) percent-encoding.  Add code to preserve empty path segments during parsing and when performing relative reference resolution.") (li "2.34 Fix two bugs that show up in very rare cases (possibly never in practice). One caused issues when creating relative paths from two URIs where one URI had a path that was a prefix of the other, the other caused issues when a relative URI's path containing \"..\" as last component was resolved.") (li "2.33 Path component for empty absolute path directly followed by query is now represented the same as empty path without query.") (li "2.32 Empty absolute path directly followed by query is now properly recognised as an URI reference.") (li "2.31 Return " (tt "#f") " in constructors if unconsumed input remains after parsing") (li "2.3 Add predicates uri-path-relative? and uri-path-absolute?") (li "2.2 Improvements to uri->string.") (li "2.1 Add new predicates for URIs, absolute URIs and relative references. Fix absolute-uri so it raises a condition when passing in a non-absolute uri string, instead of returning a string with the error. Also throw an error if a fragment is detected in the string.") (li "2.0 Export char-sets, add char-set arg to uri-encode/uri-decode, do not decode query args as x-www-form-urlencoded, change path representation.  Lots of bugfixes.") (li "1.12 Fix relative path normalization when original path ends in a slash, remove consecutive slashes from paths in URIs") (li "1.11 Added accessors for the authority components, functional update procedures. Fixed case-normalization.") (li "1.10 Fixed edge case in " (tt "uri-relative-to") " with empty path in base uri, fixed " (tt "uri->string") " for URIs with query args, fixed " (tt "uri->string") " to not add an extraneous slash after authority in case of empty path.") (li "1.9 Fixed bug in uri-encode-string with reserved characters, added tests for decoding and encoding [Peter Bex]") (li "1.8 Added uri-encode-string and uri-decode-string.  URI constructors now perform automatic normalization of percent-encoded unreserved characters. [suggested by Peter Bex]") (li "1.6 Added error message about missing scheme in absolute-uri. ") (li "trunk Small bugfix in absolute-uri. [Peter Bex]") (li "1.5 Bug fixes in uri->string and absolute-uri. [reported by Peter Bex]") (li "1.3 Ported to Hygienic Chicken and the " (int-link "test") " egg [Peter Bex]") (li "1.2 Now using defstruct instead of define-record [suggested by Peter Bex]") (li "1.1 Added utf8 compatibility") (li "1.0 Initial Release"))) (section 3 "License" (p "Based on the " (link "http://www.ninebynine.org/Software/ReadMe-URI-Haskell.txt" "Haskell URI library") " by Graham Klyne <gk@ninebynine.org>.") (pre " Copyright 2008-2010 Ivan Raikov, Peter Bex.\n All rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n \n Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n \n Redistributions in binary form must reproduce the above copyright\n notice, this list of conditions and the following disclaimer in the\n documentation and/or other materials provided with the distribution.\n \n Neither the name of the author nor the names of its contributors may\n be used to endorse or promote products derived from this software\n without specific prior written permission.\n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n OF THE POSSIBILITY OF SUCH DAMAGE."))))