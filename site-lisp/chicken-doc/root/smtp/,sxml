((tags "eggs") (toc) (section 2 "smtp" (section 3 "Description" (p (tt "smtp") " is a collection of parser combinators and state machine primitives for the grammar defined in " (link "http://www.ietf.org/rfc/rfc5321.txt" "RFC 5321") " (Simple Mail Transfer Protocol).")) (section 3 "Data Types for SMTP Commands" (p "Represenation of SMTP commands:") (pre " \n(define-datatype cmd cmd?\n (Helo (s string?))\n (Ehlo (s string?))\n (MailFrom (m mailbox?) (parameters list?))\n (RcptTo   (m mailbox?) (parameters list?))\n (Data)\n (Rset)\n (Send  (m mailbox?))\n (Soml  (m mailbox?))\n (Saml  (m mailbox?))\n (Vrfy  (s string?))\n (Expn  (s string?))\n (Help  (s string?))\n (Noop)\n (Quit)\n (Turn)\n (WrongArg (cmd string?)  (message string?)))") (p "The record printer defined for this datatype prints values of this type in a format conforming to the RFC. For example:") (pre " csi> (print (Helo \"myhost.org\"))\n HELO myhost.org") (p "The " (tt "mailbox") " datatype has the following definition:") (pre "(define-datatype mailbox mailbox?\n  (Mailbox (local-part string?) \n           (domain string?)))")) (section 3 "Data Types for SMTP Replies " (p "Representation of SMTP replies:") (pre " (define-datatype reply reply?\n  (Reply (code code?) (msg list?)))") (p "An SMTP reply is a three-digit return code plus comments. This is what the list of strings is for; one string per line in the reply.  the record printer will append an CRLF end-of-line marker to each entry in that list, so that the resulting string is ready to be sent back to the peer.") (p "For example:") (pre "> (print (Reply (Code (Success) (MailSystem) 0)\n                    (list \"worked\" \"like\" \"a charm\")))\n250-worked\n250-like\n250 a charm") (p "The " (tt "code") " datatype consists of success code, category and supplemental code:") (pre "(define-datatype code code?\n  (Code (suc success-code?) (cat category?) (num integer?)))") (p "In addition, the " (tt "success-code") " and " (tt "category") " datatypes can be used to map symbolic identifiers to integers and vice versa:") (pre "(define-enumerated-type \n  success-code success-code? success-vector \n  success-code-inject success-code-project \n  (Unused)\n  (PreliminarySuccess)\n  (Success)\n  (IntermediateSuccess)\n  (TransientFailure)\n  (PermanentFailure))") (pre "(define-enumerated-type \n  category category? category-vector\n  category-inject category-project\n  (Syntax)\n  (Information)\n  (Connection)\n  (Unspecified3)\n  (Unspecified4)\n  (MailSystem))") (p (tt "define-enumerated-type") " defines a new record type, with as many instances as there are instance names. " (tt "name-vector") " is bound to a vector containing the instances of the type in the same order as the " (tt "instance-name") " list. " (tt "name-inject") " and " (tt "name-project") " are procedures that map integers to an instance and vice versa.")) (section 3 "ESMTP State Machine" (p "The procedure that initializes the state machine mechanism of this library is provided as a field of the " (tt "<SMTP>") " typeclass. Please see the " (int-link "typeclass") " library for information on type classes.") (p "The " (tt "<SMTP>") " typeclass is intended to provide abstraction over different kinds of input sequences, e.g. character lists, strings, streams, etc. " (tt "<SMTP>") " inherits from " (tt "<CoreABNF>") ", which provides the core parsing primitives used to build the SMTP grammar parser (see the " (int-link "abnf") " library for more information).") (p "The following example illustrates the creation of an instance of " (tt "<SMTP>") " specialized for character lists.") (highlight scheme "(use datatype typeclass smtp abnf)\n\n(define char-list-<Input>\n  (make-<Input> null? car cdr))\n\n(define char-list-<Token>\n  (Input->Token char-list-<Input>))\n\n(define char-list-<CharLex>\n  (Token->CharLex char-list-<Token>))\n\n(define char-list-<CoreABNF>\n  (Token.CharLex->CoreABNF char-list-<Token> \n\t\t\t   char-list-<CharLex>))\n\n(define char-list-<SMTP>\n  (CoreABNF->SMTP char-list-<CoreABNF> ))\n\n(import-instance (<SMTP> char-list-<SMTP>))") (def (sig (procedure "(start-session)" (id start-session))) (p "Procedure " (tt "start-session") " returns an ESMTP state machine object (a procedure), which takes in a stream containing an SMTP command and returns an appropriate " (tt "session-fsm") " value:") (pre " (define-datatype session-fsm session-fsm?\n   (Event (ev event?))\n   (Trans (ev event?) (fsm procedure?)))") (p "A stream in this case is defined as the representation used by the " (int-link "abnf") " library.") (p "The " (tt "Event") " variant signals an event that must be processed by the calling library, while " (tt "Trans") " signals an event and a state machine transition. The following events can be returned by this state machine:") (pre "(define-datatype event event?\n  (SayHelo       (s string?))\n  (SayHeloAgain  (s string?))\n  (SayEhlo       (s string?))\n  (SayEhloAgain  (s string?))\n  (SetMailFrom   (m mailbox?) (parameters? list))\n  (AddRcptTo     (m mailbox?) (parameters? list))\n  (StartData)\n  (NeedHeloFirst)\n  (NeedMailFromFirst)\n  (NeedRcptToFirst)\n  (NotImplemented) ;; Turn, Send, Soml, Saml, Vrfy, Expn.\n  (ResetState)\n  (SayOK)\n  (SeeksHelp    (s string?))\n  (Shutdown)\n  (SyntaxErrorIn (s string?))\n  (Unrecognized  (s string?)))"))) (section 3 "Requires" (ul (li (int-link "abnf")) (li (int-link "datatype")) (li (int-link "matchable")) (li (int-link "typeclass")))) (section 3 "Examples" (highlight scheme "\n;; An example MTA implementation\n\n(use datatype smtp typeclass abnf)\n\n(define char-list-<Input>\n  (make-<Input> null? car cdr))\n\n(define char-list-<Token>\n  (Input->Token char-list-<Input>))\n\n(define char-list-<CharLex>\n  (Token->CharLex char-list-<Token>))\n\n(define char-list-<CoreABNF>\n  (Token.CharLex->CoreABNF char-list-<Token> \n\t\t\t   char-list-<CharLex>))\n\n\n(define char-list-<SMTP>\n  (CoreABNF->SMTP char-list-<CoreABNF> ))\n\n(import-instance (<SMTP> char-list-<SMTP>))\n\n(define domain    \"example.net\")\n(define host      \"chicken-mta\")\n(define mailfrom  (make-parameter #f))\n(define rcpto     (make-parameter '()))\n(define data      (make-parameter #f))\n\n(define (handle-event ev)\n  (cases event ev\n\t (SayHelo (s)\n\t  (Reply (Code (Success) (MailSystem) 0)\n\t\t (list host \" \" \"Hello \" s)))\n\t \n\t (SayHeloAgain (s)\n\t  (Reply (Code (Success) (MailSystem) 0)\n\t\t (list host \" \" \"Hello \" s)))\n\n\t (SayEhlo (s)\n\t  (Reply (Code (Success) (MailSystem) 0)\n\t\t (list host \" \" \"Hello \" s)))\n\t \n\t (SayEhloAgain (s)\n\t  (Reply (Code (Success) (MailSystem) 0)\n\t\t (list host \" \" \"Hello \" s)))\n\t \n\t (SetMailFrom (m)\n\t   (mailfrom m)\n\t   (Reply (Code (Success) (MailSystem) 0) \n\t\t  (list \"OK\")))\n\n\t (AddRcptTo (m)\n\t    (if (not (mailfrom))\n\t       (Reply (Code (PermanentFailure) (Syntax) 3)\n\t   \t      (list \"command out of sequence\"))\n\t       (begin\n\t\t (rcpto (cons m (rcpto)))\n\t\t (Reply (Code (Success) (MailSystem) 0) \n\t\t\t(list \"Accepted\")))))\n\n\t (StartData ()\n\t    (if (not (rcpto))\n\t       (Reply (Code (PermanentFailure) (MailSystem) 4)\n\t   \t      (list \"no valid recipients\"))\n\t       (begin\n\t\t (data (list))\n\t\t (Reply (Code (IntermediateSuccess) (MailSystem) 4)\n\t\t\t(list \"Ready\")))))\n\n\t (NeedHeloFirst ()\n\t   (Reply (Code (PermanentFailure) (Syntax) 3)\n\t   \t      (list \"command out of sequence: \"\n\t\t\t    \"need HELO first\")\n\t\t      ))\n\n\t (NeedMailFromFirst ()\n\t   (Reply (Code (PermanentFailure) (Syntax) 3)\n\t   \t      (list \"command out of sequence: \"\n\t\t\t    \"need MAIL first\")\n\t\t      ))\n\n\t (NeedMailRcptToFirst ()\n\t   (Reply (Code (PermanentFailure) (Syntax) 3)\n\t   \t      (list \"command out of sequence: \"\n\t\t\t    \"need RCPT first\")\n\t\t      ))\n\n\t (NotImplemented ()\n\t   (Reply (Code (PermanentFailure) (Syntax) 2)\n\t\t  (list \"command not implemented\")))\n\n\n\t (ResetState ()\n\t     (mailfrom #f)\n\t     (rcpto    #f)\n\t     (data     #f)\n\t     (Reply (Code (Success) (MailSystem) 0) \n\t\t    (list \"Reset OK\")))\n\n\t (SayOK ()\n\t     (Reply (Code (Success) (MailSystem) 0) \n\t\t    (list \"OK\")))\n\n\t (SeeksHelp (s)\n\t     (Reply (Code (Success) (Information) 4) \n\t\t    (list \"Commands supported:\"\n\t\t\t  \"HELO EHLO MAIL RCPT DATA QUIT RSET NOOP HELP\")))\n\n\t (Shutdown ()\n\t    (Reply (Code (Success) (MailSystem) 1)\n\t\t   (list host \" closing connection\")))\n\n\t (SyntaxErrorIn (s)\n\t    (Reply (Code (PermanentFailure) (Syntax) 1)\n\t\t   (list \"syntax error in \" s)))\n\n\t (Unrecognized (s)\n\t    (Reply (Code (PermanentFailure) (Syntax) 0)\n\t\t   (list \"Unrecognized \" s)))\n\t ))\n\n;; from SSAX lib\n(define (peek-next-char port)\n  (read-char port) \n  (peek-char port))\n\n(define (read-smtp-line port)\n  (let loop ((cs (list)))\n    (let ((c (peek-char port)))\n    (if (eof-object? c) (reverse cs)\n\t(let ((n (peek-next-char port)))\n\t  (cond ((and (eq? n #\\newline) (eq? c #\\return))\n\t\t (begin\n\t\t   (read-char port)\n\t\t   (reverse (cons* n c cs)))\n\t\t )\n\t\t(else (loop (cons c cs)))))))))\n\n(define data-end (list #\\. #\\return #\\newline))\n      \n(define (handle-data in out cont)\n  (let loop ((tempdata (list)))\n    (let ((line (read-smtp-line in)))\n      (if (equal? line data-end)\n\t  (begin (data (reverse tempdata))\n\t\t (fprintf out \"~A\" \n\t\t\t  (Reply (Code (Success) (MailSystem) 0) (list \"OK\")))\n\t\t (cont)) \n\t  (loop (cons (list->string line) tempdata))))))\n\n(define (main in out)  \n  (let loop ((fsm (start-session)))\n    (let ((line     (read-smtp-line in)))\n      (if (null? line) (loop fsm)\n\t  (let ((instream (list `(() ,line))))\n\t    (let-values\n\t     (((reply ev fsm)\n\t       (cases session-fsm (fsm instream)\n\t\t      (Event (ev)\n\t\t\t     (let ((reply (handle-event ev)))\n\t\t\t       (values reply ev fsm)))\n\t\t      (Trans (ev fsm)\n\t\t\t     (let ((reply (handle-event ev)))\n\t\t\t       (values reply ev fsm))))))\n\t     (fprintf out \"~A\" reply)\n\t     (cases event ev\n\t\t    (StartData ()\n\t\t\t       (handle-data in out (lambda () (loop fsm))))\n\t\t    (Shutdown ()\n\t\t\t      (begin))\n\t\t    (else (loop fsm)))))))))\n\t\t     \n\n")) (section 3 "Version History" (ul (li "2.1 Small fixes in the predicates of the RcptTo and MailFrom constructors") (li "2.0 Implemented typeclass interface") (li "1.0 Initial release"))) (section 3 "License" (p "Based on the Haskell Rfc2821 module by Peter Simons.") (pre " Copyright 2009-2010 Ivan Raikov and the Okinawa Institute of Science and Technology.") (pre " This program is free software: you can redistribute it and/or\n modify it under the terms of the GNU General Public License as\n published by the Free Software Foundation, either version 3 of the\n License, or (at your option) any later version.") (pre " This program is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n General Public License for more details.") (pre " A full copy of the GPL license can be found at\n <http://www.gnu.org/licenses/>."))))