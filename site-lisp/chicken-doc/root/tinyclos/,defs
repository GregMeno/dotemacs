(index ("define-class" 0) ("define-generic" 1013) ("define-method" 1457) ("add-method" 3167) ("make" 3363) ("make-class" 3680) ("define-class*" 3950) ("make-generic" 4625) ("make-method" 4790) ("slot-set!" 5142) ("set!" 5142) ("slot-ref" 5899) ("slot-value" 5899) ("class-cpl" 6133) ("class-direct-slots" 6282) ("class-direct-supers" 6496) ("class-of" 6642) ("class-name" 6857) ("class-slots" 6963) ("generic-methods" 7181) ("method-specializers" 7357) ("method-procedure" 7514) ("instance?" 7674) ("class?" 7863) ("generic?" 7983) ("subclass?" 8090) ("instance-of?" 8318) ("generic-name" 8518) ("slot@" 8661) ("initialize-slots" 9022) ("make/copy" 9519) ("register-primitive-class-of" 9769) ("add-primitive-class-of" 10076) ("add-structure-class-of" 10076) ("add-tagged-pointer-class-of" 10076) ("add-extended-procedure-class-of" 10076) ("delete-primitive-class-of" 10676) ("delete-structure-class-of" 10676) ("delete-tagged-pointer-class-of" 10676) ("delete-extended-procedure-class-of" 10676))
(def (sig (syntax "(define-class NAME (SUPERCLASS ...) (SLOT-NAME ...) [METACLASS])" (id define-class))) (p "Sets the variable " (tt "NAME") " to a new class: a new instance of the class " (tt "<class>") " or " (tt "METACLASS") ", if supplied.") (p (tt "SUPERCLASS ...") " is a list of superclasses of the newly created class. If no superclasses are given, then " (tt "<object>") " is assumed.") (p (tt "SLOT-NAME ...") " are the names of the direct slots of the class. A " (tt "SLOT-NAME") " is a " (tt "symbol") ".") (p "By convention, identifiers bound to classes in TinyCLOS are denoted by angle brackets as above. This is not required, however. A class may be bound to any identifier without affecting the behavior of the system.") (highlight scheme "(define-class NAME (SUPERCLASS ...) (SLOT-NAME ...) METACLASS)") (p "is equivalent to") (highlight scheme "(define NAME\n  (make METACLASS\n        'name 'NAME\n        'direct-supers (list SUPERCLASS ...)\n        'direct-slots (list 'SLOT-NAME ...)) )"))
(def (sig (syntax "(define-generic NAME [CLASS])" (id define-generic))) (p "Binds the variable " (tt "NAME") " to a fresh generic function object without associated methods. If the optional argument " (tt "CLASS") " is given, then the generic function will be an instance of that class.") (p "The new generic function cannot be called until appropriate methods are defined. To do that, use " (tt "add-method") " or " (tt "define-method") "."))
(def (sig (syntax "(define-method (NAME (VARIABLE1 CLASS1) ... ARGUMENT ...) BODY ...)" (id define-method))) (p "Adds a new method with the code " (tt "BODY ...") " to the generic function bound to " (tt "NAME") ".") (p (tt "CLASS1 ...") " is a list if classes that specialize this particular method.") (p "The method can have additional " (tt "ARGUMENTS") ", which do not specialize the method any further. Extended lambda-lists are allowed (argument lists with " (tt "#!optional") ", " (tt "#!key") ", and/or " (tt "#!rest") "), but cannot be specialized.") (p "Inside the " (tt "BODY ...") " of the method the identifier " (tt "call-next-method") " names a procedure of zero arguments that can be invoked to call the next applicable method with the same arguments.") (highlight scheme "; Create new generic\n(define-generic square-number?)\n\n; Provide a method to operate on integers\n(define-method (square-number? (n <integer>))\n  (and (positive? n)\n    (let ((sq (truncate (sqrt n))))\n      (= (* sq sq) n))))\n\n; Provide a method to operate on inexact numbers\n(define-method (square-number? (n <inexact>)) #f)") (p "This example also shows that generics can be used without creating classes. It exploits the primitive class system of TinyCLOS, in which all Scheme objects are members of a built-in class hierarchy.") (p "It is an error to use " (tt "define-method") " if no generic function is bound to " (tt "NAME") ". " (b "This is a change from previous versions of TinyCLOS.")) (p "Currently methods defined with " (tt "define-method") " should not be hidden (via " (tt "(declare (hide ...))") ", nor should such files be compiled in " (tt "block") " mode, unless the methods are exported."))
(def (sig (procedure "(add-method GENERIC METHOD)" (id add-method))) (p "Adds the method object " (tt "METHOD") " to the list of applicable methods for the generic function " (tt "GENERIC") "."))
(def (sig (procedure "(make CLASS INITARG ...)" (id make))) (p "Creates a new instance of " (tt "CLASS") " and passes " (tt "INITARG ...") " to the " (tt "initialize") " method of this class.") (p "If " (tt "CLASS") " is the " (tt "<primitive>") " class, the result of this procedure is " (tt "#<unspecified>") "."))
(def (sig (procedure "(make-class SUPERCLASSES SLOT-NAMES)" (id make-class))) (p "Creates a new class object, where " (tt "SUPERCLASSES") " should be the list of direct superclass objects and " (tt "SLOT-NAMES") " is a list of symbols naming the slots of this class."))
(def (sig (syntax "(define-class* (SUPERCLASS1 ...) (SLOT-NAME1 ...) [METACLASS])" (id define-class*))) (p "This macro returns a new anonymous class defined using syntax similar to " (tt "define-class") ". As in " (tt "define-class") " the " (tt "superclass") " and " (tt "slotname") " lists are not quoted.") (p (tt "(let ((CLASS (define-class* (SUPER) (SLOT1 SLOT2) METACLASS))) ...)")) (p "is equivalent to") (p (tt "(let ((CLASS (make METACLASS (list SUPER) (list 'SLOT1 'SLOT2)))) ...)")) (p "and") (p (tt "(let ((CLASS (define-class* () (SLOT1 SLOT2)))) ...)")) (p "is equivalent to") (p (tt "(let ((CLASS (make <class> (list <object>) (list 'SLOT1 'SLOT2)))) ...)")))
(def (sig (procedure "(make-generic [NAME]) => generic" (id make-generic))) (p "Creates a new generic function object.") (p (tt "NAME") " is a " (tt "string") "."))
(def (sig (procedure "(make-method SPECIALIZERS PROC)" (id make-method))) (p "Creates a new method object specialized to the list of classes in " (tt "SPECIALIZERS") ".") (highlight scheme "(define-method (foo (x <bar>)) 123)") (pre " <=>") (highlight scheme "(add-method foo\n  (make-method\n   (list <bar>)\n   (lambda (call-next-method x) 123)))"))
(def (sig (procedure "(slot-set! INSTANCE SLOT-NAME VALUE)" (id slot-set!)) (setter "(set! (slot-ref INSTANCE SLOT-NAME) VALUE)" (id set!))) (p "Sets the value of the slot " (tt "SLOT-NAME") " of the object " (tt "INSTANCE") " to " (tt "VALUE") ".") (p (i "Note") " that a " (tt "SLOT-NAME") " is not required to be a " (tt "symbol") ", so the following is perfectly valid:") (highlight scheme "(define hidden-slot (list 'hidden))\n(define <myclass>\n  (make <class>\n        'direct-supers (list <object>)\n        'direct-slots (list hidden-slot) ) )\n(define x1 (make <myclass>)\n(slot-set! x1 hidden-slot 99)") (p "To exploit this, however, the " (tt "make") " call has to be used as above. " (tt "define-class") " only supports symbolic slot names."))
(def (sig (procedure "(slot-ref INSTANCE SLOT-NAME) => *" (id slot-ref)) (procedure "(slot-value INSTANCE SLOT-NAME) => *" (id slot-value))) (p "Returns the value of the slot " (tt "SLOT-NAME") " of the object " (tt "INSTANCE") "."))
(def (sig (procedure "(class-cpl CLASS) => list" (id class-cpl))) (p "Returns the class-precedence-list of " (tt "CLASS") " as a list of classes."))
(def (sig (procedure "(class-direct-slots CLASS) => list" (id class-direct-slots))) (p "Returns the list of direct slots of " (tt "CLASS") " as a list of lists, where each sublist contains the name of the slot."))
(def (sig (procedure "(class-direct-supers CLASS)" (id class-direct-supers))) (p "Returns the list of direct superclasses of " (tt "CLASS") "."))
(def (sig (procedure "(class-of X) => class" (id class-of))) (p "Returns the class that the object " (tt "X") " is an instance of.") (p "See Extensions below for an API to extend the set of \"built-in\" classes."))
(def (sig (procedure "(class-name CLASS) => *" (id class-name))) (p "Returns name of " (tt "CLASS") "."))
(def (sig (procedure "(class-slots CLASS) => list" (id class-slots))) (p "Returns the list of all slots of " (tt "CLASS") " and its superclasses as a list of lists, where each sublist contains the name of the slot."))
(def (sig (procedure "(generic-methods GENERIC) => list" (id generic-methods))) (p "Returns the list of all methods associated with the generic function " (tt "GENERIC") "."))
(def (sig (procedure "(method-specializers METHOD) => list" (id method-specializers))) (p "Returns the list of classes that specialize " (tt "METHOD") "."))
(def (sig (procedure "(method-procedure METHOD) => procedure" (id method-procedure))) (p "Returns the procedure that contains the body of " (tt "METHOD") "."))
(def (sig (procedure "(instance? X) => boolean" (id instance?))) (p "Is " (tt "X") " an instance of a non-primitive class?") (p "A generic procedure is considered an " (i "instance") "."))
(def (sig (procedure "(class? X) => boolean" (id class?))) (p "Is " (tt "X") " an instance of a non-primitive class?"))
(def (sig (procedure "(generic? X) => boolean" (id generic?))) (p "Is " (tt "X") " a generic procedure?"))
(def (sig (procedure "(subclass? CLASS1 CLASS2) => boolean" (id subclass?))) (p "Is " (tt "CLASS1") " a subclass of " (tt "CLASS2") "?") (p "Note that the following holds:") (highlight scheme "(subclass? CLASS CLASS) ;==> #t"))
(def (sig (procedure "(instance-of? X CLASS) => boolean" (id instance-of?))) (p "Is " (tt "X") " an instance of a subclass of " (tt "CLASS") "?") (p "Remember that a class is a subclass of itself."))
(def (sig (procedure "(generic-name X) => string" (id generic-name))) (p "The name of the generic procedure " (tt "X") ", or " (tt "#f") "."))
(def (sig (syntax "(slot@ OBJECT SLOT-NAME ... [= VALUE])" (id slot@))) (p "Object slots are de-referenced by name left-to-right, with an optional last slot assignment.") (highlight scheme "(slot@ foo x y)           ;=> (slot-ref (slot-ref foo 'x) 'y)\n(slot@ foo x y = \"bar\")   ;=> (slot-set! (slot-ref foo 'x) 'y \"bar\")") (p "Symbolic slot-names only."))
(def (sig (procedure "(initialize-slots INSTANCE INITARGS)" (id initialize-slots))) (p "This procedure takes a sequence of alternating slot-names and initialization values in " (tt "INITARGS") " and initializes the corresponding slots in " (tt "INSTANCE") ".") (highlight scheme "(define-class <pos> () (x y))\n\n(define-method (initialize (pos <pos>) initargs)\n  (call-next-method)\n  (initialize-slots pos initargs))\n\n(define p1 (make <pos> 'x 1 'y 2))\n(define p2 (make <pos> 'x 3 'y 5))"))
(def (sig (procedure "(make/copy INSTANCE [INITARGS])" (id make/copy))) (p "Returns a copy of the object " (tt "INSTANCE") ". " (tt "INITARGS") " is the list of initialization arguments that will override the " (tt "INSTANCE") " copy slot values."))
(def (sig (procedure "(register-primitive-class-of FUNCTION) => (union #f class)" (id register-primitive-class-of))) (p (tt "FUNCTION") " is a " (tt "(procedure (*) *)") " taking a single argument, the object to test, and returning a " (tt "class") " when the object is known or " (tt "#f") " otherwise."))
(def (sig (procedure "(add-primitive-class-of CLASS PREDICATE)" (id add-primitive-class-of)) (procedure "(add-structure-class-of CLASS TAG)" (id add-structure-class-of)) (procedure "(add-tagged-pointer-class-of CLASS TAG)" (id add-tagged-pointer-class-of)) (procedure "(add-extended-procedure-class-of CLASS PREDICATE)" (id add-extended-procedure-class-of))) (p "Extends " (tt "class-of") " with the supplied " (tt "CLASS") " and identity detection.") (p "Any existing entry with matching " (tt "PREDICATE") " or " (tt "TAG") " will be replaced!") (p "Does not verify the types of its' arguments."))
(def (sig (procedure "(delete-primitive-class-of CLASS)" (id delete-primitive-class-of)) (procedure "(delete-structure-class-of CLASS)" (id delete-structure-class-of)) (procedure "(delete-tagged-pointer-class-of CLASS)" (id delete-tagged-pointer-class-of)) (procedure "(delete-extended-procedure-class-of CLASS)" (id delete-extended-procedure-class-of))) (p "Just removes the supplied " (tt "CLASS") " from " (tt "class-of") ", if it exists.") (p "Does not verify the types of its' arguments."))
