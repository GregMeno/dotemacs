((tags "egg") (section 2 "TinyCLOS" (toc)) (section 2 "Introduction" (p "This extension is a port of " (link "http://en.wikipedia.org/wiki/Gregor_Kiczales" "Gregor Kiczales") " " (b "TinyCLOS") " with numerous modifications.") (p "Note: you might consider taking a look at " (int-link "/eggref/4/coops" "coops") " for a more up-to-date CLOS-like object system for CHICKEN.")) (section 2 "Defining Forms" (section 3 "define-class" (def (sig (syntax "(define-class NAME (SUPERCLASS ...) (SLOT-NAME ...) [METACLASS])" (id define-class))) (p "Sets the variable " (tt "NAME") " to a new class: a new instance of the class " (tt "<class>") " or " (tt "METACLASS") ", if supplied.") (p (tt "SUPERCLASS ...") " is a list of superclasses of the newly created class. If no superclasses are given, then " (tt "<object>") " is assumed.") (p (tt "SLOT-NAME ...") " are the names of the direct slots of the class. A " (tt "SLOT-NAME") " is a " (tt "symbol") ".") (p "By convention, identifiers bound to classes in TinyCLOS are denoted by angle brackets as above. This is not required, however. A class may be bound to any identifier without affecting the behavior of the system.") (highlight scheme "(define-class NAME (SUPERCLASS ...) (SLOT-NAME ...) METACLASS)") (p "is equivalent to") (highlight scheme "(define NAME\n  (make METACLASS\n        'name 'NAME\n        'direct-supers (list SUPERCLASS ...)\n        'direct-slots (list 'SLOT-NAME ...)) )"))) (section 3 "define-generic" (def (sig (syntax "(define-generic NAME [CLASS])" (id define-generic))) (p "Binds the variable " (tt "NAME") " to a fresh generic function object without associated methods. If the optional argument " (tt "CLASS") " is given, then the generic function will be an instance of that class.") (p "The new generic function cannot be called until appropriate methods are defined. To do that, use " (tt "add-method") " or " (tt "define-method") "."))) (section 3 "define-method" (def (sig (syntax "(define-method (NAME (VARIABLE1 CLASS1) ... ARGUMENT ...) BODY ...)" (id define-method))) (p "Adds a new method with the code " (tt "BODY ...") " to the generic function bound to " (tt "NAME") ".") (p (tt "CLASS1 ...") " is a list if classes that specialize this particular method.") (p "The method can have additional " (tt "ARGUMENTS") ", which do not specialize the method any further. Extended lambda-lists are allowed (argument lists with " (tt "#!optional") ", " (tt "#!key") ", and/or " (tt "#!rest") "), but cannot be specialized.") (p "Inside the " (tt "BODY ...") " of the method the identifier " (tt "call-next-method") " names a procedure of zero arguments that can be invoked to call the next applicable method with the same arguments.") (highlight scheme "; Create new generic\n(define-generic square-number?)\n\n; Provide a method to operate on integers\n(define-method (square-number? (n <integer>))\n  (and (positive? n)\n    (let ((sq (truncate (sqrt n))))\n      (= (* sq sq) n))))\n\n; Provide a method to operate on inexact numbers\n(define-method (square-number? (n <inexact>)) #f)") (p "This example also shows that generics can be used without creating classes. It exploits the primitive class system of TinyCLOS, in which all Scheme objects are members of a built-in class hierarchy.") (p "It is an error to use " (tt "define-method") " if no generic function is bound to " (tt "NAME") ". " (b "This is a change from previous versions of TinyCLOS.")) (p "Currently methods defined with " (tt "define-method") " should not be hidden (via " (tt "(declare (hide ...))") ", nor should such files be compiled in " (tt "block") " mode, unless the methods are exported.")))) (section 2 "Base Language" (section 3 "add-method" (def (sig (procedure "(add-method GENERIC METHOD)" (id add-method))) (p "Adds the method object " (tt "METHOD") " to the list of applicable methods for the generic function " (tt "GENERIC") "."))) (section 3 "make" (def (sig (procedure "(make CLASS INITARG ...)" (id make))) (p "Creates a new instance of " (tt "CLASS") " and passes " (tt "INITARG ...") " to the " (tt "initialize") " method of this class.") (p "If " (tt "CLASS") " is the " (tt "<primitive>") " class, the result of this procedure is " (tt "#<unspecified>") "."))) (section 3 "make-class" (def (sig (procedure "(make-class SUPERCLASSES SLOT-NAMES)" (id make-class))) (p "Creates a new class object, where " (tt "SUPERCLASSES") " should be the list of direct superclass objects and " (tt "SLOT-NAMES") " is a list of symbols naming the slots of this class."))) (section 3 "define-class*" (def (sig (syntax "(define-class* (SUPERCLASS1 ...) (SLOT-NAME1 ...) [METACLASS])" (id define-class*))) (p "This macro returns a new anonymous class defined using syntax similar to " (tt "define-class") ". As in " (tt "define-class") " the " (tt "superclass") " and " (tt "slotname") " lists are not quoted.") (p (tt "(let ((CLASS (define-class* (SUPER) (SLOT1 SLOT2) METACLASS))) ...)")) (p "is equivalent to") (p (tt "(let ((CLASS (make METACLASS (list SUPER) (list 'SLOT1 'SLOT2)))) ...)")) (p "and") (p (tt "(let ((CLASS (define-class* () (SLOT1 SLOT2)))) ...)")) (p "is equivalent to") (p (tt "(let ((CLASS (make <class> (list <object>) (list 'SLOT1 'SLOT2)))) ...)")))) (section 3 "make-generic" (def (sig (procedure "(make-generic [NAME]) => generic" (id make-generic))) (p "Creates a new generic function object.") (p (tt "NAME") " is a " (tt "string") "."))) (section 3 "make-method" (def (sig (procedure "(make-method SPECIALIZERS PROC)" (id make-method))) (p "Creates a new method object specialized to the list of classes in " (tt "SPECIALIZERS") ".") (highlight scheme "(define-method (foo (x <bar>)) 123)") (pre " <=>") (highlight scheme "(add-method foo\n  (make-method\n   (list <bar>)\n   (lambda (call-next-method x) 123)))"))) (section 3 "slot-set!" (def (sig (procedure "(slot-set! INSTANCE SLOT-NAME VALUE)" (id slot-set!)) (setter "(set! (slot-ref INSTANCE SLOT-NAME) VALUE)" (id set!))) (p "Sets the value of the slot " (tt "SLOT-NAME") " of the object " (tt "INSTANCE") " to " (tt "VALUE") ".") (p (i "Note") " that a " (tt "SLOT-NAME") " is not required to be a " (tt "symbol") ", so the following is perfectly valid:") (highlight scheme "(define hidden-slot (list 'hidden))\n(define <myclass>\n  (make <class>\n        'direct-supers (list <object>)\n        'direct-slots (list hidden-slot) ) )\n(define x1 (make <myclass>)\n(slot-set! x1 hidden-slot 99)") (p "To exploit this, however, the " (tt "make") " call has to be used as above. " (tt "define-class") " only supports symbolic slot names."))) (section 3 "slot-ref") (section 3 "slot-value" (def (sig (procedure "(slot-ref INSTANCE SLOT-NAME) => *" (id slot-ref)) (procedure "(slot-value INSTANCE SLOT-NAME) => *" (id slot-value))) (p "Returns the value of the slot " (tt "SLOT-NAME") " of the object " (tt "INSTANCE") ".")))) (section 2 "Introspection" (section 3 "class-cpl" (def (sig (procedure "(class-cpl CLASS) => list" (id class-cpl))) (p "Returns the class-precedence-list of " (tt "CLASS") " as a list of classes."))) (section 3 "class-direct-slots" (def (sig (procedure "(class-direct-slots CLASS) => list" (id class-direct-slots))) (p "Returns the list of direct slots of " (tt "CLASS") " as a list of lists, where each sublist contains the name of the slot."))) (section 3 "class-direct-supers" (def (sig (procedure "(class-direct-supers CLASS)" (id class-direct-supers))) (p "Returns the list of direct superclasses of " (tt "CLASS") "."))) (section 3 "class-of" (def (sig (procedure "(class-of X) => class" (id class-of))) (p "Returns the class that the object " (tt "X") " is an instance of.") (p "See Extensions below for an API to extend the set of \"built-in\" classes."))) (section 3 "class-name" (def (sig (procedure "(class-name CLASS) => *" (id class-name))) (p "Returns name of " (tt "CLASS") "."))) (section 3 "class-slots" (def (sig (procedure "(class-slots CLASS) => list" (id class-slots))) (p "Returns the list of all slots of " (tt "CLASS") " and its superclasses as a list of lists, where each sublist contains the name of the slot."))) (section 3 "generic-methods" (def (sig (procedure "(generic-methods GENERIC) => list" (id generic-methods))) (p "Returns the list of all methods associated with the generic function " (tt "GENERIC") "."))) (section 3 "method-specializers" (def (sig (procedure "(method-specializers METHOD) => list" (id method-specializers))) (p "Returns the list of classes that specialize " (tt "METHOD") "."))) (section 3 "method-procedure" (def (sig (procedure "(method-procedure METHOD) => procedure" (id method-procedure))) (p "Returns the procedure that contains the body of " (tt "METHOD") "."))) (section 3 "instance?" (def (sig (procedure "(instance? X) => boolean" (id instance?))) (p "Is " (tt "X") " an instance of a non-primitive class?") (p "A generic procedure is considered an " (i "instance") "."))) (section 3 "class?" (def (sig (procedure "(class? X) => boolean" (id class?))) (p "Is " (tt "X") " an instance of a non-primitive class?"))) (section 3 "generic?" (def (sig (procedure "(generic? X) => boolean" (id generic?))) (p "Is " (tt "X") " a generic procedure?"))) (section 3 "subclass?" (def (sig (procedure "(subclass? CLASS1 CLASS2) => boolean" (id subclass?))) (p "Is " (tt "CLASS1") " a subclass of " (tt "CLASS2") "?") (p "Note that the following holds:") (highlight scheme "(subclass? CLASS CLASS) ;==> #t"))) (section 3 "instance-of?" (def (sig (procedure "(instance-of? X CLASS) => boolean" (id instance-of?))) (p "Is " (tt "X") " an instance of a subclass of " (tt "CLASS") "?") (p "Remember that a class is a subclass of itself."))) (section 3 "generic-name" (def (sig (procedure "(generic-name X) => string" (id generic-name))) (p "The name of the generic procedure " (tt "X") ", or " (tt "#f") ".")))) (section 2 "Intercessory Protocol" (p "These definitions allow interfacing to the Meta Object Protocol of TinyCLOS. For serious use, it is recommended to consult the source code (" (tt "tinyclos.scm") ").") (section 3 "allocate-instance" (p "<generic>(allocate-instance CLASS) => instance</generic>") (p "Allocates storage for an instance of " (tt "CLASS") " and returns the instance.")) (section 3 "compute-apply-generic" (p "<generic>(compute-apply-generic GENERIC) => procedure</generic>") (p "Returns a procedure that will be called to apply the generic function methods to the arguments.")) (section 3 "compute-apply-methods" (p "<generic>(compute-apply-methods GENERIC) => procedure</generic>") (p "Returns a procedure of two arguments, a list of applicable methods and a list of arguments and applies the methods.")) (section 3 "compute-methods" (p "<generic>(compute-methods GENERIC) => procedure</generic>") (p "Returns a procedure of one argument. The procedure is called with the list of actual arguments passed to the generic function and should return a list of applicable methods, sorted by precedence.")) (section 3 "compute-cpl" (p "<generic>(compute-cpl CLASS) => list</generic>") (p "Computes and returns the class-precedence-list of " (tt "CLASS") ".")) (section 3 "compute-getter-and-setter" (p "<generic>(compute-getter-and-setter CLASS SLOT ALLOCATOR) => procedure procedure</generic>") (p "Returns two values, the procedures that get and set the contents of the slot " (tt "SLOT") ". " (tt "ALLOCATOR") " is a procedure of one argument that gets an initializer function and returns the getter and setter procedures for the allocated slot.")) (section 3 "compute-method-more-specific?" (p "<generic>(compute-method-more-specific? GENERIC) => procedure</generic>") (p "Returns a procedure of three arguments (two methods and a list of arguments) that returns " (tt "#t") " if the first method is more specific than the second one with respect to the list of arguments. Otherwise the returned predicate returns " (tt "#f") ".")) (section 3 "compute-slots" (p "<generic>(compute-slots CLASS) => list</generic>") (p "Computes and returns the list of slots of " (tt "CLASS") ".")) (section 3 "initialize" (p "<generic>(initialize INSTANCE INITARGS)</generic>") (p "Initializes the object " (tt "INSTANCE") ". " (tt "INITARGS") " is the list of initialization arguments that were passed to the " (tt "make") " procedure.") (p (i "Note") " the slot " (tt "name") " can only be initialized with a " (tt "string") " or " (tt "symbol") ", which is coerced to a " (tt "string") ". When the supplied " (tt "name") " follows the canonical form for class names, " (tt "<...>") ", the outer angle brackets are stripped."))) (section 2 "Additional Protocol" (section 3 "print-object" (p "<generic>(print-object INSTANCE [PORT])</generic>") (p "Writes a terse textual representation of " (tt "INSTANCE") " to " (tt "PORT") ". Any output of an instance with " (tt "display") ", " (tt "write") ", and " (tt "print") " will invoke this generic function.") (p "If " (tt "PORT") " is not given it defaults to the value of " (tt "(current-output-port)") ".")) (section 3 "describe-object" (p "<generic>(describe-object OBJECT [PORT])</generic>") (p "Writes a verbose textual description of " (tt "OBJECT") " to " (tt "PORT") ".") (p "If " (tt "PORT") " is not given it defaults to the value of " (tt "(current-output-port)") ".") (p "If given an instance, this procedure will identify the class to which the instance belongs and list the names and values of all its slots. If given a primitive, this procedure will identify the primitive class to which the argument belongs.") (highlight scheme "(define-class <person> () (name age))\n(define-class <customer> (<person>) (last-contact-date purchases customer-number))\n(define-method (initialize (p <person>) initargs ) (initialize-slots p initargs))\n(define p1 (make <customer> 'name \"John\" 'purchases 12.80 'customer-number 11))\n(describe-object p1)") (p "=>") (p "instance of class customer:") (pre " last-contact-date -> #<unspecified>\n         purchases -> 12.8\n   customer-number -> 11\n              name -> \"John\"\n               age -> #<unspecified>") (highlight scheme "(describe-object (if #f '()))") (p "=>") (p "instance of primitive class void: #<unspecified>") (highlight scheme "(describe-object <customer>)") (p "=>") (p "class customer (class):") (pre "         Slots: (last-contact-date , purchases , customer-number , name , age)\n        Supers: (customer , person , object , top)\n  Direct Slots: (last-contact-date , purchases , customer-number)\n Direct Supers: (person)")) (section 3 "Detail Protocol" (section 4 "Usage" (highlight scheme "(require-extension detail-object)")) (section 4 "detail-object" (p "<generic>(detail-object OBJECT [PORT])</generic>") (p "Writes a verbose textual desription, in SRFI-10 form, of " (tt "OBJECT") " to " (tt "PORT") ".") (p "If " (tt "PORT") " is not given it defaults to the value of " (tt "(current-output-port)") ".") (p "Except in very limited cases the object detail cannot be reconstituted as the original object. So " (tt "detail-object") " violates the spirit of SRFI 10.")))) (section 2 "Utilities" (section 3 "slot@" (def (sig (syntax "(slot@ OBJECT SLOT-NAME ... [= VALUE])" (id slot@))) (p "Object slots are de-referenced by name left-to-right, with an optional last slot assignment.") (highlight scheme "(slot@ foo x y)           ;=> (slot-ref (slot-ref foo 'x) 'y)\n(slot@ foo x y = \"bar\")   ;=> (slot-set! (slot-ref foo 'x) 'y \"bar\")") (p "Symbolic slot-names only."))) (section 3 "initialize-slots" (def (sig (procedure "(initialize-slots INSTANCE INITARGS)" (id initialize-slots))) (p "This procedure takes a sequence of alternating slot-names and initialization values in " (tt "INITARGS") " and initializes the corresponding slots in " (tt "INSTANCE") ".") (highlight scheme "(define-class <pos> () (x y))\n\n(define-method (initialize (pos <pos>) initargs)\n  (call-next-method)\n  (initialize-slots pos initargs))\n\n(define p1 (make <pos> 'x 1 'y 2))\n(define p2 (make <pos> 'x 3 'y 5))"))) (section 3 "make/copy" (def (sig (procedure "(make/copy INSTANCE [INITARGS])" (id make/copy))) (p "Returns a copy of the object " (tt "INSTANCE") ". " (tt "INITARGS") " is the list of initialization arguments that will override the " (tt "INSTANCE") " copy slot values.")))) (section 2 "Built-in Classes" (p "The class hierarchy of builtin classes looks like this:") (highlight scheme "<top>\n  <object>\n    <class>\n      <procedure-class>\n        <entity-class>\n\t        <generic>\n      <method>\n      <c++-object>\n      <primitive-class>\n  <primitive>\n    <immediate>\n      <void>\n      <null>\n      <boolean>\n      <end-of-file>\n      <char>\n    <symbol>\n    <sequence>\n      <vector>\n      <list>\n      <pair>\n      <string>\n    <number>\n      <complex>\n        <real>\n          <rational>\n            <integer>\n              <exact>\n            <inexact>\n    <procedure>               (subclass <procedure-class>)\n    <port>\n      <input-port>\n      <output-port>\n    <pointer>\n      <tagged-pointer>\n      <swig-pointer>\n    <locative>\n    <blob>\n    <structure>\n      <array>                 (subclass <sequence>)\n      <u8vector>              (subclass <vector>)\n      <s8vector>              (subclass <vector>)\n      <u16vector>             (subclass <vector>)\n      <s16vector>             (subclass <vector>)\n      <u32vector>             (subclass <vector>)\n      <s32vector>             (subclass <vector>)\n      <f32vector>             (subclass <vector>)\n      <f64vector>             (subclass <vector>)\n      <char-set>              (subclass <sequence>)\n      <condition>\n      <continuation>\n      <environment>           (subclass <sequence>)\n      <hash-table>            (subclass <sequence>)\n      <lock>\n      <mmap>\n      <promise>\n      <queue>                 (subclass <sequence>)\n      <read-table>\n      <regexp>\n      <tcp-listener>\n      <time>\n      <thread>\n      <mutex>\n      <condition-variable>") (section 3 "<object>" (p "The parent class of all objects.")) (section 3 "<class>" (p "The parent class of all class objects.")) (section 3 "<procedure-class>" (p "The parent class of objects that can be invoked as a procedure.")) (section 3 "<entity-class>" (p "The parent class of objects that can be invoked as a procedure and have slots.")) (section 3 "<generic>" (p "The parent class of generic function objects.")) (section 3 "<method>" (p "The parent class of method objects.")) (section 3 "<primitive>" (p "The parent class of the classes of all primitive Scheme objects.") (p "Note that " (tt "<object>") " and " (tt "<primitive>") " are disjoint.")) (section 3 "<immediate>" (p "The parent class of immediate primitives.")) (section 3 "<sequence>" (p "The parent class of indexable primitives.")) (section 3 "<void>") (section 3 "<null>") (section 3 "<boolean>") (section 3 "<end-of-file>") (section 3 "<char>") (section 3 "<symbol>") (section 3 "<vector>") (section 3 "<list>") (section 3 "<pair>") (section 3 "<number>") (section 3 "<complex>") (section 3 "<real>") (section 3 "<rational>") (section 3 "<integer>") (section 3 "<exact>") (section 3 "<inexact>") (section 3 "<string>") (section 3 "<port>") (section 3 "<input-port>") (section 3 "<output-port>") (section 3 "<environment>") (section 3 "<procedure>") (section 3 "<condition>") (section 3 "<blob>") (section 3 "<structure>" (p "The classes of primitive Scheme and Chicken objects.")) (section 3 "<condition>" (p "SRFI 12 condition objects.")) (section 3 "<continuation>" (p "Class of continuation objects captured by " (tt "continuation-capture") ".")) (section 3 "<hash-table>") (section 3 "<queue>" (p "The classes of extended data types provided by the various library units.")) (section 3 "<char-set>") (section 3 "<time>") (section 3 "<thread>") (section 3 "<mutex>") (section 3 "<condition-variable>") (section 3 "<u8vector>") (section 3 "<s8vector>") (section 3 "<u16vector>") (section 3 "<s16vector>") (section 3 "<u32vector>") (section 3 "<s32vector>") (section 3 "<f32vector>") (section 3 "<f64vector>" (p "The classes of data objects provided by the various supplied SRFIs.")) (section 3 "<array>" (p "The SRFI 25 and SRFI 63 (array-lib), but not SRFI 47, object.")) (section 3 "<lock>") (section 3 "<mmap>" (p "Classes of objects used in the Unit " (tt "posix") ".")) (section 3 "<pointer>") (section 3 "<tagged-pointer>") (section 3 "<swig-pointer>" (p "A machine pointer (untagged, tagged or pointing to SWIG-wrapped data).")) (section 3 "<locative>" (p "A locative.")) (section 3 "<promise>" (p "The class of objects returned by " (tt "delay") ".")) (section 3 "<tcp-listener>" (p "The class of an object returned by " (tt "tcp-listen") ".")) (section 3 "<regexp>" (p "The class of an object returned by " (tt "regexp") ".")) (section 3 "<c++-object>" (p "The class of generated wrappers for C++ classes parsed by the \"easy\" foreign function interface " (int-link "easyffi") "."))) (section 2 ("Extending " (tt "class-of")) (p "The " (tt "class-of") " procedure can be extended to recognize additional classes beyond the built-in set.") (section 3 "register-primitive-class-of" (def (sig (procedure "(register-primitive-class-of FUNCTION) => (union #f class)" (id register-primitive-class-of))) (p (tt "FUNCTION") " is a " (tt "(procedure (*) *)") " taking a single argument, the object to test, and returning a " (tt "class") " when the object is known or " (tt "#f") " otherwise."))) (section 3 "Specialized Extensions" (p "When extending class-of with an opaque type and the underlying representation is known, it is best not to exploit this knowledge. For example:") (p "This will work but it is " (i "brittle") ":") (highlight scheme "(use lookup-table)\n\n(define-class <dict> (<structure>) () <primitive-class>)\n(add-structure-class-of <dict> 'dict)") (p "Better:") (highlight scheme "(use lookup-table)\n\n(define-class <dict> () () <primitive-class>)\n(add-primitive-class-of <dict> dict?)") (section 4 "add-primitive-class-of") (section 4 "add-structure-class-of") (section 4 "add-tagged-pointer-class-of") (section 4 "add-extended-procedure-class-of" (def (sig (procedure "(add-primitive-class-of CLASS PREDICATE)" (id add-primitive-class-of)) (procedure "(add-structure-class-of CLASS TAG)" (id add-structure-class-of)) (procedure "(add-tagged-pointer-class-of CLASS TAG)" (id add-tagged-pointer-class-of)) (procedure "(add-extended-procedure-class-of CLASS PREDICATE)" (id add-extended-procedure-class-of))) (p "Extends " (tt "class-of") " with the supplied " (tt "CLASS") " and identity detection.") (p "Any existing entry with matching " (tt "PREDICATE") " or " (tt "TAG") " will be replaced!") (p "Does not verify the types of its' arguments."))) (section 4 "delete-primitive-class-of") (section 4 "delete-structure-class-of") (section 4 "delete-tagged-pointer-class-of") (section 4 "delete-extended-procedure-class-of" (def (sig (procedure "(delete-primitive-class-of CLASS)" (id delete-primitive-class-of)) (procedure "(delete-structure-class-of CLASS)" (id delete-structure-class-of)) (procedure "(delete-tagged-pointer-class-of CLASS)" (id delete-tagged-pointer-class-of)) (procedure "(delete-extended-procedure-class-of CLASS)" (id delete-extended-procedure-class-of))) (p "Just removes the supplied " (tt "CLASS") " from " (tt "class-of") ", if it exists.") (p "Does not verify the types of its' arguments."))))) (section 2 "Usage" (highlight scheme "(require-extension tinyclos>")) (section 2 "Authors" (p "Original version by Gregor Kiczales, CHICKEN port and performance enhancements by " (int-link "/users/felix winkelmann" "felix winkelmann") ", some of which have been inspired by Eli Barzilays " (i "Swindle")) (p (tt "slot@") " from the '@' macro by " (int-link "Dan Muresan") ".")) (section 2 "Version History" (dl (dt "1.8.4") (dd "Removed call to broken " (tt "randomize") " function in CHICKEN 4.6.0 [thanks to Matt Welland]") (dt "1.8.3") (dd "Removed backwards-incompatible declaration") (dt "1.8.2") (dd "Printing of '(allocate-instance <top>/<primitive>) handled. [kon lovett]") (dt "1.8.1") (dd "Fixed " (tt "<sequence>") " class-name. Fixed " (tt "class-of") " extension implementation type precedence. Name of " (tt "<generic>") " is now a string, same as others. [kon lovett]") (dt "1.8.0") (dd "Added " (tt "register-primitive-class-of") ". [kon lovett]") (dt "1.7.0") (dd "Removed the " (tt "class-of") " extension convenience API (It was unused). Fixed " (tt "<port>") " & " (tt "<procedure>") " subclasses. Added more primitive classes. Name of " (tt "<class>") " is now a string, same as others. Added some " (i "tagging") " primitive classes. Added " (tt "detail-object") ". Better " (tt "describe-object") ". [kon lovett]") (dt "1.6.5") (dd "Fix for extension of extended-procedure class-of. [kon lovett]") (dt "1.6.4") (dd "exposed in repository") (dt "1.6.0") (dd "define-generic now mandatory") (dt "1.5") (dd "fixed use of obsolete reader hack") (dt "1.404") (dd "added " (tt "make/copy") " [kon lovett]") (dt "1.403") (dd "added unbound error to " (tt "class-of") " [kon lovett]") (dt "1.402") (dd "fixed bug in " (tt "class-of") " that caused crash when passed void [felix winkelmann]") (dt "1.401") (dd "Uses ':optional' (for older Chicken) [kon lovett]") (dt "1.4") (dd "Added class-of extension api, and slot@. Much internal re-ordering [kon lovett]") (dt "1.3") (dd "removed unnecessary feature-registration [thanks to Matthew Welland]") (dt "1.2") (dd "removed use of " (tt ":optional") " in " (tt "tinyclos.scm") " [thanks to Todd Ingalls]") (dt "1.1") (dd "added missing " (tt "syntax") " indicator in setup script") (dt "1.0") (dd "moved from base distribution into separate extension"))) (section 2 "License" (p "Copyright (c) 2000-2007, Felix L. Winkelmann All rights reserved.") (p "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:") (pre "Redistributions of source code must retain the above copyright notice, this list of conditions and the following\n  disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following\n  disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the author nor the names of its contributors may be used to endorse or promote\n  products derived from this software without specific prior written permission.") (p "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.")))